// Code generated from TiDBParser.g4 by ANTLR 4.13.0. DO NOT EDIT.

package parser // TiDBParser
import (
	"fmt"
	"strconv"
	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}

type TiDBParser struct {
	*antlr.BaseParser
}

var TiDBParserParserStaticData struct {
	once                   sync.Once
	serializedATN          []int32
	LiteralNames           []string
	SymbolicNames          []string
	RuleNames              []string
	PredictionContextCache *antlr.PredictionContextCache
	atn                    *antlr.ATN
	decisionToDFA          []*antlr.DFA
}

func tidbparserParserInit() {
	staticData := &TiDBParserParserStaticData
	staticData.LiteralNames = []string{
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "'='", "':='", "'<=>'", "'>='", "'>'", "'<='", "'<'", "'!='",
		"'+'", "'-'", "'*'", "'/'", "'%'", "'!'", "'~'", "'<<'", "'>>'", "'&&'",
		"'&'", "'^'", "'||'", "'|'", "'.'", "','", "';'", "':'", "'('", "')'",
		"'{'", "'}'", "'_'", "'->'", "'->>'", "'@'", "", "'@@'", "'\\N'", "'?'",
		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
		"", "", "", "", "'/*!'", "'*/'", "", "", "", "'<>'",
	}
	staticData.SymbolicNames = []string{
		"", "ACCESSIBLE_SYMBOL", "ACCOUNT_SYMBOL", "ACTION_SYMBOL", "ADD_SYMBOL",
		"ADDDATE_SYMBOL", "AFTER_SYMBOL", "AGAINST_SYMBOL", "AGGREGATE_SYMBOL",
		"ALGORITHM_SYMBOL", "ALL_SYMBOL", "ALTER_SYMBOL", "ALWAYS_SYMBOL", "ANALYSE_SYMBOL",
		"ANALYZE_SYMBOL", "AND_SYMBOL", "ANY_SYMBOL", "AS_SYMBOL", "ASC_SYMBOL",
		"ASCII_SYMBOL", "ASENSITIVE_SYMBOL", "AT_SYMBOL", "AUTHORS_SYMBOL",
		"AUTOEXTEND_SIZE_SYMBOL", "AUTO_INCREMENT_SYMBOL", "AVG_ROW_LENGTH_SYMBOL",
		"AVG_SYMBOL", "BACKUP_SYMBOL", "BEFORE_SYMBOL", "BEGIN_SYMBOL", "BETWEEN_SYMBOL",
		"BIGINT_SYMBOL", "BINARY_SYMBOL", "BINLOG_SYMBOL", "BIN_NUM_SYMBOL",
		"BIT_AND_SYMBOL", "BIT_OR_SYMBOL", "BIT_SYMBOL", "BIT_XOR_SYMBOL", "BLOB_SYMBOL",
		"BLOCK_SYMBOL", "BOOLEAN_SYMBOL", "BOOL_SYMBOL", "BOTH_SYMBOL", "BTREE_SYMBOL",
		"BY_SYMBOL", "BYTE_SYMBOL", "CACHE_SYMBOL", "CALL_SYMBOL", "CASCADE_SYMBOL",
		"CASCADED_SYMBOL", "CASE_SYMBOL", "CAST_SYMBOL", "CATALOG_NAME_SYMBOL",
		"CHAIN_SYMBOL", "CHANGE_SYMBOL", "CHANGED_SYMBOL", "CHANNEL_SYMBOL",
		"CHARSET_SYMBOL", "CHARACTER_SYMBOL", "CHAR_SYMBOL", "CHECKSUM_SYMBOL",
		"CHECK_SYMBOL", "CIPHER_SYMBOL", "CLASS_ORIGIN_SYMBOL", "CLIENT_SYMBOL",
		"CLOSE_SYMBOL", "COALESCE_SYMBOL", "CODE_SYMBOL", "COLLATE_SYMBOL",
		"COLLATION_SYMBOL", "COLUMNS_SYMBOL", "COLUMN_SYMBOL", "COLUMN_NAME_SYMBOL",
		"COLUMN_FORMAT_SYMBOL", "COMMENT_SYMBOL", "COMMITTED_SYMBOL", "COMMIT_SYMBOL",
		"COMPACT_SYMBOL", "COMPLETION_SYMBOL", "COMPRESSED_SYMBOL", "COMPRESSION_SYMBOL",
		"CONCURRENT_SYMBOL", "CONDITION_SYMBOL", "CONNECTION_SYMBOL", "CONSISTENT_SYMBOL",
		"CONSTRAINT_SYMBOL", "CONSTRAINT_CATALOG_SYMBOL", "CONSTRAINT_NAME_SYMBOL",
		"CONSTRAINT_SCHEMA_SYMBOL", "CONTAINS_SYMBOL", "CONTEXT_SYMBOL", "CONTINUE_SYMBOL",
		"CONTRIBUTORS_SYMBOL", "CONVERT_SYMBOL", "COUNT_SYMBOL", "CPU_SYMBOL",
		"CREATE_SYMBOL", "CROSS_SYMBOL", "CUBE_SYMBOL", "CURDATE_SYMBOL", "CURRENT_SYMBOL",
		"CURRENT_DATE_SYMBOL", "CURRENT_TIME_SYMBOL", "CURRENT_TIMESTAMP_SYMBOL",
		"CURRENT_USER_SYMBOL", "CURSOR_SYMBOL", "CURSOR_NAME_SYMBOL", "CURTIME_SYMBOL",
		"DATABASE_SYMBOL", "DATABASES_SYMBOL", "DATAFILE_SYMBOL", "DATA_SYMBOL",
		"DATETIME_SYMBOL", "DATE_ADD_SYMBOL", "DATE_SUB_SYMBOL", "DATE_SYMBOL",
		"DAYOFMONTH_SYMBOL", "DAY_HOUR_SYMBOL", "DAY_MICROSECOND_SYMBOL", "DAY_MINUTE_SYMBOL",
		"DAY_SECOND_SYMBOL", "DAY_SYMBOL", "DEALLOCATE_SYMBOL", "DEC_SYMBOL",
		"DECIMAL_NUM_SYMBOL", "DECIMAL_SYMBOL", "DECLARE_SYMBOL", "DEFAULT_SYMBOL",
		"DEFAULT_AUTH_SYMBOL", "DEFINER_SYMBOL", "DELAYED_SYMBOL", "DELAY_KEY_WRITE_SYMBOL",
		"DELETE_SYMBOL", "DESC_SYMBOL", "DESCRIBE_SYMBOL", "DES_KEY_FILE_SYMBOL",
		"DETERMINISTIC_SYMBOL", "DIAGNOSTICS_SYMBOL", "DIRECTORY_SYMBOL", "DISABLE_SYMBOL",
		"DISCARD_SYMBOL", "DISK_SYMBOL", "DISTINCT_SYMBOL", "DISTINCTROW_SYMBOL",
		"DIV_SYMBOL", "DOUBLE_SYMBOL", "DO_SYMBOL", "DROP_SYMBOL", "DUAL_SYMBOL",
		"DUMPFILE_SYMBOL", "DUPLICATE_SYMBOL", "DYNAMIC_SYMBOL", "EACH_SYMBOL",
		"ELSE_SYMBOL", "ELSEIF_SYMBOL", "ENABLE_SYMBOL", "ENCLOSED_SYMBOL",
		"ENCRYPTION_SYMBOL", "END_SYMBOL", "ENDS_SYMBOL", "END_OF_INPUT_SYMBOL",
		"ENGINES_SYMBOL", "ENGINE_SYMBOL", "ENUM_SYMBOL", "ERROR_SYMBOL", "ERRORS_SYMBOL",
		"ESCAPED_SYMBOL", "ESCAPE_SYMBOL", "EVENTS_SYMBOL", "EVENT_SYMBOL",
		"EVERY_SYMBOL", "EXCHANGE_SYMBOL", "EXECUTE_SYMBOL", "EXISTS_SYMBOL",
		"EXIT_SYMBOL", "EXPANSION_SYMBOL", "EXPIRE_SYMBOL", "EXPLAIN_SYMBOL",
		"EXPORT_SYMBOL", "EXTENDED_SYMBOL", "EXTENT_SIZE_SYMBOL", "EXTRACT_SYMBOL",
		"FALSE_SYMBOL", "FAST_SYMBOL", "FAULTS_SYMBOL", "FETCH_SYMBOL", "FIELDS_SYMBOL",
		"FILE_SYMBOL", "FILE_BLOCK_SIZE_SYMBOL", "FILTER_SYMBOL", "FIRST_SYMBOL",
		"FIXED_SYMBOL", "FLOAT4_SYMBOL", "FLOAT8_SYMBOL", "FLOAT_SYMBOL", "FLUSH_SYMBOL",
		"FOLLOWS_SYMBOL", "FORCE_SYMBOL", "FOREIGN_SYMBOL", "FOR_SYMBOL", "FORMAT_SYMBOL",
		"FOUND_SYMBOL", "FROM_SYMBOL", "FULL_SYMBOL", "FULLTEXT_SYMBOL", "FUNCTION_SYMBOL",
		"GET_SYMBOL", "GENERAL_SYMBOL", "GENERATED_SYMBOL", "GROUP_REPLICATION_SYMBOL",
		"GEOMETRYCOLLECTION_SYMBOL", "GEOMETRY_SYMBOL", "GET_FORMAT_SYMBOL",
		"GLOBAL_SYMBOL", "GRANT_SYMBOL", "GRANTS_SYMBOL", "GROUP_SYMBOL", "GROUP_CONCAT_SYMBOL",
		"HANDLER_SYMBOL", "HASH_SYMBOL", "HAVING_SYMBOL", "HELP_SYMBOL", "HIGH_PRIORITY_SYMBOL",
		"HOST_SYMBOL", "HOSTS_SYMBOL", "HOUR_MICROSECOND_SYMBOL", "HOUR_MINUTE_SYMBOL",
		"HOUR_SECOND_SYMBOL", "HOUR_SYMBOL", "IDENTIFIED_SYMBOL", "IF_SYMBOL",
		"IGNORE_SYMBOL", "IGNORE_SERVER_IDS_SYMBOL", "IMPORT_SYMBOL", "INDEXES_SYMBOL",
		"INDEX_SYMBOL", "INFILE_SYMBOL", "INITIAL_SIZE_SYMBOL", "INNER_SYMBOL",
		"INOUT_SYMBOL", "INSENSITIVE_SYMBOL", "INSERT_SYMBOL", "INSERT_METHOD_SYMBOL",
		"INSTANCE_SYMBOL", "INSTALL_SYMBOL", "INTEGER_SYMBOL", "INTERVAL_SYMBOL",
		"INTO_SYMBOL", "INT_SYMBOL", "INVOKER_SYMBOL", "IN_SYMBOL", "IO_AFTER_GTIDS_SYMBOL",
		"IO_BEFORE_GTIDS_SYMBOL", "IO_THREAD_SYMBOL", "IO_SYMBOL", "IPC_SYMBOL",
		"IS_SYMBOL", "ISOLATION_SYMBOL", "ISSUER_SYMBOL", "ITERATE_SYMBOL",
		"JOIN_SYMBOL", "JSON_SYMBOL", "KEYS_SYMBOL", "KEY_BLOCK_SIZE_SYMBOL",
		"KEY_SYMBOL", "KILL_SYMBOL", "LANGUAGE_SYMBOL", "LAST_SYMBOL", "LEADING_SYMBOL",
		"LEAVES_SYMBOL", "LEAVE_SYMBOL", "LEFT_SYMBOL", "LESS_SYMBOL", "LEVEL_SYMBOL",
		"LIKE_SYMBOL", "LIMIT_SYMBOL", "LINEAR_SYMBOL", "LINES_SYMBOL", "LINESTRING_SYMBOL",
		"LIST_SYMBOL", "LOAD_SYMBOL", "LOCALTIME_SYMBOL", "LOCALTIMESTAMP_SYMBOL",
		"LOCAL_SYMBOL", "LOCATOR_SYMBOL", "LOCKS_SYMBOL", "LOCK_SYMBOL", "LOGFILE_SYMBOL",
		"LOGS_SYMBOL", "LONGBLOB_SYMBOL", "LONGTEXT_SYMBOL", "LONG_NUM_SYMBOL",
		"LONG_SYMBOL", "LOOP_SYMBOL", "LOW_PRIORITY_SYMBOL", "MASTER_AUTO_POSITION_SYMBOL",
		"MASTER_BIND_SYMBOL", "MASTER_CONNECT_RETRY_SYMBOL", "MASTER_DELAY_SYMBOL",
		"MASTER_HOST_SYMBOL", "MASTER_LOG_FILE_SYMBOL", "MASTER_LOG_POS_SYMBOL",
		"MASTER_PASSWORD_SYMBOL", "MASTER_PORT_SYMBOL", "MASTER_RETRY_COUNT_SYMBOL",
		"MASTER_SERVER_ID_SYMBOL", "MASTER_SSL_CAPATH_SYMBOL", "MASTER_SSL_CA_SYMBOL",
		"MASTER_SSL_CERT_SYMBOL", "MASTER_SSL_CIPHER_SYMBOL", "MASTER_SSL_CRL_SYMBOL",
		"MASTER_SSL_CRLPATH_SYMBOL", "MASTER_SSL_KEY_SYMBOL", "MASTER_SSL_SYMBOL",
		"MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL", "MASTER_SYMBOL", "MASTER_TLS_VERSION_SYMBOL",
		"MASTER_USER_SYMBOL", "MASTER_HEARTBEAT_PERIOD_SYMBOL", "MATCH_SYMBOL",
		"MAX_CONNECTIONS_PER_HOUR_SYMBOL", "MAX_QUERIES_PER_HOUR_SYMBOL", "MAX_ROWS_SYMBOL",
		"MAX_SIZE_SYMBOL", "MAX_STATEMENT_TIME_SYMBOL", "MAX_SYMBOL", "MAX_UPDATES_PER_HOUR_SYMBOL",
		"MAX_USER_CONNECTIONS_SYMBOL", "MAXVALUE_SYMBOL", "MEDIUMBLOB_SYMBOL",
		"MEDIUMINT_SYMBOL", "MEDIUMTEXT_SYMBOL", "MEDIUM_SYMBOL", "MEMORY_SYMBOL",
		"MERGE_SYMBOL", "MESSAGE_TEXT_SYMBOL", "MICROSECOND_SYMBOL", "MID_SYMBOL",
		"MIDDLEINT_SYMBOL", "MIGRATE_SYMBOL", "MINUTE_MICROSECOND_SYMBOL", "MINUTE_SECOND_SYMBOL",
		"MINUTE_SYMBOL", "MIN_ROWS_SYMBOL", "MIN_SYMBOL", "MODE_SYMBOL", "MODIFIES_SYMBOL",
		"MODIFY_SYMBOL", "MOD_SYMBOL", "MONTH_SYMBOL", "MULTILINESTRING_SYMBOL",
		"MULTIPOINT_SYMBOL", "MULTIPOLYGON_SYMBOL", "MUTEX_SYMBOL", "MYSQL_ERRNO_SYMBOL",
		"NAMES_SYMBOL", "NAME_SYMBOL", "NATIONAL_SYMBOL", "NATURAL_SYMBOL",
		"NCHAR_STRING_SYMBOL", "NCHAR_SYMBOL", "NDB_SYMBOL", "NDBCLUSTER_SYMBOL",
		"NEG_SYMBOL", "NEVER_SYMBOL", "NEW_SYMBOL", "NEXT_SYMBOL", "NODEGROUP_SYMBOL",
		"NONE_SYMBOL", "NONBLOCKING_SYMBOL", "NOT_SYMBOL", "NOW_SYMBOL", "NO_SYMBOL",
		"NO_WAIT_SYMBOL", "NO_WRITE_TO_BINLOG_SYMBOL", "NULL_SYMBOL", "NUMBER_SYMBOL",
		"NUMERIC_SYMBOL", "NVARCHAR_SYMBOL", "OFFLINE_SYMBOL", "OFFSET_SYMBOL",
		"OLD_PASSWORD_SYMBOL", "ON_SYMBOL", "ONE_SYMBOL", "ONLINE_SYMBOL", "ONLY_SYMBOL",
		"OPEN_SYMBOL", "OPTIMIZE_SYMBOL", "OPTIMIZER_COSTS_SYMBOL", "OPTIONS_SYMBOL",
		"OPTION_SYMBOL", "OPTIONALLY_SYMBOL", "ORDER_SYMBOL", "OR_SYMBOL", "OUTER_SYMBOL",
		"OUTFILE_SYMBOL", "OUT_SYMBOL", "OWNER_SYMBOL", "PACK_KEYS_SYMBOL",
		"PAGE_SYMBOL", "PARSER_SYMBOL", "PARTIAL_SYMBOL", "PARTITIONING_SYMBOL",
		"PARTITIONS_SYMBOL", "PARTITION_SYMBOL", "PASSWORD_SYMBOL", "PHASE_SYMBOL",
		"PLUGINS_SYMBOL", "PLUGIN_DIR_SYMBOL", "PLUGIN_SYMBOL", "POINT_SYMBOL",
		"POLYGON_SYMBOL", "PORT_SYMBOL", "POSITION_SYMBOL", "PRECEDES_SYMBOL",
		"PRECISION_SYMBOL", "PREPARE_SYMBOL", "PRESERVE_SYMBOL", "PREV_SYMBOL",
		"PRIMARY_SYMBOL", "PRIVILEGES_SYMBOL", "PROCEDURE_SYMBOL", "PROCESS_SYMBOL",
		"PROCESSLIST_SYMBOL", "PROFILE_SYMBOL", "PROFILES_SYMBOL", "PROXY_SYMBOL",
		"PURGE_SYMBOL", "QUARTER_SYMBOL", "QUERY_SYMBOL", "QUICK_SYMBOL", "RANGE_SYMBOL",
		"READS_SYMBOL", "READ_ONLY_SYMBOL", "READ_SYMBOL", "READ_WRITE_SYMBOL",
		"REAL_SYMBOL", "REBUILD_SYMBOL", "RECOVER_SYMBOL", "REDOFILE_SYMBOL",
		"REDO_BUFFER_SIZE_SYMBOL", "REDUNDANT_SYMBOL", "REFERENCES_SYMBOL",
		"REGEXP_SYMBOL", "RELAY_SYMBOL", "RELAYLOG_SYMBOL", "RELAY_LOG_FILE_SYMBOL",
		"RELAY_LOG_POS_SYMBOL", "RELAY_THREAD_SYMBOL", "RELEASE_SYMBOL", "RELOAD_SYMBOL",
		"REMOVE_SYMBOL", "RENAME_SYMBOL", "REORGANIZE_SYMBOL", "REPAIR_SYMBOL",
		"REPEATABLE_SYMBOL", "REPEAT_SYMBOL", "REPLACE_SYMBOL", "REPLICATION_SYMBOL",
		"REPLICATE_DO_DB_SYMBOL", "REPLICATE_IGNORE_DB_SYMBOL", "REPLICATE_DO_TABLE_SYMBOL",
		"REPLICATE_IGNORE_TABLE_SYMBOL", "REPLICATE_WILD_DO_TABLE_SYMBOL", "REPLICATE_WILD_IGNORE_TABLE_SYMBOL",
		"REPLICATE_REWRITE_DB_SYMBOL", "REQUIRE_SYMBOL", "RESET_SYMBOL", "RESIGNAL_SYMBOL",
		"RESTORE_SYMBOL", "RESTRICT_SYMBOL", "RESUME_SYMBOL", "RETURNED_SQLSTATE_SYMBOL",
		"RETURNS_SYMBOL", "RETURN_SYMBOL", "REVERSE_SYMBOL", "REVOKE_SYMBOL",
		"RIGHT_SYMBOL", "RLIKE_SYMBOL", "ROLLBACK_SYMBOL", "ROLLUP_SYMBOL",
		"ROTATE_SYMBOL", "ROUTINE_SYMBOL", "ROWS_SYMBOL", "ROW_COUNT_SYMBOL",
		"ROW_FORMAT_SYMBOL", "ROW_SYMBOL", "RTREE_SYMBOL", "SAVEPOINT_SYMBOL",
		"SCHEDULE_SYMBOL", "SCHEMA_SYMBOL", "SCHEMA_NAME_SYMBOL", "SCHEMAS_SYMBOL",
		"SECOND_MICROSECOND_SYMBOL", "SECOND_SYMBOL", "SECURITY_SYMBOL", "SELECT_SYMBOL",
		"SENSITIVE_SYMBOL", "SEPARATOR_SYMBOL", "SERIALIZABLE_SYMBOL", "SERIAL_SYMBOL",
		"SESSION_SYMBOL", "SERVER_SYMBOL", "SERVER_OPTIONS_SYMBOL", "SESSION_USER_SYMBOL",
		"SET_SYMBOL", "SET_VAR_SYMBOL", "SHARE_SYMBOL", "SHOW_SYMBOL", "SHUTDOWN_SYMBOL",
		"SIGNAL_SYMBOL", "SIGNED_SYMBOL", "SIMPLE_SYMBOL", "SLAVE_SYMBOL", "SLOW_SYMBOL",
		"SMALLINT_SYMBOL", "SNAPSHOT_SYMBOL", "SOME_SYMBOL", "SOCKET_SYMBOL",
		"SONAME_SYMBOL", "SOUNDS_SYMBOL", "SOURCE_SYMBOL", "SPATIAL_SYMBOL",
		"SPECIFIC_SYMBOL", "SQLEXCEPTION_SYMBOL", "SQLSTATE_SYMBOL", "SQLWARNING_SYMBOL",
		"SQL_AFTER_GTIDS_SYMBOL", "SQL_AFTER_MTS_GAPS_SYMBOL", "SQL_BEFORE_GTIDS_SYMBOL",
		"SQL_BIG_RESULT_SYMBOL", "SQL_BUFFER_RESULT_SYMBOL", "SQL_CACHE_SYMBOL",
		"SQL_CALC_FOUND_ROWS_SYMBOL", "SQL_NO_CACHE_SYMBOL", "SQL_SMALL_RESULT_SYMBOL",
		"SQL_SYMBOL", "SQL_THREAD_SYMBOL", "SSL_SYMBOL", "STACKED_SYMBOL", "STARTING_SYMBOL",
		"STARTS_SYMBOL", "START_SYMBOL", "STATS_AUTO_RECALC_SYMBOL", "STATS_PERSISTENT_SYMBOL",
		"STATS_SAMPLE_PAGES_SYMBOL", "STATUS_SYMBOL", "STDDEV_SAMP_SYMBOL",
		"STDDEV_SYMBOL", "STDDEV_POP_SYMBOL", "STD_SYMBOL", "STOP_SYMBOL", "STORAGE_SYMBOL",
		"STORED_SYMBOL", "STRAIGHT_JOIN_SYMBOL", "STRING_SYMBOL", "SUBCLASS_ORIGIN_SYMBOL",
		"SUBDATE_SYMBOL", "SUBJECT_SYMBOL", "SUBPARTITIONS_SYMBOL", "SUBPARTITION_SYMBOL",
		"SUBSTR_SYMBOL", "SUBSTRING_SYMBOL", "SUM_SYMBOL", "SUPER_SYMBOL", "SUSPEND_SYMBOL",
		"SWAPS_SYMBOL", "SWITCHES_SYMBOL", "SYSDATE_SYMBOL", "SYSTEM_USER_SYMBOL",
		"TABLES_SYMBOL", "TABLESPACE_SYMBOL", "TABLE_REF_PRIORITY_SYMBOL", "TABLE_SYMBOL",
		"TABLE_CHECKSUM_SYMBOL", "TABLE_NAME_SYMBOL", "TEMPORARY_SYMBOL", "TEMPTABLE_SYMBOL",
		"TERMINATED_SYMBOL", "TEXT_SYMBOL", "THAN_SYMBOL", "THEN_SYMBOL", "TIMESTAMP_SYMBOL",
		"TIMESTAMP_ADD_SYMBOL", "TIMESTAMP_DIFF_SYMBOL", "TIME_SYMBOL", "TINYBLOB_SYMBOL",
		"TINYINT_SYMBOL", "TINYTEXT_SYMBOL", "TO_SYMBOL", "TRAILING_SYMBOL",
		"TRANSACTION_SYMBOL", "TRIGGERS_SYMBOL", "TRIGGER_SYMBOL", "TRIM_SYMBOL",
		"TRUE_SYMBOL", "TRUNCATE_SYMBOL", "TYPES_SYMBOL", "TYPE_SYMBOL", "UDF_RETURNS_SYMBOL",
		"UNCOMMITTED_SYMBOL", "UNDEFINED_SYMBOL", "UNDOFILE_SYMBOL", "UNDO_BUFFER_SIZE_SYMBOL",
		"UNDO_SYMBOL", "UNICODE_SYMBOL", "UNINSTALL_SYMBOL", "UNION_SYMBOL",
		"UNIQUE_SYMBOL", "UNKNOWN_SYMBOL", "UNLOCK_SYMBOL", "UNSIGNED_SYMBOL",
		"UNTIL_SYMBOL", "UPDATE_SYMBOL", "UPGRADE_SYMBOL", "USAGE_SYMBOL", "USER_RESOURCES_SYMBOL",
		"USER_SYMBOL", "USE_FRM_SYMBOL", "USE_SYMBOL", "USING_SYMBOL", "UTC_DATE_SYMBOL",
		"UTC_TIMESTAMP_SYMBOL", "UTC_TIME_SYMBOL", "VALIDATION_SYMBOL", "VALUES_SYMBOL",
		"VALUE_SYMBOL", "VARBINARY_SYMBOL", "VARCHAR_SYMBOL", "VARCHARACTER_SYMBOL",
		"VARIABLES_SYMBOL", "VARIANCE_SYMBOL", "VARYING_SYMBOL", "VAR_POP_SYMBOL",
		"VAR_SAMP_SYMBOL", "VIEW_SYMBOL", "VIRTUAL_SYMBOL", "WAIT_SYMBOL", "WARNINGS_SYMBOL",
		"WEEK_SYMBOL", "WEIGHT_STRING_SYMBOL", "WHEN_SYMBOL", "WHERE_SYMBOL",
		"WHILE_SYMBOL", "WITH_SYMBOL", "WITHOUT_SYMBOL", "WORK_SYMBOL", "WRAPPER_SYMBOL",
		"WRITE_SYMBOL", "X509_SYMBOL", "XA_SYMBOL", "XID_SYMBOL", "XML_SYMBOL",
		"XOR_SYMBOL", "YEAR_MONTH_SYMBOL", "YEAR_SYMBOL", "ZEROFILL_SYMBOL",
		"PERSIST_SYMBOL", "ROLE_SYMBOL", "ADMIN_SYMBOL", "INVISIBLE_SYMBOL",
		"VISIBLE_SYMBOL", "EXCEPT_SYMBOL", "COMPONENT_SYMBOL", "RECURSIVE_SYMBOL",
		"JSON_OBJECTAGG_SYMBOL", "JSON_ARRAYAGG_SYMBOL", "OF_SYMBOL", "SKIP_SYMBOL",
		"LOCKED_SYMBOL", "NOWAIT_SYMBOL", "GROUPING_SYMBOL", "PERSIST_ONLY_SYMBOL",
		"HISTOGRAM_SYMBOL", "BUCKETS_SYMBOL", "REMOTE_SYMBOL", "CLONE_SYMBOL",
		"CUME_DIST_SYMBOL", "DENSE_RANK_SYMBOL", "EXCLUDE_SYMBOL", "FIRST_VALUE_SYMBOL",
		"FOLLOWING_SYMBOL", "GROUPS_SYMBOL", "LAG_SYMBOL", "LAST_VALUE_SYMBOL",
		"LEAD_SYMBOL", "NTH_VALUE_SYMBOL", "NTILE_SYMBOL", "NULLS_SYMBOL", "OTHERS_SYMBOL",
		"OVER_SYMBOL", "PERCENT_RANK_SYMBOL", "PRECEDING_SYMBOL", "RANK_SYMBOL",
		"RESPECT_SYMBOL", "ROW_NUMBER_SYMBOL", "TIES_SYMBOL", "UNBOUNDED_SYMBOL",
		"WINDOW_SYMBOL", "EMPTY_SYMBOL", "JSON_TABLE_SYMBOL", "NESTED_SYMBOL",
		"ORDINALITY_SYMBOL", "PATH_SYMBOL", "HISTORY_SYMBOL", "REUSE_SYMBOL",
		"SRID_SYMBOL", "THREAD_PRIORITY_SYMBOL", "RESOURCE_SYMBOL", "SYSTEM_SYMBOL",
		"VCPU_SYMBOL", "MASTER_PUBLIC_KEY_PATH_SYMBOL", "GET_MASTER_PUBLIC_KEY_SYMBOL",
		"RESTART_SYMBOL", "DEFINITION_SYMBOL", "DESCRIPTION_SYMBOL", "ORGANIZATION_SYMBOL",
		"REFERENCE_SYMBOL", "OPTIONAL_SYMBOL", "SECONDARY_SYMBOL", "SECONDARY_ENGINE_SYMBOL",
		"SECONDARY_LOAD_SYMBOL", "SECONDARY_UNLOAD_SYMBOL", "ACTIVE_SYMBOL",
		"INACTIVE_SYMBOL", "LATERAL_SYMBOL", "RETAIN_SYMBOL", "OLD_SYMBOL",
		"NETWORK_NAMESPACE_SYMBOL", "ENFORCED_SYMBOL", "ARRAY_SYMBOL", "OJ_SYMBOL",
		"MEMBER_SYMBOL", "RANDOM_SYMBOL", "MASTER_COMPRESSION_ALGORITHM_SYMBOL",
		"MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL", "PRIVILEGE_CHECKS_USER_SYMBOL",
		"MASTER_TLS_CIPHERSUITES_SYMBOL", "REQUIRE_ROW_FORMAT_SYMBOL", "PASSWORD_LOCK_TIME_SYMBOL",
		"FAILED_LOGIN_ATTEMPTS_SYMBOL", "REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL",
		"STREAM_SYMBOL", "OFF_SYMBOL", "NOT2_SYMBOL", "CONCAT_PIPES_SYMBOL",
		"INT_NUMBER", "LONG_NUMBER", "ULONGLONG_NUMBER", "EQUAL_OPERATOR", "ASSIGN_OPERATOR",
		"NULL_SAFE_EQUAL_OPERATOR", "GREATER_OR_EQUAL_OPERATOR", "GREATER_THAN_OPERATOR",
		"LESS_OR_EQUAL_OPERATOR", "LESS_THAN_OPERATOR", "NOT_EQUAL_OPERATOR",
		"PLUS_OPERATOR", "MINUS_OPERATOR", "MULT_OPERATOR", "DIV_OPERATOR",
		"MOD_OPERATOR", "LOGICAL_NOT_OPERATOR", "BITWISE_NOT_OPERATOR", "SHIFT_LEFT_OPERATOR",
		"SHIFT_RIGHT_OPERATOR", "LOGICAL_AND_OPERATOR", "BITWISE_AND_OPERATOR",
		"BITWISE_XOR_OPERATOR", "LOGICAL_OR_OPERATOR", "BITWISE_OR_OPERATOR",
		"DOT_SYMBOL", "COMMA_SYMBOL", "SEMICOLON_SYMBOL", "COLON_SYMBOL", "OPEN_PAR_SYMBOL",
		"CLOSE_PAR_SYMBOL", "OPEN_CURLY_SYMBOL", "CLOSE_CURLY_SYMBOL", "UNDERLINE_SYMBOL",
		"JSON_SEPARATOR_SYMBOL", "JSON_UNQUOTED_SEPARATOR_SYMBOL", "AT_SIGN_SYMBOL",
		"AT_TEXT_SUFFIX", "AT_AT_SIGN_SYMBOL", "NULL2_SYMBOL", "PARAM_MARKER",
		"HEX_NUMBER", "BIN_NUMBER", "DECIMAL_NUMBER", "FLOAT_NUMBER", "AUTO_RANDOM_SYMBOL",
		"WHITESPACE", "INVALID_INPUT", "S3_SYMBOL", "INVOKE_SYMBOL", "LAMBDA_SYMBOL",
		"ATTRIBUTE_SYMBOL", "JSON_VALUE_SYMBOL", "RETURNING_SYMBOL", "INTERSECT_SYMBOL",
		"UNDERSCORE_CHARSET", "IDENTIFIER", "NCHAR_TEXT", "BACK_TICK_QUOTED_ID",
		"DOUBLE_QUOTED_TEXT", "SINGLE_QUOTED_TEXT", "VERSION_COMMENT_START",
		"MYSQL_COMMENT_START", "VERSION_COMMENT_END", "BLOCK_COMMENT", "POUND_COMMENT",
		"DASHDASH_COMMENT", "NOT_EQUAL2_OPERATOR",
	}
	staticData.RuleNames = []string{
		"singleColumnDef", "columnDef", "columnOptionList", "columnOption",
		"constraintName", "constraintEnforcement", "selectStatement", "selectStatementWithInto",
		"queryExpression", "queryExpressionBody", "queryExpressionParens", "queryPrimary",
		"querySpecification", "subquery", "querySpecOption", "limitClause",
		"simpleLimitClause", "limitOptions", "limitOption", "intoClause", "procedureAnalyseClause",
		"havingClause", "windowClause", "windowDefinition", "windowSpec", "windowSpecDetails",
		"windowFrameClause", "windowFrameUnits", "windowFrameExtent", "windowFrameStart",
		"windowFrameBetween", "windowFrameBound", "windowFrameExclusion", "withClause",
		"commonTableExpression", "groupByClause", "olapOption", "orderClause",
		"direction", "fromClause", "tableReferenceList", "tableValueConstructor",
		"explicitTable", "rowValueExplicit", "values", "selectOption", "lockingClauseList",
		"lockingClause", "lockStrengh", "lockedRowAction", "selectItemList",
		"selectItem", "selectAlias", "whereClause", "tableReference", "escapedTableReference",
		"joinedTable", "naturalJoinType", "innerJoinType", "outerJoinType",
		"tableFactor", "singleTable", "singleTableParens", "derivedTable", "tableReferenceListParens",
		"tableFunction", "columnsClause", "jtColumn", "onEmptyOrError", "onEmpty",
		"onError", "jtOnResponse", "setOprSymbol", "setOprOption", "tableAlias",
		"indexHintList", "indexHint", "indexHintType", "keyOrIndex", "constraintKeyType",
		"indexHintClause", "indexList", "indexListElement", "updateStatement",
		"transactionOrLockingStatement", "transactionStatement", "beginWork",
		"transactionCharacteristic", "savepointStatement", "lockStatement",
		"lockItem", "lockOption", "xaStatement", "xaConvert", "xid", "replicationStatement",
		"resetOption", "masterResetOptions", "replicationLoad", "changeMaster",
		"changeMasterOptions", "masterOption", "privilegeCheckDef", "tablePrimaryKeyCheckDef",
		"masterTlsCiphersuitesDef", "masterFileDef", "serverIdList", "changeReplication",
		"filterDefinition", "filterDbList", "filterTableList", "filterStringList",
		"filterWildDbTableString", "filterDbPairList", "slave", "slaveUntilOptions",
		"slaveConnectionOptions", "slaveThreadOptions", "slaveThreadOption",
		"groupReplication", "preparedStatement", "executeStatement", "executeVarList",
		"cloneStatement", "dataDirSSL", "ssl", "accountManagementStatement",
		"alterUser", "alterUserTail", "userFunction", "createUser", "createUserTail",
		"defaultRoleClause", "requireClause", "connectOptions", "accountLockPasswordExpireOptions",
		"dropUser", "grant", "grantTargetList", "grantOptions", "exceptRoleList",
		"withRoles", "grantAs", "versionedRequireClause", "renameUser", "revoke",
		"onTypeTo", "aclType", "roleOrPrivilegesList", "roleOrPrivilege", "grantIdentifier",
		"requireList", "requireListElement", "grantOption", "setRole", "roleList",
		"role", "tableAdministrationStatement", "histogram", "checkOption",
		"repairType", "installUninstallStatment", "setStatement", "startOptionValueList",
		"transactionCharacteristics", "transactionAccessMode", "isolationLevel",
		"optionValueListContinued", "optionValueNoOptionType", "optionValue",
		"setSystemVariable", "startOptionValueListFollowingOptionType", "optionValueFollowingOptionType",
		"setExprOrDefault", "showStatement", "showCommandType", "nonBlocking",
		"fromOrIn", "inDb", "profileType", "resourceGroupManagement", "createResourceGroup",
		"resourceGroupVcpuList", "vcpuNumOrRange", "resourceGroupPriority",
		"resourceGroupEnableDisable", "alterResourceGroup", "setResourceGroup",
		"threadIdList", "dropResourceGroup", "expr", "boolPri", "compOp", "predicate",
		"predicateOperations", "bitExpr", "simpleExpr", "arrayCast", "jsonOperator",
		"sumExpr", "groupingOperation", "windowFunctionCall", "windowingClause",
		"leadLagInfo", "nullTreatment", "jsonFunction", "inSumExpr", "identListArg",
		"identList", "fulltextOptions", "runtimeFunctionCall", "geometryFunction",
		"timeFunctionParameters", "fractionalPrecision", "weightStringLevels",
		"weightStringLevelListItem", "dateTimeTtype", "trimFunction", "substringFunction",
		"functionCall", "searchJsonFunction", "jsonValueReturning", "jsonValueOnEmpty",
		"jsonValueOnError", "udfExprList", "udfExpr", "variable", "userVariable",
		"systemVariable", "internalVariableName", "whenExpression", "thenExpression",
		"elseExpression", "castType", "exprList", "charset", "notRule", "not2Rule",
		"interval", "intervalTimeStamp", "exprListWithParentheses", "exprWithParentheses",
		"simpleExprWithParentheses", "orderList", "orderExpression", "groupList",
		"groupingExpression", "channel", "columnFormat", "storageMedia", "gcolAttribute",
		"references", "deleteOption", "keyList", "keyPart", "keyListWithExpression",
		"keyPartOrExpression", "keyListVariants", "indexType", "indexOption",
		"commonIndexOption", "visibility", "indexTypeClause", "fulltextIndexOption",
		"spatialIndexOption", "dataTypeDefinition", "dataType", "nchar", "realType",
		"fieldLength", "fieldOptions", "charsetWithOptBinary", "ascii", "unicode",
		"wsNumCodepoints", "typeDatetimePrecision", "charsetName", "collationName",
		"createTableOptions", "createTableOptionsSpaceSeparated", "createTableOption",
		"ternaryOption", "defaultCollation", "defaultEncryption", "defaultCharset",
		"partitionClause", "partitionTypeDef", "subPartitions", "partitionKeyAlgorithm",
		"partitionDefinitions", "partitionDefinition", "partitionValuesIn",
		"partitionOption", "subpartitionDefinition", "partitionValueItemListParen",
		"partitionValueItem", "definerClause", "ifExists", "ifNotExists", "procedureParameter",
		"functionParameter", "collate", "typeWithOptCollate", "schemaIdentifierPair",
		"viewRefList", "updateList", "updateElement", "charsetClause", "fieldsClause",
		"fieldTerm", "linesClause", "lineTerm", "userList", "createUserList",
		"alterUserList", "createUserEntry", "alterUserEntry", "retainCurrentPassword",
		"discardOldPassword", "replacePassword", "userIdentifierOrText", "user",
		"likeClause", "likeOrWhere", "onlineOption", "noWriteToBinLog", "usePartition",
		"fieldIdentifier", "columnName", "columnInternalRef", "columnInternalRefList",
		"columnRef", "insertIdentifier", "indexName", "indexRef", "tableWild",
		"schemaName", "schemaRef", "procedureName", "procedureRef", "functionName",
		"functionRef", "triggerName", "triggerRef", "viewName", "viewRef", "tablespaceName",
		"tablespaceRef", "logfileGroupName", "logfileGroupRef", "eventName",
		"eventRef", "udfName", "serverName", "serverRef", "engineRef", "tableName",
		"filterTableRef", "tableRefWithWildcard", "tableRef", "tableRefList",
		"tableAliasRefList", "parameterName", "labelIdentifier", "labelRef",
		"roleIdentifier", "roleRef", "pluginRef", "componentRef", "resourceGroupRef",
		"windowName", "pureIdentifier", "identifier", "identifierList", "identifierListWithParentheses",
		"qualifiedIdentifier", "simpleIdentifier", "dotIdentifier", "ulong_number",
		"real_ulong_number", "ulonglong_number", "real_ulonglong_number", "literal",
		"signedLiteral", "stringList", "textStringLiteral", "textString", "textStringHash",
		"textLiteral", "textStringNoLinebreak", "textStringLiteralList", "numLiteral",
		"boolLiteral", "nullLiteral", "temporalLiteral", "floatOptions", "standardFloatOptions",
		"precision", "textOrIdentifier", "lValueIdentifier", "roleIdentifierOrText",
		"sizeNumber", "parentheses", "equal", "optionType", "varIdentType",
		"setVarIdentType", "identifierKeyword", "identifierKeywordsAmbiguous1RolesAndLabels",
		"identifierKeywordsAmbiguous2Labels", "labelKeyword", "identifierKeywordsAmbiguous3Roles",
		"identifierKeywordsUnambiguous", "roleKeyword", "lValueKeyword", "identifierKeywordsAmbiguous4SystemVariables",
		"roleOrIdentifierKeyword", "roleOrLabelKeyword",
	}
	staticData.PredictionContextCache = antlr.NewPredictionContextCache()
	staticData.serializedATN = []int32{
		4, 1, 814, 5655, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4,
		7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10,
		7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7,
		15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20,
		2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2,
		26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31,
		7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7,
		36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41,
		2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2,
		47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52,
		7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7,
		57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62,
		2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2,
		68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73,
		7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7,
		78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83,
		2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2,
		89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94,
		7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7,
		99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2,
		104, 7, 104, 2, 105, 7, 105, 2, 106, 7, 106, 2, 107, 7, 107, 2, 108, 7,
		108, 2, 109, 7, 109, 2, 110, 7, 110, 2, 111, 7, 111, 2, 112, 7, 112, 2,
		113, 7, 113, 2, 114, 7, 114, 2, 115, 7, 115, 2, 116, 7, 116, 2, 117, 7,
		117, 2, 118, 7, 118, 2, 119, 7, 119, 2, 120, 7, 120, 2, 121, 7, 121, 2,
		122, 7, 122, 2, 123, 7, 123, 2, 124, 7, 124, 2, 125, 7, 125, 2, 126, 7,
		126, 2, 127, 7, 127, 2, 128, 7, 128, 2, 129, 7, 129, 2, 130, 7, 130, 2,
		131, 7, 131, 2, 132, 7, 132, 2, 133, 7, 133, 2, 134, 7, 134, 2, 135, 7,
		135, 2, 136, 7, 136, 2, 137, 7, 137, 2, 138, 7, 138, 2, 139, 7, 139, 2,
		140, 7, 140, 2, 141, 7, 141, 2, 142, 7, 142, 2, 143, 7, 143, 2, 144, 7,
		144, 2, 145, 7, 145, 2, 146, 7, 146, 2, 147, 7, 147, 2, 148, 7, 148, 2,
		149, 7, 149, 2, 150, 7, 150, 2, 151, 7, 151, 2, 152, 7, 152, 2, 153, 7,
		153, 2, 154, 7, 154, 2, 155, 7, 155, 2, 156, 7, 156, 2, 157, 7, 157, 2,
		158, 7, 158, 2, 159, 7, 159, 2, 160, 7, 160, 2, 161, 7, 161, 2, 162, 7,
		162, 2, 163, 7, 163, 2, 164, 7, 164, 2, 165, 7, 165, 2, 166, 7, 166, 2,
		167, 7, 167, 2, 168, 7, 168, 2, 169, 7, 169, 2, 170, 7, 170, 2, 171, 7,
		171, 2, 172, 7, 172, 2, 173, 7, 173, 2, 174, 7, 174, 2, 175, 7, 175, 2,
		176, 7, 176, 2, 177, 7, 177, 2, 178, 7, 178, 2, 179, 7, 179, 2, 180, 7,
		180, 2, 181, 7, 181, 2, 182, 7, 182, 2, 183, 7, 183, 2, 184, 7, 184, 2,
		185, 7, 185, 2, 186, 7, 186, 2, 187, 7, 187, 2, 188, 7, 188, 2, 189, 7,
		189, 2, 190, 7, 190, 2, 191, 7, 191, 2, 192, 7, 192, 2, 193, 7, 193, 2,
		194, 7, 194, 2, 195, 7, 195, 2, 196, 7, 196, 2, 197, 7, 197, 2, 198, 7,
		198, 2, 199, 7, 199, 2, 200, 7, 200, 2, 201, 7, 201, 2, 202, 7, 202, 2,
		203, 7, 203, 2, 204, 7, 204, 2, 205, 7, 205, 2, 206, 7, 206, 2, 207, 7,
		207, 2, 208, 7, 208, 2, 209, 7, 209, 2, 210, 7, 210, 2, 211, 7, 211, 2,
		212, 7, 212, 2, 213, 7, 213, 2, 214, 7, 214, 2, 215, 7, 215, 2, 216, 7,
		216, 2, 217, 7, 217, 2, 218, 7, 218, 2, 219, 7, 219, 2, 220, 7, 220, 2,
		221, 7, 221, 2, 222, 7, 222, 2, 223, 7, 223, 2, 224, 7, 224, 2, 225, 7,
		225, 2, 226, 7, 226, 2, 227, 7, 227, 2, 228, 7, 228, 2, 229, 7, 229, 2,
		230, 7, 230, 2, 231, 7, 231, 2, 232, 7, 232, 2, 233, 7, 233, 2, 234, 7,
		234, 2, 235, 7, 235, 2, 236, 7, 236, 2, 237, 7, 237, 2, 238, 7, 238, 2,
		239, 7, 239, 2, 240, 7, 240, 2, 241, 7, 241, 2, 242, 7, 242, 2, 243, 7,
		243, 2, 244, 7, 244, 2, 245, 7, 245, 2, 246, 7, 246, 2, 247, 7, 247, 2,
		248, 7, 248, 2, 249, 7, 249, 2, 250, 7, 250, 2, 251, 7, 251, 2, 252, 7,
		252, 2, 253, 7, 253, 2, 254, 7, 254, 2, 255, 7, 255, 2, 256, 7, 256, 2,
		257, 7, 257, 2, 258, 7, 258, 2, 259, 7, 259, 2, 260, 7, 260, 2, 261, 7,
		261, 2, 262, 7, 262, 2, 263, 7, 263, 2, 264, 7, 264, 2, 265, 7, 265, 2,
		266, 7, 266, 2, 267, 7, 267, 2, 268, 7, 268, 2, 269, 7, 269, 2, 270, 7,
		270, 2, 271, 7, 271, 2, 272, 7, 272, 2, 273, 7, 273, 2, 274, 7, 274, 2,
		275, 7, 275, 2, 276, 7, 276, 2, 277, 7, 277, 2, 278, 7, 278, 2, 279, 7,
		279, 2, 280, 7, 280, 2, 281, 7, 281, 2, 282, 7, 282, 2, 283, 7, 283, 2,
		284, 7, 284, 2, 285, 7, 285, 2, 286, 7, 286, 2, 287, 7, 287, 2, 288, 7,
		288, 2, 289, 7, 289, 2, 290, 7, 290, 2, 291, 7, 291, 2, 292, 7, 292, 2,
		293, 7, 293, 2, 294, 7, 294, 2, 295, 7, 295, 2, 296, 7, 296, 2, 297, 7,
		297, 2, 298, 7, 298, 2, 299, 7, 299, 2, 300, 7, 300, 2, 301, 7, 301, 2,
		302, 7, 302, 2, 303, 7, 303, 2, 304, 7, 304, 2, 305, 7, 305, 2, 306, 7,
		306, 2, 307, 7, 307, 2, 308, 7, 308, 2, 309, 7, 309, 2, 310, 7, 310, 2,
		311, 7, 311, 2, 312, 7, 312, 2, 313, 7, 313, 2, 314, 7, 314, 2, 315, 7,
		315, 2, 316, 7, 316, 2, 317, 7, 317, 2, 318, 7, 318, 2, 319, 7, 319, 2,
		320, 7, 320, 2, 321, 7, 321, 2, 322, 7, 322, 2, 323, 7, 323, 2, 324, 7,
		324, 2, 325, 7, 325, 2, 326, 7, 326, 2, 327, 7, 327, 2, 328, 7, 328, 2,
		329, 7, 329, 2, 330, 7, 330, 2, 331, 7, 331, 2, 332, 7, 332, 2, 333, 7,
		333, 2, 334, 7, 334, 2, 335, 7, 335, 2, 336, 7, 336, 2, 337, 7, 337, 2,
		338, 7, 338, 2, 339, 7, 339, 2, 340, 7, 340, 2, 341, 7, 341, 2, 342, 7,
		342, 2, 343, 7, 343, 2, 344, 7, 344, 2, 345, 7, 345, 2, 346, 7, 346, 2,
		347, 7, 347, 2, 348, 7, 348, 2, 349, 7, 349, 2, 350, 7, 350, 2, 351, 7,
		351, 2, 352, 7, 352, 2, 353, 7, 353, 2, 354, 7, 354, 2, 355, 7, 355, 2,
		356, 7, 356, 2, 357, 7, 357, 2, 358, 7, 358, 2, 359, 7, 359, 2, 360, 7,
		360, 2, 361, 7, 361, 2, 362, 7, 362, 2, 363, 7, 363, 2, 364, 7, 364, 2,
		365, 7, 365, 2, 366, 7, 366, 2, 367, 7, 367, 2, 368, 7, 368, 2, 369, 7,
		369, 2, 370, 7, 370, 2, 371, 7, 371, 2, 372, 7, 372, 2, 373, 7, 373, 2,
		374, 7, 374, 2, 375, 7, 375, 2, 376, 7, 376, 2, 377, 7, 377, 2, 378, 7,
		378, 2, 379, 7, 379, 2, 380, 7, 380, 2, 381, 7, 381, 2, 382, 7, 382, 2,
		383, 7, 383, 2, 384, 7, 384, 2, 385, 7, 385, 2, 386, 7, 386, 2, 387, 7,
		387, 2, 388, 7, 388, 2, 389, 7, 389, 2, 390, 7, 390, 2, 391, 7, 391, 2,
		392, 7, 392, 2, 393, 7, 393, 2, 394, 7, 394, 2, 395, 7, 395, 2, 396, 7,
		396, 2, 397, 7, 397, 2, 398, 7, 398, 2, 399, 7, 399, 2, 400, 7, 400, 2,
		401, 7, 401, 2, 402, 7, 402, 2, 403, 7, 403, 2, 404, 7, 404, 2, 405, 7,
		405, 2, 406, 7, 406, 2, 407, 7, 407, 2, 408, 7, 408, 2, 409, 7, 409, 2,
		410, 7, 410, 2, 411, 7, 411, 2, 412, 7, 412, 2, 413, 7, 413, 2, 414, 7,
		414, 2, 415, 7, 415, 2, 416, 7, 416, 2, 417, 7, 417, 1, 0, 1, 0, 3, 0,
		839, 8, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 3, 1, 846, 8, 1, 1, 2, 4, 2, 849,
		8, 2, 11, 2, 12, 2, 850, 1, 3, 3, 3, 854, 8, 3, 1, 3, 1, 3, 1, 3, 3, 3,
		859, 8, 3, 1, 3, 1, 3, 1, 3, 3, 3, 864, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 3,
		3, 870, 8, 3, 1, 3, 3, 3, 873, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 3, 3, 882, 8, 3, 1, 3, 1, 3, 1, 3, 3, 3, 887, 8, 3, 1, 3, 1, 3, 1,
		3, 1, 3, 1, 3, 3, 3, 894, 8, 3, 1, 3, 1, 3, 3, 3, 898, 8, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 3, 3, 905, 8, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 3,
		1, 3, 1, 3, 1, 3, 3, 3, 916, 8, 3, 3, 3, 918, 8, 3, 1, 4, 1, 4, 3, 4, 922,
		8, 4, 1, 5, 3, 5, 925, 8, 5, 1, 5, 1, 5, 1, 6, 1, 6, 3, 6, 931, 8, 6, 1,
		6, 1, 6, 3, 6, 935, 8, 6, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 1, 7, 3,
		7, 944, 8, 7, 1, 7, 1, 7, 1, 7, 3, 7, 949, 8, 7, 1, 8, 3, 8, 952, 8, 8,
		1, 8, 1, 8, 3, 8, 956, 8, 8, 1, 8, 3, 8, 959, 8, 8, 1, 8, 1, 8, 3, 8, 963,
		8, 8, 1, 8, 3, 8, 966, 8, 8, 3, 8, 968, 8, 8, 1, 8, 3, 8, 971, 8, 8, 1,
		9, 1, 9, 1, 9, 1, 9, 3, 9, 977, 8, 9, 1, 9, 1, 9, 3, 9, 981, 8, 9, 3, 9,
		983, 8, 9, 1, 9, 1, 9, 3, 9, 987, 8, 9, 1, 9, 1, 9, 3, 9, 991, 8, 9, 5,
		9, 993, 8, 9, 10, 9, 12, 9, 996, 9, 9, 1, 10, 1, 10, 1, 10, 1, 10, 3, 10,
		1002, 8, 10, 3, 10, 1004, 8, 10, 1, 10, 1, 10, 1, 11, 1, 11, 1, 11, 3,
		11, 1011, 8, 11, 1, 12, 1, 12, 5, 12, 1015, 8, 12, 10, 12, 12, 12, 1018,
		9, 12, 1, 12, 1, 12, 3, 12, 1022, 8, 12, 1, 12, 3, 12, 1025, 8, 12, 1,
		12, 3, 12, 1028, 8, 12, 1, 12, 3, 12, 1031, 8, 12, 1, 12, 3, 12, 1034,
		8, 12, 1, 12, 3, 12, 1037, 8, 12, 1, 13, 1, 13, 1, 14, 1, 14, 1, 15, 1,
		15, 1, 15, 1, 16, 1, 16, 1, 16, 1, 17, 1, 17, 1, 17, 3, 17, 1052, 8, 17,
		1, 18, 1, 18, 3, 18, 1056, 8, 18, 1, 19, 1, 19, 1, 19, 1, 19, 3, 19, 1062,
		8, 19, 1, 19, 3, 19, 1065, 8, 19, 1, 19, 3, 19, 1068, 8, 19, 1, 19, 1,
		19, 1, 19, 1, 19, 3, 19, 1074, 8, 19, 1, 19, 1, 19, 1, 19, 3, 19, 1079,
		8, 19, 5, 19, 1081, 8, 19, 10, 19, 12, 19, 1084, 9, 19, 3, 19, 1086, 8,
		19, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 1, 20, 3, 20, 1094, 8, 20, 3, 20,
		1096, 8, 20, 1, 20, 1, 20, 1, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 22, 1,
		22, 5, 22, 1107, 8, 22, 10, 22, 12, 22, 1110, 9, 22, 1, 23, 1, 23, 1, 23,
		1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 3, 25, 1121, 8, 25, 1, 25, 1,
		25, 1, 25, 3, 25, 1126, 8, 25, 1, 25, 3, 25, 1129, 8, 25, 1, 25, 3, 25,
		1132, 8, 25, 1, 26, 1, 26, 1, 26, 3, 26, 1137, 8, 26, 1, 27, 1, 27, 1,
		28, 1, 28, 3, 28, 1143, 8, 28, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29,
		1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 1, 29, 3, 29, 1159, 8,
		29, 1, 30, 1, 30, 1, 30, 1, 30, 1, 30, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31,
		1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 1, 31, 3, 31, 1179, 8,
		31, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 3, 32, 1188, 8, 32,
		1, 33, 1, 33, 3, 33, 1192, 8, 33, 1, 33, 1, 33, 1, 33, 5, 33, 1197, 8,
		33, 10, 33, 12, 33, 1200, 9, 33, 1, 34, 1, 34, 3, 34, 1204, 8, 34, 1, 34,
		1, 34, 1, 34, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 1213, 8, 35, 1, 36, 1,
		36, 1, 36, 1, 36, 3, 36, 1219, 8, 36, 1, 37, 1, 37, 1, 37, 1, 37, 1, 38,
		1, 38, 1, 39, 1, 39, 1, 39, 3, 39, 1230, 8, 39, 1, 40, 1, 40, 1, 40, 5,
		40, 1235, 8, 40, 10, 40, 12, 40, 1238, 9, 40, 1, 41, 1, 41, 1, 41, 1, 41,
		5, 41, 1244, 8, 41, 10, 41, 12, 41, 1247, 9, 41, 1, 42, 1, 42, 1, 42, 1,
		43, 1, 43, 1, 43, 3, 43, 1255, 8, 43, 1, 43, 1, 43, 1, 44, 1, 44, 3, 44,
		1261, 8, 44, 1, 44, 1, 44, 1, 44, 3, 44, 1266, 8, 44, 5, 44, 1268, 8, 44,
		10, 44, 12, 44, 1271, 9, 44, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45, 1, 45,
		3, 45, 1279, 8, 45, 1, 46, 4, 46, 1282, 8, 46, 11, 46, 12, 46, 1283, 1,
		47, 1, 47, 1, 47, 1, 47, 3, 47, 1290, 8, 47, 1, 47, 3, 47, 1293, 8, 47,
		1, 47, 1, 47, 1, 47, 1, 47, 3, 47, 1299, 8, 47, 1, 48, 1, 48, 1, 49, 1,
		49, 1, 49, 3, 49, 1306, 8, 49, 1, 50, 1, 50, 3, 50, 1310, 8, 50, 1, 50,
		1, 50, 5, 50, 1314, 8, 50, 10, 50, 12, 50, 1317, 9, 50, 1, 51, 1, 51, 1,
		51, 3, 51, 1322, 8, 51, 3, 51, 1324, 8, 51, 1, 52, 3, 52, 1327, 8, 52,
		1, 52, 1, 52, 3, 52, 1331, 8, 52, 1, 53, 1, 53, 1, 53, 1, 54, 1, 54, 1,
		54, 1, 54, 3, 54, 1340, 8, 54, 1, 54, 1, 54, 1, 54, 3, 54, 1345, 8, 54,
		1, 54, 5, 54, 1348, 8, 54, 10, 54, 12, 54, 1351, 9, 54, 1, 55, 1, 55, 5,
		55, 1355, 8, 55, 10, 55, 12, 55, 1358, 9, 55, 1, 56, 1, 56, 1, 56, 1, 56,
		1, 56, 1, 56, 3, 56, 1366, 8, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1, 56, 1,
		56, 3, 56, 1374, 8, 56, 1, 56, 1, 56, 1, 56, 3, 56, 1379, 8, 56, 1, 57,
		1, 57, 3, 57, 1383, 8, 57, 1, 57, 1, 57, 1, 57, 1, 57, 3, 57, 1389, 8,
		57, 1, 57, 3, 57, 1392, 8, 57, 1, 58, 3, 58, 1395, 8, 58, 1, 58, 1, 58,
		3, 58, 1399, 8, 58, 1, 59, 1, 59, 3, 59, 1403, 8, 59, 1, 59, 1, 59, 1,
		60, 1, 60, 1, 60, 1, 60, 1, 60, 3, 60, 1412, 8, 60, 1, 61, 1, 61, 3, 61,
		1416, 8, 61, 1, 61, 3, 61, 1419, 8, 61, 1, 61, 3, 61, 1422, 8, 61, 1, 62,
		1, 62, 1, 62, 3, 62, 1427, 8, 62, 1, 62, 1, 62, 1, 63, 1, 63, 3, 63, 1433,
		8, 63, 1, 63, 3, 63, 1436, 8, 63, 1, 63, 1, 63, 1, 63, 3, 63, 1441, 8,
		63, 1, 63, 3, 63, 1444, 8, 63, 3, 63, 1446, 8, 63, 1, 64, 1, 64, 1, 64,
		3, 64, 1451, 8, 64, 1, 64, 1, 64, 1, 65, 1, 65, 1, 65, 1, 65, 1, 65, 1,
		65, 1, 65, 1, 65, 3, 65, 1463, 8, 65, 1, 66, 1, 66, 1, 66, 1, 66, 1, 66,
		5, 66, 1470, 8, 66, 10, 66, 12, 66, 1473, 9, 66, 1, 66, 1, 66, 1, 67, 1,
		67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 1484, 8, 67, 1, 67, 3, 67,
		1487, 8, 67, 1, 67, 1, 67, 1, 67, 3, 67, 1492, 8, 67, 1, 67, 1, 67, 1,
		67, 1, 67, 1, 67, 3, 67, 1499, 8, 67, 1, 68, 1, 68, 3, 68, 1503, 8, 68,
		1, 68, 1, 68, 3, 68, 1507, 8, 68, 3, 68, 1509, 8, 68, 1, 69, 1, 69, 1,
		69, 1, 69, 1, 70, 1, 70, 1, 70, 1, 70, 1, 71, 1, 71, 1, 71, 1, 71, 3, 71,
		1523, 8, 71, 1, 72, 1, 72, 1, 73, 1, 73, 1, 74, 3, 74, 1530, 8, 74, 1,
		74, 1, 74, 1, 75, 1, 75, 1, 75, 5, 75, 1537, 8, 75, 10, 75, 12, 75, 1540,
		9, 75, 1, 76, 1, 76, 1, 76, 3, 76, 1545, 8, 76, 1, 76, 1, 76, 1, 76, 1,
		76, 1, 76, 1, 76, 1, 76, 3, 76, 1554, 8, 76, 1, 76, 1, 76, 3, 76, 1558,
		8, 76, 1, 76, 1, 76, 3, 76, 1562, 8, 76, 1, 77, 1, 77, 1, 78, 1, 78, 1,
		79, 1, 79, 1, 79, 1, 79, 3, 79, 1572, 8, 79, 3, 79, 1574, 8, 79, 1, 80,
		1, 80, 1, 80, 1, 80, 1, 80, 1, 80, 3, 80, 1582, 8, 80, 1, 81, 1, 81, 1,
		81, 5, 81, 1587, 8, 81, 10, 81, 12, 81, 1590, 9, 81, 1, 82, 1, 82, 3, 82,
		1594, 8, 82, 1, 83, 3, 83, 1597, 8, 83, 1, 83, 1, 83, 3, 83, 1601, 8, 83,
		1, 83, 3, 83, 1604, 8, 83, 1, 83, 1, 83, 1, 83, 1, 83, 3, 83, 1610, 8,
		83, 1, 83, 3, 83, 1613, 8, 83, 1, 83, 3, 83, 1616, 8, 83, 1, 84, 1, 84,
		1, 84, 1, 84, 3, 84, 1622, 8, 84, 1, 85, 1, 85, 1, 85, 5, 85, 1627, 8,
		85, 10, 85, 12, 85, 1630, 9, 85, 1, 85, 1, 85, 3, 85, 1634, 8, 85, 1, 85,
		1, 85, 3, 85, 1638, 8, 85, 1, 85, 3, 85, 1641, 8, 85, 1, 85, 3, 85, 1644,
		8, 85, 1, 85, 3, 85, 1647, 8, 85, 3, 85, 1649, 8, 85, 1, 86, 1, 86, 3,
		86, 1653, 8, 86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 87, 3, 87, 1660, 8, 87,
		1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1666, 8, 88, 1, 88, 1, 88, 3, 88, 1670,
		8, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1675, 8, 88, 1, 88, 3, 88, 1678, 8,
		88, 1, 88, 3, 88, 1681, 8, 88, 1, 88, 3, 88, 1684, 8, 88, 3, 88, 1686,
		8, 88, 1, 88, 1, 88, 1, 88, 3, 88, 1691, 8, 88, 1, 89, 1, 89, 1, 89, 1,
		89, 1, 89, 5, 89, 1698, 8, 89, 10, 89, 12, 89, 1701, 9, 89, 1, 89, 1, 89,
		1, 89, 1, 89, 1, 89, 1, 89, 3, 89, 1709, 8, 89, 1, 90, 1, 90, 3, 90, 1713,
		8, 90, 1, 90, 1, 90, 1, 91, 1, 91, 3, 91, 1719, 8, 91, 1, 91, 3, 91, 1722,
		8, 91, 1, 91, 3, 91, 1725, 8, 91, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1731,
		8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1738, 8, 92, 3, 92, 1740,
		8, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 1, 92, 3, 92, 1748, 8, 92, 1,
		92, 1, 92, 1, 92, 1, 92, 3, 92, 1754, 8, 92, 1, 93, 1, 93, 3, 93, 1758,
		8, 93, 1, 93, 3, 93, 1761, 8, 93, 1, 94, 1, 94, 1, 94, 1, 94, 1, 94, 3,
		94, 1768, 8, 94, 3, 94, 1770, 8, 94, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95,
		1, 95, 1, 95, 3, 95, 1779, 8, 95, 1, 95, 1, 95, 1, 95, 1, 95, 1, 95, 5,
		95, 1786, 8, 95, 10, 95, 12, 95, 1789, 9, 95, 1, 95, 1, 95, 1, 95, 1, 95,
		1, 95, 3, 95, 1796, 8, 95, 1, 95, 1, 95, 1, 95, 1, 95, 3, 95, 1802, 8,
		95, 1, 96, 1, 96, 3, 96, 1806, 8, 96, 1, 96, 1, 96, 1, 96, 1, 96, 3, 96,
		1812, 8, 96, 1, 96, 3, 96, 1815, 8, 96, 3, 96, 1817, 8, 96, 1, 97, 1, 97,
		1, 97, 3, 97, 1822, 8, 97, 1, 98, 1, 98, 1, 98, 1, 98, 3, 98, 1828, 8,
		98, 1, 98, 1, 98, 1, 98, 1, 99, 1, 99, 1, 99, 1, 99, 1, 99, 3, 99, 1838,
		8, 99, 1, 100, 1, 100, 1, 100, 5, 100, 1843, 8, 100, 10, 100, 12, 100,
		1846, 9, 100, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1, 101, 1,
		101, 1, 101, 1, 101, 3, 101, 1939, 8, 101, 1, 102, 1, 102, 3, 102, 1943,
		8, 102, 1, 103, 1, 103, 1, 104, 1, 104, 3, 104, 1949, 8, 104, 1, 105, 1,
		105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1, 105, 1,
		105, 1, 105, 3, 105, 1963, 8, 105, 1, 106, 1, 106, 1, 106, 1, 106, 5, 106,
		1969, 8, 106, 10, 106, 12, 106, 1972, 9, 106, 3, 106, 1974, 8, 106, 1,
		106, 1, 106, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 1, 107, 5, 107, 1984,
		8, 107, 10, 107, 12, 107, 1987, 9, 107, 1, 107, 3, 107, 1990, 8, 107, 1,
		108, 1, 108, 1, 108, 1, 108, 3, 108, 1996, 8, 108, 1, 108, 1, 108, 1, 108,
		1, 108, 1, 108, 3, 108, 2003, 8, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1,
		108, 3, 108, 2010, 8, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108,
		2017, 8, 108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 2024, 8,
		108, 1, 108, 1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 2031, 8, 108, 1, 108,
		1, 108, 1, 108, 1, 108, 1, 108, 3, 108, 2038, 8, 108, 1, 108, 3, 108, 2041,
		8, 108, 1, 109, 1, 109, 1, 109, 5, 109, 2046, 8, 109, 10, 109, 12, 109,
		2049, 9, 109, 1, 110, 1, 110, 1, 110, 5, 110, 2054, 8, 110, 10, 110, 12,
		110, 2057, 9, 110, 1, 111, 1, 111, 1, 111, 5, 111, 2062, 8, 111, 10, 111,
		12, 111, 2065, 9, 111, 1, 112, 1, 112, 1, 113, 1, 113, 1, 113, 5, 113,
		2072, 8, 113, 10, 113, 12, 113, 2075, 9, 113, 1, 114, 1, 114, 1, 114, 3,
		114, 2080, 8, 114, 1, 114, 1, 114, 3, 114, 2084, 8, 114, 1, 114, 1, 114,
		3, 114, 2088, 8, 114, 1, 114, 1, 114, 1, 114, 3, 114, 2093, 8, 114, 1,
		114, 3, 114, 2096, 8, 114, 3, 114, 2098, 8, 114, 1, 115, 1, 115, 1, 115,
		1, 115, 1, 115, 3, 115, 2105, 8, 115, 1, 115, 1, 115, 5, 115, 2109, 8,
		115, 10, 115, 12, 115, 2112, 9, 115, 1, 116, 1, 116, 1, 116, 3, 116, 2117,
		8, 116, 1, 116, 1, 116, 1, 116, 3, 116, 2122, 8, 116, 1, 116, 1, 116, 1,
		116, 3, 116, 2127, 8, 116, 1, 116, 1, 116, 1, 116, 3, 116, 2132, 8, 116,
		1, 116, 3, 116, 2135, 8, 116, 1, 117, 1, 117, 1, 117, 5, 117, 2140, 8,
		117, 10, 117, 12, 117, 2143, 9, 117, 1, 118, 1, 118, 1, 119, 1, 119, 1,
		119, 1, 120, 1, 120, 1, 120, 1, 120, 1, 120, 3, 120, 2155, 8, 120, 1, 120,
		1, 120, 1, 120, 1, 120, 3, 120, 2161, 8, 120, 1, 121, 1, 121, 1, 121, 1,
		121, 3, 121, 2167, 8, 121, 1, 122, 1, 122, 1, 122, 5, 122, 2172, 8, 122,
		10, 122, 12, 122, 2175, 9, 122, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123,
		3, 123, 2182, 8, 123, 1, 123, 1, 123, 1, 123, 1, 123, 3, 123, 2188, 8,
		123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1, 123, 1,
		123, 3, 123, 2199, 8, 123, 3, 123, 2201, 8, 123, 1, 124, 1, 124, 1, 124,
		1, 124, 3, 124, 2207, 8, 124, 1, 124, 1, 124, 3, 124, 2211, 8, 124, 3,
		124, 2213, 8, 124, 1, 125, 1, 125, 3, 125, 2217, 8, 125, 1, 125, 1, 125,
		1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 1, 126, 3, 126, 2228, 8,
		126, 1, 127, 1, 127, 1, 127, 3, 127, 2233, 8, 127, 1, 127, 1, 127, 1, 128,
		1, 128, 3, 128, 2239, 8, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1,
		128, 1, 128, 3, 128, 2248, 8, 128, 1, 128, 3, 128, 2251, 8, 128, 1, 128,
		1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128,
		2262, 8, 128, 1, 128, 1, 128, 1, 128, 1, 128, 3, 128, 2268, 8, 128, 1,
		128, 1, 128, 1, 128, 1, 128, 3, 128, 2274, 8, 128, 1, 128, 1, 128, 1, 128,
		1, 128, 1, 128, 3, 128, 2281, 8, 128, 3, 128, 2283, 8, 128, 1, 129, 1,
		129, 1, 129, 1, 130, 1, 130, 1, 130, 1, 130, 3, 130, 2292, 8, 130, 1, 130,
		1, 130, 1, 130, 1, 130, 1, 131, 3, 131, 2299, 8, 131, 1, 131, 3, 131, 2302,
		8, 131, 1, 131, 5, 131, 2305, 8, 131, 10, 131, 12, 131, 2308, 9, 131, 1,
		131, 1, 131, 1, 131, 1, 131, 3, 131, 2314, 8, 131, 1, 131, 3, 131, 2317,
		8, 131, 1, 132, 1, 132, 1, 132, 3, 132, 2322, 8, 132, 1, 132, 3, 132, 2325,
		8, 132, 1, 133, 1, 133, 1, 133, 3, 133, 2330, 8, 133, 1, 134, 1, 134, 1,
		134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 1, 134, 4, 134, 2341, 8, 134,
		11, 134, 12, 134, 2342, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135,
		1, 135, 1, 135, 1, 135, 1, 135, 3, 135, 2355, 8, 135, 1, 135, 1, 135, 1,
		135, 3, 135, 2360, 8, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135, 1, 135,
		3, 135, 2368, 8, 135, 1, 135, 1, 135, 1, 135, 3, 135, 2373, 8, 135, 3,
		135, 2375, 8, 135, 3, 135, 2377, 8, 135, 1, 136, 1, 136, 1, 136, 3, 136,
		2382, 8, 136, 1, 136, 1, 136, 1, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1,
		137, 1, 137, 3, 137, 2393, 8, 137, 1, 137, 1, 137, 1, 137, 3, 137, 2398,
		8, 137, 3, 137, 2400, 8, 137, 1, 137, 1, 137, 3, 137, 2404, 8, 137, 1,
		137, 1, 137, 1, 137, 1, 137, 3, 137, 2410, 8, 137, 1, 137, 3, 137, 2413,
		8, 137, 1, 137, 3, 137, 2416, 8, 137, 1, 137, 1, 137, 1, 137, 1, 137, 1,
		137, 1, 137, 1, 137, 1, 137, 3, 137, 2426, 8, 137, 3, 137, 2428, 8, 137,
		1, 138, 1, 138, 3, 138, 2432, 8, 138, 1, 139, 1, 139, 4, 139, 2436, 8,
		139, 11, 139, 12, 139, 2437, 1, 139, 1, 139, 1, 139, 3, 139, 2443, 8, 139,
		1, 140, 1, 140, 1, 140, 1, 141, 1, 141, 1, 141, 1, 141, 1, 141, 3, 141,
		2453, 8, 141, 1, 141, 1, 141, 3, 141, 2457, 8, 141, 1, 142, 1, 142, 1,
		142, 3, 142, 2462, 8, 142, 1, 143, 1, 143, 1, 144, 1, 144, 1, 144, 1, 144,
		1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 1, 144, 5, 144, 2476, 8, 144, 10,
		144, 12, 144, 2479, 9, 144, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1,
		145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145, 3, 145, 2493, 8, 145,
		1, 145, 1, 145, 3, 145, 2497, 8, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1,
		145, 1, 145, 3, 145, 2505, 8, 145, 1, 145, 1, 145, 1, 145, 1, 145, 1, 145,
		1, 145, 3, 145, 2513, 8, 145, 1, 146, 1, 146, 3, 146, 2517, 8, 146, 1,
		146, 1, 146, 1, 146, 3, 146, 2522, 8, 146, 1, 146, 3, 146, 2525, 8, 146,
		3, 146, 2527, 8, 146, 1, 147, 1, 147, 1, 148, 1, 148, 1, 148, 5, 148, 2534,
		8, 148, 10, 148, 12, 148, 2537, 9, 148, 1, 149, 1, 149, 3, 149, 2541, 8,
		149, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149, 2547, 8, 149, 3, 149, 2549,
		8, 149, 1, 149, 1, 149, 3, 149, 2553, 8, 149, 1, 149, 1, 149, 1, 149, 1,
		149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149, 2564, 8, 149, 1, 149,
		1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 3, 149, 2574, 8,
		149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1, 149, 1,
		149, 1, 149, 3, 149, 2586, 8, 149, 1, 150, 1, 150, 1, 150, 3, 150, 2591,
		8, 150, 1, 150, 1, 150, 1, 150, 3, 150, 2596, 8, 150, 1, 150, 1, 150, 1,
		150, 1, 150, 1, 150, 3, 150, 2603, 8, 150, 1, 151, 1, 151, 3, 151, 2607,
		8, 151, 1, 151, 5, 151, 2610, 8, 151, 10, 151, 12, 151, 2613, 9, 151, 1,
		152, 1, 152, 1, 152, 1, 152, 1, 152, 1, 152, 3, 152, 2621, 8, 152, 1, 153,
		1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153, 1, 153,
		3, 153, 2633, 8, 153, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1,
		154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 3, 154, 2647, 8, 154, 1, 154,
		1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 1, 154, 3, 154, 2656, 8, 154, 3,
		154, 2658, 8, 154, 1, 155, 1, 155, 1, 155, 5, 155, 2663, 8, 155, 10, 155,
		12, 155, 2666, 9, 155, 1, 156, 1, 156, 1, 156, 1, 156, 3, 156, 2672, 8,
		156, 1, 157, 1, 157, 3, 157, 2676, 8, 157, 1, 157, 1, 157, 1, 157, 3, 157,
		2681, 8, 157, 1, 157, 1, 157, 1, 157, 1, 157, 5, 157, 2687, 8, 157, 10,
		157, 12, 157, 2690, 9, 157, 1, 157, 1, 157, 1, 157, 1, 157, 3, 157, 2696,
		8, 157, 1, 157, 1, 157, 3, 157, 2700, 8, 157, 1, 157, 1, 157, 1, 157, 1,
		157, 3, 157, 2706, 8, 157, 1, 157, 1, 157, 1, 157, 5, 157, 2711, 8, 157,
		10, 157, 12, 157, 2714, 9, 157, 3, 157, 2716, 8, 157, 1, 158, 1, 158, 1,
		158, 1, 158, 1, 158, 1, 158, 1, 158, 3, 158, 2725, 8, 158, 1, 158, 1, 158,
		1, 158, 1, 158, 3, 158, 2731, 8, 158, 1, 159, 1, 159, 1, 159, 3, 159, 2736,
		8, 159, 1, 160, 1, 160, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161,
		1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161, 1, 161,
		1, 161, 1, 161, 5, 161, 2757, 8, 161, 10, 161, 12, 161, 2760, 9, 161, 3,
		161, 2762, 8, 161, 1, 162, 1, 162, 1, 162, 1, 163, 1, 163, 1, 163, 1, 163,
		1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 3, 163, 2778, 8,
		163, 1, 163, 1, 163, 1, 163, 3, 163, 2783, 8, 163, 1, 163, 3, 163, 2786,
		8, 163, 1, 163, 1, 163, 3, 163, 2790, 8, 163, 1, 163, 3, 163, 2793, 8,
		163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1, 163, 1,
		163, 1, 163, 3, 163, 2805, 8, 163, 1, 163, 1, 163, 1, 163, 3, 163, 2810,
		8, 163, 1, 163, 1, 163, 1, 163, 3, 163, 2815, 8, 163, 1, 163, 3, 163, 2818,
		8, 163, 3, 163, 2820, 8, 163, 1, 164, 1, 164, 3, 164, 2824, 8, 164, 1,
		164, 1, 164, 1, 164, 3, 164, 2829, 8, 164, 3, 164, 2831, 8, 164, 1, 165,
		1, 165, 1, 165, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166, 1, 166,
		3, 166, 2843, 8, 166, 1, 167, 1, 167, 5, 167, 2847, 8, 167, 10, 167, 12,
		167, 2850, 9, 167, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168,
		1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168, 1, 168,
		1, 168, 1, 168, 1, 168, 3, 168, 2871, 8, 168, 1, 168, 3, 168, 2874, 8,
		168, 3, 168, 2876, 8, 168, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169, 1, 169,
		3, 169, 2884, 8, 169, 1, 170, 1, 170, 3, 170, 2888, 8, 170, 1, 170, 1,
		170, 1, 171, 1, 171, 1, 171, 1, 171, 1, 171, 3, 171, 2897, 8, 171, 1, 172,
		1, 172, 1, 172, 1, 172, 1, 173, 1, 173, 1, 173, 3, 173, 2906, 8, 173, 1,
		174, 1, 174, 1, 174, 1, 174, 3, 174, 2912, 8, 174, 1, 174, 3, 174, 2915,
		8, 174, 1, 174, 1, 174, 3, 174, 2919, 8, 174, 1, 174, 3, 174, 2922, 8,
		174, 1, 174, 3, 174, 2925, 8, 174, 1, 174, 1, 174, 3, 174, 2929, 8, 174,
		1, 174, 3, 174, 2932, 8, 174, 1, 174, 1, 174, 3, 174, 2936, 8, 174, 1,
		174, 3, 174, 2939, 8, 174, 1, 174, 1, 174, 1, 174, 3, 174, 2944, 8, 174,
		1, 174, 3, 174, 2947, 8, 174, 1, 174, 1, 174, 1, 174, 3, 174, 2952, 8,
		174, 1, 174, 3, 174, 2955, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174,
		2961, 8, 174, 1, 174, 1, 174, 3, 174, 2965, 8, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 3, 174, 2971, 8, 174, 1, 174, 3, 174, 2974, 8, 174, 1, 174,
		1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 2983, 8, 174, 3,
		174, 2985, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 2991, 8, 174,
		1, 174, 1, 174, 3, 174, 2995, 8, 174, 1, 174, 3, 174, 2998, 8, 174, 1,
		174, 3, 174, 3001, 8, 174, 1, 174, 3, 174, 3004, 8, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 3, 174, 3010, 8, 174, 1, 174, 3, 174, 3013, 8, 174, 1,
		174, 3, 174, 3016, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 3, 174, 3026, 8, 174, 1, 174, 1, 174, 3, 174, 3030, 8,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 5, 174, 3037, 8, 174, 10,
		174, 12, 174, 3040, 9, 174, 3, 174, 3042, 8, 174, 1, 174, 1, 174, 1, 174,
		3, 174, 3047, 8, 174, 1, 174, 3, 174, 3050, 8, 174, 1, 174, 3, 174, 3053,
		8, 174, 1, 174, 1, 174, 3, 174, 3057, 8, 174, 1, 174, 3, 174, 3060, 8,
		174, 1, 174, 1, 174, 1, 174, 3, 174, 3065, 8, 174, 1, 174, 1, 174, 3, 174,
		3069, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 3, 174, 3076, 8,
		174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 3, 174, 3089, 8, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174, 1, 174,
		1, 174, 1, 174, 3, 174, 3106, 8, 174, 1, 174, 1, 174, 1, 174, 3, 174, 3111,
		8, 174, 1, 174, 1, 174, 1, 174, 3, 174, 3116, 8, 174, 1, 174, 1, 174, 1,
		174, 1, 174, 1, 174, 1, 174, 3, 174, 3124, 8, 174, 1, 175, 1, 175, 1, 175,
		3, 175, 3129, 8, 175, 3, 175, 3131, 8, 175, 1, 176, 3, 176, 3134, 8, 176,
		1, 176, 3, 176, 3137, 8, 176, 1, 177, 1, 177, 1, 178, 1, 178, 1, 178, 1,
		179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 1, 179, 3, 179, 3151, 8, 179,
		1, 180, 1, 180, 1, 180, 1, 180, 3, 180, 3157, 8, 180, 1, 181, 1, 181, 1,
		181, 1, 181, 1, 181, 1, 181, 3, 181, 3165, 8, 181, 1, 181, 1, 181, 3, 181,
		3169, 8, 181, 1, 181, 3, 181, 3172, 8, 181, 1, 181, 3, 181, 3175, 8, 181,
		1, 182, 1, 182, 3, 182, 3179, 8, 182, 1, 182, 1, 182, 3, 182, 3183, 8,
		182, 1, 182, 5, 182, 3186, 8, 182, 10, 182, 12, 182, 3189, 9, 182, 1, 183,
		1, 183, 1, 183, 3, 183, 3194, 8, 183, 1, 184, 1, 184, 3, 184, 3198, 8,
		184, 1, 184, 1, 184, 1, 185, 1, 185, 1, 186, 1, 186, 1, 186, 1, 186, 1,
		186, 3, 186, 3209, 8, 186, 1, 186, 3, 186, 3212, 8, 186, 1, 186, 3, 186,
		3215, 8, 186, 1, 186, 3, 186, 3218, 8, 186, 1, 187, 1, 187, 1, 187, 1,
		187, 1, 187, 1, 187, 3, 187, 3226, 8, 187, 1, 188, 1, 188, 3, 188, 3230,
		8, 188, 1, 188, 5, 188, 3233, 8, 188, 10, 188, 12, 188, 3236, 9, 188, 1,
		189, 1, 189, 1, 189, 1, 189, 1, 189, 3, 189, 3243, 8, 189, 1, 190, 1, 190,
		1, 190, 1, 190, 3, 190, 3249, 8, 190, 1, 190, 3, 190, 3252, 8, 190, 1,
		190, 1, 190, 3, 190, 3256, 8, 190, 1, 190, 1, 190, 1, 190, 1, 190, 1, 190,
		1, 190, 1, 190, 1, 190, 1, 190, 5, 190, 3267, 8, 190, 10, 190, 12, 190,
		3270, 9, 190, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 3, 191, 3278,
		8, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191, 1, 191,
		1, 191, 1, 191, 5, 191, 3290, 8, 191, 10, 191, 12, 191, 3293, 9, 191, 1,
		192, 1, 192, 1, 193, 1, 193, 3, 193, 3299, 8, 193, 1, 193, 1, 193, 1, 193,
		3, 193, 3304, 8, 193, 1, 193, 1, 193, 1, 193, 1, 193, 3, 193, 3310, 8,
		193, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 3, 194, 3318, 8, 194,
		1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194, 1, 194,
		3, 194, 3329, 8, 194, 1, 194, 1, 194, 3, 194, 3333, 8, 194, 1, 195, 1,
		195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1,
		195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1,
		195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 1, 195, 5, 195, 3362,
		8, 195, 10, 195, 12, 195, 3365, 9, 195, 1, 196, 1, 196, 1, 196, 1, 196,
		1, 196, 3, 196, 3372, 8, 196, 1, 196, 1, 196, 3, 196, 3376, 8, 196, 1,
		196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1,
		196, 1, 196, 1, 196, 1, 196, 3, 196, 3391, 8, 196, 1, 196, 1, 196, 1, 196,
		1, 196, 1, 196, 3, 196, 3398, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1,
		196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3, 196, 3412,
		8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196,
		1, 196, 1, 196, 3, 196, 3424, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196, 3,
		196, 3430, 8, 196, 1, 196, 1, 196, 1, 196, 4, 196, 3435, 8, 196, 11, 196,
		12, 196, 3436, 1, 196, 3, 196, 3440, 8, 196, 1, 196, 1, 196, 1, 196, 1,
		196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1,
		196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1,
		196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1, 196, 1,
		196, 1, 196, 1, 196, 3, 196, 3475, 8, 196, 1, 196, 1, 196, 1, 196, 1, 196,
		1, 196, 1, 196, 5, 196, 3483, 8, 196, 10, 196, 12, 196, 3486, 9, 196, 1,
		197, 1, 197, 1, 198, 1, 198, 1, 198, 1, 198, 3, 198, 3494, 8, 198, 1, 199,
		1, 199, 1, 199, 3, 199, 3499, 8, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3504,
		8, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3511, 8, 199, 1,
		199, 1, 199, 1, 199, 1, 199, 3, 199, 3517, 8, 199, 1, 199, 1, 199, 1, 199,
		3, 199, 3522, 8, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3527, 8, 199, 1,
		199, 1, 199, 1, 199, 1, 199, 3, 199, 3533, 8, 199, 1, 199, 1, 199, 3, 199,
		3537, 8, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3542, 8, 199, 1, 199, 1,
		199, 1, 199, 3, 199, 3547, 8, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3552,
		8, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3557, 8, 199, 1, 199, 1, 199, 1,
		199, 1, 199, 1, 199, 3, 199, 3564, 8, 199, 1, 199, 1, 199, 1, 199, 1, 199,
		1, 199, 3, 199, 3571, 8, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 3,
		199, 3578, 8, 199, 1, 199, 1, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3585,
		8, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3590, 8, 199, 1, 199, 1, 199, 1,
		199, 3, 199, 3595, 8, 199, 1, 199, 1, 199, 1, 199, 3, 199, 3600, 8, 199,
		1, 199, 1, 199, 3, 199, 3604, 8, 199, 1, 199, 1, 199, 3, 199, 3608, 8,
		199, 1, 199, 1, 199, 3, 199, 3612, 8, 199, 3, 199, 3614, 8, 199, 1, 200,
		1, 200, 1, 200, 1, 200, 1, 200, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201,
		1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 3, 201, 3633, 8,
		201, 1, 201, 1, 201, 3, 201, 3637, 8, 201, 1, 201, 1, 201, 1, 201, 1, 201,
		1, 201, 3, 201, 3644, 8, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1, 201, 1,
		201, 1, 201, 1, 201, 1, 201, 1, 201, 3, 201, 3656, 8, 201, 1, 201, 3, 201,
		3659, 8, 201, 1, 201, 1, 201, 3, 201, 3663, 8, 201, 1, 202, 1, 202, 1,
		202, 3, 202, 3668, 8, 202, 1, 203, 1, 203, 1, 203, 3, 203, 3673, 8, 203,
		1, 203, 1, 203, 3, 203, 3677, 8, 203, 1, 204, 1, 204, 1, 204, 1, 205, 1,
		205, 1, 205, 1, 205, 1, 205, 3, 205, 3687, 8, 205, 1, 205, 1, 205, 1, 205,
		1, 205, 1, 205, 1, 205, 1, 205, 3, 205, 3696, 8, 205, 3, 205, 3698, 8,
		205, 1, 206, 3, 206, 3701, 8, 206, 1, 206, 1, 206, 1, 207, 1, 207, 1, 207,
		1, 207, 1, 207, 3, 207, 3710, 8, 207, 1, 208, 1, 208, 1, 208, 5, 208, 3715,
		8, 208, 10, 208, 12, 208, 3718, 9, 208, 1, 209, 1, 209, 1, 209, 1, 209,
		1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 1, 209, 3, 209, 3730, 8, 209, 1,
		209, 1, 209, 1, 209, 3, 209, 3735, 8, 209, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 3, 210, 3742, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3748,
		8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 4, 210, 3772, 8, 210, 11, 210,
		12, 210, 3773, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3805, 8, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3825, 8, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 3, 210, 3831, 8, 210, 1, 210, 1, 210, 3,
		210, 3835, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		3, 210, 3862, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 3, 210, 3874, 8, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 3, 210,
		3887, 8, 210, 1, 210, 1, 210, 3, 210, 3891, 8, 210, 1, 210, 1, 210, 3,
		210, 3895, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 3, 210, 3923, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 3, 210, 3977, 8, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210,
		1, 210, 1, 210, 1, 210, 3, 210, 3987, 8, 210, 1, 210, 3, 210, 3990, 8,
		210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1, 210, 1,
		210, 1, 210, 3, 210, 4002, 8, 210, 1, 210, 1, 210, 1, 210, 3, 210, 4007,
		8, 210, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211,
		1, 211, 1, 211, 3, 211, 4019, 8, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1,
		211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1, 211, 1,
		211, 1, 211, 1, 211, 1, 211, 1, 211, 3, 211, 4039, 8, 211, 1, 212, 1, 212,
		3, 212, 4043, 8, 212, 1, 212, 1, 212, 1, 213, 1, 213, 1, 214, 1, 214, 1,
		214, 1, 214, 1, 214, 1, 214, 1, 214, 1, 214, 5, 214, 4057, 8, 214, 10,
		214, 12, 214, 4060, 9, 214, 3, 214, 4062, 8, 214, 1, 215, 1, 215, 1, 215,
		3, 215, 4067, 8, 215, 1, 215, 3, 215, 4070, 8, 215, 1, 216, 1, 216, 1,
		217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 4079, 8, 217, 1, 217, 1, 217,
		3, 217, 4083, 8, 217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 4089, 8,
		217, 1, 217, 1, 217, 1, 217, 1, 217, 3, 217, 4095, 8, 217, 1, 217, 1, 217,
		3, 217, 4099, 8, 217, 1, 217, 1, 217, 1, 218, 1, 218, 1, 218, 1, 218, 1,
		218, 1, 218, 1, 218, 3, 218, 4110, 8, 218, 1, 218, 1, 218, 1, 218, 1, 218,
		3, 218, 4116, 8, 218, 3, 218, 4118, 8, 218, 1, 218, 1, 218, 1, 219, 1,
		219, 1, 219, 3, 219, 4125, 8, 219, 1, 219, 1, 219, 1, 219, 1, 219, 1, 219,
		3, 219, 4132, 8, 219, 1, 219, 1, 219, 3, 219, 4136, 8, 219, 1, 220, 1,
		220, 1, 220, 1, 220, 1, 220, 1, 220, 3, 220, 4144, 8, 220, 1, 220, 3, 220,
		4147, 8, 220, 1, 220, 3, 220, 4150, 8, 220, 1, 220, 1, 220, 1, 221, 1,
		221, 1, 221, 1, 222, 1, 222, 1, 222, 1, 222, 3, 222, 4161, 8, 222, 1, 222,
		1, 222, 1, 222, 1, 223, 1, 223, 1, 223, 1, 223, 3, 223, 4170, 8, 223, 1,
		223, 1, 223, 1, 223, 1, 224, 1, 224, 1, 224, 5, 224, 4178, 8, 224, 10,
		224, 12, 224, 4181, 9, 224, 1, 225, 1, 225, 3, 225, 4185, 8, 225, 1, 226,
		1, 226, 3, 226, 4189, 8, 226, 1, 227, 1, 227, 1, 227, 3, 227, 4194, 8,
		227, 1, 228, 1, 228, 3, 228, 4198, 8, 228, 1, 228, 1, 228, 3, 228, 4202,
		8, 228, 1, 229, 1, 229, 3, 229, 4206, 8, 229, 1, 229, 1, 229, 3, 229, 4210,
		8, 229, 3, 229, 4212, 8, 229, 1, 229, 1, 229, 3, 229, 4216, 8, 229, 1,
		230, 1, 230, 1, 230, 1, 231, 1, 231, 1, 231, 1, 232, 1, 232, 1, 232, 1,
		233, 1, 233, 3, 233, 4229, 8, 233, 1, 233, 1, 233, 3, 233, 4233, 8, 233,
		1, 233, 3, 233, 4236, 8, 233, 1, 233, 1, 233, 3, 233, 4240, 8, 233, 1,
		233, 1, 233, 3, 233, 4244, 8, 233, 1, 233, 1, 233, 3, 233, 4248, 8, 233,
		1, 233, 1, 233, 1, 233, 3, 233, 4253, 8, 233, 1, 233, 1, 233, 3, 233, 4257,
		8, 233, 1, 233, 1, 233, 3, 233, 4261, 8, 233, 1, 233, 1, 233, 1, 233, 1,
		233, 3, 233, 4267, 8, 233, 3, 233, 4269, 8, 233, 1, 234, 1, 234, 1, 234,
		5, 234, 4274, 8, 234, 10, 234, 12, 234, 4277, 9, 234, 1, 235, 1, 235, 1,
		235, 3, 235, 4282, 8, 235, 1, 236, 1, 236, 1, 237, 1, 237, 1, 238, 1, 238,
		3, 238, 4290, 8, 238, 1, 239, 1, 239, 1, 240, 1, 240, 1, 240, 1, 240, 1,
		241, 1, 241, 1, 241, 1, 241, 1, 242, 1, 242, 1, 242, 1, 242, 1, 243, 1,
		243, 1, 243, 5, 243, 4309, 8, 243, 10, 243, 12, 243, 4312, 9, 243, 1, 244,
		1, 244, 3, 244, 4316, 8, 244, 1, 245, 1, 245, 1, 245, 5, 245, 4321, 8,
		245, 10, 245, 12, 245, 4324, 9, 245, 1, 246, 1, 246, 1, 247, 1, 247, 1,
		247, 1, 247, 1, 248, 1, 248, 1, 249, 1, 249, 1, 250, 1, 250, 3, 250, 4338,
		8, 250, 1, 250, 1, 250, 1, 250, 3, 250, 4343, 8, 250, 1, 250, 1, 250, 3,
		250, 4347, 8, 250, 1, 250, 3, 250, 4350, 8, 250, 1, 251, 1, 251, 1, 251,
		3, 251, 4355, 8, 251, 1, 251, 1, 251, 3, 251, 4359, 8, 251, 1, 251, 1,
		251, 1, 251, 1, 251, 1, 251, 1, 251, 3, 251, 4367, 8, 251, 1, 251, 1, 251,
		1, 251, 1, 251, 1, 251, 1, 251, 3, 251, 4375, 8, 251, 3, 251, 4377, 8,
		251, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 1, 252, 3, 252, 4386,
		8, 252, 1, 253, 1, 253, 1, 253, 1, 253, 5, 253, 4392, 8, 253, 10, 253,
		12, 253, 4395, 9, 253, 1, 253, 1, 253, 1, 254, 1, 254, 3, 254, 4401, 8,
		254, 1, 254, 3, 254, 4404, 8, 254, 1, 255, 1, 255, 1, 255, 1, 255, 5, 255,
		4410, 8, 255, 10, 255, 12, 255, 4413, 9, 255, 1, 255, 1, 255, 1, 256, 1,
		256, 1, 256, 3, 256, 4420, 8, 256, 3, 256, 4422, 8, 256, 1, 257, 1, 257,
		3, 257, 4426, 8, 257, 1, 258, 1, 258, 1, 259, 1, 259, 3, 259, 4432, 8,
		259, 1, 260, 1, 260, 3, 260, 4436, 8, 260, 1, 260, 1, 260, 1, 260, 1, 260,
		3, 260, 4442, 8, 260, 1, 261, 1, 261, 1, 262, 1, 262, 1, 262, 1, 263, 1,
		263, 1, 263, 1, 263, 3, 263, 4453, 8, 263, 1, 264, 1, 264, 1, 265, 1, 265,
		1, 265, 1, 266, 1, 266, 3, 266, 4462, 8, 266, 1, 266, 3, 266, 4465, 8,
		266, 1, 266, 1, 266, 1, 266, 3, 266, 4470, 8, 266, 3, 266, 4472, 8, 266,
		1, 266, 3, 266, 4475, 8, 266, 1, 266, 3, 266, 4478, 8, 266, 1, 266, 1,
		266, 3, 266, 4482, 8, 266, 1, 266, 3, 266, 4485, 8, 266, 1, 266, 1, 266,
		3, 266, 4489, 8, 266, 1, 266, 1, 266, 1, 266, 3, 266, 4494, 8, 266, 1,
		266, 3, 266, 4497, 8, 266, 1, 266, 1, 266, 3, 266, 4501, 8, 266, 1, 266,
		3, 266, 4504, 8, 266, 1, 266, 1, 266, 3, 266, 4508, 8, 266, 1, 266, 1,
		266, 1, 266, 3, 266, 4513, 8, 266, 1, 266, 1, 266, 3, 266, 4517, 8, 266,
		1, 266, 1, 266, 1, 266, 1, 266, 1, 266, 1, 266, 1, 266, 1, 266, 1, 266,
		1, 266, 3, 266, 4529, 8, 266, 1, 266, 1, 266, 3, 266, 4533, 8, 266, 1,
		266, 1, 266, 1, 266, 1, 266, 3, 266, 4539, 8, 266, 1, 266, 3, 266, 4542,
		8, 266, 1, 266, 1, 266, 1, 266, 3, 266, 4547, 8, 266, 1, 266, 1, 266, 3,
		266, 4551, 8, 266, 1, 266, 1, 266, 3, 266, 4555, 8, 266, 1, 266, 1, 266,
		1, 266, 3, 266, 4560, 8, 266, 1, 266, 1, 266, 1, 266, 1, 266, 1, 266, 1,
		266, 1, 266, 3, 266, 4569, 8, 266, 1, 266, 3, 266, 4572, 8, 266, 1, 266,
		1, 266, 3, 266, 4576, 8, 266, 1, 266, 1, 266, 3, 266, 4580, 8, 266, 1,
		266, 3, 266, 4583, 8, 266, 1, 266, 1, 266, 3, 266, 4587, 8, 266, 1, 266,
		1, 266, 3, 266, 4591, 8, 266, 1, 266, 1, 266, 1, 266, 3, 266, 4596, 8,
		266, 1, 266, 1, 266, 1, 266, 3, 266, 4601, 8, 266, 1, 266, 1, 266, 1, 266,
		3, 266, 4606, 8, 266, 1, 267, 1, 267, 1, 267, 3, 267, 4611, 8, 267, 1,
		268, 1, 268, 1, 268, 3, 268, 4616, 8, 268, 3, 268, 4618, 8, 268, 1, 269,
		1, 269, 1, 269, 3, 269, 4623, 8, 269, 1, 269, 1, 269, 1, 270, 4, 270, 4628,
		8, 270, 11, 270, 12, 270, 4629, 1, 271, 1, 271, 1, 271, 1, 271, 1, 271,
		1, 271, 3, 271, 4638, 8, 271, 1, 271, 1, 271, 1, 271, 1, 271, 3, 271, 4644,
		8, 271, 3, 271, 4646, 8, 271, 1, 272, 1, 272, 3, 272, 4650, 8, 272, 1,
		272, 1, 272, 3, 272, 4654, 8, 272, 1, 273, 1, 273, 3, 273, 4658, 8, 273,
		1, 273, 1, 273, 3, 273, 4662, 8, 273, 1, 274, 1, 274, 1, 274, 1, 274, 1,
		275, 1, 275, 1, 275, 1, 275, 1, 276, 1, 276, 1, 276, 3, 276, 4675, 8, 276,
		1, 277, 1, 277, 1, 277, 3, 277, 4680, 8, 277, 1, 278, 1, 278, 3, 278, 4684,
		8, 278, 1, 278, 5, 278, 4687, 8, 278, 10, 278, 12, 278, 4690, 9, 278, 1,
		279, 4, 279, 4693, 8, 279, 11, 279, 12, 279, 4694, 1, 280, 1, 280, 3, 280,
		4699, 8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4704, 8, 280, 1, 280, 1,
		280, 3, 280, 4708, 8, 280, 1, 280, 1, 280, 3, 280, 4712, 8, 280, 1, 280,
		1, 280, 1, 280, 3, 280, 4717, 8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4722,
		8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4727, 8, 280, 1, 280, 1, 280, 1,
		280, 3, 280, 4732, 8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4737, 8, 280,
		1, 280, 1, 280, 1, 280, 3, 280, 4742, 8, 280, 1, 280, 1, 280, 1, 280, 3,
		280, 4747, 8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4752, 8, 280, 1, 280,
		1, 280, 1, 280, 3, 280, 4757, 8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4762,
		8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4767, 8, 280, 1, 280, 1, 280, 1,
		280, 3, 280, 4772, 8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4777, 8, 280,
		1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 1, 280, 3, 280,
		4787, 8, 280, 1, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4793, 8, 280, 1,
		280, 1, 280, 1, 280, 1, 280, 3, 280, 4799, 8, 280, 1, 280, 1, 280, 1, 280,
		3, 280, 4804, 8, 280, 1, 280, 3, 280, 4807, 8, 280, 1, 280, 1, 280, 1,
		280, 1, 280, 1, 280, 3, 280, 4814, 8, 280, 1, 280, 1, 280, 1, 280, 3, 280,
		4819, 8, 280, 1, 280, 1, 280, 1, 280, 3, 280, 4824, 8, 280, 1, 281, 1,
		281, 3, 281, 4828, 8, 281, 1, 282, 3, 282, 4831, 8, 282, 1, 282, 1, 282,
		3, 282, 4835, 8, 282, 1, 282, 1, 282, 1, 283, 3, 283, 4840, 8, 283, 1,
		283, 1, 283, 3, 283, 4844, 8, 283, 1, 283, 1, 283, 1, 284, 3, 284, 4849,
		8, 284, 1, 284, 1, 284, 3, 284, 4853, 8, 284, 1, 284, 1, 284, 1, 285, 1,
		285, 1, 285, 1, 285, 1, 285, 3, 285, 4862, 8, 285, 1, 285, 3, 285, 4865,
		8, 285, 1, 285, 3, 285, 4868, 8, 285, 1, 286, 3, 286, 4871, 8, 286, 1,
		286, 1, 286, 3, 286, 4875, 8, 286, 1, 286, 1, 286, 3, 286, 4879, 8, 286,
		1, 286, 1, 286, 3, 286, 4883, 8, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1,
		286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 1, 286, 3,
		286, 4898, 8, 286, 1, 286, 3, 286, 4901, 8, 286, 3, 286, 4903, 8, 286,
		1, 287, 1, 287, 1, 287, 3, 287, 4908, 8, 287, 1, 287, 1, 287, 1, 287, 1,
		287, 1, 287, 1, 287, 1, 287, 3, 287, 4917, 8, 287, 1, 287, 3, 287, 4920,
		8, 287, 1, 287, 1, 287, 3, 287, 4924, 8, 287, 1, 288, 1, 288, 1, 288, 1,
		288, 1, 289, 1, 289, 1, 289, 1, 289, 5, 289, 4934, 8, 289, 10, 289, 12,
		289, 4937, 9, 289, 1, 289, 1, 289, 1, 290, 1, 290, 1, 290, 1, 290, 1, 290,
		1, 290, 1, 290, 3, 290, 4948, 8, 290, 1, 290, 1, 290, 1, 290, 3, 290, 4953,
		8, 290, 1, 290, 5, 290, 4956, 8, 290, 10, 290, 12, 290, 4959, 9, 290, 1,
		290, 1, 290, 1, 290, 1, 290, 5, 290, 4965, 8, 290, 10, 290, 12, 290, 4968,
		9, 290, 1, 290, 1, 290, 3, 290, 4972, 8, 290, 1, 291, 1, 291, 1, 291, 1,
		291, 1, 291, 5, 291, 4979, 8, 291, 10, 291, 12, 291, 4982, 9, 291, 1, 291,
		1, 291, 3, 291, 4986, 8, 291, 1, 292, 1, 292, 3, 292, 4990, 8, 292, 1,
		292, 1, 292, 3, 292, 4994, 8, 292, 1, 292, 1, 292, 3, 292, 4998, 8, 292,
		1, 292, 1, 292, 1, 292, 3, 292, 5003, 8, 292, 1, 292, 1, 292, 1, 292, 3,
		292, 5008, 8, 292, 1, 292, 1, 292, 1, 292, 1, 292, 3, 292, 5014, 8, 292,
		1, 292, 1, 292, 1, 292, 3, 292, 5019, 8, 292, 1, 292, 3, 292, 5022, 8,
		292, 1, 293, 1, 293, 1, 293, 5, 293, 5027, 8, 293, 10, 293, 12, 293, 5030,
		9, 293, 1, 294, 1, 294, 1, 294, 1, 294, 5, 294, 5036, 8, 294, 10, 294,
		12, 294, 5039, 9, 294, 1, 294, 1, 294, 1, 295, 1, 295, 3, 295, 5045, 8,
		295, 1, 296, 1, 296, 1, 296, 1, 296, 1, 297, 1, 297, 1, 297, 1, 298, 1,
		298, 1, 298, 1, 298, 1, 299, 3, 299, 5059, 8, 299, 1, 299, 1, 299, 1, 300,
		1, 300, 1, 300, 1, 301, 1, 301, 1, 301, 1, 302, 1, 302, 3, 302, 5071, 8,
		302, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 303, 1, 304, 1, 304, 1,
		304, 5, 304, 5082, 8, 304, 10, 304, 12, 304, 5085, 9, 304, 1, 305, 1, 305,
		1, 305, 5, 305, 5090, 8, 305, 10, 305, 12, 305, 5093, 9, 305, 1, 306, 1,
		306, 1, 306, 1, 306, 3, 306, 5099, 8, 306, 1, 307, 1, 307, 1, 307, 1, 308,
		1, 308, 4, 308, 5106, 8, 308, 11, 308, 12, 308, 5107, 1, 309, 1, 309, 1,
		309, 1, 309, 3, 309, 5114, 8, 309, 1, 309, 1, 309, 1, 309, 1, 309, 1, 309,
		1, 309, 3, 309, 5122, 8, 309, 1, 310, 1, 310, 4, 310, 5126, 8, 310, 11,
		310, 12, 310, 5127, 1, 311, 1, 311, 1, 311, 1, 311, 1, 312, 1, 312, 1,
		312, 5, 312, 5137, 8, 312, 10, 312, 12, 312, 5140, 9, 312, 1, 313, 1, 313,
		1, 313, 5, 313, 5145, 8, 313, 10, 313, 12, 313, 5148, 9, 313, 1, 314, 1,
		314, 1, 314, 5, 314, 5153, 8, 314, 10, 314, 12, 314, 5156, 9, 314, 1, 315,
		1, 315, 1, 315, 1, 315, 3, 315, 5162, 8, 315, 1, 315, 1, 315, 1, 315, 1,
		315, 1, 315, 1, 315, 1, 315, 3, 315, 5171, 8, 315, 1, 315, 1, 315, 3, 315,
		5175, 8, 315, 1, 315, 1, 315, 1, 315, 3, 315, 5180, 8, 315, 3, 315, 5182,
		8, 315, 1, 316, 1, 316, 1, 316, 1, 316, 3, 316, 5188, 8, 316, 1, 316, 1,
		316, 1, 316, 1, 316, 3, 316, 5194, 8, 316, 1, 316, 3, 316, 5197, 8, 316,
		1, 316, 1, 316, 1, 316, 1, 316, 1, 316, 3, 316, 5204, 8, 316, 3, 316, 5206,
		8, 316, 3, 316, 5208, 8, 316, 1, 316, 3, 316, 5211, 8, 316, 3, 316, 5213,
		8, 316, 1, 317, 1, 317, 1, 317, 1, 317, 1, 318, 1, 318, 1, 318, 1, 318,
		1, 319, 1, 319, 1, 319, 1, 320, 1, 320, 1, 320, 1, 320, 3, 320, 5230, 8,
		320, 1, 321, 1, 321, 1, 321, 3, 321, 5235, 8, 321, 3, 321, 5237, 8, 321,
		1, 322, 1, 322, 1, 322, 1, 323, 1, 323, 3, 323, 5244, 8, 323, 1, 324, 1,
		324, 1, 325, 1, 325, 1, 326, 1, 326, 1, 326, 1, 327, 1, 327, 1, 327, 3,
		327, 5256, 8, 327, 3, 327, 5258, 8, 327, 1, 328, 1, 328, 3, 328, 5262,
		8, 328, 1, 329, 1, 329, 1, 330, 1, 330, 1, 330, 1, 330, 5, 330, 5270, 8,
		330, 10, 330, 12, 330, 5273, 9, 330, 1, 330, 1, 330, 1, 331, 1, 331, 1,
		332, 1, 332, 3, 332, 5281, 8, 332, 1, 333, 1, 333, 1, 334, 1, 334, 1, 335,
		1, 335, 1, 335, 1, 335, 1, 335, 3, 335, 5292, 8, 335, 1, 335, 1, 335, 1,
		336, 1, 336, 1, 337, 1, 337, 1, 338, 1, 338, 1, 339, 1, 339, 1, 340, 1,
		340, 1, 341, 1, 341, 1, 342, 1, 342, 1, 343, 1, 343, 1, 344, 1, 344, 3,
		344, 5314, 8, 344, 1, 345, 1, 345, 3, 345, 5318, 8, 345, 1, 346, 1, 346,
		1, 347, 1, 347, 1, 348, 1, 348, 1, 349, 1, 349, 1, 350, 1, 350, 1, 351,
		1, 351, 1, 352, 1, 352, 1, 353, 1, 353, 1, 354, 1, 354, 1, 355, 1, 355,
		1, 356, 1, 356, 3, 356, 5342, 8, 356, 1, 357, 1, 357, 1, 357, 1, 358, 1,
		358, 1, 358, 1, 358, 1, 358, 1, 358, 3, 358, 5353, 8, 358, 3, 358, 5355,
		8, 358, 1, 359, 1, 359, 3, 359, 5359, 8, 359, 1, 360, 1, 360, 1, 360, 5,
		360, 5364, 8, 360, 10, 360, 12, 360, 5367, 9, 360, 1, 361, 1, 361, 1, 361,
		5, 361, 5372, 8, 361, 10, 361, 12, 361, 5375, 9, 361, 1, 362, 1, 362, 1,
		363, 1, 363, 3, 363, 5381, 8, 363, 1, 364, 1, 364, 1, 365, 1, 365, 3, 365,
		5387, 8, 365, 1, 366, 1, 366, 1, 367, 1, 367, 1, 368, 1, 368, 1, 369, 1,
		369, 1, 370, 1, 370, 1, 371, 1, 371, 1, 372, 1, 372, 3, 372, 5403, 8, 372,
		1, 373, 1, 373, 1, 373, 5, 373, 5408, 8, 373, 10, 373, 12, 373, 5411, 9,
		373, 1, 374, 1, 374, 1, 374, 1, 374, 1, 375, 1, 375, 3, 375, 5419, 8, 375,
		1, 376, 1, 376, 1, 376, 3, 376, 5424, 8, 376, 3, 376, 5426, 8, 376, 1,
		376, 1, 376, 1, 376, 3, 376, 5431, 8, 376, 1, 377, 1, 377, 1, 377, 1, 378,
		1, 378, 1, 379, 1, 379, 1, 380, 1, 380, 1, 381, 1, 381, 1, 382, 1, 382,
		1, 382, 1, 382, 1, 382, 1, 382, 3, 382, 5450, 8, 382, 1, 382, 3, 382, 5453,
		8, 382, 1, 383, 1, 383, 1, 383, 1, 383, 1, 383, 3, 383, 5460, 8, 383, 1,
		384, 1, 384, 1, 384, 1, 384, 5, 384, 5466, 8, 384, 10, 384, 12, 384, 5469,
		9, 384, 1, 384, 1, 384, 1, 385, 1, 385, 3, 385, 5475, 8, 385, 1, 386, 1,
		386, 1, 386, 3, 386, 5480, 8, 386, 1, 387, 1, 387, 3, 387, 5484, 8, 387,
		1, 388, 3, 388, 5487, 8, 388, 1, 388, 1, 388, 3, 388, 5491, 8, 388, 1,
		388, 5, 388, 5494, 8, 388, 10, 388, 12, 388, 5497, 9, 388, 1, 389, 1, 389,
		1, 390, 1, 390, 1, 390, 5, 390, 5504, 8, 390, 10, 390, 12, 390, 5507, 9,
		390, 1, 391, 1, 391, 1, 392, 1, 392, 1, 393, 1, 393, 1, 394, 1, 394, 1,
		394, 1, 394, 1, 394, 1, 394, 3, 394, 5521, 8, 394, 1, 395, 1, 395, 3, 395,
		5525, 8, 395, 1, 396, 1, 396, 1, 397, 1, 397, 1, 397, 1, 397, 1, 397, 1,
		397, 1, 398, 1, 398, 3, 398, 5537, 8, 398, 1, 399, 1, 399, 3, 399, 5541,
		8, 399, 1, 400, 1, 400, 3, 400, 5545, 8, 400, 1, 401, 1, 401, 3, 401, 5549,
		8, 401, 1, 402, 1, 402, 1, 402, 1, 403, 1, 403, 1, 404, 1, 404, 1, 405,
		1, 405, 1, 405, 1, 405, 1, 405, 1, 405, 3, 405, 5564, 8, 405, 1, 406, 1,
		406, 1, 406, 1, 406, 1, 406, 1, 406, 1, 406, 1, 406, 1, 406, 1, 406, 3,
		406, 5576, 8, 406, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 3, 407, 5583,
		8, 407, 1, 407, 1, 407, 1, 407, 1, 407, 1, 407, 3, 407, 5590, 8, 407, 1,
		407, 3, 407, 5593, 8, 407, 1, 408, 1, 408, 1, 409, 1, 409, 1, 410, 1, 410,
		1, 410, 1, 410, 1, 410, 1, 410, 1, 410, 1, 410, 1, 410, 1, 410, 3, 410,
		5609, 8, 410, 1, 410, 1, 410, 1, 410, 3, 410, 5614, 8, 410, 3, 410, 5616,
		8, 410, 1, 411, 1, 411, 1, 412, 1, 412, 3, 412, 5622, 8, 412, 1, 413, 1,
		413, 3, 413, 5626, 8, 413, 1, 413, 1, 413, 1, 413, 3, 413, 5631, 8, 413,
		3, 413, 5633, 8, 413, 1, 414, 1, 414, 1, 414, 1, 414, 3, 414, 5639, 8,
		414, 1, 415, 1, 415, 1, 416, 1, 416, 1, 416, 3, 416, 5646, 8, 416, 1, 417,
		1, 417, 1, 417, 1, 417, 1, 417, 3, 417, 5653, 8, 417, 1, 417, 0, 4, 380,
		382, 390, 392, 418, 0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26,
		28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62,
		64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98,
		100, 102, 104, 106, 108, 110, 112, 114, 116, 118, 120, 122, 124, 126, 128,
		130, 132, 134, 136, 138, 140, 142, 144, 146, 148, 150, 152, 154, 156, 158,
		160, 162, 164, 166, 168, 170, 172, 174, 176, 178, 180, 182, 184, 186, 188,
		190, 192, 194, 196, 198, 200, 202, 204, 206, 208, 210, 212, 214, 216, 218,
		220, 222, 224, 226, 228, 230, 232, 234, 236, 238, 240, 242, 244, 246, 248,
		250, 252, 254, 256, 258, 260, 262, 264, 266, 268, 270, 272, 274, 276, 278,
		280, 282, 284, 286, 288, 290, 292, 294, 296, 298, 300, 302, 304, 306, 308,
		310, 312, 314, 316, 318, 320, 322, 324, 326, 328, 330, 332, 334, 336, 338,
		340, 342, 344, 346, 348, 350, 352, 354, 356, 358, 360, 362, 364, 366, 368,
		370, 372, 374, 376, 378, 380, 382, 384, 386, 388, 390, 392, 394, 396, 398,
		400, 402, 404, 406, 408, 410, 412, 414, 416, 418, 420, 422, 424, 426, 428,
		430, 432, 434, 436, 438, 440, 442, 444, 446, 448, 450, 452, 454, 456, 458,
		460, 462, 464, 466, 468, 470, 472, 474, 476, 478, 480, 482, 484, 486, 488,
		490, 492, 494, 496, 498, 500, 502, 504, 506, 508, 510, 512, 514, 516, 518,
		520, 522, 524, 526, 528, 530, 532, 534, 536, 538, 540, 542, 544, 546, 548,
		550, 552, 554, 556, 558, 560, 562, 564, 566, 568, 570, 572, 574, 576, 578,
		580, 582, 584, 586, 588, 590, 592, 594, 596, 598, 600, 602, 604, 606, 608,
		610, 612, 614, 616, 618, 620, 622, 624, 626, 628, 630, 632, 634, 636, 638,
		640, 642, 644, 646, 648, 650, 652, 654, 656, 658, 660, 662, 664, 666, 668,
		670, 672, 674, 676, 678, 680, 682, 684, 686, 688, 690, 692, 694, 696, 698,
		700, 702, 704, 706, 708, 710, 712, 714, 716, 718, 720, 722, 724, 726, 728,
		730, 732, 734, 736, 738, 740, 742, 744, 746, 748, 750, 752, 754, 756, 758,
		760, 762, 764, 766, 768, 770, 772, 774, 776, 778, 780, 782, 784, 786, 788,
		790, 792, 794, 796, 798, 800, 802, 804, 806, 808, 810, 812, 814, 816, 818,
		820, 822, 824, 826, 828, 830, 832, 834, 0, 117, 2, 0, 554, 554, 637, 637,
		7, 0, 10, 10, 143, 143, 223, 223, 531, 532, 534, 534, 536, 536, 555, 555,
		2, 0, 381, 381, 773, 773, 2, 0, 747, 749, 787, 787, 3, 0, 432, 432, 484,
		484, 683, 683, 2, 0, 18, 18, 134, 134, 2, 0, 508, 508, 614, 614, 2, 0,
		272, 272, 478, 478, 2, 0, 98, 98, 239, 239, 3, 0, 608, 608, 663, 663, 801,
		801, 2, 0, 10, 10, 143, 143, 2, 0, 17, 17, 750, 750, 2, 0, 198, 198, 232,
		232, 2, 0, 236, 236, 265, 265, 2, 0, 386, 386, 649, 649, 2, 0, 571, 571,
		574, 574, 3, 0, 244, 244, 571, 571, 574, 574, 2, 0, 29, 29, 543, 543, 2,
		0, 261, 261, 472, 472, 2, 0, 32, 32, 316, 316, 2, 0, 383, 383, 743, 744,
		2, 0, 528, 528, 530, 530, 2, 0, 449, 449, 538, 538, 2, 0, 543, 543, 552,
		552, 2, 0, 123, 123, 148, 148, 3, 0, 369, 369, 539, 539, 650, 650, 2, 0,
		287, 287, 611, 611, 2, 0, 128, 128, 719, 719, 3, 0, 206, 206, 422, 422,
		574, 574, 4, 0, 242, 242, 443, 443, 497, 497, 614, 614, 13, 0, 133, 133,
		148, 148, 170, 170, 173, 173, 188, 188, 236, 236, 423, 423, 427, 427, 451,
		451, 510, 510, 565, 565, 594, 594, 616, 616, 4, 0, 483, 483, 572, 572,
		618, 618, 636, 636, 2, 0, 65, 65, 514, 514, 2, 0, 97, 97, 148, 148, 2,
		0, 128, 128, 369, 369, 2, 0, 180, 180, 431, 431, 5, 0, 56, 56, 180, 180,
		184, 184, 333, 333, 431, 431, 3, 0, 180, 180, 431, 431, 619, 619, 2, 0,
		76, 76, 601, 601, 4, 0, 10, 10, 32, 32, 128, 128, 383, 383, 2, 0, 487,
		487, 710, 710, 3, 0, 289, 289, 354, 354, 547, 547, 2, 0, 203, 203, 251,
		251, 2, 0, 33, 33, 446, 446, 2, 0, 235, 236, 263, 263, 2, 0, 166, 166,
		639, 639, 2, 0, 547, 547, 631, 631, 6, 0, 10, 10, 96, 96, 256, 256, 334,
		334, 522, 522, 567, 567, 2, 0, 618, 618, 710, 710, 2, 0, 140, 140, 156,
		156, 3, 0, 183, 183, 596, 596, 610, 610, 2, 0, 15, 15, 767, 767, 2, 0,
		394, 394, 770, 770, 2, 0, 10, 10, 16, 16, 2, 0, 750, 750, 752, 757, 3,
		0, 145, 145, 349, 349, 760, 762, 1, 0, 758, 759, 1, 0, 765, 766, 2, 0,
		758, 759, 764, 764, 2, 0, 35, 36, 38, 38, 4, 0, 678, 679, 692, 692, 694,
		694, 696, 696, 2, 0, 684, 684, 686, 686, 2, 0, 681, 681, 685, 685, 2, 0,
		191, 191, 268, 268, 2, 0, 232, 232, 695, 695, 2, 0, 5, 5, 558, 558, 1,
		0, 114, 115, 1, 0, 584, 585, 4, 0, 113, 113, 116, 116, 583, 583, 586, 586,
		2, 0, 371, 371, 745, 745, 2, 0, 745, 745, 763, 763, 5, 0, 118, 121, 226,
		228, 341, 342, 494, 494, 655, 655, 9, 0, 122, 122, 229, 229, 337, 337,
		343, 343, 350, 350, 429, 429, 495, 495, 640, 640, 656, 656, 3, 0, 128,
		128, 152, 152, 192, 192, 3, 0, 128, 128, 142, 142, 334, 334, 3, 0, 204,
		204, 402, 402, 513, 513, 2, 0, 49, 49, 471, 471, 3, 0, 44, 44, 220, 220,
		488, 488, 1, 0, 661, 662, 2, 0, 599, 599, 621, 621, 5, 0, 31, 31, 249,
		249, 331, 331, 516, 516, 588, 588, 4, 0, 126, 126, 192, 192, 195, 195,
		378, 378, 1, 0, 41, 42, 2, 0, 290, 290, 330, 330, 4, 0, 211, 212, 279,
		279, 351, 353, 411, 412, 3, 0, 512, 512, 612, 612, 657, 657, 1, 0, 544,
		546, 2, 0, 61, 61, 575, 575, 6, 0, 78, 78, 80, 80, 128, 128, 152, 152,
		192, 192, 442, 442, 3, 0, 191, 191, 268, 268, 373, 373, 2, 0, 142, 142,
		334, 334, 2, 0, 280, 280, 432, 432, 2, 0, 323, 323, 344, 344, 2, 0, 112,
		112, 236, 236, 3, 0, 240, 240, 251, 251, 397, 397, 2, 0, 541, 541, 579,
		579, 2, 0, 380, 380, 385, 385, 2, 0, 284, 284, 375, 375, 3, 0, 780, 780,
		803, 803, 805, 805, 3, 0, 747, 749, 788, 788, 790, 791, 2, 0, 747, 749,
		788, 788, 2, 0, 747, 749, 790, 791, 1, 0, 788, 789, 2, 0, 183, 183, 596,
		596, 2, 0, 376, 376, 786, 786, 1, 0, 750, 751, 5, 0, 214, 214, 284, 284,
		502, 502, 658, 658, 673, 673, 1, 0, 795, 801, 3, 0, 173, 173, 510, 510,
		714, 714, 32, 0, 19, 19, 29, 29, 46, 47, 58, 58, 61, 61, 75, 75, 77, 77,
		90, 90, 123, 123, 147, 147, 159, 159, 196, 197, 219, 219, 222, 222, 234,
		234, 245, 245, 267, 267, 373, 373, 415, 415, 417, 417, 455, 455, 468, 468,
		480, 480, 489, 489, 512, 512, 514, 514, 543, 543, 552, 552, 597, 597, 606,
		607, 651, 651, 677, 677, 9, 0, 170, 170, 188, 188, 369, 369, 423, 423,
		427, 427, 451, 451, 459, 459, 565, 565, 709, 709, 161, 0, 2, 3, 5, 9, 12,
		12, 16, 16, 21, 21, 23, 27, 33, 33, 37, 37, 40, 42, 44, 44, 50, 50, 53,
		54, 56, 57, 63, 68, 70, 71, 73, 74, 76, 76, 78, 82, 84, 85, 87, 89, 91,
		91, 96, 96, 101, 101, 107, 107, 111, 113, 116, 116, 122, 122, 129, 130,
		132, 132, 138, 142, 150, 152, 156, 156, 158, 158, 160, 160, 162, 166, 168,
		169, 171, 172, 176, 177, 179, 181, 184, 185, 189, 192, 201, 202, 204, 204,
		208, 208, 210, 213, 216, 216, 220, 220, 224, 225, 229, 230, 233, 233, 235,
		235, 238, 238, 243, 244, 250, 250, 255, 256, 258, 259, 262, 262, 264, 264,
		268, 268, 270, 270, 273, 274, 279, 280, 286, 286, 288, 289, 296, 296, 298,
		314, 316, 319, 321, 324, 327, 328, 333, 337, 340, 340, 343, 344, 346, 346,
		348, 348, 350, 358, 361, 361, 363, 363, 365, 368, 374, 374, 377, 377, 379,
		379, 381, 381, 384, 384, 386, 387, 390, 390, 398, 404, 406, 413, 418, 419,
		421, 421, 424, 426, 429, 431, 434, 434, 438, 439, 441, 442, 445, 449, 452,
		452, 454, 454, 456, 456, 460, 466, 470, 470, 472, 474, 476, 476, 481, 483,
		485, 486, 488, 488, 490, 490, 492, 492, 495, 496, 500, 501, 503, 503, 508,
		508, 513, 513, 515, 515, 517, 517, 519, 522, 528, 530, 532, 532, 535, 535,
		538, 538, 540, 540, 542, 542, 544, 547, 553, 553, 556, 561, 566, 568, 571,
		572, 575, 578, 580, 581, 583, 586, 592, 593, 598, 599, 601, 604, 610, 610,
		613, 613, 615, 615, 617, 619, 625, 625, 627, 627, 631, 631, 636, 636, 638,
		641, 646, 648, 650, 650, 652, 653, 656, 656, 659, 662, 664, 664, 669, 671,
		674, 675, 680, 680, 682, 682, 689, 690, 693, 693, 695, 695, 697, 698, 702,
		708, 711, 713, 715, 725, 727, 730, 732, 732, 735, 738, 4, 0, 583, 583,
		586, 586, 731, 731, 733, 744, 54, 0, 2, 2, 12, 12, 19, 19, 27, 27, 29,
		29, 46, 47, 58, 58, 61, 61, 66, 66, 75, 75, 77, 77, 90, 90, 123, 123, 147,
		147, 159, 159, 196, 197, 201, 201, 210, 210, 219, 219, 222, 222, 224, 224,
		245, 245, 267, 267, 373, 373, 387, 387, 390, 390, 398, 398, 401, 401, 405,
		405, 413, 413, 415, 415, 417, 417, 452, 452, 455, 455, 468, 468, 470, 470,
		480, 480, 489, 489, 496, 496, 503, 503, 512, 512, 514, 514, 519, 520, 543,
		543, 552, 552, 597, 597, 606, 607, 615, 615, 648, 648, 651, 651, 659, 659,
		661, 662, 677, 677, 720, 723, 155, 0, 3, 3, 5, 9, 13, 13, 16, 16, 21, 26,
		33, 33, 37, 37, 40, 42, 44, 44, 50, 50, 53, 54, 56, 57, 63, 65, 67, 68,
		70, 71, 73, 74, 76, 76, 78, 82, 84, 85, 87, 89, 91, 91, 93, 93, 96, 96,
		101, 101, 107, 107, 111, 113, 116, 116, 122, 122, 129, 130, 132, 132, 136,
		136, 138, 142, 150, 152, 156, 156, 158, 158, 160, 160, 162, 166, 168, 169,
		171, 171, 176, 176, 179, 181, 184, 185, 189, 192, 202, 202, 204, 204, 208,
		208, 211, 214, 216, 216, 220, 220, 225, 225, 229, 230, 233, 233, 235, 235,
		238, 238, 243, 244, 250, 250, 255, 256, 258, 259, 262, 262, 264, 264, 268,
		268, 270, 270, 273, 274, 279, 280, 284, 284, 286, 286, 288, 289, 296, 296,
		298, 314, 316, 319, 321, 325, 327, 328, 333, 337, 340, 340, 343, 344, 346,
		346, 348, 348, 350, 358, 361, 361, 363, 363, 365, 368, 374, 374, 377, 377,
		379, 379, 381, 382, 384, 384, 399, 400, 402, 404, 406, 412, 418, 419, 421,
		421, 424, 426, 429, 431, 434, 434, 438, 442, 445, 449, 454, 454, 456, 456,
		460, 466, 472, 474, 476, 476, 481, 483, 485, 486, 488, 488, 490, 490, 492,
		492, 495, 495, 500, 502, 508, 508, 513, 513, 515, 515, 517, 517, 521, 522,
		528, 530, 532, 533, 535, 535, 538, 538, 540, 540, 542, 542, 544, 547, 553,
		553, 556, 561, 565, 568, 571, 572, 575, 578, 580, 581, 583, 586, 592, 593,
		598, 604, 610, 610, 613, 613, 617, 619, 627, 627, 631, 631, 636, 636, 638,
		641, 647, 647, 650, 650, 652, 653, 656, 656, 664, 664, 669, 671, 674, 676,
		680, 680, 682, 682, 689, 690, 693, 693, 695, 695, 697, 698, 702, 708, 711,
		712, 716, 717, 719, 719, 724, 725, 727, 728, 5, 0, 99, 99, 206, 206, 234,
		234, 484, 484, 487, 487, 6, 0, 172, 172, 177, 177, 386, 386, 565, 565,
		625, 625, 646, 646, 6426, 0, 836, 1, 0, 0, 0, 2, 842, 1, 0, 0, 0, 4, 848,
		1, 0, 0, 0, 6, 917, 1, 0, 0, 0, 8, 919, 1, 0, 0, 0, 10, 924, 1, 0, 0, 0,
		12, 934, 1, 0, 0, 0, 14, 948, 1, 0, 0, 0, 16, 951, 1, 0, 0, 0, 18, 982,
		1, 0, 0, 0, 20, 997, 1, 0, 0, 0, 22, 1010, 1, 0, 0, 0, 24, 1012, 1, 0,
		0, 0, 26, 1038, 1, 0, 0, 0, 28, 1040, 1, 0, 0, 0, 30, 1042, 1, 0, 0, 0,
		32, 1045, 1, 0, 0, 0, 34, 1048, 1, 0, 0, 0, 36, 1055, 1, 0, 0, 0, 38, 1057,
		1, 0, 0, 0, 40, 1087, 1, 0, 0, 0, 42, 1099, 1, 0, 0, 0, 44, 1102, 1, 0,
		0, 0, 46, 1111, 1, 0, 0, 0, 48, 1115, 1, 0, 0, 0, 50, 1120, 1, 0, 0, 0,
		52, 1133, 1, 0, 0, 0, 54, 1138, 1, 0, 0, 0, 56, 1142, 1, 0, 0, 0, 58, 1158,
		1, 0, 0, 0, 60, 1160, 1, 0, 0, 0, 62, 1178, 1, 0, 0, 0, 64, 1180, 1, 0,
		0, 0, 66, 1189, 1, 0, 0, 0, 68, 1201, 1, 0, 0, 0, 70, 1208, 1, 0, 0, 0,
		72, 1218, 1, 0, 0, 0, 74, 1220, 1, 0, 0, 0, 76, 1224, 1, 0, 0, 0, 78, 1226,
		1, 0, 0, 0, 80, 1231, 1, 0, 0, 0, 82, 1239, 1, 0, 0, 0, 84, 1248, 1, 0,
		0, 0, 86, 1251, 1, 0, 0, 0, 88, 1260, 1, 0, 0, 0, 90, 1278, 1, 0, 0, 0,
		92, 1281, 1, 0, 0, 0, 94, 1298, 1, 0, 0, 0, 96, 1300, 1, 0, 0, 0, 98, 1305,
		1, 0, 0, 0, 100, 1309, 1, 0, 0, 0, 102, 1323, 1, 0, 0, 0, 104, 1326, 1,
		0, 0, 0, 106, 1332, 1, 0, 0, 0, 108, 1344, 1, 0, 0, 0, 110, 1352, 1, 0,
		0, 0, 112, 1378, 1, 0, 0, 0, 114, 1391, 1, 0, 0, 0, 116, 1398, 1, 0, 0,
		0, 118, 1400, 1, 0, 0, 0, 120, 1411, 1, 0, 0, 0, 122, 1413, 1, 0, 0, 0,
		124, 1423, 1, 0, 0, 0, 126, 1445, 1, 0, 0, 0, 128, 1447, 1, 0, 0, 0, 130,
		1454, 1, 0, 0, 0, 132, 1464, 1, 0, 0, 0, 134, 1498, 1, 0, 0, 0, 136, 1508,
		1, 0, 0, 0, 138, 1510, 1, 0, 0, 0, 140, 1514, 1, 0, 0, 0, 142, 1522, 1,
		0, 0, 0, 144, 1524, 1, 0, 0, 0, 146, 1526, 1, 0, 0, 0, 148, 1529, 1, 0,
		0, 0, 150, 1533, 1, 0, 0, 0, 152, 1561, 1, 0, 0, 0, 154, 1563, 1, 0, 0,
		0, 156, 1565, 1, 0, 0, 0, 158, 1573, 1, 0, 0, 0, 160, 1575, 1, 0, 0, 0,
		162, 1583, 1, 0, 0, 0, 164, 1593, 1, 0, 0, 0, 166, 1596, 1, 0, 0, 0, 168,
		1621, 1, 0, 0, 0, 170, 1648, 1, 0, 0, 0, 172, 1650, 1, 0, 0, 0, 174, 1659,
		1, 0, 0, 0, 176, 1690, 1, 0, 0, 0, 178, 1708, 1, 0, 0, 0, 180, 1710, 1,
		0, 0, 0, 182, 1724, 1, 0, 0, 0, 184, 1726, 1, 0, 0, 0, 186, 1760, 1, 0,
		0, 0, 188, 1762, 1, 0, 0, 0, 190, 1801, 1, 0, 0, 0, 192, 1816, 1, 0, 0,
		0, 194, 1818, 1, 0, 0, 0, 196, 1823, 1, 0, 0, 0, 198, 1832, 1, 0, 0, 0,
		200, 1839, 1, 0, 0, 0, 202, 1938, 1, 0, 0, 0, 204, 1942, 1, 0, 0, 0, 206,
		1944, 1, 0, 0, 0, 208, 1948, 1, 0, 0, 0, 210, 1962, 1, 0, 0, 0, 212, 1964,
		1, 0, 0, 0, 214, 1977, 1, 0, 0, 0, 216, 2040, 1, 0, 0, 0, 218, 2042, 1,
		0, 0, 0, 220, 2050, 1, 0, 0, 0, 222, 2058, 1, 0, 0, 0, 224, 2066, 1, 0,
		0, 0, 226, 2068, 1, 0, 0, 0, 228, 2097, 1, 0, 0, 0, 230, 2104, 1, 0, 0,
		0, 232, 2134, 1, 0, 0, 0, 234, 2136, 1, 0, 0, 0, 236, 2144, 1, 0, 0, 0,
		238, 2146, 1, 0, 0, 0, 240, 2160, 1, 0, 0, 0, 242, 2162, 1, 0, 0, 0, 244,
		2168, 1, 0, 0, 0, 246, 2176, 1, 0, 0, 0, 248, 2212, 1, 0, 0, 0, 250, 2214,
		1, 0, 0, 0, 252, 2227, 1, 0, 0, 0, 254, 2229, 1, 0, 0, 0, 256, 2282, 1,
		0, 0, 0, 258, 2284, 1, 0, 0, 0, 260, 2287, 1, 0, 0, 0, 262, 2316, 1, 0,
		0, 0, 264, 2324, 1, 0, 0, 0, 266, 2326, 1, 0, 0, 0, 268, 2331, 1, 0, 0,
		0, 270, 2376, 1, 0, 0, 0, 272, 2378, 1, 0, 0, 0, 274, 2385, 1, 0, 0, 0,
		276, 2431, 1, 0, 0, 0, 278, 2442, 1, 0, 0, 0, 280, 2444, 1, 0, 0, 0, 282,
		2447, 1, 0, 0, 0, 284, 2458, 1, 0, 0, 0, 286, 2463, 1, 0, 0, 0, 288, 2465,
		1, 0, 0, 0, 290, 2480, 1, 0, 0, 0, 292, 2526, 1, 0, 0, 0, 294, 2528, 1,
		0, 0, 0, 296, 2530, 1, 0, 0, 0, 298, 2585, 1, 0, 0, 0, 300, 2602, 1, 0,
		0, 0, 302, 2604, 1, 0, 0, 0, 304, 2620, 1, 0, 0, 0, 306, 2632, 1, 0, 0,
		0, 308, 2657, 1, 0, 0, 0, 310, 2659, 1, 0, 0, 0, 312, 2667, 1, 0, 0, 0,
		314, 2715, 1, 0, 0, 0, 316, 2730, 1, 0, 0, 0, 318, 2735, 1, 0, 0, 0, 320,
		2737, 1, 0, 0, 0, 322, 2761, 1, 0, 0, 0, 324, 2763, 1, 0, 0, 0, 326, 2819,
		1, 0, 0, 0, 328, 2830, 1, 0, 0, 0, 330, 2832, 1, 0, 0, 0, 332, 2835, 1,
		0, 0, 0, 334, 2848, 1, 0, 0, 0, 336, 2875, 1, 0, 0, 0, 338, 2883, 1, 0,
		0, 0, 340, 2885, 1, 0, 0, 0, 342, 2896, 1, 0, 0, 0, 344, 2898, 1, 0, 0,
		0, 346, 2905, 1, 0, 0, 0, 348, 2907, 1, 0, 0, 0, 350, 3130, 1, 0, 0, 0,
		352, 3136, 1, 0, 0, 0, 354, 3138, 1, 0, 0, 0, 356, 3140, 1, 0, 0, 0, 358,
		3150, 1, 0, 0, 0, 360, 3156, 1, 0, 0, 0, 362, 3158, 1, 0, 0, 0, 364, 3176,
		1, 0, 0, 0, 366, 3190, 1, 0, 0, 0, 368, 3195, 1, 0, 0, 0, 370, 3201, 1,
		0, 0, 0, 372, 3203, 1, 0, 0, 0, 374, 3219, 1, 0, 0, 0, 376, 3227, 1, 0,
		0, 0, 378, 3237, 1, 0, 0, 0, 380, 3255, 1, 0, 0, 0, 382, 3271, 1, 0, 0,
		0, 384, 3294, 1, 0, 0, 0, 386, 3296, 1, 0, 0, 0, 388, 3332, 1, 0, 0, 0,
		390, 3334, 1, 0, 0, 0, 392, 3474, 1, 0, 0, 0, 394, 3487, 1, 0, 0, 0, 396,
		3493, 1, 0, 0, 0, 398, 3613, 1, 0, 0, 0, 400, 3615, 1, 0, 0, 0, 402, 3662,
		1, 0, 0, 0, 404, 3664, 1, 0, 0, 0, 406, 3669, 1, 0, 0, 0, 408, 3678, 1,
		0, 0, 0, 410, 3697, 1, 0, 0, 0, 412, 3700, 1, 0, 0, 0, 414, 3709, 1, 0,
		0, 0, 416, 3711, 1, 0, 0, 0, 418, 3734, 1, 0, 0, 0, 420, 4006, 1, 0, 0,
		0, 422, 4038, 1, 0, 0, 0, 424, 4040, 1, 0, 0, 0, 426, 4046, 1, 0, 0, 0,
		428, 4048, 1, 0, 0, 0, 430, 4063, 1, 0, 0, 0, 432, 4071, 1, 0, 0, 0, 434,
		4073, 1, 0, 0, 0, 436, 4102, 1, 0, 0, 0, 438, 4135, 1, 0, 0, 0, 440, 4137,
		1, 0, 0, 0, 442, 4153, 1, 0, 0, 0, 444, 4160, 1, 0, 0, 0, 446, 4169, 1,
		0, 0, 0, 448, 4174, 1, 0, 0, 0, 450, 4182, 1, 0, 0, 0, 452, 4188, 1, 0,
		0, 0, 454, 4193, 1, 0, 0, 0, 456, 4195, 1, 0, 0, 0, 458, 4215, 1, 0, 0,
		0, 460, 4217, 1, 0, 0, 0, 462, 4220, 1, 0, 0, 0, 464, 4223, 1, 0, 0, 0,
		466, 4268, 1, 0, 0, 0, 468, 4270, 1, 0, 0, 0, 470, 4281, 1, 0, 0, 0, 472,
		4283, 1, 0, 0, 0, 474, 4285, 1, 0, 0, 0, 476, 4289, 1, 0, 0, 0, 478, 4291,
		1, 0, 0, 0, 480, 4293, 1, 0, 0, 0, 482, 4297, 1, 0, 0, 0, 484, 4301, 1,
		0, 0, 0, 486, 4305, 1, 0, 0, 0, 488, 4313, 1, 0, 0, 0, 490, 4317, 1, 0,
		0, 0, 492, 4325, 1, 0, 0, 0, 494, 4327, 1, 0, 0, 0, 496, 4331, 1, 0, 0,
		0, 498, 4333, 1, 0, 0, 0, 500, 4349, 1, 0, 0, 0, 502, 4351, 1, 0, 0, 0,
		504, 4385, 1, 0, 0, 0, 506, 4387, 1, 0, 0, 0, 508, 4398, 1, 0, 0, 0, 510,
		4405, 1, 0, 0, 0, 512, 4421, 1, 0, 0, 0, 514, 4425, 1, 0, 0, 0, 516, 4427,
		1, 0, 0, 0, 518, 4431, 1, 0, 0, 0, 520, 4441, 1, 0, 0, 0, 522, 4443, 1,
		0, 0, 0, 524, 4445, 1, 0, 0, 0, 526, 4452, 1, 0, 0, 0, 528, 4454, 1, 0,
		0, 0, 530, 4456, 1, 0, 0, 0, 532, 4605, 1, 0, 0, 0, 534, 4610, 1, 0, 0,
		0, 536, 4617, 1, 0, 0, 0, 538, 4619, 1, 0, 0, 0, 540, 4627, 1, 0, 0, 0,
		542, 4645, 1, 0, 0, 0, 544, 4653, 1, 0, 0, 0, 546, 4661, 1, 0, 0, 0, 548,
		4663, 1, 0, 0, 0, 550, 4667, 1, 0, 0, 0, 552, 4674, 1, 0, 0, 0, 554, 4679,
		1, 0, 0, 0, 556, 4681, 1, 0, 0, 0, 558, 4692, 1, 0, 0, 0, 560, 4823, 1,
		0, 0, 0, 562, 4827, 1, 0, 0, 0, 564, 4830, 1, 0, 0, 0, 566, 4839, 1, 0,
		0, 0, 568, 4848, 1, 0, 0, 0, 570, 4856, 1, 0, 0, 0, 572, 4902, 1, 0, 0,
		0, 574, 4904, 1, 0, 0, 0, 576, 4925, 1, 0, 0, 0, 578, 4929, 1, 0, 0, 0,
		580, 4940, 1, 0, 0, 0, 582, 4985, 1, 0, 0, 0, 584, 5021, 1, 0, 0, 0, 586,
		5023, 1, 0, 0, 0, 588, 5031, 1, 0, 0, 0, 590, 5044, 1, 0, 0, 0, 592, 5046,
		1, 0, 0, 0, 594, 5050, 1, 0, 0, 0, 596, 5053, 1, 0, 0, 0, 598, 5058, 1,
		0, 0, 0, 600, 5062, 1, 0, 0, 0, 602, 5065, 1, 0, 0, 0, 604, 5068, 1, 0,
		0, 0, 606, 5072, 1, 0, 0, 0, 608, 5078, 1, 0, 0, 0, 610, 5086, 1, 0, 0,
		0, 612, 5094, 1, 0, 0, 0, 614, 5100, 1, 0, 0, 0, 616, 5103, 1, 0, 0, 0,
		618, 5121, 1, 0, 0, 0, 620, 5123, 1, 0, 0, 0, 622, 5129, 1, 0, 0, 0, 624,
		5133, 1, 0, 0, 0, 626, 5141, 1, 0, 0, 0, 628, 5149, 1, 0, 0, 0, 630, 5157,
		1, 0, 0, 0, 632, 5183, 1, 0, 0, 0, 634, 5214, 1, 0, 0, 0, 636, 5218, 1,
		0, 0, 0, 638, 5222, 1, 0, 0, 0, 640, 5225, 1, 0, 0, 0, 642, 5236, 1, 0,
		0, 0, 644, 5238, 1, 0, 0, 0, 646, 5243, 1, 0, 0, 0, 648, 5245, 1, 0, 0,
		0, 650, 5247, 1, 0, 0, 0, 652, 5249, 1, 0, 0, 0, 654, 5257, 1, 0, 0, 0,
		656, 5261, 1, 0, 0, 0, 658, 5263, 1, 0, 0, 0, 660, 5265, 1, 0, 0, 0, 662,
		5276, 1, 0, 0, 0, 664, 5280, 1, 0, 0, 0, 666, 5282, 1, 0, 0, 0, 668, 5284,
		1, 0, 0, 0, 670, 5286, 1, 0, 0, 0, 672, 5295, 1, 0, 0, 0, 674, 5297, 1,
		0, 0, 0, 676, 5299, 1, 0, 0, 0, 678, 5301, 1, 0, 0, 0, 680, 5303, 1, 0,
		0, 0, 682, 5305, 1, 0, 0, 0, 684, 5307, 1, 0, 0, 0, 686, 5309, 1, 0, 0,
		0, 688, 5313, 1, 0, 0, 0, 690, 5317, 1, 0, 0, 0, 692, 5319, 1, 0, 0, 0,
		694, 5321, 1, 0, 0, 0, 696, 5323, 1, 0, 0, 0, 698, 5325, 1, 0, 0, 0, 700,
		5327, 1, 0, 0, 0, 702, 5329, 1, 0, 0, 0, 704, 5331, 1, 0, 0, 0, 706, 5333,
		1, 0, 0, 0, 708, 5335, 1, 0, 0, 0, 710, 5337, 1, 0, 0, 0, 712, 5341, 1,
		0, 0, 0, 714, 5343, 1, 0, 0, 0, 716, 5346, 1, 0, 0, 0, 718, 5358, 1, 0,
		0, 0, 720, 5360, 1, 0, 0, 0, 722, 5368, 1, 0, 0, 0, 724, 5376, 1, 0, 0,
		0, 726, 5380, 1, 0, 0, 0, 728, 5382, 1, 0, 0, 0, 730, 5386, 1, 0, 0, 0,
		732, 5388, 1, 0, 0, 0, 734, 5390, 1, 0, 0, 0, 736, 5392, 1, 0, 0, 0, 738,
		5394, 1, 0, 0, 0, 740, 5396, 1, 0, 0, 0, 742, 5398, 1, 0, 0, 0, 744, 5402,
		1, 0, 0, 0, 746, 5404, 1, 0, 0, 0, 748, 5412, 1, 0, 0, 0, 750, 5416, 1,
		0, 0, 0, 752, 5430, 1, 0, 0, 0, 754, 5432, 1, 0, 0, 0, 756, 5435, 1, 0,
		0, 0, 758, 5437, 1, 0, 0, 0, 760, 5439, 1, 0, 0, 0, 762, 5441, 1, 0, 0,
		0, 764, 5452, 1, 0, 0, 0, 766, 5459, 1, 0, 0, 0, 768, 5461, 1, 0, 0, 0,
		770, 5474, 1, 0, 0, 0, 772, 5479, 1, 0, 0, 0, 774, 5483, 1, 0, 0, 0, 776,
		5490, 1, 0, 0, 0, 778, 5498, 1, 0, 0, 0, 780, 5500, 1, 0, 0, 0, 782, 5508,
		1, 0, 0, 0, 784, 5510, 1, 0, 0, 0, 786, 5512, 1, 0, 0, 0, 788, 5520, 1,
		0, 0, 0, 790, 5524, 1, 0, 0, 0, 792, 5526, 1, 0, 0, 0, 794, 5528, 1, 0,
		0, 0, 796, 5536, 1, 0, 0, 0, 798, 5540, 1, 0, 0, 0, 800, 5544, 1, 0, 0,
		0, 802, 5548, 1, 0, 0, 0, 804, 5550, 1, 0, 0, 0, 806, 5553, 1, 0, 0, 0,
		808, 5555, 1, 0, 0, 0, 810, 5563, 1, 0, 0, 0, 812, 5575, 1, 0, 0, 0, 814,
		5592, 1, 0, 0, 0, 816, 5594, 1, 0, 0, 0, 818, 5596, 1, 0, 0, 0, 820, 5615,
		1, 0, 0, 0, 822, 5617, 1, 0, 0, 0, 824, 5621, 1, 0, 0, 0, 826, 5632, 1,
		0, 0, 0, 828, 5638, 1, 0, 0, 0, 830, 5640, 1, 0, 0, 0, 832, 5645, 1, 0,
		0, 0, 834, 5652, 1, 0, 0, 0, 836, 838, 3, 2, 1, 0, 837, 839, 5, 773, 0,
		0, 838, 837, 1, 0, 0, 0, 838, 839, 1, 0, 0, 0, 839, 840, 1, 0, 0, 0, 840,
		841, 5, 0, 0, 1, 841, 1, 1, 0, 0, 0, 842, 843, 3, 656, 328, 0, 843, 845,
		3, 532, 266, 0, 844, 846, 3, 4, 2, 0, 845, 844, 1, 0, 0, 0, 845, 846, 1,
		0, 0, 0, 846, 3, 1, 0, 0, 0, 847, 849, 3, 6, 3, 0, 848, 847, 1, 0, 0, 0,
		849, 850, 1, 0, 0, 0, 850, 848, 1, 0, 0, 0, 850, 851, 1, 0, 0, 0, 851,
		5, 1, 0, 0, 0, 852, 854, 5, 371, 0, 0, 853, 852, 1, 0, 0, 0, 853, 854,
		1, 0, 0, 0, 854, 855, 1, 0, 0, 0, 855, 918, 5, 376, 0, 0, 856, 918, 5,
		24, 0, 0, 857, 859, 5, 420, 0, 0, 858, 857, 1, 0, 0, 0, 858, 859, 1, 0,
		0, 0, 859, 860, 1, 0, 0, 0, 860, 918, 5, 265, 0, 0, 861, 863, 5, 609, 0,
		0, 862, 864, 5, 265, 0, 0, 863, 862, 1, 0, 0, 0, 863, 864, 1, 0, 0, 0,
		864, 918, 1, 0, 0, 0, 865, 872, 5, 128, 0, 0, 866, 873, 3, 766, 383, 0,
		867, 869, 5, 372, 0, 0, 868, 870, 3, 424, 212, 0, 869, 868, 1, 0, 0, 0,
		869, 870, 1, 0, 0, 0, 870, 873, 1, 0, 0, 0, 871, 873, 3, 482, 241, 0, 872,
		866, 1, 0, 0, 0, 872, 867, 1, 0, 0, 0, 872, 871, 1, 0, 0, 0, 873, 918,
		1, 0, 0, 0, 874, 875, 5, 501, 0, 0, 875, 876, 5, 128, 0, 0, 876, 918, 5,
		627, 0, 0, 877, 878, 5, 383, 0, 0, 878, 879, 5, 614, 0, 0, 879, 881, 5,
		372, 0, 0, 880, 882, 3, 424, 212, 0, 881, 880, 1, 0, 0, 0, 881, 882, 1,
		0, 0, 0, 882, 918, 1, 0, 0, 0, 883, 884, 5, 75, 0, 0, 884, 918, 3, 776,
		388, 0, 885, 887, 3, 8, 4, 0, 886, 885, 1, 0, 0, 0, 886, 887, 1, 0, 0,
		0, 887, 888, 1, 0, 0, 0, 888, 889, 5, 62, 0, 0, 889, 890, 5, 776, 0, 0,
		890, 891, 3, 380, 190, 0, 891, 893, 5, 777, 0, 0, 892, 894, 3, 10, 5, 0,
		893, 892, 1, 0, 0, 0, 893, 894, 1, 0, 0, 0, 894, 918, 1, 0, 0, 0, 895,
		896, 5, 209, 0, 0, 896, 898, 5, 12, 0, 0, 897, 895, 1, 0, 0, 0, 897, 898,
		1, 0, 0, 0, 898, 899, 1, 0, 0, 0, 899, 900, 5, 17, 0, 0, 900, 901, 5, 776,
		0, 0, 901, 902, 3, 380, 190, 0, 902, 904, 5, 777, 0, 0, 903, 905, 7, 0,
		0, 0, 904, 903, 1, 0, 0, 0, 904, 905, 1, 0, 0, 0, 905, 918, 1, 0, 0, 0,
		906, 918, 3, 502, 251, 0, 907, 908, 5, 69, 0, 0, 908, 918, 3, 554, 277,
		0, 909, 910, 5, 74, 0, 0, 910, 918, 3, 496, 248, 0, 911, 912, 5, 553, 0,
		0, 912, 918, 3, 498, 249, 0, 913, 915, 5, 792, 0, 0, 914, 916, 3, 538,
		269, 0, 915, 914, 1, 0, 0, 0, 915, 916, 1, 0, 0, 0, 916, 918, 1, 0, 0,
		0, 917, 853, 1, 0, 0, 0, 917, 856, 1, 0, 0, 0, 917, 858, 1, 0, 0, 0, 917,
		861, 1, 0, 0, 0, 917, 865, 1, 0, 0, 0, 917, 874, 1, 0, 0, 0, 917, 877,
		1, 0, 0, 0, 917, 883, 1, 0, 0, 0, 917, 886, 1, 0, 0, 0, 917, 897, 1, 0,
		0, 0, 917, 906, 1, 0, 0, 0, 917, 907, 1, 0, 0, 0, 917, 909, 1, 0, 0, 0,
		917, 911, 1, 0, 0, 0, 917, 913, 1, 0, 0, 0, 918, 7, 1, 0, 0, 0, 919, 921,
		5, 86, 0, 0, 920, 922, 3, 744, 372, 0, 921, 920, 1, 0, 0, 0, 921, 922,
		1, 0, 0, 0, 922, 9, 1, 0, 0, 0, 923, 925, 5, 371, 0, 0, 924, 923, 1, 0,
		0, 0, 924, 925, 1, 0, 0, 0, 925, 926, 1, 0, 0, 0, 926, 927, 5, 730, 0,
		0, 927, 11, 1, 0, 0, 0, 928, 930, 3, 16, 8, 0, 929, 931, 3, 92, 46, 0,
		930, 929, 1, 0, 0, 0, 930, 931, 1, 0, 0, 0, 931, 935, 1, 0, 0, 0, 932,
		935, 3, 20, 10, 0, 933, 935, 3, 14, 7, 0, 934, 928, 1, 0, 0, 0, 934, 932,
		1, 0, 0, 0, 934, 933, 1, 0, 0, 0, 935, 13, 1, 0, 0, 0, 936, 937, 5, 776,
		0, 0, 937, 938, 3, 14, 7, 0, 938, 939, 5, 777, 0, 0, 939, 949, 1, 0, 0,
		0, 940, 941, 3, 16, 8, 0, 941, 943, 3, 38, 19, 0, 942, 944, 3, 92, 46,
		0, 943, 942, 1, 0, 0, 0, 943, 944, 1, 0, 0, 0, 944, 949, 1, 0, 0, 0, 945,
		946, 3, 92, 46, 0, 946, 947, 3, 38, 19, 0, 947, 949, 1, 0, 0, 0, 948, 936,
		1, 0, 0, 0, 948, 940, 1, 0, 0, 0, 948, 945, 1, 0, 0, 0, 949, 15, 1, 0,
		0, 0, 950, 952, 3, 66, 33, 0, 951, 950, 1, 0, 0, 0, 951, 952, 1, 0, 0,
		0, 952, 967, 1, 0, 0, 0, 953, 955, 3, 18, 9, 0, 954, 956, 3, 74, 37, 0,
		955, 954, 1, 0, 0, 0, 955, 956, 1, 0, 0, 0, 956, 958, 1, 0, 0, 0, 957,
		959, 3, 30, 15, 0, 958, 957, 1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 968,
		1, 0, 0, 0, 960, 962, 3, 20, 10, 0, 961, 963, 3, 74, 37, 0, 962, 961, 1,
		0, 0, 0, 962, 963, 1, 0, 0, 0, 963, 965, 1, 0, 0, 0, 964, 966, 3, 30, 15,
		0, 965, 964, 1, 0, 0, 0, 965, 966, 1, 0, 0, 0, 966, 968, 1, 0, 0, 0, 967,
		953, 1, 0, 0, 0, 967, 960, 1, 0, 0, 0, 968, 970, 1, 0, 0, 0, 969, 971,
		3, 40, 20, 0, 970, 969, 1, 0, 0, 0, 970, 971, 1, 0, 0, 0, 971, 17, 1, 0,
		0, 0, 972, 983, 3, 22, 11, 0, 973, 974, 3, 20, 10, 0, 974, 976, 3, 144,
		72, 0, 975, 977, 3, 146, 73, 0, 976, 975, 1, 0, 0, 0, 976, 977, 1, 0, 0,
		0, 977, 980, 1, 0, 0, 0, 978, 981, 3, 22, 11, 0, 979, 981, 3, 20, 10, 0,
		980, 978, 1, 0, 0, 0, 980, 979, 1, 0, 0, 0, 981, 983, 1, 0, 0, 0, 982,
		972, 1, 0, 0, 0, 982, 973, 1, 0, 0, 0, 983, 994, 1, 0, 0, 0, 984, 986,
		3, 144, 72, 0, 985, 987, 3, 146, 73, 0, 986, 985, 1, 0, 0, 0, 986, 987,
		1, 0, 0, 0, 987, 990, 1, 0, 0, 0, 988, 991, 3, 22, 11, 0, 989, 991, 3,
		20, 10, 0, 990, 988, 1, 0, 0, 0, 990, 989, 1, 0, 0, 0, 991, 993, 1, 0,
		0, 0, 992, 984, 1, 0, 0, 0, 993, 996, 1, 0, 0, 0, 994, 992, 1, 0, 0, 0,
		994, 995, 1, 0, 0, 0, 995, 19, 1, 0, 0, 0, 996, 994, 1, 0, 0, 0, 997, 1003,
		5, 776, 0, 0, 998, 1004, 3, 20, 10, 0, 999, 1001, 3, 16, 8, 0, 1000, 1002,
		3, 92, 46, 0, 1001, 1000, 1, 0, 0, 0, 1001, 1002, 1, 0, 0, 0, 1002, 1004,
		1, 0, 0, 0, 1003, 998, 1, 0, 0, 0, 1003, 999, 1, 0, 0, 0, 1004, 1005, 1,
		0, 0, 0, 1005, 1006, 5, 777, 0, 0, 1006, 21, 1, 0, 0, 0, 1007, 1011, 3,
		24, 12, 0, 1008, 1011, 3, 82, 41, 0, 1009, 1011, 3, 84, 42, 0, 1010, 1007,
		1, 0, 0, 0, 1010, 1008, 1, 0, 0, 0, 1010, 1009, 1, 0, 0, 0, 1011, 23, 1,
		0, 0, 0, 1012, 1016, 5, 497, 0, 0, 1013, 1015, 3, 90, 45, 0, 1014, 1013,
		1, 0, 0, 0, 1015, 1018, 1, 0, 0, 0, 1016, 1014, 1, 0, 0, 0, 1016, 1017,
		1, 0, 0, 0, 1017, 1019, 1, 0, 0, 0, 1018, 1016, 1, 0, 0, 0, 1019, 1021,
		3, 100, 50, 0, 1020, 1022, 3, 38, 19, 0, 1021, 1020, 1, 0, 0, 0, 1021,
		1022, 1, 0, 0, 0, 1022, 1024, 1, 0, 0, 0, 1023, 1025, 3, 78, 39, 0, 1024,
		1023, 1, 0, 0, 0, 1024, 1025, 1, 0, 0, 0, 1025, 1027, 1, 0, 0, 0, 1026,
		1028, 3, 106, 53, 0, 1027, 1026, 1, 0, 0, 0, 1027, 1028, 1, 0, 0, 0, 1028,
		1030, 1, 0, 0, 0, 1029, 1031, 3, 70, 35, 0, 1030, 1029, 1, 0, 0, 0, 1030,
		1031, 1, 0, 0, 0, 1031, 1033, 1, 0, 0, 0, 1032, 1034, 3, 42, 21, 0, 1033,
		1032, 1, 0, 0, 0, 1033, 1034, 1, 0, 0, 0, 1034, 1036, 1, 0, 0, 0, 1035,
		1037, 3, 44, 22, 0, 1036, 1035, 1, 0, 0, 0, 1036, 1037, 1, 0, 0, 0, 1037,
		25, 1, 0, 0, 0, 1038, 1039, 3, 20, 10, 0, 1039, 27, 1, 0, 0, 0, 1040, 1041,
		7, 1, 0, 0, 1041, 29, 1, 0, 0, 0, 1042, 1043, 5, 276, 0, 0, 1043, 1044,
		3, 34, 17, 0, 1044, 31, 1, 0, 0, 0, 1045, 1046, 5, 276, 0, 0, 1046, 1047,
		3, 36, 18, 0, 1047, 33, 1, 0, 0, 0, 1048, 1051, 3, 36, 18, 0, 1049, 1050,
		7, 2, 0, 0, 1050, 1052, 3, 36, 18, 0, 1051, 1049, 1, 0, 0, 0, 1051, 1052,
		1, 0, 0, 0, 1052, 35, 1, 0, 0, 0, 1053, 1056, 3, 744, 372, 0, 1054, 1056,
		7, 3, 0, 0, 1055, 1053, 1, 0, 0, 0, 1055, 1054, 1, 0, 0, 0, 1056, 37, 1,
		0, 0, 0, 1057, 1085, 5, 248, 0, 0, 1058, 1059, 5, 396, 0, 0, 1059, 1061,
		3, 770, 385, 0, 1060, 1062, 3, 614, 307, 0, 1061, 1060, 1, 0, 0, 0, 1061,
		1062, 1, 0, 0, 0, 1062, 1064, 1, 0, 0, 0, 1063, 1065, 3, 616, 308, 0, 1064,
		1063, 1, 0, 0, 0, 1064, 1065, 1, 0, 0, 0, 1065, 1067, 1, 0, 0, 0, 1066,
		1068, 3, 620, 310, 0, 1067, 1066, 1, 0, 0, 0, 1067, 1068, 1, 0, 0, 0, 1068,
		1086, 1, 0, 0, 0, 1069, 1070, 5, 150, 0, 0, 1070, 1086, 3, 770, 385, 0,
		1071, 1074, 3, 796, 398, 0, 1072, 1074, 3, 454, 227, 0, 1073, 1071, 1,
		0, 0, 0, 1073, 1072, 1, 0, 0, 0, 1074, 1082, 1, 0, 0, 0, 1075, 1078, 5,
		773, 0, 0, 1076, 1079, 3, 796, 398, 0, 1077, 1079, 3, 454, 227, 0, 1078,
		1076, 1, 0, 0, 0, 1078, 1077, 1, 0, 0, 0, 1079, 1081, 1, 0, 0, 0, 1080,
		1075, 1, 0, 0, 0, 1081, 1084, 1, 0, 0, 0, 1082, 1080, 1, 0, 0, 0, 1082,
		1083, 1, 0, 0, 0, 1083, 1086, 1, 0, 0, 0, 1084, 1082, 1, 0, 0, 0, 1085,
		1058, 1, 0, 0, 0, 1085, 1069, 1, 0, 0, 0, 1085, 1073, 1, 0, 0, 0, 1086,
		39, 1, 0, 0, 0, 1087, 1088, 5, 422, 0, 0, 1088, 1089, 5, 13, 0, 0, 1089,
		1095, 5, 776, 0, 0, 1090, 1093, 5, 747, 0, 0, 1091, 1092, 5, 773, 0, 0,
		1092, 1094, 5, 747, 0, 0, 1093, 1091, 1, 0, 0, 0, 1093, 1094, 1, 0, 0,
		0, 1094, 1096, 1, 0, 0, 0, 1095, 1090, 1, 0, 0, 0, 1095, 1096, 1, 0, 0,
		0, 1096, 1097, 1, 0, 0, 0, 1097, 1098, 5, 777, 0, 0, 1098, 41, 1, 0, 0,
		0, 1099, 1100, 5, 221, 0, 0, 1100, 1101, 3, 380, 190, 0, 1101, 43, 1, 0,
		0, 0, 1102, 1103, 5, 699, 0, 0, 1103, 1108, 3, 46, 23, 0, 1104, 1105, 5,
		773, 0, 0, 1105, 1107, 3, 46, 23, 0, 1106, 1104, 1, 0, 0, 0, 1107, 1110,
		1, 0, 0, 0, 1108, 1106, 1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 45, 1,
		0, 0, 0, 1110, 1108, 1, 0, 0, 0, 1111, 1112, 3, 740, 370, 0, 1112, 1113,
		5, 17, 0, 0, 1113, 1114, 3, 48, 24, 0, 1114, 47, 1, 0, 0, 0, 1115, 1116,
		5, 776, 0, 0, 1116, 1117, 3, 50, 25, 0, 1117, 1118, 5, 777, 0, 0, 1118,
		49, 1, 0, 0, 0, 1119, 1121, 3, 740, 370, 0, 1120, 1119, 1, 0, 0, 0, 1120,
		1121, 1, 0, 0, 0, 1121, 1125, 1, 0, 0, 0, 1122, 1123, 5, 405, 0, 0, 1123,
		1124, 5, 45, 0, 0, 1124, 1126, 3, 486, 243, 0, 1125, 1122, 1, 0, 0, 0,
		1125, 1126, 1, 0, 0, 0, 1126, 1128, 1, 0, 0, 0, 1127, 1129, 3, 74, 37,
		0, 1128, 1127, 1, 0, 0, 0, 1128, 1129, 1, 0, 0, 0, 1129, 1131, 1, 0, 0,
		0, 1130, 1132, 3, 52, 26, 0, 1131, 1130, 1, 0, 0, 0, 1131, 1132, 1, 0,
		0, 0, 1132, 51, 1, 0, 0, 0, 1133, 1134, 3, 54, 27, 0, 1134, 1136, 3, 56,
		28, 0, 1135, 1137, 3, 64, 32, 0, 1136, 1135, 1, 0, 0, 0, 1136, 1137, 1,
		0, 0, 0, 1137, 53, 1, 0, 0, 0, 1138, 1139, 7, 4, 0, 0, 1139, 55, 1, 0,
		0, 0, 1140, 1143, 3, 58, 29, 0, 1141, 1143, 3, 60, 30, 0, 1142, 1140, 1,
		0, 0, 0, 1142, 1141, 1, 0, 0, 0, 1143, 57, 1, 0, 0, 0, 1144, 1145, 5, 698,
		0, 0, 1145, 1159, 5, 693, 0, 0, 1146, 1147, 3, 760, 380, 0, 1147, 1148,
		5, 693, 0, 0, 1148, 1159, 1, 0, 0, 0, 1149, 1150, 5, 787, 0, 0, 1150, 1159,
		5, 693, 0, 0, 1151, 1152, 5, 247, 0, 0, 1152, 1153, 3, 380, 190, 0, 1153,
		1154, 3, 476, 238, 0, 1154, 1155, 5, 693, 0, 0, 1155, 1159, 1, 0, 0, 0,
		1156, 1157, 5, 101, 0, 0, 1157, 1159, 5, 487, 0, 0, 1158, 1144, 1, 0, 0,
		0, 1158, 1146, 1, 0, 0, 0, 1158, 1149, 1, 0, 0, 0, 1158, 1151, 1, 0, 0,
		0, 1158, 1156, 1, 0, 0, 0, 1159, 59, 1, 0, 0, 0, 1160, 1161, 5, 30, 0,
		0, 1161, 1162, 3, 62, 31, 0, 1162, 1163, 5, 15, 0, 0, 1163, 1164, 3, 62,
		31, 0, 1164, 61, 1, 0, 0, 0, 1165, 1179, 3, 58, 29, 0, 1166, 1167, 5, 698,
		0, 0, 1167, 1179, 5, 682, 0, 0, 1168, 1169, 3, 760, 380, 0, 1169, 1170,
		5, 682, 0, 0, 1170, 1179, 1, 0, 0, 0, 1171, 1172, 5, 787, 0, 0, 1172, 1179,
		5, 682, 0, 0, 1173, 1174, 5, 247, 0, 0, 1174, 1175, 3, 380, 190, 0, 1175,
		1176, 3, 476, 238, 0, 1176, 1177, 5, 682, 0, 0, 1177, 1179, 1, 0, 0, 0,
		1178, 1165, 1, 0, 0, 0, 1178, 1166, 1, 0, 0, 0, 1178, 1168, 1, 0, 0, 0,
		1178, 1171, 1, 0, 0, 0, 1178, 1173, 1, 0, 0, 0, 1179, 63, 1, 0, 0, 0, 1180,
		1187, 5, 680, 0, 0, 1181, 1182, 5, 101, 0, 0, 1182, 1188, 5, 487, 0, 0,
		1183, 1188, 5, 217, 0, 0, 1184, 1188, 5, 697, 0, 0, 1185, 1186, 5, 373,
		0, 0, 1186, 1188, 5, 690, 0, 0, 1187, 1181, 1, 0, 0, 0, 1187, 1183, 1,
		0, 0, 0, 1187, 1184, 1, 0, 0, 0, 1187, 1185, 1, 0, 0, 0, 1188, 65, 1, 0,
		0, 0, 1189, 1191, 5, 645, 0, 0, 1190, 1192, 5, 665, 0, 0, 1191, 1190, 1,
		0, 0, 0, 1191, 1192, 1, 0, 0, 0, 1192, 1193, 1, 0, 0, 0, 1193, 1198, 3,
		68, 34, 0, 1194, 1195, 5, 773, 0, 0, 1195, 1197, 3, 68, 34, 0, 1196, 1194,
		1, 0, 0, 0, 1197, 1200, 1, 0, 0, 0, 1198, 1196, 1, 0, 0, 0, 1198, 1199,
		1, 0, 0, 0, 1199, 67, 1, 0, 0, 0, 1200, 1198, 1, 0, 0, 0, 1201, 1203, 3,
		744, 372, 0, 1202, 1204, 3, 660, 330, 0, 1203, 1202, 1, 0, 0, 0, 1203,
		1204, 1, 0, 0, 0, 1204, 1205, 1, 0, 0, 0, 1205, 1206, 5, 17, 0, 0, 1206,
		1207, 3, 26, 13, 0, 1207, 69, 1, 0, 0, 0, 1208, 1209, 5, 217, 0, 0, 1209,
		1210, 5, 45, 0, 0, 1210, 1212, 3, 486, 243, 0, 1211, 1213, 3, 72, 36, 0,
		1212, 1211, 1, 0, 0, 0, 1212, 1213, 1, 0, 0, 0, 1213, 71, 1, 0, 0, 0, 1214,
		1215, 5, 645, 0, 0, 1215, 1219, 5, 481, 0, 0, 1216, 1217, 5, 645, 0, 0,
		1217, 1219, 5, 99, 0, 0, 1218, 1214, 1, 0, 0, 0, 1218, 1216, 1, 0, 0, 0,
		1219, 73, 1, 0, 0, 0, 1220, 1221, 5, 393, 0, 0, 1221, 1222, 5, 45, 0, 0,
		1222, 1223, 3, 486, 243, 0, 1223, 75, 1, 0, 0, 0, 1224, 1225, 7, 5, 0,
		0, 1225, 77, 1, 0, 0, 0, 1226, 1229, 5, 203, 0, 0, 1227, 1230, 5, 149,
		0, 0, 1228, 1230, 3, 80, 40, 0, 1229, 1227, 1, 0, 0, 0, 1229, 1228, 1,
		0, 0, 0, 1230, 79, 1, 0, 0, 0, 1231, 1236, 3, 108, 54, 0, 1232, 1233, 5,
		773, 0, 0, 1233, 1235, 3, 108, 54, 0, 1234, 1232, 1, 0, 0, 0, 1235, 1238,
		1, 0, 0, 0, 1236, 1234, 1, 0, 0, 0, 1236, 1237, 1, 0, 0, 0, 1237, 81, 1,
		0, 0, 0, 1238, 1236, 1, 0, 0, 0, 1239, 1240, 5, 626, 0, 0, 1240, 1245,
		3, 86, 43, 0, 1241, 1242, 5, 773, 0, 0, 1242, 1244, 3, 86, 43, 0, 1243,
		1241, 1, 0, 0, 0, 1244, 1247, 1, 0, 0, 0, 1245, 1243, 1, 0, 0, 0, 1245,
		1246, 1, 0, 0, 0, 1246, 83, 1, 0, 0, 0, 1247, 1245, 1, 0, 0, 0, 1248, 1249,
		5, 574, 0, 0, 1249, 1250, 3, 718, 359, 0, 1250, 85, 1, 0, 0, 0, 1251, 1252,
		5, 487, 0, 0, 1252, 1254, 5, 776, 0, 0, 1253, 1255, 3, 88, 44, 0, 1254,
		1253, 1, 0, 0, 0, 1254, 1255, 1, 0, 0, 0, 1255, 1256, 1, 0, 0, 0, 1256,
		1257, 5, 777, 0, 0, 1257, 87, 1, 0, 0, 0, 1258, 1261, 3, 380, 190, 0, 1259,
		1261, 5, 128, 0, 0, 1260, 1258, 1, 0, 0, 0, 1260, 1259, 1, 0, 0, 0, 1261,
		1269, 1, 0, 0, 0, 1262, 1265, 5, 773, 0, 0, 1263, 1266, 3, 380, 190, 0,
		1264, 1266, 5, 128, 0, 0, 1265, 1263, 1, 0, 0, 0, 1265, 1264, 1, 0, 0,
		0, 1266, 1268, 1, 0, 0, 0, 1267, 1262, 1, 0, 0, 0, 1268, 1271, 1, 0, 0,
		0, 1269, 1267, 1, 0, 0, 0, 1269, 1270, 1, 0, 0, 0, 1270, 89, 1, 0, 0, 0,
		1271, 1269, 1, 0, 0, 0, 1272, 1279, 3, 28, 14, 0, 1273, 1279, 5, 535, 0,
		0, 1274, 1279, 5, 533, 0, 0, 1275, 1276, 5, 325, 0, 0, 1276, 1277, 5, 750,
		0, 0, 1277, 1279, 3, 758, 379, 0, 1278, 1272, 1, 0, 0, 0, 1278, 1273, 1,
		0, 0, 0, 1278, 1274, 1, 0, 0, 0, 1278, 1275, 1, 0, 0, 0, 1279, 91, 1, 0,
		0, 0, 1280, 1282, 3, 94, 47, 0, 1281, 1280, 1, 0, 0, 0, 1282, 1283, 1,
		0, 0, 0, 1283, 1281, 1, 0, 0, 0, 1283, 1284, 1, 0, 0, 0, 1284, 93, 1, 0,
		0, 0, 1285, 1286, 5, 200, 0, 0, 1286, 1289, 3, 96, 48, 0, 1287, 1288, 5,
		668, 0, 0, 1288, 1290, 3, 722, 361, 0, 1289, 1287, 1, 0, 0, 0, 1289, 1290,
		1, 0, 0, 0, 1290, 1292, 1, 0, 0, 0, 1291, 1293, 3, 98, 49, 0, 1292, 1291,
		1, 0, 0, 0, 1292, 1293, 1, 0, 0, 0, 1293, 1299, 1, 0, 0, 0, 1294, 1295,
		5, 287, 0, 0, 1295, 1296, 5, 251, 0, 0, 1296, 1297, 5, 508, 0, 0, 1297,
		1299, 5, 346, 0, 0, 1298, 1285, 1, 0, 0, 0, 1298, 1294, 1, 0, 0, 0, 1299,
		95, 1, 0, 0, 0, 1300, 1301, 7, 6, 0, 0, 1301, 97, 1, 0, 0, 0, 1302, 1303,
		5, 669, 0, 0, 1303, 1306, 5, 670, 0, 0, 1304, 1306, 5, 671, 0, 0, 1305,
		1302, 1, 0, 0, 0, 1305, 1304, 1, 0, 0, 0, 1306, 99, 1, 0, 0, 0, 1307, 1310,
		3, 102, 51, 0, 1308, 1310, 5, 760, 0, 0, 1309, 1307, 1, 0, 0, 0, 1309,
		1308, 1, 0, 0, 0, 1310, 1315, 1, 0, 0, 0, 1311, 1312, 5, 773, 0, 0, 1312,
		1314, 3, 102, 51, 0, 1313, 1311, 1, 0, 0, 0, 1314, 1317, 1, 0, 0, 0, 1315,
		1313, 1, 0, 0, 0, 1315, 1316, 1, 0, 0, 0, 1316, 101, 1, 0, 0, 0, 1317,
		1315, 1, 0, 0, 0, 1318, 1324, 3, 670, 335, 0, 1319, 1321, 3, 380, 190,
		0, 1320, 1322, 3, 104, 52, 0, 1321, 1320, 1, 0, 0, 0, 1321, 1322, 1, 0,
		0, 0, 1322, 1324, 1, 0, 0, 0, 1323, 1318, 1, 0, 0, 0, 1323, 1319, 1, 0,
		0, 0, 1324, 103, 1, 0, 0, 0, 1325, 1327, 5, 17, 0, 0, 1326, 1325, 1, 0,
		0, 0, 1326, 1327, 1, 0, 0, 0, 1327, 1330, 1, 0, 0, 0, 1328, 1331, 3, 744,
		372, 0, 1329, 1331, 3, 770, 385, 0, 1330, 1328, 1, 0, 0, 0, 1330, 1329,
		1, 0, 0, 0, 1331, 105, 1, 0, 0, 0, 1332, 1333, 5, 643, 0, 0, 1333, 1334,
		3, 380, 190, 0, 1334, 107, 1, 0, 0, 0, 1335, 1345, 3, 120, 60, 0, 1336,
		1339, 5, 778, 0, 0, 1337, 1340, 3, 744, 372, 0, 1338, 1340, 5, 732, 0,
		0, 1339, 1337, 1, 0, 0, 0, 1339, 1338, 1, 0, 0, 0, 1340, 1341, 1, 0, 0,
		0, 1341, 1342, 3, 110, 55, 0, 1342, 1343, 5, 779, 0, 0, 1343, 1345, 1,
		0, 0, 0, 1344, 1335, 1, 0, 0, 0, 1344, 1336, 1, 0, 0, 0, 1345, 1349, 1,
		0, 0, 0, 1346, 1348, 3, 112, 56, 0, 1347, 1346, 1, 0, 0, 0, 1348, 1351,
		1, 0, 0, 0, 1349, 1347, 1, 0, 0, 0, 1349, 1350, 1, 0, 0, 0, 1350, 109,
		1, 0, 0, 0, 1351, 1349, 1, 0, 0, 0, 1352, 1356, 3, 120, 60, 0, 1353, 1355,
		3, 112, 56, 0, 1354, 1353, 1, 0, 0, 0, 1355, 1358, 1, 0, 0, 0, 1356, 1354,
		1, 0, 0, 0, 1356, 1357, 1, 0, 0, 0, 1357, 111, 1, 0, 0, 0, 1358, 1356,
		1, 0, 0, 0, 1359, 1360, 3, 116, 58, 0, 1360, 1365, 3, 108, 54, 0, 1361,
		1362, 5, 383, 0, 0, 1362, 1366, 3, 380, 190, 0, 1363, 1364, 5, 621, 0,
		0, 1364, 1366, 3, 748, 374, 0, 1365, 1361, 1, 0, 0, 0, 1365, 1363, 1, 0,
		0, 0, 1365, 1366, 1, 0, 0, 0, 1366, 1379, 1, 0, 0, 0, 1367, 1368, 3, 118,
		59, 0, 1368, 1373, 3, 108, 54, 0, 1369, 1370, 5, 383, 0, 0, 1370, 1374,
		3, 380, 190, 0, 1371, 1372, 5, 621, 0, 0, 1372, 1374, 3, 748, 374, 0, 1373,
		1369, 1, 0, 0, 0, 1373, 1371, 1, 0, 0, 0, 1374, 1379, 1, 0, 0, 0, 1375,
		1376, 3, 114, 57, 0, 1376, 1377, 3, 120, 60, 0, 1377, 1379, 1, 0, 0, 0,
		1378, 1359, 1, 0, 0, 0, 1378, 1367, 1, 0, 0, 0, 1378, 1375, 1, 0, 0, 0,
		1379, 113, 1, 0, 0, 0, 1380, 1382, 5, 359, 0, 0, 1381, 1383, 5, 239, 0,
		0, 1382, 1381, 1, 0, 0, 0, 1382, 1383, 1, 0, 0, 0, 1383, 1384, 1, 0, 0,
		0, 1384, 1392, 5, 261, 0, 0, 1385, 1386, 5, 359, 0, 0, 1386, 1388, 7, 7,
		0, 0, 1387, 1389, 5, 395, 0, 0, 1388, 1387, 1, 0, 0, 0, 1388, 1389, 1,
		0, 0, 0, 1389, 1390, 1, 0, 0, 0, 1390, 1392, 5, 261, 0, 0, 1391, 1380,
		1, 0, 0, 0, 1391, 1385, 1, 0, 0, 0, 1392, 115, 1, 0, 0, 0, 1393, 1395,
		7, 8, 0, 0, 1394, 1393, 1, 0, 0, 0, 1394, 1395, 1, 0, 0, 0, 1395, 1396,
		1, 0, 0, 0, 1396, 1399, 5, 261, 0, 0, 1397, 1399, 5, 555, 0, 0, 1398, 1394,
		1, 0, 0, 0, 1398, 1397, 1, 0, 0, 0, 1399, 117, 1, 0, 0, 0, 1400, 1402,
		7, 7, 0, 0, 1401, 1403, 5, 395, 0, 0, 1402, 1401, 1, 0, 0, 0, 1402, 1403,
		1, 0, 0, 0, 1403, 1404, 1, 0, 0, 0, 1404, 1405, 5, 261, 0, 0, 1405, 119,
		1, 0, 0, 0, 1406, 1412, 3, 122, 61, 0, 1407, 1412, 3, 124, 62, 0, 1408,
		1412, 3, 126, 63, 0, 1409, 1412, 3, 128, 64, 0, 1410, 1412, 3, 130, 65,
		0, 1411, 1406, 1, 0, 0, 0, 1411, 1407, 1, 0, 0, 0, 1411, 1408, 1, 0, 0,
		0, 1411, 1409, 1, 0, 0, 0, 1411, 1410, 1, 0, 0, 0, 1412, 121, 1, 0, 0,
		0, 1413, 1415, 3, 718, 359, 0, 1414, 1416, 3, 652, 326, 0, 1415, 1414,
		1, 0, 0, 0, 1415, 1416, 1, 0, 0, 0, 1416, 1418, 1, 0, 0, 0, 1417, 1419,
		3, 148, 74, 0, 1418, 1417, 1, 0, 0, 0, 1418, 1419, 1, 0, 0, 0, 1419, 1421,
		1, 0, 0, 0, 1420, 1422, 3, 150, 75, 0, 1421, 1420, 1, 0, 0, 0, 1421, 1422,
		1, 0, 0, 0, 1422, 123, 1, 0, 0, 0, 1423, 1426, 5, 776, 0, 0, 1424, 1427,
		3, 122, 61, 0, 1425, 1427, 3, 124, 62, 0, 1426, 1424, 1, 0, 0, 0, 1426,
		1425, 1, 0, 0, 0, 1427, 1428, 1, 0, 0, 0, 1428, 1429, 5, 777, 0, 0, 1429,
		125, 1, 0, 0, 0, 1430, 1432, 3, 26, 13, 0, 1431, 1433, 3, 148, 74, 0, 1432,
		1431, 1, 0, 0, 0, 1432, 1433, 1, 0, 0, 0, 1433, 1435, 1, 0, 0, 0, 1434,
		1436, 3, 660, 330, 0, 1435, 1434, 1, 0, 0, 0, 1435, 1436, 1, 0, 0, 0, 1436,
		1446, 1, 0, 0, 0, 1437, 1438, 5, 726, 0, 0, 1438, 1440, 3, 26, 13, 0, 1439,
		1441, 3, 148, 74, 0, 1440, 1439, 1, 0, 0, 0, 1440, 1441, 1, 0, 0, 0, 1441,
		1443, 1, 0, 0, 0, 1442, 1444, 3, 660, 330, 0, 1443, 1442, 1, 0, 0, 0, 1443,
		1444, 1, 0, 0, 0, 1444, 1446, 1, 0, 0, 0, 1445, 1430, 1, 0, 0, 0, 1445,
		1437, 1, 0, 0, 0, 1446, 127, 1, 0, 0, 0, 1447, 1450, 5, 776, 0, 0, 1448,
		1451, 3, 80, 40, 0, 1449, 1451, 3, 128, 64, 0, 1450, 1448, 1, 0, 0, 0,
		1450, 1449, 1, 0, 0, 0, 1451, 1452, 1, 0, 0, 0, 1452, 1453, 5, 777, 0,
		0, 1453, 129, 1, 0, 0, 0, 1454, 1455, 5, 701, 0, 0, 1455, 1456, 5, 776,
		0, 0, 1456, 1457, 3, 380, 190, 0, 1457, 1458, 5, 773, 0, 0, 1458, 1459,
		3, 770, 385, 0, 1459, 1460, 3, 132, 66, 0, 1460, 1462, 5, 777, 0, 0, 1461,
		1463, 3, 148, 74, 0, 1462, 1461, 1, 0, 0, 0, 1462, 1463, 1, 0, 0, 0, 1463,
		131, 1, 0, 0, 0, 1464, 1465, 5, 71, 0, 0, 1465, 1466, 5, 776, 0, 0, 1466,
		1471, 3, 134, 67, 0, 1467, 1468, 5, 773, 0, 0, 1468, 1470, 3, 134, 67,
		0, 1469, 1467, 1, 0, 0, 0, 1470, 1473, 1, 0, 0, 0, 1471, 1469, 1, 0, 0,
		0, 1471, 1472, 1, 0, 0, 0, 1472, 1474, 1, 0, 0, 0, 1473, 1471, 1, 0, 0,
		0, 1474, 1475, 5, 777, 0, 0, 1475, 133, 1, 0, 0, 0, 1476, 1477, 3, 744,
		372, 0, 1477, 1478, 5, 200, 0, 0, 1478, 1479, 5, 703, 0, 0, 1479, 1499,
		1, 0, 0, 0, 1480, 1481, 3, 744, 372, 0, 1481, 1483, 3, 532, 266, 0, 1482,
		1484, 3, 602, 301, 0, 1483, 1482, 1, 0, 0, 0, 1483, 1484, 1, 0, 0, 0, 1484,
		1486, 1, 0, 0, 0, 1485, 1487, 5, 174, 0, 0, 1486, 1485, 1, 0, 0, 0, 1486,
		1487, 1, 0, 0, 0, 1487, 1488, 1, 0, 0, 0, 1488, 1489, 5, 704, 0, 0, 1489,
		1491, 3, 770, 385, 0, 1490, 1492, 3, 136, 68, 0, 1491, 1490, 1, 0, 0, 0,
		1491, 1492, 1, 0, 0, 0, 1492, 1499, 1, 0, 0, 0, 1493, 1494, 5, 702, 0,
		0, 1494, 1495, 5, 704, 0, 0, 1495, 1496, 3, 770, 385, 0, 1496, 1497, 3,
		132, 66, 0, 1497, 1499, 1, 0, 0, 0, 1498, 1476, 1, 0, 0, 0, 1498, 1480,
		1, 0, 0, 0, 1498, 1493, 1, 0, 0, 0, 1499, 135, 1, 0, 0, 0, 1500, 1502,
		3, 138, 69, 0, 1501, 1503, 3, 140, 70, 0, 1502, 1501, 1, 0, 0, 0, 1502,
		1503, 1, 0, 0, 0, 1503, 1509, 1, 0, 0, 0, 1504, 1506, 3, 140, 70, 0, 1505,
		1507, 3, 138, 69, 0, 1506, 1505, 1, 0, 0, 0, 1506, 1507, 1, 0, 0, 0, 1507,
		1509, 1, 0, 0, 0, 1508, 1500, 1, 0, 0, 0, 1508, 1504, 1, 0, 0, 0, 1509,
		137, 1, 0, 0, 0, 1510, 1511, 3, 142, 71, 0, 1511, 1512, 5, 383, 0, 0, 1512,
		1513, 5, 700, 0, 0, 1513, 139, 1, 0, 0, 0, 1514, 1515, 3, 142, 71, 0, 1515,
		1516, 5, 383, 0, 0, 1516, 1517, 5, 165, 0, 0, 1517, 141, 1, 0, 0, 0, 1518,
		1523, 5, 165, 0, 0, 1519, 1523, 5, 376, 0, 0, 1520, 1521, 5, 128, 0, 0,
		1521, 1523, 3, 770, 385, 0, 1522, 1518, 1, 0, 0, 0, 1522, 1519, 1, 0, 0,
		0, 1522, 1520, 1, 0, 0, 0, 1523, 143, 1, 0, 0, 0, 1524, 1525, 7, 9, 0,
		0, 1525, 145, 1, 0, 0, 0, 1526, 1527, 7, 10, 0, 0, 1527, 147, 1, 0, 0,
		0, 1528, 1530, 7, 11, 0, 0, 1529, 1528, 1, 0, 0, 0, 1529, 1530, 1, 0, 0,
		0, 1530, 1531, 1, 0, 0, 0, 1531, 1532, 3, 744, 372, 0, 1532, 149, 1, 0,
		0, 0, 1533, 1538, 3, 152, 76, 0, 1534, 1535, 5, 773, 0, 0, 1535, 1537,
		3, 152, 76, 0, 1536, 1534, 1, 0, 0, 0, 1537, 1540, 1, 0, 0, 0, 1538, 1536,
		1, 0, 0, 0, 1538, 1539, 1, 0, 0, 0, 1539, 151, 1, 0, 0, 0, 1540, 1538,
		1, 0, 0, 0, 1541, 1542, 3, 154, 77, 0, 1542, 1544, 3, 156, 78, 0, 1543,
		1545, 3, 160, 80, 0, 1544, 1543, 1, 0, 0, 0, 1544, 1545, 1, 0, 0, 0, 1545,
		1546, 1, 0, 0, 0, 1546, 1547, 5, 776, 0, 0, 1547, 1548, 3, 162, 81, 0,
		1548, 1549, 5, 777, 0, 0, 1549, 1562, 1, 0, 0, 0, 1550, 1551, 5, 620, 0,
		0, 1551, 1553, 3, 156, 78, 0, 1552, 1554, 3, 160, 80, 0, 1553, 1552, 1,
		0, 0, 0, 1553, 1554, 1, 0, 0, 0, 1554, 1555, 1, 0, 0, 0, 1555, 1557, 5,
		776, 0, 0, 1556, 1558, 3, 162, 81, 0, 1557, 1556, 1, 0, 0, 0, 1557, 1558,
		1, 0, 0, 0, 1558, 1559, 1, 0, 0, 0, 1559, 1560, 5, 777, 0, 0, 1560, 1562,
		1, 0, 0, 0, 1561, 1541, 1, 0, 0, 0, 1561, 1550, 1, 0, 0, 0, 1562, 153,
		1, 0, 0, 0, 1563, 1564, 7, 12, 0, 0, 1564, 155, 1, 0, 0, 0, 1565, 1566,
		7, 13, 0, 0, 1566, 157, 1, 0, 0, 0, 1567, 1568, 5, 420, 0, 0, 1568, 1574,
		5, 265, 0, 0, 1569, 1571, 5, 609, 0, 0, 1570, 1572, 3, 156, 78, 0, 1571,
		1570, 1, 0, 0, 0, 1571, 1572, 1, 0, 0, 0, 1572, 1574, 1, 0, 0, 0, 1573,
		1567, 1, 0, 0, 0, 1573, 1569, 1, 0, 0, 0, 1574, 159, 1, 0, 0, 0, 1575,
		1581, 5, 200, 0, 0, 1576, 1582, 5, 261, 0, 0, 1577, 1578, 5, 393, 0, 0,
		1578, 1582, 5, 45, 0, 0, 1579, 1580, 5, 217, 0, 0, 1580, 1582, 5, 45, 0,
		0, 1581, 1576, 1, 0, 0, 0, 1581, 1577, 1, 0, 0, 0, 1581, 1579, 1, 0, 0,
		0, 1582, 161, 1, 0, 0, 0, 1583, 1588, 3, 164, 82, 0, 1584, 1585, 5, 773,
		0, 0, 1585, 1587, 3, 164, 82, 0, 1586, 1584, 1, 0, 0, 0, 1587, 1590, 1,
		0, 0, 0, 1588, 1586, 1, 0, 0, 0, 1588, 1589, 1, 0, 0, 0, 1589, 163, 1,
		0, 0, 0, 1590, 1588, 1, 0, 0, 0, 1591, 1594, 3, 744, 372, 0, 1592, 1594,
		5, 420, 0, 0, 1593, 1591, 1, 0, 0, 0, 1593, 1592, 1, 0, 0, 0, 1594, 165,
		1, 0, 0, 0, 1595, 1597, 3, 66, 33, 0, 1596, 1595, 1, 0, 0, 0, 1596, 1597,
		1, 0, 0, 0, 1597, 1598, 1, 0, 0, 0, 1598, 1600, 5, 614, 0, 0, 1599, 1601,
		5, 295, 0, 0, 1600, 1599, 1, 0, 0, 0, 1600, 1601, 1, 0, 0, 0, 1601, 1603,
		1, 0, 0, 0, 1602, 1604, 5, 232, 0, 0, 1603, 1602, 1, 0, 0, 0, 1603, 1604,
		1, 0, 0, 0, 1604, 1605, 1, 0, 0, 0, 1605, 1606, 3, 80, 40, 0, 1606, 1607,
		5, 506, 0, 0, 1607, 1609, 3, 610, 305, 0, 1608, 1610, 3, 106, 53, 0, 1609,
		1608, 1, 0, 0, 0, 1609, 1610, 1, 0, 0, 0, 1610, 1612, 1, 0, 0, 0, 1611,
		1613, 3, 74, 37, 0, 1612, 1611, 1, 0, 0, 0, 1612, 1613, 1, 0, 0, 0, 1613,
		1615, 1, 0, 0, 0, 1614, 1616, 3, 32, 16, 0, 1615, 1614, 1, 0, 0, 0, 1615,
		1616, 1, 0, 0, 0, 1616, 167, 1, 0, 0, 0, 1617, 1622, 3, 170, 85, 0, 1618,
		1622, 3, 176, 88, 0, 1619, 1622, 3, 178, 89, 0, 1620, 1622, 3, 184, 92,
		0, 1621, 1617, 1, 0, 0, 0, 1621, 1618, 1, 0, 0, 0, 1621, 1619, 1, 0, 0,
		0, 1621, 1620, 1, 0, 0, 0, 1622, 169, 1, 0, 0, 0, 1623, 1624, 5, 543, 0,
		0, 1624, 1628, 5, 592, 0, 0, 1625, 1627, 3, 174, 87, 0, 1626, 1625, 1,
		0, 0, 0, 1627, 1630, 1, 0, 0, 0, 1628, 1626, 1, 0, 0, 0, 1628, 1629, 1,
		0, 0, 0, 1629, 1649, 1, 0, 0, 0, 1630, 1628, 1, 0, 0, 0, 1631, 1633, 5,
		77, 0, 0, 1632, 1634, 5, 647, 0, 0, 1633, 1632, 1, 0, 0, 0, 1633, 1634,
		1, 0, 0, 0, 1634, 1640, 1, 0, 0, 0, 1635, 1637, 5, 15, 0, 0, 1636, 1638,
		5, 373, 0, 0, 1637, 1636, 1, 0, 0, 0, 1637, 1638, 1, 0, 0, 0, 1638, 1639,
		1, 0, 0, 0, 1639, 1641, 5, 54, 0, 0, 1640, 1635, 1, 0, 0, 0, 1640, 1641,
		1, 0, 0, 0, 1641, 1646, 1, 0, 0, 0, 1642, 1644, 5, 373, 0, 0, 1643, 1642,
		1, 0, 0, 0, 1643, 1644, 1, 0, 0, 0, 1644, 1645, 1, 0, 0, 0, 1645, 1647,
		5, 450, 0, 0, 1646, 1643, 1, 0, 0, 0, 1646, 1647, 1, 0, 0, 0, 1647, 1649,
		1, 0, 0, 0, 1648, 1623, 1, 0, 0, 0, 1648, 1631, 1, 0, 0, 0, 1649, 171,
		1, 0, 0, 0, 1650, 1652, 5, 29, 0, 0, 1651, 1653, 5, 647, 0, 0, 1652, 1651,
		1, 0, 0, 0, 1652, 1653, 1, 0, 0, 0, 1653, 173, 1, 0, 0, 0, 1654, 1655,
		5, 645, 0, 0, 1655, 1656, 5, 85, 0, 0, 1656, 1660, 5, 517, 0, 0, 1657,
		1658, 5, 435, 0, 0, 1658, 1660, 7, 14, 0, 0, 1659, 1654, 1, 0, 0, 0, 1659,
		1657, 1, 0, 0, 0, 1660, 175, 1, 0, 0, 0, 1661, 1662, 5, 489, 0, 0, 1662,
		1691, 3, 744, 372, 0, 1663, 1665, 5, 480, 0, 0, 1664, 1666, 5, 647, 0,
		0, 1665, 1664, 1, 0, 0, 0, 1665, 1666, 1, 0, 0, 0, 1666, 1685, 1, 0, 0,
		0, 1667, 1669, 5, 590, 0, 0, 1668, 1670, 5, 489, 0, 0, 1669, 1668, 1, 0,
		0, 0, 1669, 1670, 1, 0, 0, 0, 1670, 1671, 1, 0, 0, 0, 1671, 1686, 3, 744,
		372, 0, 1672, 1674, 5, 15, 0, 0, 1673, 1675, 5, 373, 0, 0, 1674, 1673,
		1, 0, 0, 0, 1674, 1675, 1, 0, 0, 0, 1675, 1676, 1, 0, 0, 0, 1676, 1678,
		5, 54, 0, 0, 1677, 1672, 1, 0, 0, 0, 1677, 1678, 1, 0, 0, 0, 1678, 1683,
		1, 0, 0, 0, 1679, 1681, 5, 373, 0, 0, 1680, 1679, 1, 0, 0, 0, 1680, 1681,
		1, 0, 0, 0, 1681, 1682, 1, 0, 0, 0, 1682, 1684, 5, 450, 0, 0, 1683, 1680,
		1, 0, 0, 0, 1683, 1684, 1, 0, 0, 0, 1684, 1686, 1, 0, 0, 0, 1685, 1667,
		1, 0, 0, 0, 1685, 1677, 1, 0, 0, 0, 1686, 1691, 1, 0, 0, 0, 1687, 1688,
		5, 450, 0, 0, 1688, 1689, 5, 489, 0, 0, 1689, 1691, 3, 744, 372, 0, 1690,
		1661, 1, 0, 0, 0, 1690, 1663, 1, 0, 0, 0, 1690, 1687, 1, 0, 0, 0, 1691,
		177, 1, 0, 0, 0, 1692, 1693, 5, 287, 0, 0, 1693, 1694, 7, 15, 0, 0, 1694,
		1699, 3, 180, 90, 0, 1695, 1696, 5, 773, 0, 0, 1696, 1698, 3, 180, 90,
		0, 1697, 1695, 1, 0, 0, 0, 1698, 1701, 1, 0, 0, 0, 1699, 1697, 1, 0, 0,
		0, 1699, 1700, 1, 0, 0, 0, 1700, 1709, 1, 0, 0, 0, 1701, 1699, 1, 0, 0,
		0, 1702, 1703, 5, 287, 0, 0, 1703, 1704, 5, 244, 0, 0, 1704, 1705, 5, 200,
		0, 0, 1705, 1709, 5, 27, 0, 0, 1706, 1707, 5, 611, 0, 0, 1707, 1709, 7,
		16, 0, 0, 1708, 1692, 1, 0, 0, 0, 1708, 1702, 1, 0, 0, 0, 1708, 1706, 1,
		0, 0, 0, 1709, 179, 1, 0, 0, 0, 1710, 1712, 3, 718, 359, 0, 1711, 1713,
		3, 148, 74, 0, 1712, 1711, 1, 0, 0, 0, 1712, 1713, 1, 0, 0, 0, 1713, 1714,
		1, 0, 0, 0, 1714, 1715, 3, 182, 91, 0, 1715, 181, 1, 0, 0, 0, 1716, 1718,
		5, 435, 0, 0, 1717, 1719, 5, 284, 0, 0, 1718, 1717, 1, 0, 0, 0, 1718, 1719,
		1, 0, 0, 0, 1719, 1725, 1, 0, 0, 0, 1720, 1722, 5, 295, 0, 0, 1721, 1720,
		1, 0, 0, 0, 1721, 1722, 1, 0, 0, 0, 1722, 1723, 1, 0, 0, 0, 1723, 1725,
		5, 649, 0, 0, 1724, 1716, 1, 0, 0, 0, 1724, 1721, 1, 0, 0, 0, 1725, 183,
		1, 0, 0, 0, 1726, 1753, 5, 651, 0, 0, 1727, 1728, 7, 17, 0, 0, 1728, 1730,
		3, 188, 94, 0, 1729, 1731, 7, 18, 0, 0, 1730, 1729, 1, 0, 0, 0, 1730, 1731,
		1, 0, 0, 0, 1731, 1754, 1, 0, 0, 0, 1732, 1733, 5, 159, 0, 0, 1733, 1739,
		3, 188, 94, 0, 1734, 1737, 5, 566, 0, 0, 1735, 1736, 5, 200, 0, 0, 1736,
		1738, 5, 340, 0, 0, 1737, 1735, 1, 0, 0, 0, 1737, 1738, 1, 0, 0, 0, 1738,
		1740, 1, 0, 0, 0, 1739, 1734, 1, 0, 0, 0, 1739, 1740, 1, 0, 0, 0, 1740,
		1754, 1, 0, 0, 0, 1741, 1742, 5, 417, 0, 0, 1742, 1754, 3, 188, 94, 0,
		1743, 1744, 5, 77, 0, 0, 1744, 1747, 3, 188, 94, 0, 1745, 1746, 5, 384,
		0, 0, 1746, 1748, 5, 407, 0, 0, 1747, 1745, 1, 0, 0, 0, 1747, 1748, 1,
		0, 0, 0, 1748, 1754, 1, 0, 0, 0, 1749, 1750, 5, 480, 0, 0, 1750, 1754,
		3, 188, 94, 0, 1751, 1752, 5, 439, 0, 0, 1752, 1754, 3, 186, 93, 0, 1753,
		1727, 1, 0, 0, 0, 1753, 1732, 1, 0, 0, 0, 1753, 1741, 1, 0, 0, 0, 1753,
		1743, 1, 0, 0, 0, 1753, 1749, 1, 0, 0, 0, 1753, 1751, 1, 0, 0, 0, 1754,
		185, 1, 0, 0, 0, 1755, 1756, 5, 94, 0, 0, 1756, 1758, 5, 652, 0, 0, 1757,
		1755, 1, 0, 0, 0, 1757, 1758, 1, 0, 0, 0, 1758, 1761, 1, 0, 0, 0, 1759,
		1761, 1, 0, 0, 0, 1760, 1757, 1, 0, 0, 0, 1760, 1759, 1, 0, 0, 0, 1761,
		187, 1, 0, 0, 0, 1762, 1769, 3, 772, 386, 0, 1763, 1764, 5, 773, 0, 0,
		1764, 1767, 3, 772, 386, 0, 1765, 1766, 5, 773, 0, 0, 1766, 1768, 3, 756,
		378, 0, 1767, 1765, 1, 0, 0, 0, 1767, 1768, 1, 0, 0, 0, 1768, 1770, 1,
		0, 0, 0, 1769, 1763, 1, 0, 0, 0, 1769, 1770, 1, 0, 0, 0, 1770, 189, 1,
		0, 0, 0, 1771, 1772, 5, 428, 0, 0, 1772, 1773, 7, 19, 0, 0, 1773, 1778,
		5, 289, 0, 0, 1774, 1775, 5, 590, 0, 0, 1775, 1779, 3, 776, 388, 0, 1776,
		1777, 5, 28, 0, 0, 1777, 1779, 3, 380, 190, 0, 1778, 1774, 1, 0, 0, 0,
		1778, 1776, 1, 0, 0, 0, 1779, 1802, 1, 0, 0, 0, 1780, 1802, 3, 198, 99,
		0, 1781, 1782, 5, 468, 0, 0, 1782, 1787, 3, 192, 96, 0, 1783, 1784, 5,
		773, 0, 0, 1784, 1786, 3, 192, 96, 0, 1785, 1783, 1, 0, 0, 0, 1786, 1789,
		1, 0, 0, 0, 1787, 1785, 1, 0, 0, 0, 1787, 1788, 1, 0, 0, 0, 1788, 1802,
		1, 0, 0, 0, 1789, 1787, 1, 0, 0, 0, 1790, 1791, 5, 468, 0, 0, 1791, 1795,
		5, 658, 0, 0, 1792, 1793, 3, 594, 297, 0, 1793, 1794, 3, 744, 372, 0, 1794,
		1796, 1, 0, 0, 0, 1795, 1792, 1, 0, 0, 0, 1795, 1796, 1, 0, 0, 0, 1796,
		1802, 1, 0, 0, 0, 1797, 1802, 3, 228, 114, 0, 1798, 1802, 3, 214, 107,
		0, 1799, 1802, 3, 196, 98, 0, 1800, 1802, 3, 238, 119, 0, 1801, 1771, 1,
		0, 0, 0, 1801, 1780, 1, 0, 0, 0, 1801, 1781, 1, 0, 0, 0, 1801, 1790, 1,
		0, 0, 0, 1801, 1797, 1, 0, 0, 0, 1801, 1798, 1, 0, 0, 0, 1801, 1799, 1,
		0, 0, 0, 1801, 1800, 1, 0, 0, 0, 1802, 191, 1, 0, 0, 0, 1803, 1805, 5,
		316, 0, 0, 1804, 1806, 3, 194, 97, 0, 1805, 1804, 1, 0, 0, 0, 1805, 1806,
		1, 0, 0, 0, 1806, 1817, 1, 0, 0, 0, 1807, 1808, 5, 430, 0, 0, 1808, 1817,
		5, 47, 0, 0, 1809, 1811, 5, 514, 0, 0, 1810, 1812, 5, 10, 0, 0, 1811, 1810,
		1, 0, 0, 0, 1811, 1812, 1, 0, 0, 0, 1812, 1814, 1, 0, 0, 0, 1813, 1815,
		3, 494, 247, 0, 1814, 1813, 1, 0, 0, 0, 1814, 1815, 1, 0, 0, 0, 1815, 1817,
		1, 0, 0, 0, 1816, 1803, 1, 0, 0, 0, 1816, 1807, 1, 0, 0, 0, 1816, 1809,
		1, 0, 0, 0, 1817, 193, 1, 0, 0, 0, 1818, 1821, 5, 590, 0, 0, 1819, 1822,
		3, 758, 379, 0, 1820, 1822, 3, 762, 381, 0, 1821, 1819, 1, 0, 0, 0, 1821,
		1820, 1, 0, 0, 0, 1822, 195, 1, 0, 0, 0, 1823, 1827, 5, 281, 0, 0, 1824,
		1828, 5, 112, 0, 0, 1825, 1826, 5, 574, 0, 0, 1826, 1828, 3, 718, 359,
		0, 1827, 1824, 1, 0, 0, 0, 1827, 1825, 1, 0, 0, 0, 1828, 1829, 1, 0, 0,
		0, 1829, 1830, 5, 203, 0, 0, 1830, 1831, 5, 316, 0, 0, 1831, 197, 1, 0,
		0, 0, 1832, 1833, 5, 55, 0, 0, 1833, 1834, 5, 316, 0, 0, 1834, 1835, 5,
		590, 0, 0, 1835, 1837, 3, 200, 100, 0, 1836, 1838, 3, 494, 247, 0, 1837,
		1836, 1, 0, 0, 0, 1837, 1838, 1, 0, 0, 0, 1838, 199, 1, 0, 0, 0, 1839,
		1844, 3, 202, 101, 0, 1840, 1841, 5, 773, 0, 0, 1841, 1843, 3, 202, 101,
		0, 1842, 1840, 1, 0, 0, 0, 1843, 1846, 1, 0, 0, 0, 1844, 1842, 1, 0, 0,
		0, 1844, 1845, 1, 0, 0, 0, 1845, 201, 1, 0, 0, 0, 1846, 1844, 1, 0, 0,
		0, 1847, 1848, 5, 300, 0, 0, 1848, 1849, 5, 750, 0, 0, 1849, 1939, 3, 778,
		389, 0, 1850, 1851, 5, 729, 0, 0, 1851, 1852, 5, 750, 0, 0, 1852, 1939,
		3, 778, 389, 0, 1853, 1854, 5, 297, 0, 0, 1854, 1855, 5, 750, 0, 0, 1855,
		1939, 3, 778, 389, 0, 1856, 1857, 5, 318, 0, 0, 1857, 1858, 5, 750, 0,
		0, 1858, 1939, 3, 778, 389, 0, 1859, 1860, 5, 303, 0, 0, 1860, 1861, 5,
		750, 0, 0, 1861, 1939, 3, 778, 389, 0, 1862, 1863, 5, 304, 0, 0, 1863,
		1864, 5, 750, 0, 0, 1864, 1939, 3, 756, 378, 0, 1865, 1866, 5, 298, 0,
		0, 1866, 1867, 5, 750, 0, 0, 1867, 1939, 3, 756, 378, 0, 1868, 1869, 5,
		305, 0, 0, 1869, 1870, 5, 750, 0, 0, 1870, 1939, 3, 756, 378, 0, 1871,
		1872, 5, 299, 0, 0, 1872, 1873, 5, 750, 0, 0, 1873, 1939, 3, 756, 378,
		0, 1874, 1875, 5, 314, 0, 0, 1875, 1876, 5, 750, 0, 0, 1876, 1939, 3, 756,
		378, 0, 1877, 1878, 5, 308, 0, 0, 1878, 1879, 5, 750, 0, 0, 1879, 1939,
		3, 778, 389, 0, 1880, 1881, 5, 307, 0, 0, 1881, 1882, 5, 750, 0, 0, 1882,
		1939, 3, 778, 389, 0, 1883, 1884, 5, 317, 0, 0, 1884, 1885, 5, 750, 0,
		0, 1885, 1939, 3, 778, 389, 0, 1886, 1887, 5, 309, 0, 0, 1887, 1888, 5,
		750, 0, 0, 1888, 1939, 3, 778, 389, 0, 1889, 1890, 5, 738, 0, 0, 1890,
		1891, 5, 750, 0, 0, 1891, 1939, 3, 208, 104, 0, 1892, 1893, 5, 310, 0,
		0, 1893, 1894, 5, 750, 0, 0, 1894, 1939, 3, 778, 389, 0, 1895, 1896, 5,
		313, 0, 0, 1896, 1897, 5, 750, 0, 0, 1897, 1939, 3, 778, 389, 0, 1898,
		1899, 5, 315, 0, 0, 1899, 1900, 5, 750, 0, 0, 1900, 1939, 3, 756, 378,
		0, 1901, 1902, 5, 311, 0, 0, 1902, 1903, 5, 750, 0, 0, 1903, 1939, 3, 776,
		388, 0, 1904, 1905, 5, 312, 0, 0, 1905, 1906, 5, 750, 0, 0, 1906, 1939,
		3, 778, 389, 0, 1907, 1908, 5, 712, 0, 0, 1908, 1909, 5, 750, 0, 0, 1909,
		1939, 3, 778, 389, 0, 1910, 1911, 5, 713, 0, 0, 1911, 1912, 5, 750, 0,
		0, 1912, 1939, 3, 756, 378, 0, 1913, 1914, 5, 319, 0, 0, 1914, 1915, 5,
		750, 0, 0, 1915, 1939, 3, 756, 378, 0, 1916, 1917, 5, 233, 0, 0, 1917,
		1918, 5, 750, 0, 0, 1918, 1939, 3, 212, 106, 0, 1919, 1920, 5, 735, 0,
		0, 1920, 1921, 5, 750, 0, 0, 1921, 1939, 3, 770, 385, 0, 1922, 1923, 5,
		736, 0, 0, 1923, 1924, 5, 750, 0, 0, 1924, 1939, 3, 756, 378, 0, 1925,
		1926, 5, 296, 0, 0, 1926, 1927, 5, 750, 0, 0, 1927, 1939, 3, 756, 378,
		0, 1928, 1929, 5, 737, 0, 0, 1929, 1930, 5, 750, 0, 0, 1930, 1939, 3, 204,
		102, 0, 1931, 1932, 5, 739, 0, 0, 1932, 1933, 5, 750, 0, 0, 1933, 1939,
		3, 756, 378, 0, 1934, 1935, 5, 742, 0, 0, 1935, 1936, 5, 750, 0, 0, 1936,
		1939, 3, 206, 103, 0, 1937, 1939, 3, 210, 105, 0, 1938, 1847, 1, 0, 0,
		0, 1938, 1850, 1, 0, 0, 0, 1938, 1853, 1, 0, 0, 0, 1938, 1856, 1, 0, 0,
		0, 1938, 1859, 1, 0, 0, 0, 1938, 1862, 1, 0, 0, 0, 1938, 1865, 1, 0, 0,
		0, 1938, 1868, 1, 0, 0, 0, 1938, 1871, 1, 0, 0, 0, 1938, 1874, 1, 0, 0,
		0, 1938, 1877, 1, 0, 0, 0, 1938, 1880, 1, 0, 0, 0, 1938, 1883, 1, 0, 0,
		0, 1938, 1886, 1, 0, 0, 0, 1938, 1889, 1, 0, 0, 0, 1938, 1892, 1, 0, 0,
		0, 1938, 1895, 1, 0, 0, 0, 1938, 1898, 1, 0, 0, 0, 1938, 1901, 1, 0, 0,
		0, 1938, 1904, 1, 0, 0, 0, 1938, 1907, 1, 0, 0, 0, 1938, 1910, 1, 0, 0,
		0, 1938, 1913, 1, 0, 0, 0, 1938, 1916, 1, 0, 0, 0, 1938, 1919, 1, 0, 0,
		0, 1938, 1922, 1, 0, 0, 0, 1938, 1925, 1, 0, 0, 0, 1938, 1928, 1, 0, 0,
		0, 1938, 1931, 1, 0, 0, 0, 1938, 1934, 1, 0, 0, 0, 1938, 1937, 1, 0, 0,
		0, 1939, 203, 1, 0, 0, 0, 1940, 1943, 3, 640, 320, 0, 1941, 1943, 5, 376,
		0, 0, 1942, 1940, 1, 0, 0, 0, 1942, 1941, 1, 0, 0, 0, 1943, 205, 1, 0,
		0, 0, 1944, 1945, 7, 20, 0, 0, 1945, 207, 1, 0, 0, 0, 1946, 1949, 3, 778,
		389, 0, 1947, 1949, 5, 376, 0, 0, 1948, 1946, 1, 0, 0, 0, 1948, 1947, 1,
		0, 0, 0, 1949, 209, 1, 0, 0, 0, 1950, 1951, 5, 301, 0, 0, 1951, 1952, 5,
		750, 0, 0, 1952, 1963, 3, 778, 389, 0, 1953, 1954, 5, 302, 0, 0, 1954,
		1955, 5, 750, 0, 0, 1955, 1963, 3, 760, 380, 0, 1956, 1957, 5, 447, 0,
		0, 1957, 1958, 5, 750, 0, 0, 1958, 1963, 3, 778, 389, 0, 1959, 1960, 5,
		448, 0, 0, 1960, 1961, 5, 750, 0, 0, 1961, 1963, 3, 756, 378, 0, 1962,
		1950, 1, 0, 0, 0, 1962, 1953, 1, 0, 0, 0, 1962, 1956, 1, 0, 0, 0, 1962,
		1959, 1, 0, 0, 0, 1963, 211, 1, 0, 0, 0, 1964, 1973, 5, 776, 0, 0, 1965,
		1970, 3, 756, 378, 0, 1966, 1967, 5, 773, 0, 0, 1967, 1969, 3, 756, 378,
		0, 1968, 1966, 1, 0, 0, 0, 1969, 1972, 1, 0, 0, 0, 1970, 1968, 1, 0, 0,
		0, 1970, 1971, 1, 0, 0, 0, 1971, 1974, 1, 0, 0, 0, 1972, 1970, 1, 0, 0,
		0, 1973, 1965, 1, 0, 0, 0, 1973, 1974, 1, 0, 0, 0, 1974, 1975, 1, 0, 0,
		0, 1975, 1976, 5, 777, 0, 0, 1976, 213, 1, 0, 0, 0, 1977, 1978, 5, 55,
		0, 0, 1978, 1979, 5, 459, 0, 0, 1979, 1980, 5, 190, 0, 0, 1980, 1985, 3,
		216, 108, 0, 1981, 1982, 5, 773, 0, 0, 1982, 1984, 3, 216, 108, 0, 1983,
		1981, 1, 0, 0, 0, 1984, 1987, 1, 0, 0, 0, 1985, 1983, 1, 0, 0, 0, 1985,
		1986, 1, 0, 0, 0, 1986, 1989, 1, 0, 0, 0, 1987, 1985, 1, 0, 0, 0, 1988,
		1990, 3, 494, 247, 0, 1989, 1988, 1, 0, 0, 0, 1989, 1990, 1, 0, 0, 0, 1990,
		215, 1, 0, 0, 0, 1991, 1992, 5, 460, 0, 0, 1992, 1993, 5, 750, 0, 0, 1993,
		1995, 5, 776, 0, 0, 1994, 1996, 3, 218, 109, 0, 1995, 1994, 1, 0, 0, 0,
		1995, 1996, 1, 0, 0, 0, 1996, 1997, 1, 0, 0, 0, 1997, 2041, 5, 777, 0,
		0, 1998, 1999, 5, 461, 0, 0, 1999, 2000, 5, 750, 0, 0, 2000, 2002, 5, 776,
		0, 0, 2001, 2003, 3, 218, 109, 0, 2002, 2001, 1, 0, 0, 0, 2002, 2003, 1,
		0, 0, 0, 2003, 2004, 1, 0, 0, 0, 2004, 2041, 5, 777, 0, 0, 2005, 2006,
		5, 462, 0, 0, 2006, 2007, 5, 750, 0, 0, 2007, 2009, 5, 776, 0, 0, 2008,
		2010, 3, 220, 110, 0, 2009, 2008, 1, 0, 0, 0, 2009, 2010, 1, 0, 0, 0, 2010,
		2011, 1, 0, 0, 0, 2011, 2041, 5, 777, 0, 0, 2012, 2013, 5, 463, 0, 0, 2013,
		2014, 5, 750, 0, 0, 2014, 2016, 5, 776, 0, 0, 2015, 2017, 3, 220, 110,
		0, 2016, 2015, 1, 0, 0, 0, 2016, 2017, 1, 0, 0, 0, 2017, 2018, 1, 0, 0,
		0, 2018, 2041, 5, 777, 0, 0, 2019, 2020, 5, 464, 0, 0, 2020, 2021, 5, 750,
		0, 0, 2021, 2023, 5, 776, 0, 0, 2022, 2024, 3, 222, 111, 0, 2023, 2022,
		1, 0, 0, 0, 2023, 2024, 1, 0, 0, 0, 2024, 2025, 1, 0, 0, 0, 2025, 2041,
		5, 777, 0, 0, 2026, 2027, 5, 465, 0, 0, 2027, 2028, 5, 750, 0, 0, 2028,
		2030, 5, 776, 0, 0, 2029, 2031, 3, 222, 111, 0, 2030, 2029, 1, 0, 0, 0,
		2030, 2031, 1, 0, 0, 0, 2031, 2032, 1, 0, 0, 0, 2032, 2041, 5, 777, 0,
		0, 2033, 2034, 5, 466, 0, 0, 2034, 2035, 5, 750, 0, 0, 2035, 2037, 5, 776,
		0, 0, 2036, 2038, 3, 226, 113, 0, 2037, 2036, 1, 0, 0, 0, 2037, 2038, 1,
		0, 0, 0, 2038, 2039, 1, 0, 0, 0, 2039, 2041, 5, 777, 0, 0, 2040, 1991,
		1, 0, 0, 0, 2040, 1998, 1, 0, 0, 0, 2040, 2005, 1, 0, 0, 0, 2040, 2012,
		1, 0, 0, 0, 2040, 2019, 1, 0, 0, 0, 2040, 2026, 1, 0, 0, 0, 2040, 2033,
		1, 0, 0, 0, 2041, 217, 1, 0, 0, 0, 2042, 2047, 3, 674, 337, 0, 2043, 2044,
		5, 773, 0, 0, 2044, 2046, 3, 674, 337, 0, 2045, 2043, 1, 0, 0, 0, 2046,
		2049, 1, 0, 0, 0, 2047, 2045, 1, 0, 0, 0, 2047, 2048, 1, 0, 0, 0, 2048,
		219, 1, 0, 0, 0, 2049, 2047, 1, 0, 0, 0, 2050, 2055, 3, 714, 357, 0, 2051,
		2052, 5, 773, 0, 0, 2052, 2054, 3, 714, 357, 0, 2053, 2051, 1, 0, 0, 0,
		2054, 2057, 1, 0, 0, 0, 2055, 2053, 1, 0, 0, 0, 2055, 2056, 1, 0, 0, 0,
		2056, 221, 1, 0, 0, 0, 2057, 2055, 1, 0, 0, 0, 2058, 2063, 3, 224, 112,
		0, 2059, 2060, 5, 773, 0, 0, 2060, 2062, 3, 224, 112, 0, 2061, 2059, 1,
		0, 0, 0, 2062, 2065, 1, 0, 0, 0, 2063, 2061, 1, 0, 0, 0, 2063, 2064, 1,
		0, 0, 0, 2064, 223, 1, 0, 0, 0, 2065, 2063, 1, 0, 0, 0, 2066, 2067, 3,
		778, 389, 0, 2067, 225, 1, 0, 0, 0, 2068, 2073, 3, 606, 303, 0, 2069, 2070,
		5, 773, 0, 0, 2070, 2072, 3, 606, 303, 0, 2071, 2069, 1, 0, 0, 0, 2072,
		2075, 1, 0, 0, 0, 2073, 2071, 1, 0, 0, 0, 2073, 2074, 1, 0, 0, 0, 2074,
		227, 1, 0, 0, 0, 2075, 2073, 1, 0, 0, 0, 2076, 2077, 5, 543, 0, 0, 2077,
		2079, 5, 514, 0, 0, 2078, 2080, 3, 234, 117, 0, 2079, 2078, 1, 0, 0, 0,
		2079, 2080, 1, 0, 0, 0, 2080, 2083, 1, 0, 0, 0, 2081, 2082, 5, 613, 0,
		0, 2082, 2084, 3, 230, 115, 0, 2083, 2081, 1, 0, 0, 0, 2083, 2084, 1, 0,
		0, 0, 2084, 2085, 1, 0, 0, 0, 2085, 2087, 3, 232, 116, 0, 2086, 2088, 3,
		494, 247, 0, 2087, 2086, 1, 0, 0, 0, 2087, 2088, 1, 0, 0, 0, 2088, 2098,
		1, 0, 0, 0, 2089, 2090, 5, 552, 0, 0, 2090, 2092, 5, 514, 0, 0, 2091, 2093,
		3, 234, 117, 0, 2092, 2091, 1, 0, 0, 0, 2092, 2093, 1, 0, 0, 0, 2093, 2095,
		1, 0, 0, 0, 2094, 2096, 3, 494, 247, 0, 2095, 2094, 1, 0, 0, 0, 2095, 2096,
		1, 0, 0, 0, 2096, 2098, 1, 0, 0, 0, 2097, 2076, 1, 0, 0, 0, 2097, 2089,
		1, 0, 0, 0, 2098, 229, 1, 0, 0, 0, 2099, 2105, 3, 210, 105, 0, 2100, 2101,
		7, 21, 0, 0, 2101, 2102, 5, 750, 0, 0, 2102, 2105, 3, 772, 386, 0, 2103,
		2105, 5, 529, 0, 0, 2104, 2099, 1, 0, 0, 0, 2104, 2100, 1, 0, 0, 0, 2104,
		2103, 1, 0, 0, 0, 2105, 2110, 1, 0, 0, 0, 2106, 2107, 5, 773, 0, 0, 2107,
		2109, 3, 210, 105, 0, 2108, 2106, 1, 0, 0, 0, 2109, 2112, 1, 0, 0, 0, 2110,
		2108, 1, 0, 0, 0, 2110, 2111, 1, 0, 0, 0, 2111, 231, 1, 0, 0, 0, 2112,
		2110, 1, 0, 0, 0, 2113, 2114, 5, 618, 0, 0, 2114, 2115, 5, 750, 0, 0, 2115,
		2117, 3, 772, 386, 0, 2116, 2113, 1, 0, 0, 0, 2116, 2117, 1, 0, 0, 0, 2117,
		2121, 1, 0, 0, 0, 2118, 2119, 5, 406, 0, 0, 2119, 2120, 5, 750, 0, 0, 2120,
		2122, 3, 772, 386, 0, 2121, 2118, 1, 0, 0, 0, 2121, 2122, 1, 0, 0, 0, 2122,
		2126, 1, 0, 0, 0, 2123, 2124, 5, 129, 0, 0, 2124, 2125, 5, 750, 0, 0, 2125,
		2127, 3, 772, 386, 0, 2126, 2123, 1, 0, 0, 0, 2126, 2127, 1, 0, 0, 0, 2127,
		2131, 1, 0, 0, 0, 2128, 2129, 5, 409, 0, 0, 2129, 2130, 5, 750, 0, 0, 2130,
		2132, 3, 772, 386, 0, 2131, 2128, 1, 0, 0, 0, 2131, 2132, 1, 0, 0, 0, 2132,
		2135, 1, 0, 0, 0, 2133, 2135, 1, 0, 0, 0, 2134, 2116, 1, 0, 0, 0, 2134,
		2133, 1, 0, 0, 0, 2135, 233, 1, 0, 0, 0, 2136, 2141, 3, 236, 118, 0, 2137,
		2138, 5, 773, 0, 0, 2138, 2140, 3, 236, 118, 0, 2139, 2137, 1, 0, 0, 0,
		2140, 2143, 1, 0, 0, 0, 2141, 2139, 1, 0, 0, 0, 2141, 2142, 1, 0, 0, 0,
		2142, 235, 1, 0, 0, 0, 2143, 2141, 1, 0, 0, 0, 2144, 2145, 7, 22, 0, 0,
		2145, 237, 1, 0, 0, 0, 2146, 2147, 7, 23, 0, 0, 2147, 2148, 5, 210, 0,
		0, 2148, 239, 1, 0, 0, 0, 2149, 2150, 5, 417, 0, 0, 2150, 2151, 3, 744,
		372, 0, 2151, 2154, 5, 203, 0, 0, 2152, 2155, 3, 776, 388, 0, 2153, 2155,
		3, 454, 227, 0, 2154, 2152, 1, 0, 0, 0, 2154, 2153, 1, 0, 0, 0, 2155, 2161,
		1, 0, 0, 0, 2156, 2161, 3, 242, 121, 0, 2157, 2158, 7, 24, 0, 0, 2158,
		2159, 5, 417, 0, 0, 2159, 2161, 3, 744, 372, 0, 2160, 2149, 1, 0, 0, 0,
		2160, 2156, 1, 0, 0, 0, 2160, 2157, 1, 0, 0, 0, 2161, 241, 1, 0, 0, 0,
		2162, 2163, 5, 173, 0, 0, 2163, 2166, 3, 744, 372, 0, 2164, 2165, 5, 621,
		0, 0, 2165, 2167, 3, 244, 122, 0, 2166, 2164, 1, 0, 0, 0, 2166, 2167, 1,
		0, 0, 0, 2167, 243, 1, 0, 0, 0, 2168, 2173, 3, 454, 227, 0, 2169, 2170,
		5, 773, 0, 0, 2170, 2172, 3, 454, 227, 0, 2171, 2169, 1, 0, 0, 0, 2172,
		2175, 1, 0, 0, 0, 2173, 2171, 1, 0, 0, 0, 2173, 2174, 1, 0, 0, 0, 2174,
		245, 1, 0, 0, 0, 2175, 2173, 1, 0, 0, 0, 2176, 2200, 5, 677, 0, 0, 2177,
		2178, 5, 284, 0, 0, 2178, 2179, 5, 112, 0, 0, 2179, 2181, 5, 139, 0, 0,
		2180, 2182, 3, 806, 403, 0, 2181, 2180, 1, 0, 0, 0, 2181, 2182, 1, 0, 0,
		0, 2182, 2183, 1, 0, 0, 0, 2183, 2201, 3, 770, 385, 0, 2184, 2187, 5, 676,
		0, 0, 2185, 2186, 5, 200, 0, 0, 2186, 2188, 5, 459, 0, 0, 2187, 2185, 1,
		0, 0, 0, 2187, 2188, 1, 0, 0, 0, 2188, 2201, 1, 0, 0, 0, 2189, 2190, 5,
		244, 0, 0, 2190, 2191, 5, 203, 0, 0, 2191, 2192, 3, 642, 321, 0, 2192,
		2193, 5, 775, 0, 0, 2193, 2194, 3, 756, 378, 0, 2194, 2195, 5, 230, 0,
		0, 2195, 2196, 5, 45, 0, 0, 2196, 2198, 3, 770, 385, 0, 2197, 2199, 3,
		248, 124, 0, 2198, 2197, 1, 0, 0, 0, 2198, 2199, 1, 0, 0, 0, 2199, 2201,
		1, 0, 0, 0, 2200, 2177, 1, 0, 0, 0, 2200, 2184, 1, 0, 0, 0, 2200, 2189,
		1, 0, 0, 0, 2201, 247, 1, 0, 0, 0, 2202, 2213, 3, 250, 125, 0, 2203, 2204,
		5, 112, 0, 0, 2204, 2206, 5, 139, 0, 0, 2205, 2207, 3, 806, 403, 0, 2206,
		2205, 1, 0, 0, 0, 2206, 2207, 1, 0, 0, 0, 2207, 2208, 1, 0, 0, 0, 2208,
		2210, 3, 770, 385, 0, 2209, 2211, 3, 250, 125, 0, 2210, 2209, 1, 0, 0,
		0, 2210, 2211, 1, 0, 0, 0, 2211, 2213, 1, 0, 0, 0, 2212, 2202, 1, 0, 0,
		0, 2212, 2203, 1, 0, 0, 0, 2213, 249, 1, 0, 0, 0, 2214, 2216, 5, 467, 0,
		0, 2215, 2217, 5, 373, 0, 0, 2216, 2215, 1, 0, 0, 0, 2216, 2217, 1, 0,
		0, 0, 2217, 2218, 1, 0, 0, 0, 2218, 2219, 5, 539, 0, 0, 2219, 251, 1, 0,
		0, 0, 2220, 2228, 3, 254, 127, 0, 2221, 2228, 3, 260, 130, 0, 2222, 2228,
		3, 272, 136, 0, 2223, 2228, 3, 274, 137, 0, 2224, 2228, 3, 288, 144, 0,
		2225, 2228, 3, 290, 145, 0, 2226, 2228, 3, 308, 154, 0, 2227, 2220, 1,
		0, 0, 0, 2227, 2221, 1, 0, 0, 0, 2227, 2222, 1, 0, 0, 0, 2227, 2223, 1,
		0, 0, 0, 2227, 2224, 1, 0, 0, 0, 2227, 2225, 1, 0, 0, 0, 2227, 2226, 1,
		0, 0, 0, 2228, 253, 1, 0, 0, 0, 2229, 2230, 5, 11, 0, 0, 2230, 2232, 5,
		618, 0, 0, 2231, 2233, 3, 594, 297, 0, 2232, 2231, 1, 0, 0, 0, 2232, 2233,
		1, 0, 0, 0, 2233, 2234, 1, 0, 0, 0, 2234, 2235, 3, 256, 128, 0, 2235, 255,
		1, 0, 0, 0, 2236, 2239, 3, 626, 313, 0, 2237, 2239, 3, 628, 314, 0, 2238,
		2236, 1, 0, 0, 0, 2238, 2237, 1, 0, 0, 0, 2239, 2240, 1, 0, 0, 0, 2240,
		2241, 3, 262, 131, 0, 2241, 2283, 1, 0, 0, 0, 2242, 2243, 3, 642, 321,
		0, 2243, 2244, 5, 230, 0, 0, 2244, 2245, 5, 45, 0, 0, 2245, 2247, 3, 772,
		386, 0, 2246, 2248, 3, 638, 319, 0, 2247, 2246, 1, 0, 0, 0, 2247, 2248,
		1, 0, 0, 0, 2248, 2250, 1, 0, 0, 0, 2249, 2251, 3, 634, 317, 0, 2250, 2249,
		1, 0, 0, 0, 2250, 2251, 1, 0, 0, 0, 2251, 2283, 1, 0, 0, 0, 2252, 2253,
		3, 642, 321, 0, 2253, 2254, 3, 636, 318, 0, 2254, 2283, 1, 0, 0, 0, 2255,
		2256, 3, 642, 321, 0, 2256, 2257, 5, 128, 0, 0, 2257, 2261, 5, 659, 0,
		0, 2258, 2262, 5, 10, 0, 0, 2259, 2262, 5, 369, 0, 0, 2260, 2262, 3, 310,
		155, 0, 2261, 2258, 1, 0, 0, 0, 2261, 2259, 1, 0, 0, 0, 2261, 2260, 1,
		0, 0, 0, 2262, 2283, 1, 0, 0, 0, 2263, 2264, 3, 642, 321, 0, 2264, 2267,
		5, 230, 0, 0, 2265, 2266, 5, 645, 0, 0, 2266, 2268, 3, 796, 398, 0, 2267,
		2265, 1, 0, 0, 0, 2267, 2268, 1, 0, 0, 0, 2268, 2269, 1, 0, 0, 0, 2269,
		2270, 5, 45, 0, 0, 2270, 2271, 5, 734, 0, 0, 2271, 2273, 5, 406, 0, 0,
		2272, 2274, 3, 634, 317, 0, 2273, 2272, 1, 0, 0, 0, 2273, 2274, 1, 0, 0,
		0, 2274, 2283, 1, 0, 0, 0, 2275, 2276, 5, 741, 0, 0, 2276, 2283, 3, 758,
		379, 0, 2277, 2280, 5, 740, 0, 0, 2278, 2281, 3, 758, 379, 0, 2279, 2281,
		5, 698, 0, 0, 2280, 2278, 1, 0, 0, 0, 2280, 2279, 1, 0, 0, 0, 2281, 2283,
		1, 0, 0, 0, 2282, 2238, 1, 0, 0, 0, 2282, 2242, 1, 0, 0, 0, 2282, 2252,
		1, 0, 0, 0, 2282, 2255, 1, 0, 0, 0, 2282, 2263, 1, 0, 0, 0, 2282, 2275,
		1, 0, 0, 0, 2282, 2277, 1, 0, 0, 0, 2283, 257, 1, 0, 0, 0, 2284, 2285,
		5, 618, 0, 0, 2285, 2286, 3, 804, 402, 0, 2286, 259, 1, 0, 0, 0, 2287,
		2288, 5, 97, 0, 0, 2288, 2291, 5, 618, 0, 0, 2289, 2292, 3, 596, 298, 0,
		2290, 2292, 1, 0, 0, 0, 2291, 2289, 1, 0, 0, 0, 2291, 2290, 1, 0, 0, 0,
		2292, 2293, 1, 0, 0, 0, 2293, 2294, 3, 626, 313, 0, 2294, 2295, 3, 264,
		132, 0, 2295, 2296, 3, 262, 131, 0, 2296, 261, 1, 0, 0, 0, 2297, 2299,
		3, 266, 133, 0, 2298, 2297, 1, 0, 0, 0, 2298, 2299, 1, 0, 0, 0, 2299, 2301,
		1, 0, 0, 0, 2300, 2302, 3, 268, 134, 0, 2301, 2300, 1, 0, 0, 0, 2301, 2302,
		1, 0, 0, 0, 2302, 2306, 1, 0, 0, 0, 2303, 2305, 3, 270, 135, 0, 2304, 2303,
		1, 0, 0, 0, 2305, 2308, 1, 0, 0, 0, 2306, 2304, 1, 0, 0, 0, 2306, 2307,
		1, 0, 0, 0, 2307, 2313, 1, 0, 0, 0, 2308, 2306, 1, 0, 0, 0, 2309, 2310,
		5, 75, 0, 0, 2310, 2314, 3, 770, 385, 0, 2311, 2312, 5, 798, 0, 0, 2312,
		2314, 3, 770, 385, 0, 2313, 2309, 1, 0, 0, 0, 2313, 2311, 1, 0, 0, 0, 2313,
		2314, 1, 0, 0, 0, 2314, 2317, 1, 0, 0, 0, 2315, 2317, 1, 0, 0, 0, 2316,
		2298, 1, 0, 0, 0, 2316, 2315, 1, 0, 0, 0, 2317, 263, 1, 0, 0, 0, 2318,
		2319, 5, 128, 0, 0, 2319, 2320, 5, 659, 0, 0, 2320, 2322, 3, 310, 155,
		0, 2321, 2318, 1, 0, 0, 0, 2321, 2322, 1, 0, 0, 0, 2322, 2325, 1, 0, 0,
		0, 2323, 2325, 1, 0, 0, 0, 2324, 2321, 1, 0, 0, 0, 2324, 2323, 1, 0, 0,
		0, 2325, 265, 1, 0, 0, 0, 2326, 2329, 5, 467, 0, 0, 2327, 2330, 3, 302,
		151, 0, 2328, 2330, 7, 25, 0, 0, 2329, 2327, 1, 0, 0, 0, 2329, 2328, 1,
		0, 0, 0, 2330, 267, 1, 0, 0, 0, 2331, 2340, 5, 645, 0, 0, 2332, 2333, 5,
		322, 0, 0, 2333, 2341, 3, 756, 378, 0, 2334, 2335, 5, 327, 0, 0, 2335,
		2341, 3, 756, 378, 0, 2336, 2337, 5, 321, 0, 0, 2337, 2341, 3, 756, 378,
		0, 2338, 2339, 5, 328, 0, 0, 2339, 2341, 3, 756, 378, 0, 2340, 2332, 1,
		0, 0, 0, 2340, 2334, 1, 0, 0, 0, 2340, 2336, 1, 0, 0, 0, 2340, 2338, 1,
		0, 0, 0, 2341, 2342, 1, 0, 0, 0, 2342, 2340, 1, 0, 0, 0, 2342, 2343, 1,
		0, 0, 0, 2343, 269, 1, 0, 0, 0, 2344, 2345, 5, 2, 0, 0, 2345, 2377, 7,
		26, 0, 0, 2346, 2374, 5, 406, 0, 0, 2347, 2354, 5, 177, 0, 0, 2348, 2349,
		5, 247, 0, 0, 2349, 2350, 3, 758, 379, 0, 2350, 2351, 5, 122, 0, 0, 2351,
		2355, 1, 0, 0, 0, 2352, 2355, 5, 365, 0, 0, 2353, 2355, 5, 128, 0, 0, 2354,
		2348, 1, 0, 0, 0, 2354, 2352, 1, 0, 0, 0, 2354, 2353, 1, 0, 0, 0, 2354,
		2355, 1, 0, 0, 0, 2355, 2375, 1, 0, 0, 0, 2356, 2359, 5, 705, 0, 0, 2357,
		2360, 3, 758, 379, 0, 2358, 2360, 5, 128, 0, 0, 2359, 2357, 1, 0, 0, 0,
		2359, 2358, 1, 0, 0, 0, 2360, 2375, 1, 0, 0, 0, 2361, 2362, 5, 706, 0,
		0, 2362, 2367, 5, 247, 0, 0, 2363, 2364, 3, 758, 379, 0, 2364, 2365, 5,
		122, 0, 0, 2365, 2368, 1, 0, 0, 0, 2366, 2368, 5, 128, 0, 0, 2367, 2363,
		1, 0, 0, 0, 2367, 2366, 1, 0, 0, 0, 2368, 2375, 1, 0, 0, 0, 2369, 2370,
		5, 467, 0, 0, 2370, 2372, 5, 101, 0, 0, 2371, 2373, 7, 27, 0, 0, 2372,
		2371, 1, 0, 0, 0, 2372, 2373, 1, 0, 0, 0, 2373, 2375, 1, 0, 0, 0, 2374,
		2347, 1, 0, 0, 0, 2374, 2356, 1, 0, 0, 0, 2374, 2361, 1, 0, 0, 0, 2374,
		2369, 1, 0, 0, 0, 2375, 2377, 1, 0, 0, 0, 2376, 2344, 1, 0, 0, 0, 2376,
		2346, 1, 0, 0, 0, 2377, 271, 1, 0, 0, 0, 2378, 2379, 5, 148, 0, 0, 2379,
		2381, 5, 618, 0, 0, 2380, 2382, 3, 594, 297, 0, 2381, 2380, 1, 0, 0, 0,
		2381, 2382, 1, 0, 0, 0, 2382, 2383, 1, 0, 0, 0, 2383, 2384, 3, 624, 312,
		0, 2384, 273, 1, 0, 0, 0, 2385, 2427, 5, 215, 0, 0, 2386, 2387, 3, 296,
		148, 0, 2387, 2388, 5, 590, 0, 0, 2388, 2392, 3, 624, 312, 0, 2389, 2390,
		5, 645, 0, 0, 2390, 2391, 5, 660, 0, 0, 2391, 2393, 5, 391, 0, 0, 2392,
		2389, 1, 0, 0, 0, 2392, 2393, 1, 0, 0, 0, 2393, 2428, 1, 0, 0, 0, 2394,
		2400, 3, 296, 148, 0, 2395, 2397, 5, 10, 0, 0, 2396, 2398, 5, 421, 0, 0,
		2397, 2396, 1, 0, 0, 0, 2397, 2398, 1, 0, 0, 0, 2398, 2400, 1, 0, 0, 0,
		2399, 2394, 1, 0, 0, 0, 2399, 2395, 1, 0, 0, 0, 2400, 2401, 1, 0, 0, 0,
		2401, 2403, 5, 383, 0, 0, 2402, 2404, 3, 294, 147, 0, 2403, 2402, 1, 0,
		0, 0, 2403, 2404, 1, 0, 0, 0, 2404, 2405, 1, 0, 0, 0, 2405, 2406, 3, 300,
		150, 0, 2406, 2407, 5, 590, 0, 0, 2407, 2409, 3, 276, 138, 0, 2408, 2410,
		3, 286, 143, 0, 2409, 2408, 1, 0, 0, 0, 2409, 2410, 1, 0, 0, 0, 2410, 2412,
		1, 0, 0, 0, 2411, 2413, 3, 278, 139, 0, 2412, 2411, 1, 0, 0, 0, 2412, 2413,
		1, 0, 0, 0, 2413, 2415, 1, 0, 0, 0, 2414, 2416, 3, 284, 142, 0, 2415, 2414,
		1, 0, 0, 0, 2415, 2416, 1, 0, 0, 0, 2416, 2428, 1, 0, 0, 0, 2417, 2418,
		5, 427, 0, 0, 2418, 2419, 5, 383, 0, 0, 2419, 2420, 3, 642, 321, 0, 2420,
		2421, 5, 590, 0, 0, 2421, 2425, 3, 276, 138, 0, 2422, 2423, 5, 645, 0,
		0, 2423, 2424, 5, 215, 0, 0, 2424, 2426, 5, 391, 0, 0, 2425, 2422, 1, 0,
		0, 0, 2425, 2426, 1, 0, 0, 0, 2426, 2428, 1, 0, 0, 0, 2427, 2386, 1, 0,
		0, 0, 2427, 2399, 1, 0, 0, 0, 2427, 2417, 1, 0, 0, 0, 2428, 275, 1, 0,
		0, 0, 2429, 2432, 3, 626, 313, 0, 2430, 2432, 3, 624, 312, 0, 2431, 2429,
		1, 0, 0, 0, 2431, 2430, 1, 0, 0, 0, 2432, 277, 1, 0, 0, 0, 2433, 2435,
		5, 645, 0, 0, 2434, 2436, 3, 306, 153, 0, 2435, 2434, 1, 0, 0, 0, 2436,
		2437, 1, 0, 0, 0, 2437, 2435, 1, 0, 0, 0, 2437, 2438, 1, 0, 0, 0, 2438,
		2443, 1, 0, 0, 0, 2439, 2440, 5, 645, 0, 0, 2440, 2441, 5, 215, 0, 0, 2441,
		2443, 5, 391, 0, 0, 2442, 2433, 1, 0, 0, 0, 2442, 2439, 1, 0, 0, 0, 2443,
		279, 1, 0, 0, 0, 2444, 2445, 5, 663, 0, 0, 2445, 2446, 3, 310, 155, 0,
		2446, 281, 1, 0, 0, 0, 2447, 2448, 5, 645, 0, 0, 2448, 2456, 5, 659, 0,
		0, 2449, 2457, 3, 310, 155, 0, 2450, 2452, 5, 10, 0, 0, 2451, 2453, 3,
		280, 140, 0, 2452, 2451, 1, 0, 0, 0, 2452, 2453, 1, 0, 0, 0, 2453, 2457,
		1, 0, 0, 0, 2454, 2457, 5, 369, 0, 0, 2455, 2457, 5, 128, 0, 0, 2456, 2449,
		1, 0, 0, 0, 2456, 2450, 1, 0, 0, 0, 2456, 2454, 1, 0, 0, 0, 2456, 2455,
		1, 0, 0, 0, 2457, 283, 1, 0, 0, 0, 2458, 2459, 5, 17, 0, 0, 2459, 2461,
		3, 642, 321, 0, 2460, 2462, 3, 282, 141, 0, 2461, 2460, 1, 0, 0, 0, 2461,
		2462, 1, 0, 0, 0, 2462, 285, 1, 0, 0, 0, 2463, 2464, 3, 266, 133, 0, 2464,
		287, 1, 0, 0, 0, 2465, 2466, 5, 453, 0, 0, 2466, 2467, 5, 618, 0, 0, 2467,
		2468, 3, 642, 321, 0, 2468, 2469, 5, 590, 0, 0, 2469, 2477, 3, 642, 321,
		0, 2470, 2471, 5, 773, 0, 0, 2471, 2472, 3, 642, 321, 0, 2472, 2473, 5,
		590, 0, 0, 2473, 2474, 3, 642, 321, 0, 2474, 2476, 1, 0, 0, 0, 2475, 2470,
		1, 0, 0, 0, 2476, 2479, 1, 0, 0, 0, 2477, 2475, 1, 0, 0, 0, 2477, 2478,
		1, 0, 0, 0, 2478, 289, 1, 0, 0, 0, 2479, 2477, 1, 0, 0, 0, 2480, 2512,
		5, 477, 0, 0, 2481, 2482, 3, 296, 148, 0, 2482, 2483, 5, 203, 0, 0, 2483,
		2484, 3, 624, 312, 0, 2484, 2513, 1, 0, 0, 0, 2485, 2486, 3, 296, 148,
		0, 2486, 2487, 3, 292, 146, 0, 2487, 2488, 5, 203, 0, 0, 2488, 2489, 3,
		624, 312, 0, 2489, 2513, 1, 0, 0, 0, 2490, 2492, 5, 10, 0, 0, 2491, 2493,
		5, 421, 0, 0, 2492, 2491, 1, 0, 0, 0, 2492, 2493, 1, 0, 0, 0, 2493, 2504,
		1, 0, 0, 0, 2494, 2496, 5, 383, 0, 0, 2495, 2497, 3, 294, 147, 0, 2496,
		2495, 1, 0, 0, 0, 2496, 2497, 1, 0, 0, 0, 2497, 2498, 1, 0, 0, 0, 2498,
		2505, 3, 300, 150, 0, 2499, 2500, 5, 773, 0, 0, 2500, 2501, 5, 215, 0,
		0, 2501, 2502, 5, 391, 0, 0, 2502, 2503, 5, 203, 0, 0, 2503, 2505, 3, 624,
		312, 0, 2504, 2494, 1, 0, 0, 0, 2504, 2499, 1, 0, 0, 0, 2505, 2513, 1,
		0, 0, 0, 2506, 2507, 5, 427, 0, 0, 2507, 2508, 5, 383, 0, 0, 2508, 2509,
		3, 642, 321, 0, 2509, 2510, 5, 203, 0, 0, 2510, 2511, 3, 624, 312, 0, 2511,
		2513, 1, 0, 0, 0, 2512, 2481, 1, 0, 0, 0, 2512, 2485, 1, 0, 0, 0, 2512,
		2490, 1, 0, 0, 0, 2512, 2506, 1, 0, 0, 0, 2513, 291, 1, 0, 0, 0, 2514,
		2516, 5, 383, 0, 0, 2515, 2517, 3, 294, 147, 0, 2516, 2515, 1, 0, 0, 0,
		2516, 2517, 1, 0, 0, 0, 2517, 2518, 1, 0, 0, 0, 2518, 2527, 3, 300, 150,
		0, 2519, 2521, 5, 383, 0, 0, 2520, 2522, 3, 294, 147, 0, 2521, 2520, 1,
		0, 0, 0, 2521, 2522, 1, 0, 0, 0, 2522, 2523, 1, 0, 0, 0, 2523, 2525, 3,
		300, 150, 0, 2524, 2519, 1, 0, 0, 0, 2524, 2525, 1, 0, 0, 0, 2525, 2527,
		1, 0, 0, 0, 2526, 2514, 1, 0, 0, 0, 2526, 2524, 1, 0, 0, 0, 2527, 293,
		1, 0, 0, 0, 2528, 2529, 7, 28, 0, 0, 2529, 295, 1, 0, 0, 0, 2530, 2535,
		3, 298, 149, 0, 2531, 2532, 5, 773, 0, 0, 2532, 2534, 3, 298, 149, 0, 2533,
		2531, 1, 0, 0, 0, 2534, 2537, 1, 0, 0, 0, 2535, 2533, 1, 0, 0, 0, 2535,
		2536, 1, 0, 0, 0, 2536, 297, 1, 0, 0, 0, 2537, 2535, 1, 0, 0, 0, 2538,
		2540, 3, 800, 400, 0, 2539, 2541, 3, 660, 330, 0, 2540, 2539, 1, 0, 0,
		0, 2540, 2541, 1, 0, 0, 0, 2541, 2549, 1, 0, 0, 0, 2542, 2546, 3, 800,
		400, 0, 2543, 2547, 5, 784, 0, 0, 2544, 2545, 5, 783, 0, 0, 2545, 2547,
		3, 796, 398, 0, 2546, 2543, 1, 0, 0, 0, 2546, 2544, 1, 0, 0, 0, 2547, 2549,
		1, 0, 0, 0, 2548, 2538, 1, 0, 0, 0, 2548, 2542, 1, 0, 0, 0, 2549, 2586,
		1, 0, 0, 0, 2550, 2552, 7, 29, 0, 0, 2551, 2553, 3, 660, 330, 0, 2552,
		2551, 1, 0, 0, 0, 2552, 2553, 1, 0, 0, 0, 2553, 2586, 1, 0, 0, 0, 2554,
		2586, 7, 30, 0, 0, 2555, 2556, 5, 215, 0, 0, 2556, 2586, 5, 391, 0, 0,
		2557, 2558, 5, 509, 0, 0, 2558, 2586, 5, 110, 0, 0, 2559, 2563, 5, 97,
		0, 0, 2560, 2561, 5, 577, 0, 0, 2561, 2564, 5, 571, 0, 0, 2562, 2564, 7,
		31, 0, 0, 2563, 2560, 1, 0, 0, 0, 2563, 2562, 1, 0, 0, 0, 2563, 2564, 1,
		0, 0, 0, 2564, 2586, 1, 0, 0, 0, 2565, 2566, 5, 287, 0, 0, 2566, 2586,
		5, 571, 0, 0, 2567, 2568, 5, 459, 0, 0, 2568, 2586, 7, 32, 0, 0, 2569,
		2570, 5, 509, 0, 0, 2570, 2586, 5, 636, 0, 0, 2571, 2573, 5, 11, 0, 0,
		2572, 2574, 5, 483, 0, 0, 2573, 2572, 1, 0, 0, 0, 2573, 2574, 1, 0, 0,
		0, 2574, 2586, 1, 0, 0, 0, 2575, 2576, 7, 33, 0, 0, 2576, 2586, 5, 659,
		0, 0, 2577, 2578, 5, 281, 0, 0, 2578, 2579, 5, 203, 0, 0, 2579, 2586, 5,
		795, 0, 0, 2580, 2581, 5, 497, 0, 0, 2581, 2582, 5, 248, 0, 0, 2582, 2586,
		5, 795, 0, 0, 2583, 2584, 5, 796, 0, 0, 2584, 2586, 5, 797, 0, 0, 2585,
		2548, 1, 0, 0, 0, 2585, 2550, 1, 0, 0, 0, 2585, 2554, 1, 0, 0, 0, 2585,
		2555, 1, 0, 0, 0, 2585, 2557, 1, 0, 0, 0, 2585, 2559, 1, 0, 0, 0, 2585,
		2565, 1, 0, 0, 0, 2585, 2567, 1, 0, 0, 0, 2585, 2569, 1, 0, 0, 0, 2585,
		2571, 1, 0, 0, 0, 2585, 2575, 1, 0, 0, 0, 2585, 2577, 1, 0, 0, 0, 2585,
		2580, 1, 0, 0, 0, 2585, 2583, 1, 0, 0, 0, 2586, 299, 1, 0, 0, 0, 2587,
		2590, 5, 760, 0, 0, 2588, 2589, 5, 772, 0, 0, 2589, 2591, 5, 760, 0, 0,
		2590, 2588, 1, 0, 0, 0, 2590, 2591, 1, 0, 0, 0, 2591, 2603, 1, 0, 0, 0,
		2592, 2595, 3, 674, 337, 0, 2593, 2594, 5, 772, 0, 0, 2594, 2596, 5, 760,
		0, 0, 2595, 2593, 1, 0, 0, 0, 2595, 2596, 1, 0, 0, 0, 2596, 2603, 1, 0,
		0, 0, 2597, 2603, 3, 718, 359, 0, 2598, 2599, 3, 674, 337, 0, 2599, 2600,
		5, 772, 0, 0, 2600, 2601, 3, 718, 359, 0, 2601, 2603, 1, 0, 0, 0, 2602,
		2587, 1, 0, 0, 0, 2602, 2592, 1, 0, 0, 0, 2602, 2597, 1, 0, 0, 0, 2602,
		2598, 1, 0, 0, 0, 2603, 301, 1, 0, 0, 0, 2604, 2611, 3, 304, 152, 0, 2605,
		2607, 5, 15, 0, 0, 2606, 2605, 1, 0, 0, 0, 2606, 2607, 1, 0, 0, 0, 2607,
		2608, 1, 0, 0, 0, 2608, 2610, 3, 304, 152, 0, 2609, 2606, 1, 0, 0, 0, 2610,
		2613, 1, 0, 0, 0, 2611, 2609, 1, 0, 0, 0, 2611, 2612, 1, 0, 0, 0, 2612,
		303, 1, 0, 0, 0, 2613, 2611, 1, 0, 0, 0, 2614, 2615, 5, 63, 0, 0, 2615,
		2621, 3, 772, 386, 0, 2616, 2617, 5, 259, 0, 0, 2617, 2621, 3, 772, 386,
		0, 2618, 2619, 5, 559, 0, 0, 2619, 2621, 3, 772, 386, 0, 2620, 2614, 1,
		0, 0, 0, 2620, 2616, 1, 0, 0, 0, 2620, 2618, 1, 0, 0, 0, 2621, 305, 1,
		0, 0, 0, 2622, 2623, 5, 215, 0, 0, 2623, 2633, 5, 391, 0, 0, 2624, 2625,
		5, 322, 0, 0, 2625, 2633, 3, 756, 378, 0, 2626, 2627, 5, 327, 0, 0, 2627,
		2633, 3, 756, 378, 0, 2628, 2629, 5, 321, 0, 0, 2629, 2633, 3, 756, 378,
		0, 2630, 2631, 5, 328, 0, 0, 2631, 2633, 3, 756, 378, 0, 2632, 2622, 1,
		0, 0, 0, 2632, 2624, 1, 0, 0, 0, 2632, 2626, 1, 0, 0, 0, 2632, 2628, 1,
		0, 0, 0, 2632, 2630, 1, 0, 0, 0, 2633, 307, 1, 0, 0, 0, 2634, 2635, 5,
		506, 0, 0, 2635, 2636, 5, 659, 0, 0, 2636, 2658, 3, 310, 155, 0, 2637,
		2638, 5, 506, 0, 0, 2638, 2639, 5, 659, 0, 0, 2639, 2658, 7, 34, 0, 0,
		2640, 2641, 5, 506, 0, 0, 2641, 2642, 5, 128, 0, 0, 2642, 2646, 5, 659,
		0, 0, 2643, 2647, 3, 310, 155, 0, 2644, 2647, 5, 369, 0, 0, 2645, 2647,
		5, 10, 0, 0, 2646, 2643, 1, 0, 0, 0, 2646, 2644, 1, 0, 0, 0, 2646, 2645,
		1, 0, 0, 0, 2647, 2648, 1, 0, 0, 0, 2648, 2649, 5, 590, 0, 0, 2649, 2658,
		3, 310, 155, 0, 2650, 2651, 5, 506, 0, 0, 2651, 2652, 5, 659, 0, 0, 2652,
		2655, 5, 10, 0, 0, 2653, 2654, 5, 663, 0, 0, 2654, 2656, 3, 310, 155, 0,
		2655, 2653, 1, 0, 0, 0, 2655, 2656, 1, 0, 0, 0, 2656, 2658, 1, 0, 0, 0,
		2657, 2634, 1, 0, 0, 0, 2657, 2637, 1, 0, 0, 0, 2657, 2640, 1, 0, 0, 0,
		2657, 2650, 1, 0, 0, 0, 2658, 309, 1, 0, 0, 0, 2659, 2664, 3, 312, 156,
		0, 2660, 2661, 5, 773, 0, 0, 2661, 2663, 3, 312, 156, 0, 2662, 2660, 1,
		0, 0, 0, 2663, 2666, 1, 0, 0, 0, 2664, 2662, 1, 0, 0, 0, 2664, 2665, 1,
		0, 0, 0, 2665, 311, 1, 0, 0, 0, 2666, 2664, 1, 0, 0, 0, 2667, 2671, 3,
		800, 400, 0, 2668, 2669, 5, 783, 0, 0, 2669, 2672, 3, 796, 398, 0, 2670,
		2672, 5, 784, 0, 0, 2671, 2668, 1, 0, 0, 0, 2671, 2670, 1, 0, 0, 0, 2671,
		2672, 1, 0, 0, 0, 2672, 313, 1, 0, 0, 0, 2673, 2675, 5, 14, 0, 0, 2674,
		2676, 3, 650, 325, 0, 2675, 2674, 1, 0, 0, 0, 2675, 2676, 1, 0, 0, 0, 2676,
		2677, 1, 0, 0, 0, 2677, 2678, 5, 574, 0, 0, 2678, 2680, 3, 720, 360, 0,
		2679, 2681, 3, 316, 158, 0, 2680, 2679, 1, 0, 0, 0, 2680, 2681, 1, 0, 0,
		0, 2681, 2716, 1, 0, 0, 0, 2682, 2683, 5, 62, 0, 0, 2683, 2684, 5, 574,
		0, 0, 2684, 2688, 3, 720, 360, 0, 2685, 2687, 3, 318, 159, 0, 2686, 2685,
		1, 0, 0, 0, 2687, 2690, 1, 0, 0, 0, 2688, 2686, 1, 0, 0, 0, 2688, 2689,
		1, 0, 0, 0, 2689, 2716, 1, 0, 0, 0, 2690, 2688, 1, 0, 0, 0, 2691, 2692,
		5, 61, 0, 0, 2692, 2693, 5, 574, 0, 0, 2693, 2695, 3, 720, 360, 0, 2694,
		2696, 7, 35, 0, 0, 2695, 2694, 1, 0, 0, 0, 2695, 2696, 1, 0, 0, 0, 2696,
		2716, 1, 0, 0, 0, 2697, 2699, 5, 388, 0, 0, 2698, 2700, 3, 650, 325, 0,
		2699, 2698, 1, 0, 0, 0, 2699, 2700, 1, 0, 0, 0, 2700, 2701, 1, 0, 0, 0,
		2701, 2702, 5, 574, 0, 0, 2702, 2716, 3, 720, 360, 0, 2703, 2705, 5, 455,
		0, 0, 2704, 2706, 3, 650, 325, 0, 2705, 2704, 1, 0, 0, 0, 2705, 2706, 1,
		0, 0, 0, 2706, 2707, 1, 0, 0, 0, 2707, 2708, 5, 574, 0, 0, 2708, 2712,
		3, 720, 360, 0, 2709, 2711, 3, 320, 160, 0, 2710, 2709, 1, 0, 0, 0, 2711,
		2714, 1, 0, 0, 0, 2712, 2710, 1, 0, 0, 0, 2712, 2713, 1, 0, 0, 0, 2713,
		2716, 1, 0, 0, 0, 2714, 2712, 1, 0, 0, 0, 2715, 2673, 1, 0, 0, 0, 2715,
		2682, 1, 0, 0, 0, 2715, 2691, 1, 0, 0, 0, 2715, 2697, 1, 0, 0, 0, 2715,
		2703, 1, 0, 0, 0, 2716, 315, 1, 0, 0, 0, 2717, 2718, 5, 614, 0, 0, 2718,
		2719, 5, 674, 0, 0, 2719, 2720, 5, 383, 0, 0, 2720, 2724, 3, 746, 373,
		0, 2721, 2722, 5, 645, 0, 0, 2722, 2723, 5, 747, 0, 0, 2723, 2725, 5, 675,
		0, 0, 2724, 2721, 1, 0, 0, 0, 2724, 2725, 1, 0, 0, 0, 2725, 2731, 1, 0,
		0, 0, 2726, 2727, 5, 148, 0, 0, 2727, 2728, 5, 674, 0, 0, 2728, 2729, 5,
		383, 0, 0, 2729, 2731, 3, 746, 373, 0, 2730, 2717, 1, 0, 0, 0, 2730, 2726,
		1, 0, 0, 0, 2731, 317, 1, 0, 0, 0, 2732, 2733, 5, 200, 0, 0, 2733, 2736,
		5, 615, 0, 0, 2734, 2736, 7, 36, 0, 0, 2735, 2732, 1, 0, 0, 0, 2735, 2734,
		1, 0, 0, 0, 2736, 319, 1, 0, 0, 0, 2737, 2738, 7, 37, 0, 0, 2738, 321,
		1, 0, 0, 0, 2739, 2740, 5, 245, 0, 0, 2740, 2741, 5, 410, 0, 0, 2741, 2742,
		3, 744, 372, 0, 2742, 2743, 5, 520, 0, 0, 2743, 2744, 3, 770, 385, 0, 2744,
		2762, 1, 0, 0, 0, 2745, 2746, 5, 245, 0, 0, 2746, 2747, 5, 664, 0, 0, 2747,
		2762, 3, 780, 390, 0, 2748, 2749, 5, 607, 0, 0, 2749, 2750, 5, 410, 0,
		0, 2750, 2762, 3, 734, 367, 0, 2751, 2752, 5, 607, 0, 0, 2752, 2753, 5,
		664, 0, 0, 2753, 2758, 3, 736, 368, 0, 2754, 2755, 5, 773, 0, 0, 2755,
		2757, 3, 736, 368, 0, 2756, 2754, 1, 0, 0, 0, 2757, 2760, 1, 0, 0, 0, 2758,
		2756, 1, 0, 0, 0, 2758, 2759, 1, 0, 0, 0, 2759, 2762, 1, 0, 0, 0, 2760,
		2758, 1, 0, 0, 0, 2761, 2739, 1, 0, 0, 0, 2761, 2745, 1, 0, 0, 0, 2761,
		2748, 1, 0, 0, 0, 2761, 2751, 1, 0, 0, 0, 2762, 323, 1, 0, 0, 0, 2763,
		2764, 5, 506, 0, 0, 2764, 2765, 3, 326, 163, 0, 2765, 325, 1, 0, 0, 0,
		2766, 2767, 3, 336, 168, 0, 2767, 2768, 3, 334, 167, 0, 2768, 2820, 1,
		0, 0, 0, 2769, 2770, 5, 592, 0, 0, 2770, 2820, 3, 328, 164, 0, 2771, 2772,
		3, 808, 404, 0, 2772, 2773, 3, 342, 171, 0, 2773, 2820, 1, 0, 0, 0, 2774,
		2777, 5, 406, 0, 0, 2775, 2776, 5, 200, 0, 0, 2776, 2778, 3, 642, 321,
		0, 2777, 2775, 1, 0, 0, 0, 2777, 2778, 1, 0, 0, 0, 2778, 2779, 1, 0, 0,
		0, 2779, 2804, 3, 806, 403, 0, 2780, 2782, 3, 772, 386, 0, 2781, 2783,
		3, 638, 319, 0, 2782, 2781, 1, 0, 0, 0, 2782, 2783, 1, 0, 0, 0, 2783, 2785,
		1, 0, 0, 0, 2784, 2786, 3, 634, 317, 0, 2785, 2784, 1, 0, 0, 0, 2785, 2786,
		1, 0, 0, 0, 2786, 2805, 1, 0, 0, 0, 2787, 2789, 3, 772, 386, 0, 2788, 2790,
		3, 638, 319, 0, 2789, 2788, 1, 0, 0, 0, 2789, 2790, 1, 0, 0, 0, 2790, 2792,
		1, 0, 0, 0, 2791, 2793, 3, 634, 317, 0, 2792, 2791, 1, 0, 0, 0, 2792, 2793,
		1, 0, 0, 0, 2793, 2805, 1, 0, 0, 0, 2794, 2795, 5, 382, 0, 0, 2795, 2796,
		5, 776, 0, 0, 2796, 2797, 3, 772, 386, 0, 2797, 2798, 5, 777, 0, 0, 2798,
		2805, 1, 0, 0, 0, 2799, 2800, 5, 406, 0, 0, 2800, 2801, 5, 776, 0, 0, 2801,
		2802, 3, 772, 386, 0, 2802, 2803, 5, 777, 0, 0, 2803, 2805, 1, 0, 0, 0,
		2804, 2780, 1, 0, 0, 0, 2804, 2787, 1, 0, 0, 0, 2804, 2794, 1, 0, 0, 0,
		2804, 2799, 1, 0, 0, 0, 2805, 2820, 1, 0, 0, 0, 2806, 2809, 5, 406, 0,
		0, 2807, 2808, 5, 200, 0, 0, 2808, 2810, 3, 642, 321, 0, 2809, 2807, 1,
		0, 0, 0, 2809, 2810, 1, 0, 0, 0, 2810, 2811, 1, 0, 0, 0, 2811, 2812, 5,
		590, 0, 0, 2812, 2814, 5, 734, 0, 0, 2813, 2815, 3, 638, 319, 0, 2814,
		2813, 1, 0, 0, 0, 2814, 2815, 1, 0, 0, 0, 2815, 2817, 1, 0, 0, 0, 2816,
		2818, 3, 634, 317, 0, 2817, 2816, 1, 0, 0, 0, 2817, 2818, 1, 0, 0, 0, 2818,
		2820, 1, 0, 0, 0, 2819, 2766, 1, 0, 0, 0, 2819, 2769, 1, 0, 0, 0, 2819,
		2771, 1, 0, 0, 0, 2819, 2774, 1, 0, 0, 0, 2819, 2806, 1, 0, 0, 0, 2820,
		327, 1, 0, 0, 0, 2821, 2823, 3, 330, 165, 0, 2822, 2824, 3, 332, 166, 0,
		2823, 2822, 1, 0, 0, 0, 2823, 2824, 1, 0, 0, 0, 2824, 2831, 1, 0, 0, 0,
		2825, 2828, 3, 332, 166, 0, 2826, 2827, 5, 773, 0, 0, 2827, 2829, 3, 330,
		165, 0, 2828, 2826, 1, 0, 0, 0, 2828, 2829, 1, 0, 0, 0, 2829, 2831, 1,
		0, 0, 0, 2830, 2821, 1, 0, 0, 0, 2830, 2825, 1, 0, 0, 0, 2831, 329, 1,
		0, 0, 0, 2832, 2833, 5, 435, 0, 0, 2833, 2834, 7, 14, 0, 0, 2834, 331,
		1, 0, 0, 0, 2835, 2836, 5, 258, 0, 0, 2836, 2842, 5, 274, 0, 0, 2837, 2838,
		5, 456, 0, 0, 2838, 2843, 5, 435, 0, 0, 2839, 2840, 5, 435, 0, 0, 2840,
		2843, 7, 38, 0, 0, 2841, 2843, 5, 500, 0, 0, 2842, 2837, 1, 0, 0, 0, 2842,
		2839, 1, 0, 0, 0, 2842, 2841, 1, 0, 0, 0, 2843, 333, 1, 0, 0, 0, 2844,
		2845, 5, 773, 0, 0, 2845, 2847, 3, 338, 169, 0, 2846, 2844, 1, 0, 0, 0,
		2847, 2850, 1, 0, 0, 0, 2848, 2846, 1, 0, 0, 0, 2848, 2849, 1, 0, 0, 0,
		2849, 335, 1, 0, 0, 0, 2850, 2848, 1, 0, 0, 0, 2851, 2852, 3, 458, 229,
		0, 2852, 2853, 3, 806, 403, 0, 2853, 2854, 3, 346, 173, 0, 2854, 2876,
		1, 0, 0, 0, 2855, 2876, 3, 614, 307, 0, 2856, 2857, 3, 454, 227, 0, 2857,
		2858, 3, 806, 403, 0, 2858, 2859, 3, 380, 190, 0, 2859, 2876, 1, 0, 0,
		0, 2860, 2861, 3, 340, 170, 0, 2861, 2862, 3, 806, 403, 0, 2862, 2863,
		3, 346, 173, 0, 2863, 2876, 1, 0, 0, 0, 2864, 2873, 5, 356, 0, 0, 2865,
		2866, 3, 806, 403, 0, 2866, 2867, 3, 380, 190, 0, 2867, 2874, 1, 0, 0,
		0, 2868, 2870, 3, 552, 276, 0, 2869, 2871, 3, 602, 301, 0, 2870, 2869,
		1, 0, 0, 0, 2870, 2871, 1, 0, 0, 0, 2871, 2874, 1, 0, 0, 0, 2872, 2874,
		5, 128, 0, 0, 2873, 2865, 1, 0, 0, 0, 2873, 2868, 1, 0, 0, 0, 2873, 2872,
		1, 0, 0, 0, 2874, 2876, 1, 0, 0, 0, 2875, 2851, 1, 0, 0, 0, 2875, 2855,
		1, 0, 0, 0, 2875, 2856, 1, 0, 0, 0, 2875, 2860, 1, 0, 0, 0, 2875, 2864,
		1, 0, 0, 0, 2876, 337, 1, 0, 0, 0, 2877, 2878, 3, 808, 404, 0, 2878, 2879,
		3, 458, 229, 0, 2879, 2880, 3, 806, 403, 0, 2880, 2881, 3, 346, 173, 0,
		2881, 2884, 1, 0, 0, 0, 2882, 2884, 3, 336, 168, 0, 2883, 2877, 1, 0, 0,
		0, 2883, 2882, 1, 0, 0, 0, 2884, 339, 1, 0, 0, 0, 2885, 2887, 5, 785, 0,
		0, 2886, 2888, 3, 812, 406, 0, 2887, 2886, 1, 0, 0, 0, 2887, 2888, 1, 0,
		0, 0, 2888, 2889, 1, 0, 0, 0, 2889, 2890, 3, 458, 229, 0, 2890, 341, 1,
		0, 0, 0, 2891, 2892, 3, 344, 172, 0, 2892, 2893, 3, 334, 167, 0, 2893,
		2897, 1, 0, 0, 0, 2894, 2895, 5, 592, 0, 0, 2895, 2897, 3, 328, 164, 0,
		2896, 2891, 1, 0, 0, 0, 2896, 2894, 1, 0, 0, 0, 2897, 343, 1, 0, 0, 0,
		2898, 2899, 3, 458, 229, 0, 2899, 2900, 3, 806, 403, 0, 2900, 2901, 3,
		346, 173, 0, 2901, 345, 1, 0, 0, 0, 2902, 2906, 3, 380, 190, 0, 2903, 2906,
		7, 39, 0, 0, 2904, 2906, 7, 40, 0, 0, 2905, 2902, 1, 0, 0, 0, 2905, 2903,
		1, 0, 0, 0, 2905, 2904, 1, 0, 0, 0, 2906, 347, 1, 0, 0, 0, 2907, 3123,
		5, 509, 0, 0, 2908, 3124, 5, 22, 0, 0, 2909, 2911, 5, 110, 0, 0, 2910,
		2912, 3, 646, 323, 0, 2911, 2910, 1, 0, 0, 0, 2911, 2912, 1, 0, 0, 0, 2912,
		3124, 1, 0, 0, 0, 2913, 2915, 3, 350, 175, 0, 2914, 2913, 1, 0, 0, 0, 2914,
		2915, 1, 0, 0, 0, 2915, 2916, 1, 0, 0, 0, 2916, 2918, 5, 571, 0, 0, 2917,
		2919, 3, 356, 178, 0, 2918, 2917, 1, 0, 0, 0, 2918, 2919, 1, 0, 0, 0, 2919,
		2921, 1, 0, 0, 0, 2920, 2922, 3, 646, 323, 0, 2921, 2920, 1, 0, 0, 0, 2921,
		2922, 1, 0, 0, 0, 2922, 3124, 1, 0, 0, 0, 2923, 2925, 5, 204, 0, 0, 2924,
		2923, 1, 0, 0, 0, 2924, 2925, 1, 0, 0, 0, 2925, 2926, 1, 0, 0, 0, 2926,
		2928, 5, 593, 0, 0, 2927, 2929, 3, 356, 178, 0, 2928, 2927, 1, 0, 0, 0,
		2928, 2929, 1, 0, 0, 0, 2929, 2931, 1, 0, 0, 0, 2930, 2932, 3, 646, 323,
		0, 2931, 2930, 1, 0, 0, 0, 2931, 2932, 1, 0, 0, 0, 2932, 3124, 1, 0, 0,
		0, 2933, 2935, 5, 169, 0, 0, 2934, 2936, 3, 356, 178, 0, 2935, 2934, 1,
		0, 0, 0, 2935, 2936, 1, 0, 0, 0, 2936, 2938, 1, 0, 0, 0, 2937, 2939, 3,
		646, 323, 0, 2938, 2937, 1, 0, 0, 0, 2938, 2939, 1, 0, 0, 0, 2939, 3124,
		1, 0, 0, 0, 2940, 2941, 5, 574, 0, 0, 2941, 2943, 5, 547, 0, 0, 2942, 2944,
		3, 356, 178, 0, 2943, 2942, 1, 0, 0, 0, 2943, 2944, 1, 0, 0, 0, 2944, 2946,
		1, 0, 0, 0, 2945, 2947, 3, 646, 323, 0, 2946, 2945, 1, 0, 0, 0, 2946, 2947,
		1, 0, 0, 0, 2947, 3124, 1, 0, 0, 0, 2948, 2949, 5, 387, 0, 0, 2949, 2951,
		5, 571, 0, 0, 2950, 2952, 3, 356, 178, 0, 2951, 2950, 1, 0, 0, 0, 2951,
		2952, 1, 0, 0, 0, 2952, 2954, 1, 0, 0, 0, 2953, 2955, 3, 646, 323, 0, 2954,
		2953, 1, 0, 0, 0, 2954, 2955, 1, 0, 0, 0, 2955, 3124, 1, 0, 0, 0, 2956,
		3124, 5, 408, 0, 0, 2957, 2960, 5, 163, 0, 0, 2958, 2961, 3, 710, 355,
		0, 2959, 2961, 5, 10, 0, 0, 2960, 2958, 1, 0, 0, 0, 2960, 2959, 1, 0, 0,
		0, 2961, 2962, 1, 0, 0, 0, 2962, 3124, 7, 41, 0, 0, 2963, 2965, 3, 350,
		175, 0, 2964, 2963, 1, 0, 0, 0, 2964, 2965, 1, 0, 0, 0, 2965, 2966, 1,
		0, 0, 0, 2966, 2967, 5, 71, 0, 0, 2967, 2968, 7, 42, 0, 0, 2968, 2970,
		3, 718, 359, 0, 2969, 2971, 3, 356, 178, 0, 2970, 2969, 1, 0, 0, 0, 2970,
		2971, 1, 0, 0, 0, 2971, 2973, 1, 0, 0, 0, 2972, 2974, 3, 646, 323, 0, 2973,
		2972, 1, 0, 0, 0, 2973, 2974, 1, 0, 0, 0, 2974, 3124, 1, 0, 0, 0, 2975,
		2976, 7, 19, 0, 0, 2976, 3124, 5, 289, 0, 0, 2977, 2984, 5, 514, 0, 0,
		2978, 2985, 5, 225, 0, 0, 2979, 2980, 5, 547, 0, 0, 2980, 2982, 3, 352,
		176, 0, 2981, 2983, 3, 494, 247, 0, 2982, 2981, 1, 0, 0, 0, 2982, 2983,
		1, 0, 0, 0, 2983, 2985, 1, 0, 0, 0, 2984, 2978, 1, 0, 0, 0, 2984, 2979,
		1, 0, 0, 0, 2985, 3124, 1, 0, 0, 0, 2986, 2987, 7, 43, 0, 0, 2987, 2990,
		5, 169, 0, 0, 2988, 2989, 5, 251, 0, 0, 2989, 2991, 3, 772, 386, 0, 2990,
		2988, 1, 0, 0, 0, 2990, 2991, 1, 0, 0, 0, 2991, 2994, 1, 0, 0, 0, 2992,
		2993, 5, 203, 0, 0, 2993, 2995, 3, 760, 380, 0, 2994, 2992, 1, 0, 0, 0,
		2994, 2995, 1, 0, 0, 0, 2995, 2997, 1, 0, 0, 0, 2996, 2998, 3, 30, 15,
		0, 2997, 2996, 1, 0, 0, 0, 2997, 2998, 1, 0, 0, 0, 2998, 3000, 1, 0, 0,
		0, 2999, 3001, 3, 494, 247, 0, 3000, 2999, 1, 0, 0, 0, 3000, 3001, 1, 0,
		0, 0, 3001, 3124, 1, 0, 0, 0, 3002, 3004, 5, 180, 0, 0, 3003, 3002, 1,
		0, 0, 0, 3003, 3004, 1, 0, 0, 0, 3004, 3005, 1, 0, 0, 0, 3005, 3006, 7,
		44, 0, 0, 3006, 3007, 3, 354, 177, 0, 3007, 3009, 3, 718, 359, 0, 3008,
		3010, 3, 356, 178, 0, 3009, 3008, 1, 0, 0, 0, 3009, 3010, 1, 0, 0, 0, 3010,
		3012, 1, 0, 0, 0, 3011, 3013, 3, 106, 53, 0, 3012, 3011, 1, 0, 0, 0, 3012,
		3013, 1, 0, 0, 0, 3013, 3124, 1, 0, 0, 0, 3014, 3016, 5, 553, 0, 0, 3015,
		3014, 1, 0, 0, 0, 3015, 3016, 1, 0, 0, 0, 3016, 3017, 1, 0, 0, 0, 3017,
		3124, 5, 162, 0, 0, 3018, 3019, 5, 95, 0, 0, 3019, 3020, 5, 776, 0, 0,
		3020, 3021, 5, 760, 0, 0, 3021, 3022, 5, 777, 0, 0, 3022, 3124, 7, 45,
		0, 0, 3023, 3025, 5, 639, 0, 0, 3024, 3026, 3, 30, 15, 0, 3025, 3024, 1,
		0, 0, 0, 3025, 3026, 1, 0, 0, 0, 3026, 3124, 1, 0, 0, 0, 3027, 3029, 5,
		166, 0, 0, 3028, 3030, 3, 30, 15, 0, 3029, 3028, 1, 0, 0, 0, 3029, 3030,
		1, 0, 0, 0, 3030, 3124, 1, 0, 0, 0, 3031, 3124, 5, 426, 0, 0, 3032, 3041,
		5, 425, 0, 0, 3033, 3038, 3, 358, 179, 0, 3034, 3035, 5, 773, 0, 0, 3035,
		3037, 3, 358, 179, 0, 3036, 3034, 1, 0, 0, 0, 3037, 3040, 1, 0, 0, 0, 3038,
		3036, 1, 0, 0, 0, 3038, 3039, 1, 0, 0, 0, 3039, 3042, 1, 0, 0, 0, 3040,
		3038, 1, 0, 0, 0, 3041, 3033, 1, 0, 0, 0, 3041, 3042, 1, 0, 0, 0, 3042,
		3046, 1, 0, 0, 0, 3043, 3044, 5, 200, 0, 0, 3044, 3045, 5, 430, 0, 0, 3045,
		3047, 5, 747, 0, 0, 3046, 3043, 1, 0, 0, 0, 3046, 3047, 1, 0, 0, 0, 3047,
		3049, 1, 0, 0, 0, 3048, 3050, 3, 30, 15, 0, 3049, 3048, 1, 0, 0, 0, 3049,
		3050, 1, 0, 0, 0, 3050, 3124, 1, 0, 0, 0, 3051, 3053, 3, 808, 404, 0, 3052,
		3051, 1, 0, 0, 0, 3052, 3053, 1, 0, 0, 0, 3053, 3054, 1, 0, 0, 0, 3054,
		3056, 7, 46, 0, 0, 3055, 3057, 3, 646, 323, 0, 3056, 3055, 1, 0, 0, 0,
		3056, 3057, 1, 0, 0, 0, 3057, 3124, 1, 0, 0, 0, 3058, 3060, 5, 204, 0,
		0, 3059, 3058, 1, 0, 0, 0, 3059, 3060, 1, 0, 0, 0, 3060, 3061, 1, 0, 0,
		0, 3061, 3124, 5, 424, 0, 0, 3062, 3064, 3, 470, 235, 0, 3063, 3065, 3,
		646, 323, 0, 3064, 3063, 1, 0, 0, 0, 3064, 3065, 1, 0, 0, 0, 3065, 3124,
		1, 0, 0, 0, 3066, 3068, 5, 70, 0, 0, 3067, 3069, 3, 646, 323, 0, 3068,
		3067, 1, 0, 0, 0, 3068, 3069, 1, 0, 0, 0, 3069, 3124, 1, 0, 0, 0, 3070,
		3124, 5, 93, 0, 0, 3071, 3124, 5, 421, 0, 0, 3072, 3075, 5, 216, 0, 0,
		3073, 3074, 5, 200, 0, 0, 3074, 3076, 3, 642, 321, 0, 3075, 3073, 1, 0,
		0, 0, 3075, 3076, 1, 0, 0, 0, 3076, 3124, 1, 0, 0, 0, 3077, 3078, 5, 216,
		0, 0, 3078, 3079, 5, 200, 0, 0, 3079, 3080, 3, 642, 321, 0, 3080, 3081,
		5, 621, 0, 0, 3081, 3082, 3, 624, 312, 0, 3082, 3124, 1, 0, 0, 0, 3083,
		3084, 5, 316, 0, 0, 3084, 3124, 5, 547, 0, 0, 3085, 3105, 5, 97, 0, 0,
		3086, 3088, 5, 109, 0, 0, 3087, 3089, 3, 596, 298, 0, 3088, 3087, 1, 0,
		0, 0, 3088, 3089, 1, 0, 0, 0, 3089, 3090, 1, 0, 0, 0, 3090, 3106, 3, 674,
		337, 0, 3091, 3092, 5, 170, 0, 0, 3092, 3106, 3, 702, 351, 0, 3093, 3094,
		5, 206, 0, 0, 3094, 3106, 3, 682, 341, 0, 3095, 3096, 5, 422, 0, 0, 3096,
		3106, 3, 678, 339, 0, 3097, 3098, 5, 574, 0, 0, 3098, 3106, 3, 718, 359,
		0, 3099, 3100, 5, 594, 0, 0, 3100, 3106, 3, 686, 343, 0, 3101, 3102, 5,
		636, 0, 0, 3102, 3106, 3, 690, 345, 0, 3103, 3104, 5, 618, 0, 0, 3104,
		3106, 3, 642, 321, 0, 3105, 3086, 1, 0, 0, 0, 3105, 3091, 1, 0, 0, 0, 3105,
		3093, 1, 0, 0, 0, 3105, 3095, 1, 0, 0, 0, 3105, 3097, 1, 0, 0, 0, 3105,
		3099, 1, 0, 0, 0, 3105, 3101, 1, 0, 0, 0, 3105, 3103, 1, 0, 0, 0, 3106,
		3124, 1, 0, 0, 0, 3107, 3108, 5, 422, 0, 0, 3108, 3110, 5, 547, 0, 0, 3109,
		3111, 3, 646, 323, 0, 3110, 3109, 1, 0, 0, 0, 3110, 3111, 1, 0, 0, 0, 3111,
		3124, 1, 0, 0, 0, 3112, 3113, 5, 206, 0, 0, 3113, 3115, 5, 547, 0, 0, 3114,
		3116, 3, 646, 323, 0, 3115, 3114, 1, 0, 0, 0, 3115, 3116, 1, 0, 0, 0, 3116,
		3124, 1, 0, 0, 0, 3117, 3118, 5, 422, 0, 0, 3118, 3119, 5, 68, 0, 0, 3119,
		3124, 3, 678, 339, 0, 3120, 3121, 5, 206, 0, 0, 3121, 3122, 5, 68, 0, 0,
		3122, 3124, 3, 682, 341, 0, 3123, 2908, 1, 0, 0, 0, 3123, 2909, 1, 0, 0,
		0, 3123, 2914, 1, 0, 0, 0, 3123, 2924, 1, 0, 0, 0, 3123, 2933, 1, 0, 0,
		0, 3123, 2940, 1, 0, 0, 0, 3123, 2948, 1, 0, 0, 0, 3123, 2956, 1, 0, 0,
		0, 3123, 2957, 1, 0, 0, 0, 3123, 2964, 1, 0, 0, 0, 3123, 2975, 1, 0, 0,
		0, 3123, 2977, 1, 0, 0, 0, 3123, 2986, 1, 0, 0, 0, 3123, 3003, 1, 0, 0,
		0, 3123, 3015, 1, 0, 0, 0, 3123, 3018, 1, 0, 0, 0, 3123, 3023, 1, 0, 0,
		0, 3123, 3027, 1, 0, 0, 0, 3123, 3031, 1, 0, 0, 0, 3123, 3032, 1, 0, 0,
		0, 3123, 3052, 1, 0, 0, 0, 3123, 3059, 1, 0, 0, 0, 3123, 3062, 1, 0, 0,
		0, 3123, 3066, 1, 0, 0, 0, 3123, 3070, 1, 0, 0, 0, 3123, 3071, 1, 0, 0,
		0, 3123, 3072, 1, 0, 0, 0, 3123, 3077, 1, 0, 0, 0, 3123, 3083, 1, 0, 0,
		0, 3123, 3085, 1, 0, 0, 0, 3123, 3107, 1, 0, 0, 0, 3123, 3112, 1, 0, 0,
		0, 3123, 3117, 1, 0, 0, 0, 3123, 3120, 1, 0, 0, 0, 3124, 349, 1, 0, 0,
		0, 3125, 3131, 5, 204, 0, 0, 3126, 3128, 5, 180, 0, 0, 3127, 3129, 5, 204,
		0, 0, 3128, 3127, 1, 0, 0, 0, 3128, 3129, 1, 0, 0, 0, 3129, 3131, 1, 0,
		0, 0, 3130, 3125, 1, 0, 0, 0, 3130, 3126, 1, 0, 0, 0, 3131, 351, 1, 0,
		0, 0, 3132, 3134, 5, 370, 0, 0, 3133, 3132, 1, 0, 0, 0, 3133, 3134, 1,
		0, 0, 0, 3134, 3137, 1, 0, 0, 0, 3135, 3137, 1, 0, 0, 0, 3136, 3133, 1,
		0, 0, 0, 3136, 3135, 1, 0, 0, 0, 3137, 353, 1, 0, 0, 0, 3138, 3139, 7,
		42, 0, 0, 3139, 355, 1, 0, 0, 0, 3140, 3141, 3, 354, 177, 0, 3141, 3142,
		3, 744, 372, 0, 3142, 357, 1, 0, 0, 0, 3143, 3144, 5, 40, 0, 0, 3144, 3151,
		5, 255, 0, 0, 3145, 3146, 5, 91, 0, 0, 3146, 3151, 5, 568, 0, 0, 3147,
		3148, 5, 400, 0, 0, 3148, 3151, 5, 185, 0, 0, 3149, 3151, 7, 47, 0, 0,
		3150, 3143, 1, 0, 0, 0, 3150, 3145, 1, 0, 0, 0, 3150, 3147, 1, 0, 0, 0,
		3150, 3149, 1, 0, 0, 0, 3151, 359, 1, 0, 0, 0, 3152, 3157, 3, 362, 181,
		0, 3153, 3157, 3, 372, 186, 0, 3154, 3157, 3, 374, 187, 0, 3155, 3157,
		3, 378, 189, 0, 3156, 3152, 1, 0, 0, 0, 3156, 3153, 1, 0, 0, 0, 3156, 3154,
		1, 0, 0, 0, 3156, 3155, 1, 0, 0, 0, 3157, 361, 1, 0, 0, 0, 3158, 3159,
		5, 97, 0, 0, 3159, 3160, 5, 709, 0, 0, 3160, 3161, 5, 217, 0, 0, 3161,
		3162, 3, 744, 372, 0, 3162, 3164, 5, 599, 0, 0, 3163, 3165, 3, 806, 403,
		0, 3164, 3163, 1, 0, 0, 0, 3164, 3165, 1, 0, 0, 0, 3165, 3166, 1, 0, 0,
		0, 3166, 3168, 7, 48, 0, 0, 3167, 3169, 3, 364, 182, 0, 3168, 3167, 1,
		0, 0, 0, 3168, 3169, 1, 0, 0, 0, 3169, 3171, 1, 0, 0, 0, 3170, 3172, 3,
		368, 184, 0, 3171, 3170, 1, 0, 0, 0, 3171, 3172, 1, 0, 0, 0, 3172, 3174,
		1, 0, 0, 0, 3173, 3175, 3, 370, 185, 0, 3174, 3173, 1, 0, 0, 0, 3174, 3175,
		1, 0, 0, 0, 3175, 363, 1, 0, 0, 0, 3176, 3178, 5, 711, 0, 0, 3177, 3179,
		3, 806, 403, 0, 3178, 3177, 1, 0, 0, 0, 3178, 3179, 1, 0, 0, 0, 3179, 3180,
		1, 0, 0, 0, 3180, 3187, 3, 366, 183, 0, 3181, 3183, 5, 773, 0, 0, 3182,
		3181, 1, 0, 0, 0, 3182, 3183, 1, 0, 0, 0, 3183, 3184, 1, 0, 0, 0, 3184,
		3186, 3, 366, 183, 0, 3185, 3182, 1, 0, 0, 0, 3186, 3189, 1, 0, 0, 0, 3187,
		3185, 1, 0, 0, 0, 3187, 3188, 1, 0, 0, 0, 3188, 365, 1, 0, 0, 0, 3189,
		3187, 1, 0, 0, 0, 3190, 3193, 5, 747, 0, 0, 3191, 3192, 5, 759, 0, 0, 3192,
		3194, 5, 747, 0, 0, 3193, 3191, 1, 0, 0, 0, 3193, 3194, 1, 0, 0, 0, 3194,
		367, 1, 0, 0, 0, 3195, 3197, 5, 708, 0, 0, 3196, 3198, 3, 806, 403, 0,
		3197, 3196, 1, 0, 0, 0, 3197, 3198, 1, 0, 0, 0, 3198, 3199, 1, 0, 0, 0,
		3199, 3200, 5, 747, 0, 0, 3200, 369, 1, 0, 0, 0, 3201, 3202, 7, 49, 0,
		0, 3202, 371, 1, 0, 0, 0, 3203, 3204, 5, 11, 0, 0, 3204, 3205, 5, 709,
		0, 0, 3205, 3206, 5, 217, 0, 0, 3206, 3208, 3, 738, 369, 0, 3207, 3209,
		3, 364, 182, 0, 3208, 3207, 1, 0, 0, 0, 3208, 3209, 1, 0, 0, 0, 3209, 3211,
		1, 0, 0, 0, 3210, 3212, 3, 368, 184, 0, 3211, 3210, 1, 0, 0, 0, 3211, 3212,
		1, 0, 0, 0, 3212, 3214, 1, 0, 0, 0, 3213, 3215, 3, 370, 185, 0, 3214, 3213,
		1, 0, 0, 0, 3214, 3215, 1, 0, 0, 0, 3215, 3217, 1, 0, 0, 0, 3216, 3218,
		5, 198, 0, 0, 3217, 3216, 1, 0, 0, 0, 3217, 3218, 1, 0, 0, 0, 3218, 373,
		1, 0, 0, 0, 3219, 3220, 5, 506, 0, 0, 3220, 3221, 5, 709, 0, 0, 3221, 3222,
		5, 217, 0, 0, 3222, 3225, 3, 744, 372, 0, 3223, 3224, 5, 200, 0, 0, 3224,
		3226, 3, 376, 188, 0, 3225, 3223, 1, 0, 0, 0, 3225, 3226, 1, 0, 0, 0, 3226,
		375, 1, 0, 0, 0, 3227, 3234, 3, 758, 379, 0, 3228, 3230, 5, 773, 0, 0,
		3229, 3228, 1, 0, 0, 0, 3229, 3230, 1, 0, 0, 0, 3230, 3231, 1, 0, 0, 0,
		3231, 3233, 3, 758, 379, 0, 3232, 3229, 1, 0, 0, 0, 3233, 3236, 1, 0, 0,
		0, 3234, 3232, 1, 0, 0, 0, 3234, 3235, 1, 0, 0, 0, 3235, 377, 1, 0, 0,
		0, 3236, 3234, 1, 0, 0, 0, 3237, 3238, 5, 148, 0, 0, 3238, 3239, 5, 709,
		0, 0, 3239, 3240, 5, 217, 0, 0, 3240, 3242, 3, 738, 369, 0, 3241, 3243,
		5, 198, 0, 0, 3242, 3241, 1, 0, 0, 0, 3242, 3243, 1, 0, 0, 0, 3243, 379,
		1, 0, 0, 0, 3244, 3245, 6, 190, -1, 0, 3245, 3251, 3, 382, 191, 0, 3246,
		3248, 5, 257, 0, 0, 3247, 3249, 3, 472, 236, 0, 3248, 3247, 1, 0, 0, 0,
		3248, 3249, 1, 0, 0, 0, 3249, 3250, 1, 0, 0, 0, 3250, 3252, 7, 50, 0, 0,
		3251, 3246, 1, 0, 0, 0, 3251, 3252, 1, 0, 0, 0, 3252, 3256, 1, 0, 0, 0,
		3253, 3254, 5, 371, 0, 0, 3254, 3256, 3, 380, 190, 4, 3255, 3244, 1, 0,
		0, 0, 3255, 3253, 1, 0, 0, 0, 3256, 3268, 1, 0, 0, 0, 3257, 3258, 10, 3,
		0, 0, 3258, 3259, 7, 51, 0, 0, 3259, 3267, 3, 380, 190, 4, 3260, 3261,
		10, 2, 0, 0, 3261, 3262, 5, 654, 0, 0, 3262, 3267, 3, 380, 190, 3, 3263,
		3264, 10, 1, 0, 0, 3264, 3265, 7, 52, 0, 0, 3265, 3267, 3, 380, 190, 2,
		3266, 3257, 1, 0, 0, 0, 3266, 3260, 1, 0, 0, 0, 3266, 3263, 1, 0, 0, 0,
		3267, 3270, 1, 0, 0, 0, 3268, 3266, 1, 0, 0, 0, 3268, 3269, 1, 0, 0, 0,
		3269, 381, 1, 0, 0, 0, 3270, 3268, 1, 0, 0, 0, 3271, 3272, 6, 191, -1,
		0, 3272, 3273, 3, 386, 193, 0, 3273, 3291, 1, 0, 0, 0, 3274, 3275, 10,
		3, 0, 0, 3275, 3277, 5, 257, 0, 0, 3276, 3278, 3, 472, 236, 0, 3277, 3276,
		1, 0, 0, 0, 3277, 3278, 1, 0, 0, 0, 3278, 3279, 1, 0, 0, 0, 3279, 3290,
		5, 376, 0, 0, 3280, 3281, 10, 2, 0, 0, 3281, 3282, 3, 384, 192, 0, 3282,
		3283, 3, 386, 193, 0, 3283, 3290, 1, 0, 0, 0, 3284, 3285, 10, 1, 0, 0,
		3285, 3286, 3, 384, 192, 0, 3286, 3287, 7, 53, 0, 0, 3287, 3288, 3, 26,
		13, 0, 3288, 3290, 1, 0, 0, 0, 3289, 3274, 1, 0, 0, 0, 3289, 3280, 1, 0,
		0, 0, 3289, 3284, 1, 0, 0, 0, 3290, 3293, 1, 0, 0, 0, 3291, 3289, 1, 0,
		0, 0, 3291, 3292, 1, 0, 0, 0, 3292, 383, 1, 0, 0, 0, 3293, 3291, 1, 0,
		0, 0, 3294, 3295, 7, 54, 0, 0, 3295, 385, 1, 0, 0, 0, 3296, 3309, 3, 390,
		195, 0, 3297, 3299, 3, 472, 236, 0, 3298, 3297, 1, 0, 0, 0, 3298, 3299,
		1, 0, 0, 0, 3299, 3300, 1, 0, 0, 0, 3300, 3310, 3, 388, 194, 0, 3301, 3303,
		5, 733, 0, 0, 3302, 3304, 5, 668, 0, 0, 3303, 3302, 1, 0, 0, 0, 3303, 3304,
		1, 0, 0, 0, 3304, 3305, 1, 0, 0, 0, 3305, 3310, 3, 484, 242, 0, 3306, 3307,
		5, 521, 0, 0, 3307, 3308, 5, 275, 0, 0, 3308, 3310, 3, 390, 195, 0, 3309,
		3298, 1, 0, 0, 0, 3309, 3301, 1, 0, 0, 0, 3309, 3306, 1, 0, 0, 0, 3309,
		3310, 1, 0, 0, 0, 3310, 387, 1, 0, 0, 0, 3311, 3317, 5, 251, 0, 0, 3312,
		3318, 3, 26, 13, 0, 3313, 3314, 5, 776, 0, 0, 3314, 3315, 3, 468, 234,
		0, 3315, 3316, 5, 777, 0, 0, 3316, 3318, 1, 0, 0, 0, 3317, 3312, 1, 0,
		0, 0, 3317, 3313, 1, 0, 0, 0, 3318, 3333, 1, 0, 0, 0, 3319, 3320, 5, 30,
		0, 0, 3320, 3321, 3, 390, 195, 0, 3321, 3322, 5, 15, 0, 0, 3322, 3323,
		3, 386, 193, 0, 3323, 3333, 1, 0, 0, 0, 3324, 3325, 5, 275, 0, 0, 3325,
		3328, 3, 392, 196, 0, 3326, 3327, 5, 168, 0, 0, 3327, 3329, 3, 392, 196,
		0, 3328, 3326, 1, 0, 0, 0, 3328, 3329, 1, 0, 0, 0, 3329, 3333, 1, 0, 0,
		0, 3330, 3331, 5, 444, 0, 0, 3331, 3333, 3, 390, 195, 0, 3332, 3311, 1,
		0, 0, 0, 3332, 3319, 1, 0, 0, 0, 3332, 3324, 1, 0, 0, 0, 3332, 3330, 1,
		0, 0, 0, 3333, 389, 1, 0, 0, 0, 3334, 3335, 6, 195, -1, 0, 3335, 3336,
		3, 392, 196, 0, 3336, 3363, 1, 0, 0, 0, 3337, 3338, 10, 7, 0, 0, 3338,
		3339, 5, 769, 0, 0, 3339, 3362, 3, 390, 195, 8, 3340, 3341, 10, 6, 0, 0,
		3341, 3342, 7, 55, 0, 0, 3342, 3362, 3, 390, 195, 7, 3343, 3344, 10, 5,
		0, 0, 3344, 3345, 7, 56, 0, 0, 3345, 3362, 3, 390, 195, 6, 3346, 3347,
		10, 3, 0, 0, 3347, 3348, 7, 57, 0, 0, 3348, 3362, 3, 390, 195, 4, 3349,
		3350, 10, 2, 0, 0, 3350, 3351, 5, 768, 0, 0, 3351, 3362, 3, 390, 195, 3,
		3352, 3353, 10, 1, 0, 0, 3353, 3354, 5, 771, 0, 0, 3354, 3362, 3, 390,
		195, 2, 3355, 3356, 10, 4, 0, 0, 3356, 3357, 7, 56, 0, 0, 3357, 3358, 5,
		247, 0, 0, 3358, 3359, 3, 380, 190, 0, 3359, 3360, 3, 476, 238, 0, 3360,
		3362, 1, 0, 0, 0, 3361, 3337, 1, 0, 0, 0, 3361, 3340, 1, 0, 0, 0, 3361,
		3343, 1, 0, 0, 0, 3361, 3346, 1, 0, 0, 0, 3361, 3349, 1, 0, 0, 0, 3361,
		3352, 1, 0, 0, 0, 3361, 3355, 1, 0, 0, 0, 3362, 3365, 1, 0, 0, 0, 3363,
		3361, 1, 0, 0, 0, 3363, 3364, 1, 0, 0, 0, 3364, 391, 1, 0, 0, 0, 3365,
		3363, 1, 0, 0, 0, 3366, 3367, 6, 196, -1, 0, 3367, 3371, 3, 452, 226, 0,
		3368, 3369, 3, 806, 403, 0, 3369, 3370, 3, 380, 190, 0, 3370, 3372, 1,
		0, 0, 0, 3371, 3368, 1, 0, 0, 0, 3371, 3372, 1, 0, 0, 0, 3372, 3475, 1,
		0, 0, 0, 3373, 3375, 3, 662, 331, 0, 3374, 3376, 3, 396, 198, 0, 3375,
		3374, 1, 0, 0, 0, 3375, 3376, 1, 0, 0, 0, 3376, 3475, 1, 0, 0, 0, 3377,
		3475, 3, 420, 210, 0, 3378, 3475, 3, 438, 219, 0, 3379, 3475, 3, 764, 382,
		0, 3380, 3475, 5, 787, 0, 0, 3381, 3475, 3, 398, 199, 0, 3382, 3475, 3,
		400, 200, 0, 3383, 3475, 3, 402, 201, 0, 3384, 3385, 7, 58, 0, 0, 3385,
		3475, 3, 392, 196, 15, 3386, 3387, 3, 474, 237, 0, 3387, 3388, 3, 392,
		196, 14, 3388, 3475, 1, 0, 0, 0, 3389, 3391, 5, 487, 0, 0, 3390, 3389,
		1, 0, 0, 0, 3390, 3391, 1, 0, 0, 0, 3391, 3392, 1, 0, 0, 0, 3392, 3393,
		5, 776, 0, 0, 3393, 3394, 3, 468, 234, 0, 3394, 3395, 5, 777, 0, 0, 3395,
		3475, 1, 0, 0, 0, 3396, 3398, 5, 174, 0, 0, 3397, 3396, 1, 0, 0, 0, 3397,
		3398, 1, 0, 0, 0, 3398, 3399, 1, 0, 0, 0, 3399, 3475, 3, 26, 13, 0, 3400,
		3401, 5, 778, 0, 0, 3401, 3402, 3, 744, 372, 0, 3402, 3403, 3, 380, 190,
		0, 3403, 3404, 5, 779, 0, 0, 3404, 3475, 1, 0, 0, 0, 3405, 3406, 5, 320,
		0, 0, 3406, 3407, 3, 414, 207, 0, 3407, 3408, 5, 7, 0, 0, 3408, 3409, 5,
		776, 0, 0, 3409, 3411, 3, 390, 195, 0, 3410, 3412, 3, 418, 209, 0, 3411,
		3410, 1, 0, 0, 0, 3411, 3412, 1, 0, 0, 0, 3412, 3413, 1, 0, 0, 0, 3413,
		3414, 5, 777, 0, 0, 3414, 3475, 1, 0, 0, 0, 3415, 3416, 5, 32, 0, 0, 3416,
		3475, 3, 392, 196, 9, 3417, 3418, 5, 52, 0, 0, 3418, 3419, 5, 776, 0, 0,
		3419, 3420, 3, 380, 190, 0, 3420, 3421, 5, 17, 0, 0, 3421, 3423, 3, 466,
		233, 0, 3422, 3424, 3, 394, 197, 0, 3423, 3422, 1, 0, 0, 0, 3423, 3424,
		1, 0, 0, 0, 3424, 3425, 1, 0, 0, 0, 3425, 3426, 5, 777, 0, 0, 3426, 3475,
		1, 0, 0, 0, 3427, 3429, 5, 51, 0, 0, 3428, 3430, 3, 380, 190, 0, 3429,
		3428, 1, 0, 0, 0, 3429, 3430, 1, 0, 0, 0, 3430, 3434, 1, 0, 0, 0, 3431,
		3432, 3, 460, 230, 0, 3432, 3433, 3, 462, 231, 0, 3433, 3435, 1, 0, 0,
		0, 3434, 3431, 1, 0, 0, 0, 3435, 3436, 1, 0, 0, 0, 3436, 3434, 1, 0, 0,
		0, 3436, 3437, 1, 0, 0, 0, 3437, 3439, 1, 0, 0, 0, 3438, 3440, 3, 464,
		232, 0, 3439, 3438, 1, 0, 0, 0, 3439, 3440, 1, 0, 0, 0, 3440, 3441, 1,
		0, 0, 0, 3441, 3442, 5, 159, 0, 0, 3442, 3475, 1, 0, 0, 0, 3443, 3444,
		5, 94, 0, 0, 3444, 3445, 5, 776, 0, 0, 3445, 3446, 3, 380, 190, 0, 3446,
		3447, 5, 773, 0, 0, 3447, 3448, 3, 466, 233, 0, 3448, 3449, 5, 777, 0,
		0, 3449, 3475, 1, 0, 0, 0, 3450, 3451, 5, 94, 0, 0, 3451, 3452, 5, 776,
		0, 0, 3452, 3453, 3, 380, 190, 0, 3453, 3454, 5, 621, 0, 0, 3454, 3455,
		3, 552, 276, 0, 3455, 3456, 5, 777, 0, 0, 3456, 3475, 1, 0, 0, 0, 3457,
		3458, 5, 128, 0, 0, 3458, 3459, 5, 776, 0, 0, 3459, 3460, 3, 752, 376,
		0, 3460, 3461, 5, 777, 0, 0, 3461, 3475, 1, 0, 0, 0, 3462, 3463, 5, 626,
		0, 0, 3463, 3464, 5, 776, 0, 0, 3464, 3465, 3, 752, 376, 0, 3465, 3466,
		5, 777, 0, 0, 3466, 3475, 1, 0, 0, 0, 3467, 3468, 5, 247, 0, 0, 3468, 3469,
		3, 380, 190, 0, 3469, 3470, 3, 476, 238, 0, 3470, 3471, 5, 758, 0, 0, 3471,
		3472, 3, 380, 190, 0, 3472, 3475, 1, 0, 0, 0, 3473, 3475, 3, 440, 220,
		0, 3474, 3366, 1, 0, 0, 0, 3474, 3373, 1, 0, 0, 0, 3474, 3377, 1, 0, 0,
		0, 3474, 3378, 1, 0, 0, 0, 3474, 3379, 1, 0, 0, 0, 3474, 3380, 1, 0, 0,
		0, 3474, 3381, 1, 0, 0, 0, 3474, 3382, 1, 0, 0, 0, 3474, 3383, 1, 0, 0,
		0, 3474, 3384, 1, 0, 0, 0, 3474, 3386, 1, 0, 0, 0, 3474, 3390, 1, 0, 0,
		0, 3474, 3397, 1, 0, 0, 0, 3474, 3400, 1, 0, 0, 0, 3474, 3405, 1, 0, 0,
		0, 3474, 3415, 1, 0, 0, 0, 3474, 3417, 1, 0, 0, 0, 3474, 3427, 1, 0, 0,
		0, 3474, 3443, 1, 0, 0, 0, 3474, 3450, 1, 0, 0, 0, 3474, 3457, 1, 0, 0,
		0, 3474, 3462, 1, 0, 0, 0, 3474, 3467, 1, 0, 0, 0, 3474, 3473, 1, 0, 0,
		0, 3475, 3484, 1, 0, 0, 0, 3476, 3477, 10, 16, 0, 0, 3477, 3478, 5, 746,
		0, 0, 3478, 3483, 3, 392, 196, 17, 3479, 3480, 10, 22, 0, 0, 3480, 3481,
		5, 69, 0, 0, 3481, 3483, 3, 796, 398, 0, 3482, 3476, 1, 0, 0, 0, 3482,
		3479, 1, 0, 0, 0, 3483, 3486, 1, 0, 0, 0, 3484, 3482, 1, 0, 0, 0, 3484,
		3485, 1, 0, 0, 0, 3485, 393, 1, 0, 0, 0, 3486, 3484, 1, 0, 0, 0, 3487,
		3488, 5, 731, 0, 0, 3488, 395, 1, 0, 0, 0, 3489, 3490, 5, 781, 0, 0, 3490,
		3494, 3, 770, 385, 0, 3491, 3492, 5, 782, 0, 0, 3492, 3494, 3, 770, 385,
		0, 3493, 3489, 1, 0, 0, 0, 3493, 3491, 1, 0, 0, 0, 3494, 397, 1, 0, 0,
		0, 3495, 3496, 5, 26, 0, 0, 3496, 3498, 5, 776, 0, 0, 3497, 3499, 5, 143,
		0, 0, 3498, 3497, 1, 0, 0, 0, 3498, 3499, 1, 0, 0, 0, 3499, 3500, 1, 0,
		0, 0, 3500, 3501, 3, 412, 206, 0, 3501, 3503, 5, 777, 0, 0, 3502, 3504,
		3, 404, 202, 0, 3503, 3502, 1, 0, 0, 0, 3503, 3504, 1, 0, 0, 0, 3504, 3614,
		1, 0, 0, 0, 3505, 3506, 7, 59, 0, 0, 3506, 3507, 5, 776, 0, 0, 3507, 3508,
		3, 412, 206, 0, 3508, 3510, 5, 777, 0, 0, 3509, 3511, 3, 404, 202, 0, 3510,
		3509, 1, 0, 0, 0, 3510, 3511, 1, 0, 0, 0, 3511, 3614, 1, 0, 0, 0, 3512,
		3614, 3, 410, 205, 0, 3513, 3514, 5, 95, 0, 0, 3514, 3516, 5, 776, 0, 0,
		3515, 3517, 5, 10, 0, 0, 3516, 3515, 1, 0, 0, 0, 3516, 3517, 1, 0, 0, 0,
		3517, 3518, 1, 0, 0, 0, 3518, 3519, 5, 760, 0, 0, 3519, 3521, 5, 777, 0,
		0, 3520, 3522, 3, 404, 202, 0, 3521, 3520, 1, 0, 0, 0, 3521, 3522, 1, 0,
		0, 0, 3522, 3614, 1, 0, 0, 0, 3523, 3524, 5, 95, 0, 0, 3524, 3532, 5, 776,
		0, 0, 3525, 3527, 5, 10, 0, 0, 3526, 3525, 1, 0, 0, 0, 3526, 3527, 1, 0,
		0, 0, 3527, 3528, 1, 0, 0, 0, 3528, 3533, 5, 760, 0, 0, 3529, 3533, 3,
		412, 206, 0, 3530, 3531, 5, 143, 0, 0, 3531, 3533, 3, 468, 234, 0, 3532,
		3526, 1, 0, 0, 0, 3532, 3529, 1, 0, 0, 0, 3532, 3530, 1, 0, 0, 0, 3533,
		3534, 1, 0, 0, 0, 3534, 3536, 5, 777, 0, 0, 3535, 3537, 3, 404, 202, 0,
		3536, 3535, 1, 0, 0, 0, 3536, 3537, 1, 0, 0, 0, 3537, 3614, 1, 0, 0, 0,
		3538, 3539, 5, 345, 0, 0, 3539, 3541, 5, 776, 0, 0, 3540, 3542, 5, 143,
		0, 0, 3541, 3540, 1, 0, 0, 0, 3541, 3542, 1, 0, 0, 0, 3542, 3543, 1, 0,
		0, 0, 3543, 3544, 3, 412, 206, 0, 3544, 3546, 5, 777, 0, 0, 3545, 3547,
		3, 404, 202, 0, 3546, 3545, 1, 0, 0, 0, 3546, 3547, 1, 0, 0, 0, 3547, 3614,
		1, 0, 0, 0, 3548, 3549, 5, 326, 0, 0, 3549, 3551, 5, 776, 0, 0, 3550, 3552,
		5, 143, 0, 0, 3551, 3550, 1, 0, 0, 0, 3551, 3552, 1, 0, 0, 0, 3552, 3553,
		1, 0, 0, 0, 3553, 3554, 3, 412, 206, 0, 3554, 3556, 5, 777, 0, 0, 3555,
		3557, 3, 404, 202, 0, 3556, 3555, 1, 0, 0, 0, 3556, 3557, 1, 0, 0, 0, 3557,
		3614, 1, 0, 0, 0, 3558, 3559, 5, 551, 0, 0, 3559, 3560, 5, 776, 0, 0, 3560,
		3561, 3, 412, 206, 0, 3561, 3563, 5, 777, 0, 0, 3562, 3564, 3, 404, 202,
		0, 3563, 3562, 1, 0, 0, 0, 3563, 3564, 1, 0, 0, 0, 3564, 3614, 1, 0, 0,
		0, 3565, 3566, 5, 632, 0, 0, 3566, 3567, 5, 776, 0, 0, 3567, 3568, 3, 412,
		206, 0, 3568, 3570, 5, 777, 0, 0, 3569, 3571, 3, 404, 202, 0, 3570, 3569,
		1, 0, 0, 0, 3570, 3571, 1, 0, 0, 0, 3571, 3614, 1, 0, 0, 0, 3572, 3573,
		5, 548, 0, 0, 3573, 3574, 5, 776, 0, 0, 3574, 3575, 3, 412, 206, 0, 3575,
		3577, 5, 777, 0, 0, 3576, 3578, 3, 404, 202, 0, 3577, 3576, 1, 0, 0, 0,
		3577, 3578, 1, 0, 0, 0, 3578, 3614, 1, 0, 0, 0, 3579, 3580, 5, 635, 0,
		0, 3580, 3581, 5, 776, 0, 0, 3581, 3582, 3, 412, 206, 0, 3582, 3584, 5,
		777, 0, 0, 3583, 3585, 3, 404, 202, 0, 3584, 3583, 1, 0, 0, 0, 3584, 3585,
		1, 0, 0, 0, 3585, 3614, 1, 0, 0, 0, 3586, 3587, 5, 564, 0, 0, 3587, 3589,
		5, 776, 0, 0, 3588, 3590, 5, 143, 0, 0, 3589, 3588, 1, 0, 0, 0, 3589, 3590,
		1, 0, 0, 0, 3590, 3591, 1, 0, 0, 0, 3591, 3592, 3, 412, 206, 0, 3592, 3594,
		5, 777, 0, 0, 3593, 3595, 3, 404, 202, 0, 3594, 3593, 1, 0, 0, 0, 3594,
		3595, 1, 0, 0, 0, 3595, 3614, 1, 0, 0, 0, 3596, 3597, 5, 218, 0, 0, 3597,
		3599, 5, 776, 0, 0, 3598, 3600, 5, 143, 0, 0, 3599, 3598, 1, 0, 0, 0, 3599,
		3600, 1, 0, 0, 0, 3600, 3601, 1, 0, 0, 0, 3601, 3603, 3, 468, 234, 0, 3602,
		3604, 3, 74, 37, 0, 3603, 3602, 1, 0, 0, 0, 3603, 3604, 1, 0, 0, 0, 3604,
		3607, 1, 0, 0, 0, 3605, 3606, 5, 499, 0, 0, 3606, 3608, 3, 772, 386, 0,
		3607, 3605, 1, 0, 0, 0, 3607, 3608, 1, 0, 0, 0, 3608, 3609, 1, 0, 0, 0,
		3609, 3611, 5, 777, 0, 0, 3610, 3612, 3, 404, 202, 0, 3611, 3610, 1, 0,
		0, 0, 3611, 3612, 1, 0, 0, 0, 3612, 3614, 1, 0, 0, 0, 3613, 3495, 1, 0,
		0, 0, 3613, 3505, 1, 0, 0, 0, 3613, 3512, 1, 0, 0, 0, 3613, 3513, 1, 0,
		0, 0, 3613, 3523, 1, 0, 0, 0, 3613, 3538, 1, 0, 0, 0, 3613, 3548, 1, 0,
		0, 0, 3613, 3558, 1, 0, 0, 0, 3613, 3565, 1, 0, 0, 0, 3613, 3572, 1, 0,
		0, 0, 3613, 3579, 1, 0, 0, 0, 3613, 3586, 1, 0, 0, 0, 3613, 3596, 1, 0,
		0, 0, 3614, 399, 1, 0, 0, 0, 3615, 3616, 5, 672, 0, 0, 3616, 3617, 5, 776,
		0, 0, 3617, 3618, 3, 468, 234, 0, 3618, 3619, 5, 777, 0, 0, 3619, 401,
		1, 0, 0, 0, 3620, 3621, 7, 60, 0, 0, 3621, 3622, 3, 804, 402, 0, 3622,
		3623, 3, 404, 202, 0, 3623, 3663, 1, 0, 0, 0, 3624, 3625, 5, 688, 0, 0,
		3625, 3626, 3, 484, 242, 0, 3626, 3627, 3, 404, 202, 0, 3627, 3663, 1,
		0, 0, 0, 3628, 3629, 7, 61, 0, 0, 3629, 3630, 5, 776, 0, 0, 3630, 3632,
		3, 380, 190, 0, 3631, 3633, 3, 406, 203, 0, 3632, 3631, 1, 0, 0, 0, 3632,
		3633, 1, 0, 0, 0, 3633, 3634, 1, 0, 0, 0, 3634, 3636, 5, 777, 0, 0, 3635,
		3637, 3, 408, 204, 0, 3636, 3635, 1, 0, 0, 0, 3636, 3637, 1, 0, 0, 0, 3637,
		3638, 1, 0, 0, 0, 3638, 3639, 3, 404, 202, 0, 3639, 3663, 1, 0, 0, 0, 3640,
		3641, 7, 62, 0, 0, 3641, 3643, 3, 482, 241, 0, 3642, 3644, 3, 408, 204,
		0, 3643, 3642, 1, 0, 0, 0, 3643, 3644, 1, 0, 0, 0, 3644, 3645, 1, 0, 0,
		0, 3645, 3646, 3, 404, 202, 0, 3646, 3663, 1, 0, 0, 0, 3647, 3648, 5, 687,
		0, 0, 3648, 3649, 5, 776, 0, 0, 3649, 3650, 3, 380, 190, 0, 3650, 3651,
		5, 773, 0, 0, 3651, 3652, 3, 392, 196, 0, 3652, 3655, 5, 777, 0, 0, 3653,
		3654, 5, 203, 0, 0, 3654, 3656, 7, 63, 0, 0, 3655, 3653, 1, 0, 0, 0, 3655,
		3656, 1, 0, 0, 0, 3656, 3658, 1, 0, 0, 0, 3657, 3659, 3, 408, 204, 0, 3658,
		3657, 1, 0, 0, 0, 3658, 3659, 1, 0, 0, 0, 3659, 3660, 1, 0, 0, 0, 3660,
		3661, 3, 404, 202, 0, 3661, 3663, 1, 0, 0, 0, 3662, 3620, 1, 0, 0, 0, 3662,
		3624, 1, 0, 0, 0, 3662, 3628, 1, 0, 0, 0, 3662, 3640, 1, 0, 0, 0, 3662,
		3647, 1, 0, 0, 0, 3663, 403, 1, 0, 0, 0, 3664, 3667, 5, 691, 0, 0, 3665,
		3668, 3, 740, 370, 0, 3666, 3668, 3, 48, 24, 0, 3667, 3665, 1, 0, 0, 0,
		3667, 3666, 1, 0, 0, 0, 3668, 405, 1, 0, 0, 0, 3669, 3672, 5, 773, 0, 0,
		3670, 3673, 3, 760, 380, 0, 3671, 3673, 5, 787, 0, 0, 3672, 3670, 1, 0,
		0, 0, 3672, 3671, 1, 0, 0, 0, 3673, 3676, 1, 0, 0, 0, 3674, 3675, 5, 773,
		0, 0, 3675, 3677, 3, 380, 190, 0, 3676, 3674, 1, 0, 0, 0, 3676, 3677, 1,
		0, 0, 0, 3677, 407, 1, 0, 0, 0, 3678, 3679, 7, 64, 0, 0, 3679, 3680, 5,
		689, 0, 0, 3680, 409, 1, 0, 0, 0, 3681, 3682, 5, 667, 0, 0, 3682, 3683,
		5, 776, 0, 0, 3683, 3684, 3, 412, 206, 0, 3684, 3686, 5, 777, 0, 0, 3685,
		3687, 3, 404, 202, 0, 3686, 3685, 1, 0, 0, 0, 3686, 3687, 1, 0, 0, 0, 3687,
		3698, 1, 0, 0, 0, 3688, 3689, 5, 666, 0, 0, 3689, 3690, 5, 776, 0, 0, 3690,
		3691, 3, 412, 206, 0, 3691, 3692, 5, 773, 0, 0, 3692, 3693, 3, 412, 206,
		0, 3693, 3695, 5, 777, 0, 0, 3694, 3696, 3, 404, 202, 0, 3695, 3694, 1,
		0, 0, 0, 3695, 3696, 1, 0, 0, 0, 3696, 3698, 1, 0, 0, 0, 3697, 3681, 1,
		0, 0, 0, 3697, 3688, 1, 0, 0, 0, 3698, 411, 1, 0, 0, 0, 3699, 3701, 5,
		10, 0, 0, 3700, 3699, 1, 0, 0, 0, 3700, 3701, 1, 0, 0, 0, 3701, 3702, 1,
		0, 0, 0, 3702, 3703, 3, 380, 190, 0, 3703, 413, 1, 0, 0, 0, 3704, 3710,
		3, 416, 208, 0, 3705, 3706, 5, 776, 0, 0, 3706, 3707, 3, 416, 208, 0, 3707,
		3708, 5, 777, 0, 0, 3708, 3710, 1, 0, 0, 0, 3709, 3704, 1, 0, 0, 0, 3709,
		3705, 1, 0, 0, 0, 3710, 415, 1, 0, 0, 0, 3711, 3716, 3, 752, 376, 0, 3712,
		3713, 5, 773, 0, 0, 3713, 3715, 3, 752, 376, 0, 3714, 3712, 1, 0, 0, 0,
		3715, 3718, 1, 0, 0, 0, 3716, 3714, 1, 0, 0, 0, 3716, 3717, 1, 0, 0, 0,
		3717, 417, 1, 0, 0, 0, 3718, 3716, 1, 0, 0, 0, 3719, 3720, 5, 251, 0, 0,
		3720, 3721, 5, 41, 0, 0, 3721, 3735, 5, 346, 0, 0, 3722, 3723, 5, 251,
		0, 0, 3723, 3724, 5, 359, 0, 0, 3724, 3725, 5, 267, 0, 0, 3725, 3729, 5,
		346, 0, 0, 3726, 3727, 5, 645, 0, 0, 3727, 3728, 5, 430, 0, 0, 3728, 3730,
		5, 176, 0, 0, 3729, 3726, 1, 0, 0, 0, 3729, 3730, 1, 0, 0, 0, 3730, 3735,
		1, 0, 0, 0, 3731, 3732, 5, 645, 0, 0, 3732, 3733, 5, 430, 0, 0, 3733, 3735,
		5, 176, 0, 0, 3734, 3719, 1, 0, 0, 0, 3734, 3722, 1, 0, 0, 0, 3734, 3731,
		1, 0, 0, 0, 3735, 419, 1, 0, 0, 0, 3736, 3737, 5, 60, 0, 0, 3737, 3738,
		5, 776, 0, 0, 3738, 3741, 3, 468, 234, 0, 3739, 3740, 5, 621, 0, 0, 3740,
		3742, 3, 552, 276, 0, 3741, 3739, 1, 0, 0, 0, 3741, 3742, 1, 0, 0, 0, 3742,
		3743, 1, 0, 0, 0, 3743, 3744, 5, 777, 0, 0, 3744, 4007, 1, 0, 0, 0, 3745,
		3747, 5, 105, 0, 0, 3746, 3748, 3, 804, 402, 0, 3747, 3746, 1, 0, 0, 0,
		3747, 3748, 1, 0, 0, 0, 3748, 4007, 1, 0, 0, 0, 3749, 3750, 5, 116, 0,
		0, 3750, 4007, 3, 482, 241, 0, 3751, 3752, 5, 122, 0, 0, 3752, 4007, 3,
		482, 241, 0, 3753, 3754, 5, 229, 0, 0, 3754, 4007, 3, 482, 241, 0, 3755,
		3756, 5, 242, 0, 0, 3756, 3757, 5, 776, 0, 0, 3757, 3758, 3, 380, 190,
		0, 3758, 3759, 5, 773, 0, 0, 3759, 3760, 3, 380, 190, 0, 3760, 3761, 5,
		773, 0, 0, 3761, 3762, 3, 380, 190, 0, 3762, 3763, 5, 773, 0, 0, 3763,
		3764, 3, 380, 190, 0, 3764, 3765, 5, 777, 0, 0, 3765, 4007, 1, 0, 0, 0,
		3766, 3767, 5, 247, 0, 0, 3767, 3768, 5, 776, 0, 0, 3768, 3771, 3, 380,
		190, 0, 3769, 3770, 5, 773, 0, 0, 3770, 3772, 3, 380, 190, 0, 3771, 3769,
		1, 0, 0, 0, 3772, 3773, 1, 0, 0, 0, 3773, 3771, 1, 0, 0, 0, 3773, 3774,
		1, 0, 0, 0, 3774, 3775, 1, 0, 0, 0, 3775, 3776, 5, 777, 0, 0, 3776, 4007,
		1, 0, 0, 0, 3777, 3778, 5, 272, 0, 0, 3778, 3779, 5, 776, 0, 0, 3779, 3780,
		3, 380, 190, 0, 3780, 3781, 5, 773, 0, 0, 3781, 3782, 3, 380, 190, 0, 3782,
		3783, 5, 777, 0, 0, 3783, 4007, 1, 0, 0, 0, 3784, 3785, 5, 343, 0, 0, 3785,
		4007, 3, 482, 241, 0, 3786, 3787, 5, 350, 0, 0, 3787, 4007, 3, 482, 241,
		0, 3788, 3789, 5, 478, 0, 0, 3789, 3790, 5, 776, 0, 0, 3790, 3791, 3, 380,
		190, 0, 3791, 3792, 5, 773, 0, 0, 3792, 3793, 3, 380, 190, 0, 3793, 3794,
		5, 777, 0, 0, 3794, 4007, 1, 0, 0, 0, 3795, 3796, 5, 495, 0, 0, 3796, 4007,
		3, 482, 241, 0, 3797, 3798, 5, 586, 0, 0, 3798, 4007, 3, 482, 241, 0, 3799,
		3800, 5, 583, 0, 0, 3800, 3801, 5, 776, 0, 0, 3801, 3804, 3, 380, 190,
		0, 3802, 3803, 5, 773, 0, 0, 3803, 3805, 3, 380, 190, 0, 3804, 3802, 1,
		0, 0, 0, 3804, 3805, 1, 0, 0, 0, 3805, 3806, 1, 0, 0, 0, 3806, 3807, 5,
		777, 0, 0, 3807, 4007, 1, 0, 0, 0, 3808, 4007, 3, 434, 217, 0, 3809, 3810,
		5, 618, 0, 0, 3810, 4007, 3, 804, 402, 0, 3811, 3812, 5, 626, 0, 0, 3812,
		4007, 3, 482, 241, 0, 3813, 3814, 5, 656, 0, 0, 3814, 4007, 3, 482, 241,
		0, 3815, 3816, 7, 65, 0, 0, 3816, 3817, 5, 776, 0, 0, 3817, 3818, 3, 380,
		190, 0, 3818, 3824, 5, 773, 0, 0, 3819, 3825, 3, 380, 190, 0, 3820, 3821,
		5, 247, 0, 0, 3821, 3822, 3, 380, 190, 0, 3822, 3823, 3, 476, 238, 0, 3823,
		3825, 1, 0, 0, 0, 3824, 3819, 1, 0, 0, 0, 3824, 3820, 1, 0, 0, 0, 3825,
		3826, 1, 0, 0, 0, 3826, 3827, 5, 777, 0, 0, 3827, 4007, 1, 0, 0, 0, 3828,
		3830, 5, 100, 0, 0, 3829, 3831, 3, 804, 402, 0, 3830, 3829, 1, 0, 0, 0,
		3830, 3831, 1, 0, 0, 0, 3831, 4007, 1, 0, 0, 0, 3832, 3834, 5, 108, 0,
		0, 3833, 3835, 3, 424, 212, 0, 3834, 3833, 1, 0, 0, 0, 3834, 3835, 1, 0,
		0, 0, 3835, 4007, 1, 0, 0, 0, 3836, 3837, 7, 66, 0, 0, 3837, 3838, 5, 776,
		0, 0, 3838, 3839, 3, 380, 190, 0, 3839, 3840, 5, 773, 0, 0, 3840, 3841,
		5, 247, 0, 0, 3841, 3842, 3, 380, 190, 0, 3842, 3843, 3, 476, 238, 0, 3843,
		3844, 5, 777, 0, 0, 3844, 4007, 1, 0, 0, 0, 3845, 3846, 5, 182, 0, 0, 3846,
		3847, 5, 776, 0, 0, 3847, 3848, 3, 476, 238, 0, 3848, 3849, 5, 203, 0,
		0, 3849, 3850, 3, 380, 190, 0, 3850, 3851, 5, 777, 0, 0, 3851, 4007, 1,
		0, 0, 0, 3852, 3853, 5, 213, 0, 0, 3853, 3854, 5, 776, 0, 0, 3854, 3855,
		3, 432, 216, 0, 3855, 3856, 5, 773, 0, 0, 3856, 3857, 3, 380, 190, 0, 3857,
		3858, 5, 777, 0, 0, 3858, 4007, 1, 0, 0, 0, 3859, 3861, 5, 372, 0, 0, 3860,
		3862, 3, 424, 212, 0, 3861, 3860, 1, 0, 0, 0, 3861, 3862, 1, 0, 0, 0, 3862,
		4007, 1, 0, 0, 0, 3863, 3864, 5, 414, 0, 0, 3864, 3865, 5, 776, 0, 0, 3865,
		3866, 3, 390, 195, 0, 3866, 3867, 5, 251, 0, 0, 3867, 3868, 3, 380, 190,
		0, 3868, 3869, 5, 777, 0, 0, 3869, 4007, 1, 0, 0, 0, 3870, 4007, 3, 436,
		218, 0, 3871, 3873, 5, 569, 0, 0, 3872, 3874, 3, 424, 212, 0, 3873, 3872,
		1, 0, 0, 0, 3873, 3874, 1, 0, 0, 0, 3874, 4007, 1, 0, 0, 0, 3875, 3876,
		7, 67, 0, 0, 3876, 3877, 5, 776, 0, 0, 3877, 3878, 3, 478, 239, 0, 3878,
		3879, 5, 773, 0, 0, 3879, 3880, 3, 380, 190, 0, 3880, 3881, 5, 773, 0,
		0, 3881, 3882, 3, 380, 190, 0, 3882, 3883, 5, 777, 0, 0, 3883, 4007, 1,
		0, 0, 0, 3884, 3886, 5, 622, 0, 0, 3885, 3887, 3, 804, 402, 0, 3886, 3885,
		1, 0, 0, 0, 3886, 3887, 1, 0, 0, 0, 3887, 4007, 1, 0, 0, 0, 3888, 3890,
		5, 624, 0, 0, 3889, 3891, 3, 424, 212, 0, 3890, 3889, 1, 0, 0, 0, 3890,
		3891, 1, 0, 0, 0, 3891, 4007, 1, 0, 0, 0, 3892, 3894, 5, 623, 0, 0, 3893,
		3895, 3, 424, 212, 0, 3894, 3893, 1, 0, 0, 0, 3894, 3895, 1, 0, 0, 0, 3895,
		4007, 1, 0, 0, 0, 3896, 3897, 5, 19, 0, 0, 3897, 4007, 3, 482, 241, 0,
		3898, 3899, 5, 58, 0, 0, 3899, 4007, 3, 482, 241, 0, 3900, 3901, 5, 67,
		0, 0, 3901, 4007, 3, 480, 240, 0, 3902, 3903, 5, 70, 0, 0, 3903, 4007,
		3, 482, 241, 0, 3904, 3905, 5, 109, 0, 0, 3905, 4007, 3, 804, 402, 0, 3906,
		3907, 5, 231, 0, 0, 3907, 3908, 5, 776, 0, 0, 3908, 3909, 3, 380, 190,
		0, 3909, 3910, 5, 773, 0, 0, 3910, 3911, 3, 380, 190, 0, 3911, 3912, 5,
		773, 0, 0, 3912, 3913, 3, 380, 190, 0, 3913, 3914, 5, 777, 0, 0, 3914,
		4007, 1, 0, 0, 0, 3915, 3916, 5, 201, 0, 0, 3916, 3917, 5, 776, 0, 0, 3917,
		3918, 3, 380, 190, 0, 3918, 3919, 5, 773, 0, 0, 3919, 3922, 3, 380, 190,
		0, 3920, 3921, 5, 773, 0, 0, 3921, 3923, 3, 380, 190, 0, 3922, 3920, 1,
		0, 0, 0, 3922, 3923, 1, 0, 0, 0, 3923, 3924, 1, 0, 0, 0, 3924, 3925, 5,
		777, 0, 0, 3925, 4007, 1, 0, 0, 0, 3926, 3927, 5, 337, 0, 0, 3927, 4007,
		3, 482, 241, 0, 3928, 3929, 5, 349, 0, 0, 3929, 3930, 5, 776, 0, 0, 3930,
		3931, 3, 380, 190, 0, 3931, 3932, 5, 773, 0, 0, 3932, 3933, 3, 380, 190,
		0, 3933, 3934, 5, 777, 0, 0, 3934, 4007, 1, 0, 0, 0, 3935, 3936, 5, 382,
		0, 0, 3936, 3937, 5, 776, 0, 0, 3937, 3938, 3, 776, 388, 0, 3938, 3939,
		5, 777, 0, 0, 3939, 4007, 1, 0, 0, 0, 3940, 3941, 5, 406, 0, 0, 3941, 4007,
		3, 482, 241, 0, 3942, 3943, 5, 429, 0, 0, 3943, 4007, 3, 482, 241, 0, 3944,
		3945, 5, 457, 0, 0, 3945, 3946, 5, 776, 0, 0, 3946, 3947, 3, 380, 190,
		0, 3947, 3948, 5, 773, 0, 0, 3948, 3949, 3, 380, 190, 0, 3949, 3950, 5,
		777, 0, 0, 3950, 4007, 1, 0, 0, 0, 3951, 3952, 5, 458, 0, 0, 3952, 3953,
		5, 776, 0, 0, 3953, 3954, 3, 380, 190, 0, 3954, 3955, 5, 773, 0, 0, 3955,
		3956, 3, 380, 190, 0, 3956, 3957, 5, 773, 0, 0, 3957, 3958, 3, 380, 190,
		0, 3958, 3959, 5, 777, 0, 0, 3959, 4007, 1, 0, 0, 0, 3960, 3961, 5, 476,
		0, 0, 3961, 4007, 3, 482, 241, 0, 3962, 3963, 5, 485, 0, 0, 3963, 4007,
		3, 804, 402, 0, 3964, 3965, 5, 597, 0, 0, 3965, 3966, 5, 776, 0, 0, 3966,
		3967, 3, 380, 190, 0, 3967, 3968, 5, 773, 0, 0, 3968, 3969, 3, 380, 190,
		0, 3969, 3970, 5, 777, 0, 0, 3970, 4007, 1, 0, 0, 0, 3971, 3972, 5, 640,
		0, 0, 3972, 3973, 5, 776, 0, 0, 3973, 3976, 3, 380, 190, 0, 3974, 3975,
		5, 773, 0, 0, 3975, 3977, 3, 380, 190, 0, 3976, 3974, 1, 0, 0, 0, 3976,
		3977, 1, 0, 0, 0, 3977, 3978, 1, 0, 0, 0, 3978, 3979, 5, 777, 0, 0, 3979,
		4007, 1, 0, 0, 0, 3980, 3981, 5, 641, 0, 0, 3981, 3982, 5, 776, 0, 0, 3982,
		4001, 3, 380, 190, 0, 3983, 3984, 5, 17, 0, 0, 3984, 3985, 5, 60, 0, 0,
		3985, 3987, 3, 548, 274, 0, 3986, 3983, 1, 0, 0, 0, 3986, 3987, 1, 0, 0,
		0, 3987, 3989, 1, 0, 0, 0, 3988, 3990, 3, 428, 214, 0, 3989, 3988, 1, 0,
		0, 0, 3989, 3990, 1, 0, 0, 0, 3990, 4002, 1, 0, 0, 0, 3991, 3992, 5, 17,
		0, 0, 3992, 3993, 5, 32, 0, 0, 3993, 4002, 3, 548, 274, 0, 3994, 3995,
		5, 773, 0, 0, 3995, 3996, 3, 756, 378, 0, 3996, 3997, 5, 773, 0, 0, 3997,
		3998, 3, 756, 378, 0, 3998, 3999, 5, 773, 0, 0, 3999, 4000, 3, 756, 378,
		0, 4000, 4002, 1, 0, 0, 0, 4001, 3986, 1, 0, 0, 0, 4001, 3991, 1, 0, 0,
		0, 4001, 3994, 1, 0, 0, 0, 4002, 4003, 1, 0, 0, 0, 4003, 4004, 5, 777,
		0, 0, 4004, 4007, 1, 0, 0, 0, 4005, 4007, 3, 422, 211, 0, 4006, 3736, 1,
		0, 0, 0, 4006, 3745, 1, 0, 0, 0, 4006, 3749, 1, 0, 0, 0, 4006, 3751, 1,
		0, 0, 0, 4006, 3753, 1, 0, 0, 0, 4006, 3755, 1, 0, 0, 0, 4006, 3766, 1,
		0, 0, 0, 4006, 3777, 1, 0, 0, 0, 4006, 3784, 1, 0, 0, 0, 4006, 3786, 1,
		0, 0, 0, 4006, 3788, 1, 0, 0, 0, 4006, 3795, 1, 0, 0, 0, 4006, 3797, 1,
		0, 0, 0, 4006, 3799, 1, 0, 0, 0, 4006, 3808, 1, 0, 0, 0, 4006, 3809, 1,
		0, 0, 0, 4006, 3811, 1, 0, 0, 0, 4006, 3813, 1, 0, 0, 0, 4006, 3815, 1,
		0, 0, 0, 4006, 3828, 1, 0, 0, 0, 4006, 3832, 1, 0, 0, 0, 4006, 3836, 1,
		0, 0, 0, 4006, 3845, 1, 0, 0, 0, 4006, 3852, 1, 0, 0, 0, 4006, 3859, 1,
		0, 0, 0, 4006, 3863, 1, 0, 0, 0, 4006, 3870, 1, 0, 0, 0, 4006, 3871, 1,
		0, 0, 0, 4006, 3875, 1, 0, 0, 0, 4006, 3884, 1, 0, 0, 0, 4006, 3888, 1,
		0, 0, 0, 4006, 3892, 1, 0, 0, 0, 4006, 3896, 1, 0, 0, 0, 4006, 3898, 1,
		0, 0, 0, 4006, 3900, 1, 0, 0, 0, 4006, 3902, 1, 0, 0, 0, 4006, 3904, 1,
		0, 0, 0, 4006, 3906, 1, 0, 0, 0, 4006, 3915, 1, 0, 0, 0, 4006, 3926, 1,
		0, 0, 0, 4006, 3928, 1, 0, 0, 0, 4006, 3935, 1, 0, 0, 0, 4006, 3940, 1,
		0, 0, 0, 4006, 3942, 1, 0, 0, 0, 4006, 3944, 1, 0, 0, 0, 4006, 3951, 1,
		0, 0, 0, 4006, 3960, 1, 0, 0, 0, 4006, 3962, 1, 0, 0, 0, 4006, 3964, 1,
		0, 0, 0, 4006, 3971, 1, 0, 0, 0, 4006, 3980, 1, 0, 0, 0, 4006, 4005, 1,
		0, 0, 0, 4007, 421, 1, 0, 0, 0, 4008, 4009, 5, 90, 0, 0, 4009, 4010, 5,
		776, 0, 0, 4010, 4011, 3, 380, 190, 0, 4011, 4012, 5, 773, 0, 0, 4012,
		4013, 3, 380, 190, 0, 4013, 4014, 5, 777, 0, 0, 4014, 4039, 1, 0, 0, 0,
		4015, 4016, 5, 211, 0, 0, 4016, 4018, 5, 776, 0, 0, 4017, 4019, 3, 468,
		234, 0, 4018, 4017, 1, 0, 0, 0, 4018, 4019, 1, 0, 0, 0, 4019, 4020, 1,
		0, 0, 0, 4020, 4039, 5, 777, 0, 0, 4021, 4022, 5, 279, 0, 0, 4022, 4039,
		3, 480, 240, 0, 4023, 4024, 5, 351, 0, 0, 4024, 4039, 3, 480, 240, 0, 4025,
		4026, 5, 352, 0, 0, 4026, 4039, 3, 480, 240, 0, 4027, 4028, 5, 353, 0,
		0, 4028, 4039, 3, 480, 240, 0, 4029, 4030, 5, 411, 0, 0, 4030, 4031, 5,
		776, 0, 0, 4031, 4032, 3, 380, 190, 0, 4032, 4033, 5, 773, 0, 0, 4033,
		4034, 3, 380, 190, 0, 4034, 4035, 5, 777, 0, 0, 4035, 4039, 1, 0, 0, 0,
		4036, 4037, 5, 412, 0, 0, 4037, 4039, 3, 480, 240, 0, 4038, 4008, 1, 0,
		0, 0, 4038, 4015, 1, 0, 0, 0, 4038, 4021, 1, 0, 0, 0, 4038, 4023, 1, 0,
		0, 0, 4038, 4025, 1, 0, 0, 0, 4038, 4027, 1, 0, 0, 0, 4038, 4029, 1, 0,
		0, 0, 4038, 4036, 1, 0, 0, 0, 4039, 423, 1, 0, 0, 0, 4040, 4042, 5, 776,
		0, 0, 4041, 4043, 3, 426, 213, 0, 4042, 4041, 1, 0, 0, 0, 4042, 4043, 1,
		0, 0, 0, 4043, 4044, 1, 0, 0, 0, 4044, 4045, 5, 777, 0, 0, 4045, 425, 1,
		0, 0, 0, 4046, 4047, 5, 747, 0, 0, 4047, 427, 1, 0, 0, 0, 4048, 4061, 5,
		274, 0, 0, 4049, 4050, 3, 758, 379, 0, 4050, 4051, 5, 759, 0, 0, 4051,
		4052, 3, 758, 379, 0, 4052, 4062, 1, 0, 0, 0, 4053, 4058, 3, 430, 215,
		0, 4054, 4055, 5, 773, 0, 0, 4055, 4057, 3, 430, 215, 0, 4056, 4054, 1,
		0, 0, 0, 4057, 4060, 1, 0, 0, 0, 4058, 4056, 1, 0, 0, 0, 4058, 4059, 1,
		0, 0, 0, 4059, 4062, 1, 0, 0, 0, 4060, 4058, 1, 0, 0, 0, 4061, 4049, 1,
		0, 0, 0, 4061, 4053, 1, 0, 0, 0, 4062, 429, 1, 0, 0, 0, 4063, 4069, 3,
		758, 379, 0, 4064, 4066, 7, 5, 0, 0, 4065, 4067, 5, 476, 0, 0, 4066, 4065,
		1, 0, 0, 0, 4066, 4067, 1, 0, 0, 0, 4067, 4070, 1, 0, 0, 0, 4068, 4070,
		5, 476, 0, 0, 4069, 4064, 1, 0, 0, 0, 4069, 4068, 1, 0, 0, 0, 4069, 4070,
		1, 0, 0, 0, 4070, 431, 1, 0, 0, 0, 4071, 4072, 7, 68, 0, 0, 4072, 433,
		1, 0, 0, 0, 4073, 4074, 5, 595, 0, 0, 4074, 4098, 5, 776, 0, 0, 4075, 4078,
		3, 380, 190, 0, 4076, 4077, 5, 203, 0, 0, 4077, 4079, 3, 380, 190, 0, 4078,
		4076, 1, 0, 0, 0, 4078, 4079, 1, 0, 0, 0, 4079, 4099, 1, 0, 0, 0, 4080,
		4082, 5, 269, 0, 0, 4081, 4083, 3, 380, 190, 0, 4082, 4081, 1, 0, 0, 0,
		4082, 4083, 1, 0, 0, 0, 4083, 4084, 1, 0, 0, 0, 4084, 4085, 5, 203, 0,
		0, 4085, 4099, 3, 380, 190, 0, 4086, 4088, 5, 591, 0, 0, 4087, 4089, 3,
		380, 190, 0, 4088, 4087, 1, 0, 0, 0, 4088, 4089, 1, 0, 0, 0, 4089, 4090,
		1, 0, 0, 0, 4090, 4091, 5, 203, 0, 0, 4091, 4099, 3, 380, 190, 0, 4092,
		4094, 5, 43, 0, 0, 4093, 4095, 3, 380, 190, 0, 4094, 4093, 1, 0, 0, 0,
		4094, 4095, 1, 0, 0, 0, 4095, 4096, 1, 0, 0, 0, 4096, 4097, 5, 203, 0,
		0, 4097, 4099, 3, 380, 190, 0, 4098, 4075, 1, 0, 0, 0, 4098, 4080, 1, 0,
		0, 0, 4098, 4086, 1, 0, 0, 0, 4098, 4092, 1, 0, 0, 0, 4099, 4100, 1, 0,
		0, 0, 4100, 4101, 5, 777, 0, 0, 4101, 435, 1, 0, 0, 0, 4102, 4103, 5, 563,
		0, 0, 4103, 4104, 5, 776, 0, 0, 4104, 4117, 3, 380, 190, 0, 4105, 4106,
		5, 773, 0, 0, 4106, 4109, 3, 380, 190, 0, 4107, 4108, 5, 773, 0, 0, 4108,
		4110, 3, 380, 190, 0, 4109, 4107, 1, 0, 0, 0, 4109, 4110, 1, 0, 0, 0, 4110,
		4118, 1, 0, 0, 0, 4111, 4112, 5, 203, 0, 0, 4112, 4115, 3, 380, 190, 0,
		4113, 4114, 5, 200, 0, 0, 4114, 4116, 3, 380, 190, 0, 4115, 4113, 1, 0,
		0, 0, 4115, 4116, 1, 0, 0, 0, 4116, 4118, 1, 0, 0, 0, 4117, 4105, 1, 0,
		0, 0, 4117, 4111, 1, 0, 0, 0, 4118, 4119, 1, 0, 0, 0, 4119, 4120, 5, 777,
		0, 0, 4120, 437, 1, 0, 0, 0, 4121, 4122, 3, 742, 371, 0, 4122, 4124, 5,
		776, 0, 0, 4123, 4125, 3, 448, 224, 0, 4124, 4123, 1, 0, 0, 0, 4124, 4125,
		1, 0, 0, 0, 4125, 4126, 1, 0, 0, 0, 4126, 4127, 5, 777, 0, 0, 4127, 4136,
		1, 0, 0, 0, 4128, 4129, 3, 750, 375, 0, 4129, 4131, 5, 776, 0, 0, 4130,
		4132, 3, 468, 234, 0, 4131, 4130, 1, 0, 0, 0, 4131, 4132, 1, 0, 0, 0, 4132,
		4133, 1, 0, 0, 0, 4133, 4134, 5, 777, 0, 0, 4134, 4136, 1, 0, 0, 0, 4135,
		4121, 1, 0, 0, 0, 4135, 4128, 1, 0, 0, 0, 4136, 439, 1, 0, 0, 0, 4137,
		4138, 5, 799, 0, 0, 4138, 4139, 5, 776, 0, 0, 4139, 4140, 3, 380, 190,
		0, 4140, 4141, 5, 773, 0, 0, 4141, 4143, 3, 776, 388, 0, 4142, 4144, 3,
		442, 221, 0, 4143, 4142, 1, 0, 0, 0, 4143, 4144, 1, 0, 0, 0, 4144, 4146,
		1, 0, 0, 0, 4145, 4147, 3, 444, 222, 0, 4146, 4145, 1, 0, 0, 0, 4146, 4147,
		1, 0, 0, 0, 4147, 4149, 1, 0, 0, 0, 4148, 4150, 3, 446, 223, 0, 4149, 4148,
		1, 0, 0, 0, 4149, 4150, 1, 0, 0, 0, 4150, 4151, 1, 0, 0, 0, 4151, 4152,
		5, 777, 0, 0, 4152, 441, 1, 0, 0, 0, 4153, 4154, 5, 800, 0, 0, 4154, 4155,
		3, 466, 233, 0, 4155, 443, 1, 0, 0, 0, 4156, 4161, 3, 786, 393, 0, 4157,
		4161, 5, 165, 0, 0, 4158, 4159, 5, 128, 0, 0, 4159, 4161, 3, 380, 190,
		0, 4160, 4156, 1, 0, 0, 0, 4160, 4157, 1, 0, 0, 0, 4160, 4158, 1, 0, 0,
		0, 4161, 4162, 1, 0, 0, 0, 4162, 4163, 5, 383, 0, 0, 4163, 4164, 5, 700,
		0, 0, 4164, 445, 1, 0, 0, 0, 4165, 4170, 3, 786, 393, 0, 4166, 4170, 5,
		165, 0, 0, 4167, 4168, 5, 128, 0, 0, 4168, 4170, 3, 380, 190, 0, 4169,
		4165, 1, 0, 0, 0, 4169, 4166, 1, 0, 0, 0, 4169, 4167, 1, 0, 0, 0, 4170,
		4171, 1, 0, 0, 0, 4171, 4172, 5, 383, 0, 0, 4172, 4173, 5, 165, 0, 0, 4173,
		447, 1, 0, 0, 0, 4174, 4179, 3, 450, 225, 0, 4175, 4176, 5, 773, 0, 0,
		4176, 4178, 3, 450, 225, 0, 4177, 4175, 1, 0, 0, 0, 4178, 4181, 1, 0, 0,
		0, 4179, 4177, 1, 0, 0, 0, 4179, 4180, 1, 0, 0, 0, 4180, 449, 1, 0, 0,
		0, 4181, 4179, 1, 0, 0, 0, 4182, 4184, 3, 380, 190, 0, 4183, 4185, 3, 104,
		52, 0, 4184, 4183, 1, 0, 0, 0, 4184, 4185, 1, 0, 0, 0, 4185, 451, 1, 0,
		0, 0, 4186, 4189, 3, 454, 227, 0, 4187, 4189, 3, 456, 228, 0, 4188, 4186,
		1, 0, 0, 0, 4188, 4187, 1, 0, 0, 0, 4189, 453, 1, 0, 0, 0, 4190, 4191,
		5, 783, 0, 0, 4191, 4194, 3, 796, 398, 0, 4192, 4194, 5, 784, 0, 0, 4193,
		4190, 1, 0, 0, 0, 4193, 4192, 1, 0, 0, 0, 4194, 455, 1, 0, 0, 0, 4195,
		4197, 5, 785, 0, 0, 4196, 4198, 3, 810, 405, 0, 4197, 4196, 1, 0, 0, 0,
		4197, 4198, 1, 0, 0, 0, 4198, 4199, 1, 0, 0, 0, 4199, 4201, 3, 796, 398,
		0, 4200, 4202, 3, 754, 377, 0, 4201, 4200, 1, 0, 0, 0, 4201, 4202, 1, 0,
		0, 0, 4202, 457, 1, 0, 0, 0, 4203, 4205, 3, 744, 372, 0, 4204, 4206, 3,
		754, 377, 0, 4205, 4204, 1, 0, 0, 0, 4205, 4206, 1, 0, 0, 0, 4206, 4212,
		1, 0, 0, 0, 4207, 4209, 3, 798, 399, 0, 4208, 4210, 3, 754, 377, 0, 4209,
		4208, 1, 0, 0, 0, 4209, 4210, 1, 0, 0, 0, 4210, 4212, 1, 0, 0, 0, 4211,
		4203, 1, 0, 0, 0, 4211, 4207, 1, 0, 0, 0, 4212, 4216, 1, 0, 0, 0, 4213,
		4214, 5, 128, 0, 0, 4214, 4216, 3, 754, 377, 0, 4215, 4211, 1, 0, 0, 0,
		4215, 4213, 1, 0, 0, 0, 4216, 459, 1, 0, 0, 0, 4217, 4218, 5, 642, 0, 0,
		4218, 4219, 3, 380, 190, 0, 4219, 461, 1, 0, 0, 0, 4220, 4221, 5, 582,
		0, 0, 4221, 4222, 3, 380, 190, 0, 4222, 463, 1, 0, 0, 0, 4223, 4224, 5,
		154, 0, 0, 4224, 4225, 3, 380, 190, 0, 4225, 465, 1, 0, 0, 0, 4226, 4228,
		5, 32, 0, 0, 4227, 4229, 3, 538, 269, 0, 4228, 4227, 1, 0, 0, 0, 4228,
		4229, 1, 0, 0, 0, 4229, 4269, 1, 0, 0, 0, 4230, 4232, 5, 60, 0, 0, 4231,
		4233, 3, 538, 269, 0, 4232, 4231, 1, 0, 0, 0, 4232, 4233, 1, 0, 0, 0, 4233,
		4235, 1, 0, 0, 0, 4234, 4236, 3, 542, 271, 0, 4235, 4234, 1, 0, 0, 0, 4235,
		4236, 1, 0, 0, 0, 4236, 4269, 1, 0, 0, 0, 4237, 4239, 3, 534, 267, 0, 4238,
		4240, 3, 538, 269, 0, 4239, 4238, 1, 0, 0, 0, 4239, 4240, 1, 0, 0, 0, 4240,
		4269, 1, 0, 0, 0, 4241, 4243, 5, 512, 0, 0, 4242, 4244, 5, 249, 0, 0, 4243,
		4242, 1, 0, 0, 0, 4243, 4244, 1, 0, 0, 0, 4244, 4269, 1, 0, 0, 0, 4245,
		4247, 5, 612, 0, 0, 4246, 4248, 5, 249, 0, 0, 4247, 4246, 1, 0, 0, 0, 4247,
		4248, 1, 0, 0, 0, 4248, 4269, 1, 0, 0, 0, 4249, 4269, 5, 116, 0, 0, 4250,
		4252, 5, 586, 0, 0, 4251, 4253, 3, 550, 275, 0, 4252, 4251, 1, 0, 0, 0,
		4252, 4253, 1, 0, 0, 0, 4253, 4269, 1, 0, 0, 0, 4254, 4256, 5, 113, 0,
		0, 4255, 4257, 3, 550, 275, 0, 4256, 4255, 1, 0, 0, 0, 4256, 4257, 1, 0,
		0, 0, 4257, 4269, 1, 0, 0, 0, 4258, 4260, 5, 126, 0, 0, 4259, 4261, 3,
		790, 395, 0, 4260, 4259, 1, 0, 0, 0, 4260, 4261, 1, 0, 0, 0, 4261, 4269,
		1, 0, 0, 0, 4262, 4269, 5, 262, 0, 0, 4263, 4269, 3, 536, 268, 0, 4264,
		4266, 5, 195, 0, 0, 4265, 4267, 3, 792, 396, 0, 4266, 4265, 1, 0, 0, 0,
		4266, 4267, 1, 0, 0, 0, 4267, 4269, 1, 0, 0, 0, 4268, 4226, 1, 0, 0, 0,
		4268, 4230, 1, 0, 0, 0, 4268, 4237, 1, 0, 0, 0, 4268, 4241, 1, 0, 0, 0,
		4268, 4245, 1, 0, 0, 0, 4268, 4249, 1, 0, 0, 0, 4268, 4250, 1, 0, 0, 0,
		4268, 4254, 1, 0, 0, 0, 4268, 4258, 1, 0, 0, 0, 4268, 4262, 1, 0, 0, 0,
		4268, 4263, 1, 0, 0, 0, 4268, 4264, 1, 0, 0, 0, 4269, 467, 1, 0, 0, 0,
		4270, 4275, 3, 380, 190, 0, 4271, 4272, 5, 773, 0, 0, 4272, 4274, 3, 380,
		190, 0, 4273, 4271, 1, 0, 0, 0, 4274, 4277, 1, 0, 0, 0, 4275, 4273, 1,
		0, 0, 0, 4275, 4276, 1, 0, 0, 0, 4276, 469, 1, 0, 0, 0, 4277, 4275, 1,
		0, 0, 0, 4278, 4279, 5, 60, 0, 0, 4279, 4282, 5, 506, 0, 0, 4280, 4282,
		5, 58, 0, 0, 4281, 4278, 1, 0, 0, 0, 4281, 4280, 1, 0, 0, 0, 4282, 471,
		1, 0, 0, 0, 4283, 4284, 7, 69, 0, 0, 4284, 473, 1, 0, 0, 0, 4285, 4286,
		7, 70, 0, 0, 4286, 475, 1, 0, 0, 0, 4287, 4290, 3, 478, 239, 0, 4288, 4290,
		7, 71, 0, 0, 4289, 4287, 1, 0, 0, 0, 4289, 4288, 1, 0, 0, 0, 4290, 477,
		1, 0, 0, 0, 4291, 4292, 7, 72, 0, 0, 4292, 479, 1, 0, 0, 0, 4293, 4294,
		5, 776, 0, 0, 4294, 4295, 3, 468, 234, 0, 4295, 4296, 5, 777, 0, 0, 4296,
		481, 1, 0, 0, 0, 4297, 4298, 5, 776, 0, 0, 4298, 4299, 3, 380, 190, 0,
		4299, 4300, 5, 777, 0, 0, 4300, 483, 1, 0, 0, 0, 4301, 4302, 5, 776, 0,
		0, 4302, 4303, 3, 392, 196, 0, 4303, 4304, 5, 777, 0, 0, 4304, 485, 1,
		0, 0, 0, 4305, 4310, 3, 488, 244, 0, 4306, 4307, 5, 773, 0, 0, 4307, 4309,
		3, 488, 244, 0, 4308, 4306, 1, 0, 0, 0, 4309, 4312, 1, 0, 0, 0, 4310, 4308,
		1, 0, 0, 0, 4310, 4311, 1, 0, 0, 0, 4311, 487, 1, 0, 0, 0, 4312, 4310,
		1, 0, 0, 0, 4313, 4315, 3, 380, 190, 0, 4314, 4316, 3, 76, 38, 0, 4315,
		4314, 1, 0, 0, 0, 4315, 4316, 1, 0, 0, 0, 4316, 489, 1, 0, 0, 0, 4317,
		4322, 3, 492, 246, 0, 4318, 4319, 5, 773, 0, 0, 4319, 4321, 3, 492, 246,
		0, 4320, 4318, 1, 0, 0, 0, 4321, 4324, 1, 0, 0, 0, 4322, 4320, 1, 0, 0,
		0, 4322, 4323, 1, 0, 0, 0, 4323, 491, 1, 0, 0, 0, 4324, 4322, 1, 0, 0,
		0, 4325, 4326, 3, 380, 190, 0, 4326, 493, 1, 0, 0, 0, 4327, 4328, 5, 200,
		0, 0, 4328, 4329, 5, 57, 0, 0, 4329, 4330, 3, 778, 389, 0, 4330, 495, 1,
		0, 0, 0, 4331, 4332, 7, 73, 0, 0, 4332, 497, 1, 0, 0, 0, 4333, 4334, 7,
		74, 0, 0, 4334, 499, 1, 0, 0, 0, 4335, 4337, 5, 609, 0, 0, 4336, 4338,
		5, 265, 0, 0, 4337, 4336, 1, 0, 0, 0, 4337, 4338, 1, 0, 0, 0, 4338, 4350,
		1, 0, 0, 0, 4339, 4340, 5, 75, 0, 0, 4340, 4350, 3, 772, 386, 0, 4341,
		4343, 3, 472, 236, 0, 4342, 4341, 1, 0, 0, 0, 4342, 4343, 1, 0, 0, 0, 4343,
		4344, 1, 0, 0, 0, 4344, 4350, 5, 376, 0, 0, 4345, 4347, 5, 420, 0, 0, 4346,
		4345, 1, 0, 0, 0, 4346, 4347, 1, 0, 0, 0, 4347, 4348, 1, 0, 0, 0, 4348,
		4350, 5, 265, 0, 0, 4349, 4335, 1, 0, 0, 0, 4349, 4339, 1, 0, 0, 0, 4349,
		4342, 1, 0, 0, 0, 4349, 4346, 1, 0, 0, 0, 4350, 501, 1, 0, 0, 0, 4351,
		4352, 5, 443, 0, 0, 4352, 4354, 3, 718, 359, 0, 4353, 4355, 3, 748, 374,
		0, 4354, 4353, 1, 0, 0, 0, 4354, 4355, 1, 0, 0, 0, 4355, 4358, 1, 0, 0,
		0, 4356, 4357, 5, 320, 0, 0, 4357, 4359, 7, 75, 0, 0, 4358, 4356, 1, 0,
		0, 0, 4358, 4359, 1, 0, 0, 0, 4359, 4376, 1, 0, 0, 0, 4360, 4361, 5, 383,
		0, 0, 4361, 4362, 5, 614, 0, 0, 4362, 4366, 3, 504, 252, 0, 4363, 4364,
		5, 383, 0, 0, 4364, 4365, 5, 133, 0, 0, 4365, 4367, 3, 504, 252, 0, 4366,
		4363, 1, 0, 0, 0, 4366, 4367, 1, 0, 0, 0, 4367, 4377, 1, 0, 0, 0, 4368,
		4369, 5, 383, 0, 0, 4369, 4370, 5, 133, 0, 0, 4370, 4374, 3, 504, 252,
		0, 4371, 4372, 5, 383, 0, 0, 4372, 4373, 5, 614, 0, 0, 4373, 4375, 3, 504,
		252, 0, 4374, 4371, 1, 0, 0, 0, 4374, 4375, 1, 0, 0, 0, 4375, 4377, 1,
		0, 0, 0, 4376, 4360, 1, 0, 0, 0, 4376, 4368, 1, 0, 0, 0, 4376, 4377, 1,
		0, 0, 0, 4377, 503, 1, 0, 0, 0, 4378, 4386, 7, 76, 0, 0, 4379, 4380, 5,
		506, 0, 0, 4380, 4386, 3, 786, 393, 0, 4381, 4382, 5, 506, 0, 0, 4382,
		4386, 5, 128, 0, 0, 4383, 4384, 5, 373, 0, 0, 4384, 4386, 5, 3, 0, 0, 4385,
		4378, 1, 0, 0, 0, 4385, 4379, 1, 0, 0, 0, 4385, 4381, 1, 0, 0, 0, 4385,
		4383, 1, 0, 0, 0, 4386, 505, 1, 0, 0, 0, 4387, 4388, 5, 776, 0, 0, 4388,
		4393, 3, 508, 254, 0, 4389, 4390, 5, 773, 0, 0, 4390, 4392, 3, 508, 254,
		0, 4391, 4389, 1, 0, 0, 0, 4392, 4395, 1, 0, 0, 0, 4393, 4391, 1, 0, 0,
		0, 4393, 4394, 1, 0, 0, 0, 4394, 4396, 1, 0, 0, 0, 4395, 4393, 1, 0, 0,
		0, 4396, 4397, 5, 777, 0, 0, 4397, 507, 1, 0, 0, 0, 4398, 4400, 3, 744,
		372, 0, 4399, 4401, 3, 538, 269, 0, 4400, 4399, 1, 0, 0, 0, 4400, 4401,
		1, 0, 0, 0, 4401, 4403, 1, 0, 0, 0, 4402, 4404, 3, 76, 38, 0, 4403, 4402,
		1, 0, 0, 0, 4403, 4404, 1, 0, 0, 0, 4404, 509, 1, 0, 0, 0, 4405, 4406,
		5, 776, 0, 0, 4406, 4411, 3, 512, 256, 0, 4407, 4408, 5, 773, 0, 0, 4408,
		4410, 3, 512, 256, 0, 4409, 4407, 1, 0, 0, 0, 4410, 4413, 1, 0, 0, 0, 4411,
		4409, 1, 0, 0, 0, 4411, 4412, 1, 0, 0, 0, 4412, 4414, 1, 0, 0, 0, 4413,
		4411, 1, 0, 0, 0, 4414, 4415, 5, 777, 0, 0, 4415, 511, 1, 0, 0, 0, 4416,
		4422, 3, 508, 254, 0, 4417, 4419, 3, 482, 241, 0, 4418, 4420, 3, 76, 38,
		0, 4419, 4418, 1, 0, 0, 0, 4419, 4420, 1, 0, 0, 0, 4420, 4422, 1, 0, 0,
		0, 4421, 4416, 1, 0, 0, 0, 4421, 4417, 1, 0, 0, 0, 4422, 513, 1, 0, 0,
		0, 4423, 4426, 3, 510, 255, 0, 4424, 4426, 3, 506, 253, 0, 4425, 4423,
		1, 0, 0, 0, 4425, 4424, 1, 0, 0, 0, 4426, 515, 1, 0, 0, 0, 4427, 4428,
		7, 77, 0, 0, 4428, 517, 1, 0, 0, 0, 4429, 4432, 3, 520, 260, 0, 4430, 4432,
		3, 524, 262, 0, 4431, 4429, 1, 0, 0, 0, 4431, 4430, 1, 0, 0, 0, 4432, 519,
		1, 0, 0, 0, 4433, 4435, 5, 264, 0, 0, 4434, 4436, 5, 750, 0, 0, 4435, 4434,
		1, 0, 0, 0, 4435, 4436, 1, 0, 0, 0, 4436, 4437, 1, 0, 0, 0, 4437, 4442,
		3, 756, 378, 0, 4438, 4439, 5, 75, 0, 0, 4439, 4442, 3, 776, 388, 0, 4440,
		4442, 3, 522, 261, 0, 4441, 4433, 1, 0, 0, 0, 4441, 4438, 1, 0, 0, 0, 4441,
		4440, 1, 0, 0, 0, 4442, 521, 1, 0, 0, 0, 4443, 4444, 7, 78, 0, 0, 4444,
		523, 1, 0, 0, 0, 4445, 4446, 7, 79, 0, 0, 4446, 4447, 3, 516, 258, 0, 4447,
		525, 1, 0, 0, 0, 4448, 4453, 3, 520, 260, 0, 4449, 4450, 5, 645, 0, 0,
		4450, 4451, 5, 401, 0, 0, 4451, 4453, 3, 744, 372, 0, 4452, 4448, 1, 0,
		0, 0, 4452, 4449, 1, 0, 0, 0, 4453, 527, 1, 0, 0, 0, 4454, 4455, 3, 520,
		260, 0, 4455, 529, 1, 0, 0, 0, 4456, 4457, 3, 532, 266, 0, 4457, 4458,
		5, 0, 0, 1, 4458, 531, 1, 0, 0, 0, 4459, 4461, 7, 80, 0, 0, 4460, 4462,
		3, 538, 269, 0, 4461, 4460, 1, 0, 0, 0, 4461, 4462, 1, 0, 0, 0, 4462, 4464,
		1, 0, 0, 0, 4463, 4465, 3, 540, 270, 0, 4464, 4463, 1, 0, 0, 0, 4464, 4465,
		1, 0, 0, 0, 4465, 4606, 1, 0, 0, 0, 4466, 4472, 5, 437, 0, 0, 4467, 4469,
		5, 146, 0, 0, 4468, 4470, 5, 416, 0, 0, 4469, 4468, 1, 0, 0, 0, 4469, 4470,
		1, 0, 0, 0, 4470, 4472, 1, 0, 0, 0, 4471, 4466, 1, 0, 0, 0, 4471, 4467,
		1, 0, 0, 0, 4472, 4474, 1, 0, 0, 0, 4473, 4475, 3, 794, 397, 0, 4474, 4473,
		1, 0, 0, 0, 4474, 4475, 1, 0, 0, 0, 4475, 4477, 1, 0, 0, 0, 4476, 4478,
		3, 540, 270, 0, 4477, 4476, 1, 0, 0, 0, 4477, 4478, 1, 0, 0, 0, 4478, 4606,
		1, 0, 0, 0, 4479, 4481, 7, 81, 0, 0, 4480, 4482, 3, 790, 395, 0, 4481,
		4480, 1, 0, 0, 0, 4481, 4482, 1, 0, 0, 0, 4482, 4484, 1, 0, 0, 0, 4483,
		4485, 3, 540, 270, 0, 4484, 4483, 1, 0, 0, 0, 4484, 4485, 1, 0, 0, 0, 4485,
		4606, 1, 0, 0, 0, 4486, 4488, 5, 37, 0, 0, 4487, 4489, 3, 538, 269, 0,
		4488, 4487, 1, 0, 0, 0, 4488, 4489, 1, 0, 0, 0, 4489, 4606, 1, 0, 0, 0,
		4490, 4606, 7, 82, 0, 0, 4491, 4493, 5, 60, 0, 0, 4492, 4494, 3, 538, 269,
		0, 4493, 4492, 1, 0, 0, 0, 4493, 4494, 1, 0, 0, 0, 4494, 4496, 1, 0, 0,
		0, 4495, 4497, 3, 542, 271, 0, 4496, 4495, 1, 0, 0, 0, 4496, 4497, 1, 0,
		0, 0, 4497, 4606, 1, 0, 0, 0, 4498, 4500, 3, 534, 267, 0, 4499, 4501, 3,
		538, 269, 0, 4500, 4499, 1, 0, 0, 0, 4500, 4501, 1, 0, 0, 0, 4501, 4503,
		1, 0, 0, 0, 4502, 4504, 5, 32, 0, 0, 4503, 4502, 1, 0, 0, 0, 4503, 4504,
		1, 0, 0, 0, 4504, 4606, 1, 0, 0, 0, 4505, 4507, 5, 32, 0, 0, 4506, 4508,
		3, 538, 269, 0, 4507, 4506, 1, 0, 0, 0, 4507, 4508, 1, 0, 0, 0, 4508, 4606,
		1, 0, 0, 0, 4509, 4510, 5, 60, 0, 0, 4510, 4513, 5, 633, 0, 0, 4511, 4513,
		5, 629, 0, 0, 4512, 4509, 1, 0, 0, 0, 4512, 4511, 1, 0, 0, 0, 4513, 4514,
		1, 0, 0, 0, 4514, 4516, 3, 538, 269, 0, 4515, 4517, 3, 542, 271, 0, 4516,
		4515, 1, 0, 0, 0, 4516, 4517, 1, 0, 0, 0, 4517, 4606, 1, 0, 0, 0, 4518,
		4519, 5, 358, 0, 0, 4519, 4529, 5, 629, 0, 0, 4520, 4529, 5, 379, 0, 0,
		4521, 4522, 5, 361, 0, 0, 4522, 4529, 5, 629, 0, 0, 4523, 4524, 5, 358,
		0, 0, 4524, 4525, 5, 60, 0, 0, 4525, 4529, 5, 633, 0, 0, 4526, 4527, 5,
		361, 0, 0, 4527, 4529, 5, 633, 0, 0, 4528, 4518, 1, 0, 0, 0, 4528, 4520,
		1, 0, 0, 0, 4528, 4521, 1, 0, 0, 0, 4528, 4523, 1, 0, 0, 0, 4528, 4526,
		1, 0, 0, 0, 4529, 4530, 1, 0, 0, 0, 4530, 4532, 3, 538, 269, 0, 4531, 4533,
		5, 32, 0, 0, 4532, 4531, 1, 0, 0, 0, 4532, 4533, 1, 0, 0, 0, 4533, 4606,
		1, 0, 0, 0, 4534, 4535, 5, 628, 0, 0, 4535, 4606, 3, 538, 269, 0, 4536,
		4538, 5, 656, 0, 0, 4537, 4539, 3, 538, 269, 0, 4538, 4537, 1, 0, 0, 0,
		4538, 4539, 1, 0, 0, 0, 4539, 4541, 1, 0, 0, 0, 4540, 4542, 3, 540, 270,
		0, 4541, 4540, 1, 0, 0, 0, 4541, 4542, 1, 0, 0, 0, 4542, 4606, 1, 0, 0,
		0, 4543, 4606, 5, 116, 0, 0, 4544, 4546, 5, 586, 0, 0, 4545, 4547, 3, 550,
		275, 0, 4546, 4545, 1, 0, 0, 0, 4546, 4547, 1, 0, 0, 0, 4547, 4606, 1,
		0, 0, 0, 4548, 4550, 5, 583, 0, 0, 4549, 4551, 3, 550, 275, 0, 4550, 4549,
		1, 0, 0, 0, 4550, 4551, 1, 0, 0, 0, 4551, 4606, 1, 0, 0, 0, 4552, 4554,
		5, 113, 0, 0, 4553, 4555, 3, 550, 275, 0, 4554, 4553, 1, 0, 0, 0, 4554,
		4555, 1, 0, 0, 0, 4555, 4606, 1, 0, 0, 0, 4556, 4606, 5, 587, 0, 0, 4557,
		4559, 5, 39, 0, 0, 4558, 4560, 3, 538, 269, 0, 4559, 4558, 1, 0, 0, 0,
		4559, 4560, 1, 0, 0, 0, 4560, 4606, 1, 0, 0, 0, 4561, 4606, 7, 83, 0, 0,
		4562, 4563, 5, 293, 0, 0, 4563, 4606, 5, 628, 0, 0, 4564, 4568, 5, 293,
		0, 0, 4565, 4566, 5, 60, 0, 0, 4566, 4569, 5, 633, 0, 0, 4567, 4569, 5,
		629, 0, 0, 4568, 4565, 1, 0, 0, 0, 4568, 4567, 1, 0, 0, 0, 4568, 4569,
		1, 0, 0, 0, 4569, 4571, 1, 0, 0, 0, 4570, 4572, 3, 542, 271, 0, 4571, 4570,
		1, 0, 0, 0, 4571, 4572, 1, 0, 0, 0, 4572, 4606, 1, 0, 0, 0, 4573, 4575,
		5, 589, 0, 0, 4574, 4576, 3, 542, 271, 0, 4575, 4574, 1, 0, 0, 0, 4575,
		4576, 1, 0, 0, 0, 4576, 4606, 1, 0, 0, 0, 4577, 4579, 5, 580, 0, 0, 4578,
		4580, 3, 538, 269, 0, 4579, 4578, 1, 0, 0, 0, 4579, 4580, 1, 0, 0, 0, 4580,
		4582, 1, 0, 0, 0, 4581, 4583, 3, 542, 271, 0, 4582, 4581, 1, 0, 0, 0, 4582,
		4583, 1, 0, 0, 0, 4583, 4606, 1, 0, 0, 0, 4584, 4586, 5, 332, 0, 0, 4585,
		4587, 3, 542, 271, 0, 4586, 4585, 1, 0, 0, 0, 4586, 4587, 1, 0, 0, 0, 4587,
		4606, 1, 0, 0, 0, 4588, 4590, 5, 291, 0, 0, 4589, 4591, 3, 542, 271, 0,
		4590, 4589, 1, 0, 0, 0, 4590, 4591, 1, 0, 0, 0, 4591, 4606, 1, 0, 0, 0,
		4592, 4593, 5, 164, 0, 0, 4593, 4595, 3, 768, 384, 0, 4594, 4596, 3, 542,
		271, 0, 4595, 4594, 1, 0, 0, 0, 4595, 4596, 1, 0, 0, 0, 4596, 4606, 1,
		0, 0, 0, 4597, 4598, 5, 506, 0, 0, 4598, 4600, 3, 768, 384, 0, 4599, 4601,
		3, 542, 271, 0, 4600, 4599, 1, 0, 0, 0, 4600, 4601, 1, 0, 0, 0, 4601, 4606,
		1, 0, 0, 0, 4602, 4606, 5, 501, 0, 0, 4603, 4606, 5, 262, 0, 0, 4604, 4606,
		7, 84, 0, 0, 4605, 4459, 1, 0, 0, 0, 4605, 4471, 1, 0, 0, 0, 4605, 4479,
		1, 0, 0, 0, 4605, 4486, 1, 0, 0, 0, 4605, 4490, 1, 0, 0, 0, 4605, 4491,
		1, 0, 0, 0, 4605, 4498, 1, 0, 0, 0, 4605, 4505, 1, 0, 0, 0, 4605, 4512,
		1, 0, 0, 0, 4605, 4528, 1, 0, 0, 0, 4605, 4534, 1, 0, 0, 0, 4605, 4536,
		1, 0, 0, 0, 4605, 4543, 1, 0, 0, 0, 4605, 4544, 1, 0, 0, 0, 4605, 4548,
		1, 0, 0, 0, 4605, 4552, 1, 0, 0, 0, 4605, 4556, 1, 0, 0, 0, 4605, 4557,
		1, 0, 0, 0, 4605, 4561, 1, 0, 0, 0, 4605, 4562, 1, 0, 0, 0, 4605, 4564,
		1, 0, 0, 0, 4605, 4573, 1, 0, 0, 0, 4605, 4577, 1, 0, 0, 0, 4605, 4584,
		1, 0, 0, 0, 4605, 4588, 1, 0, 0, 0, 4605, 4592, 1, 0, 0, 0, 4605, 4597,
		1, 0, 0, 0, 4605, 4602, 1, 0, 0, 0, 4605, 4603, 1, 0, 0, 0, 4605, 4604,
		1, 0, 0, 0, 4606, 533, 1, 0, 0, 0, 4607, 4611, 5, 361, 0, 0, 4608, 4609,
		5, 358, 0, 0, 4609, 4611, 5, 60, 0, 0, 4610, 4607, 1, 0, 0, 0, 4610, 4608,
		1, 0, 0, 0, 4611, 535, 1, 0, 0, 0, 4612, 4618, 5, 437, 0, 0, 4613, 4615,
		5, 146, 0, 0, 4614, 4616, 5, 416, 0, 0, 4615, 4614, 1, 0, 0, 0, 4615, 4616,
		1, 0, 0, 0, 4616, 4618, 1, 0, 0, 0, 4617, 4612, 1, 0, 0, 0, 4617, 4613,
		1, 0, 0, 0, 4618, 537, 1, 0, 0, 0, 4619, 4622, 5, 776, 0, 0, 4620, 4623,
		3, 762, 381, 0, 4621, 4623, 5, 790, 0, 0, 4622, 4620, 1, 0, 0, 0, 4622,
		4621, 1, 0, 0, 0, 4623, 4624, 1, 0, 0, 0, 4624, 4625, 5, 777, 0, 0, 4625,
		539, 1, 0, 0, 0, 4626, 4628, 7, 85, 0, 0, 4627, 4626, 1, 0, 0, 0, 4628,
		4629, 1, 0, 0, 0, 4629, 4627, 1, 0, 0, 0, 4629, 4630, 1, 0, 0, 0, 4630,
		541, 1, 0, 0, 0, 4631, 4646, 3, 544, 272, 0, 4632, 4646, 3, 546, 273, 0,
		4633, 4646, 5, 46, 0, 0, 4634, 4635, 3, 470, 235, 0, 4635, 4637, 3, 552,
		276, 0, 4636, 4638, 5, 32, 0, 0, 4637, 4636, 1, 0, 0, 0, 4637, 4638, 1,
		0, 0, 0, 4638, 4646, 1, 0, 0, 0, 4639, 4643, 5, 32, 0, 0, 4640, 4641, 3,
		470, 235, 0, 4641, 4642, 3, 552, 276, 0, 4642, 4644, 1, 0, 0, 0, 4643,
		4640, 1, 0, 0, 0, 4643, 4644, 1, 0, 0, 0, 4644, 4646, 1, 0, 0, 0, 4645,
		4631, 1, 0, 0, 0, 4645, 4632, 1, 0, 0, 0, 4645, 4633, 1, 0, 0, 0, 4645,
		4634, 1, 0, 0, 0, 4645, 4639, 1, 0, 0, 0, 4646, 543, 1, 0, 0, 0, 4647,
		4649, 5, 19, 0, 0, 4648, 4650, 5, 32, 0, 0, 4649, 4648, 1, 0, 0, 0, 4649,
		4650, 1, 0, 0, 0, 4650, 4654, 1, 0, 0, 0, 4651, 4652, 5, 32, 0, 0, 4652,
		4654, 5, 19, 0, 0, 4653, 4647, 1, 0, 0, 0, 4653, 4651, 1, 0, 0, 0, 4654,
		545, 1, 0, 0, 0, 4655, 4657, 5, 606, 0, 0, 4656, 4658, 5, 32, 0, 0, 4657,
		4656, 1, 0, 0, 0, 4657, 4658, 1, 0, 0, 0, 4658, 4662, 1, 0, 0, 0, 4659,
		4660, 5, 32, 0, 0, 4660, 4662, 5, 606, 0, 0, 4661, 4655, 1, 0, 0, 0, 4661,
		4659, 1, 0, 0, 0, 4662, 547, 1, 0, 0, 0, 4663, 4664, 5, 776, 0, 0, 4664,
		4665, 3, 758, 379, 0, 4665, 4666, 5, 777, 0, 0, 4666, 549, 1, 0, 0, 0,
		4667, 4668, 5, 776, 0, 0, 4668, 4669, 5, 747, 0, 0, 4669, 4670, 5, 777,
		0, 0, 4670, 551, 1, 0, 0, 0, 4671, 4675, 3, 796, 398, 0, 4672, 4675, 5,
		32, 0, 0, 4673, 4675, 5, 128, 0, 0, 4674, 4671, 1, 0, 0, 0, 4674, 4672,
		1, 0, 0, 0, 4674, 4673, 1, 0, 0, 0, 4675, 553, 1, 0, 0, 0, 4676, 4680,
		3, 796, 398, 0, 4677, 4680, 5, 128, 0, 0, 4678, 4680, 5, 32, 0, 0, 4679,
		4676, 1, 0, 0, 0, 4679, 4677, 1, 0, 0, 0, 4679, 4678, 1, 0, 0, 0, 4680,
		555, 1, 0, 0, 0, 4681, 4688, 3, 560, 280, 0, 4682, 4684, 5, 773, 0, 0,
		4683, 4682, 1, 0, 0, 0, 4683, 4684, 1, 0, 0, 0, 4684, 4685, 1, 0, 0, 0,
		4685, 4687, 3, 560, 280, 0, 4686, 4683, 1, 0, 0, 0, 4687, 4690, 1, 0, 0,
		0, 4688, 4686, 1, 0, 0, 0, 4688, 4689, 1, 0, 0, 0, 4689, 557, 1, 0, 0,
		0, 4690, 4688, 1, 0, 0, 0, 4691, 4693, 3, 560, 280, 0, 4692, 4691, 1, 0,
		0, 0, 4693, 4694, 1, 0, 0, 0, 4694, 4692, 1, 0, 0, 0, 4694, 4695, 1, 0,
		0, 0, 4695, 559, 1, 0, 0, 0, 4696, 4698, 5, 163, 0, 0, 4697, 4699, 5, 750,
		0, 0, 4698, 4697, 1, 0, 0, 0, 4698, 4699, 1, 0, 0, 0, 4699, 4700, 1, 0,
		0, 0, 4700, 4824, 3, 710, 355, 0, 4701, 4703, 5, 721, 0, 0, 4702, 4704,
		3, 806, 403, 0, 4703, 4702, 1, 0, 0, 0, 4703, 4704, 1, 0, 0, 0, 4704, 4707,
		1, 0, 0, 0, 4705, 4708, 5, 376, 0, 0, 4706, 4708, 3, 796, 398, 0, 4707,
		4705, 1, 0, 0, 0, 4707, 4706, 1, 0, 0, 0, 4708, 4824, 1, 0, 0, 0, 4709,
		4711, 5, 323, 0, 0, 4710, 4712, 5, 750, 0, 0, 4711, 4710, 1, 0, 0, 0, 4711,
		4712, 1, 0, 0, 0, 4712, 4713, 1, 0, 0, 0, 4713, 4824, 3, 760, 380, 0, 4714,
		4716, 5, 344, 0, 0, 4715, 4717, 5, 750, 0, 0, 4716, 4715, 1, 0, 0, 0, 4716,
		4717, 1, 0, 0, 0, 4717, 4718, 1, 0, 0, 0, 4718, 4824, 3, 760, 380, 0, 4719,
		4721, 5, 25, 0, 0, 4720, 4722, 5, 750, 0, 0, 4721, 4720, 1, 0, 0, 0, 4721,
		4722, 1, 0, 0, 0, 4722, 4723, 1, 0, 0, 0, 4723, 4824, 3, 756, 378, 0, 4724,
		4726, 5, 406, 0, 0, 4725, 4727, 5, 750, 0, 0, 4726, 4725, 1, 0, 0, 0, 4726,
		4727, 1, 0, 0, 0, 4727, 4728, 1, 0, 0, 0, 4728, 4824, 3, 770, 385, 0, 4729,
		4731, 5, 75, 0, 0, 4730, 4732, 5, 750, 0, 0, 4731, 4730, 1, 0, 0, 0, 4731,
		4732, 1, 0, 0, 0, 4732, 4733, 1, 0, 0, 0, 4733, 4824, 3, 770, 385, 0, 4734,
		4736, 5, 81, 0, 0, 4735, 4737, 5, 750, 0, 0, 4736, 4735, 1, 0, 0, 0, 4736,
		4737, 1, 0, 0, 0, 4737, 4738, 1, 0, 0, 0, 4738, 4824, 3, 772, 386, 0, 4739,
		4741, 5, 158, 0, 0, 4740, 4742, 5, 750, 0, 0, 4741, 4740, 1, 0, 0, 0, 4741,
		4742, 1, 0, 0, 0, 4742, 4743, 1, 0, 0, 0, 4743, 4824, 3, 772, 386, 0, 4744,
		4746, 5, 24, 0, 0, 4745, 4747, 5, 750, 0, 0, 4746, 4745, 1, 0, 0, 0, 4746,
		4747, 1, 0, 0, 0, 4747, 4748, 1, 0, 0, 0, 4748, 4824, 3, 760, 380, 0, 4749,
		4751, 5, 399, 0, 0, 4750, 4752, 5, 750, 0, 0, 4751, 4750, 1, 0, 0, 0, 4751,
		4752, 1, 0, 0, 0, 4752, 4753, 1, 0, 0, 0, 4753, 4824, 3, 562, 281, 0, 4754,
		4756, 7, 86, 0, 0, 4755, 4757, 5, 750, 0, 0, 4756, 4755, 1, 0, 0, 0, 4756,
		4757, 1, 0, 0, 0, 4757, 4758, 1, 0, 0, 0, 4758, 4824, 3, 562, 281, 0, 4759,
		4761, 7, 87, 0, 0, 4760, 4762, 5, 750, 0, 0, 4761, 4760, 1, 0, 0, 0, 4761,
		4762, 1, 0, 0, 0, 4762, 4763, 1, 0, 0, 0, 4763, 4824, 3, 756, 378, 0, 4764,
		4766, 5, 132, 0, 0, 4765, 4767, 5, 750, 0, 0, 4766, 4765, 1, 0, 0, 0, 4766,
		4767, 1, 0, 0, 0, 4767, 4768, 1, 0, 0, 0, 4768, 4824, 3, 756, 378, 0, 4769,
		4771, 5, 486, 0, 0, 4770, 4772, 5, 750, 0, 0, 4771, 4770, 1, 0, 0, 0, 4771,
		4772, 1, 0, 0, 0, 4772, 4773, 1, 0, 0, 0, 4773, 4824, 7, 88, 0, 0, 4774,
		4776, 5, 608, 0, 0, 4775, 4777, 5, 750, 0, 0, 4776, 4775, 1, 0, 0, 0, 4776,
		4777, 1, 0, 0, 0, 4777, 4778, 1, 0, 0, 0, 4778, 4779, 5, 776, 0, 0, 4779,
		4780, 3, 720, 360, 0, 4780, 4781, 5, 777, 0, 0, 4781, 4824, 1, 0, 0, 0,
		4782, 4824, 3, 568, 284, 0, 4783, 4824, 3, 564, 282, 0, 4784, 4786, 5,
		243, 0, 0, 4785, 4787, 5, 750, 0, 0, 4786, 4785, 1, 0, 0, 0, 4786, 4787,
		1, 0, 0, 0, 4787, 4788, 1, 0, 0, 0, 4788, 4824, 7, 89, 0, 0, 4789, 4790,
		5, 112, 0, 0, 4790, 4792, 5, 139, 0, 0, 4791, 4793, 5, 750, 0, 0, 4792,
		4791, 1, 0, 0, 0, 4792, 4793, 1, 0, 0, 0, 4793, 4794, 1, 0, 0, 0, 4794,
		4824, 3, 772, 386, 0, 4795, 4796, 5, 236, 0, 0, 4796, 4798, 5, 139, 0,
		0, 4797, 4799, 5, 750, 0, 0, 4798, 4797, 1, 0, 0, 0, 4798, 4799, 1, 0,
		0, 0, 4799, 4800, 1, 0, 0, 0, 4800, 4824, 3, 772, 386, 0, 4801, 4806, 5,
		572, 0, 0, 4802, 4804, 5, 750, 0, 0, 4803, 4802, 1, 0, 0, 0, 4803, 4804,
		1, 0, 0, 0, 4804, 4807, 1, 0, 0, 0, 4805, 4807, 1, 0, 0, 0, 4806, 4803,
		1, 0, 0, 0, 4806, 4805, 1, 0, 0, 0, 4807, 4808, 1, 0, 0, 0, 4808, 4824,
		3, 744, 372, 0, 4809, 4810, 5, 553, 0, 0, 4810, 4824, 7, 90, 0, 0, 4811,
		4813, 5, 84, 0, 0, 4812, 4814, 5, 750, 0, 0, 4813, 4812, 1, 0, 0, 0, 4813,
		4814, 1, 0, 0, 0, 4814, 4815, 1, 0, 0, 0, 4815, 4824, 3, 772, 386, 0, 4816,
		4818, 5, 264, 0, 0, 4817, 4819, 5, 750, 0, 0, 4818, 4817, 1, 0, 0, 0, 4818,
		4819, 1, 0, 0, 0, 4819, 4820, 1, 0, 0, 0, 4820, 4824, 3, 756, 378, 0, 4821,
		4822, 5, 543, 0, 0, 4822, 4824, 5, 592, 0, 0, 4823, 4696, 1, 0, 0, 0, 4823,
		4701, 1, 0, 0, 0, 4823, 4709, 1, 0, 0, 0, 4823, 4714, 1, 0, 0, 0, 4823,
		4719, 1, 0, 0, 0, 4823, 4724, 1, 0, 0, 0, 4823, 4729, 1, 0, 0, 0, 4823,
		4734, 1, 0, 0, 0, 4823, 4739, 1, 0, 0, 0, 4823, 4744, 1, 0, 0, 0, 4823,
		4749, 1, 0, 0, 0, 4823, 4754, 1, 0, 0, 0, 4823, 4759, 1, 0, 0, 0, 4823,
		4764, 1, 0, 0, 0, 4823, 4769, 1, 0, 0, 0, 4823, 4774, 1, 0, 0, 0, 4823,
		4782, 1, 0, 0, 0, 4823, 4783, 1, 0, 0, 0, 4823, 4784, 1, 0, 0, 0, 4823,
		4789, 1, 0, 0, 0, 4823, 4795, 1, 0, 0, 0, 4823, 4801, 1, 0, 0, 0, 4823,
		4809, 1, 0, 0, 0, 4823, 4811, 1, 0, 0, 0, 4823, 4816, 1, 0, 0, 0, 4823,
		4821, 1, 0, 0, 0, 4824, 561, 1, 0, 0, 0, 4825, 4828, 3, 756, 378, 0, 4826,
		4828, 5, 128, 0, 0, 4827, 4825, 1, 0, 0, 0, 4827, 4826, 1, 0, 0, 0, 4828,
		563, 1, 0, 0, 0, 4829, 4831, 5, 128, 0, 0, 4830, 4829, 1, 0, 0, 0, 4830,
		4831, 1, 0, 0, 0, 4831, 4832, 1, 0, 0, 0, 4832, 4834, 5, 69, 0, 0, 4833,
		4835, 5, 750, 0, 0, 4834, 4833, 1, 0, 0, 0, 4834, 4835, 1, 0, 0, 0, 4835,
		4836, 1, 0, 0, 0, 4836, 4837, 3, 554, 277, 0, 4837, 565, 1, 0, 0, 0, 4838,
		4840, 5, 128, 0, 0, 4839, 4838, 1, 0, 0, 0, 4839, 4840, 1, 0, 0, 0, 4840,
		4841, 1, 0, 0, 0, 4841, 4843, 5, 158, 0, 0, 4842, 4844, 5, 750, 0, 0, 4843,
		4842, 1, 0, 0, 0, 4843, 4844, 1, 0, 0, 0, 4844, 4845, 1, 0, 0, 0, 4845,
		4846, 3, 770, 385, 0, 4846, 567, 1, 0, 0, 0, 4847, 4849, 5, 128, 0, 0,
		4848, 4847, 1, 0, 0, 0, 4848, 4849, 1, 0, 0, 0, 4849, 4850, 1, 0, 0, 0,
		4850, 4852, 3, 470, 235, 0, 4851, 4853, 5, 750, 0, 0, 4852, 4851, 1, 0,
		0, 0, 4852, 4853, 1, 0, 0, 0, 4853, 4854, 1, 0, 0, 0, 4854, 4855, 3, 552,
		276, 0, 4855, 569, 1, 0, 0, 0, 4856, 4857, 5, 405, 0, 0, 4857, 4858, 5,
		45, 0, 0, 4858, 4861, 3, 572, 286, 0, 4859, 4860, 5, 404, 0, 0, 4860, 4862,
		3, 758, 379, 0, 4861, 4859, 1, 0, 0, 0, 4861, 4862, 1, 0, 0, 0, 4862, 4864,
		1, 0, 0, 0, 4863, 4865, 3, 574, 287, 0, 4864, 4863, 1, 0, 0, 0, 4864, 4865,
		1, 0, 0, 0, 4865, 4867, 1, 0, 0, 0, 4866, 4868, 3, 578, 289, 0, 4867, 4866,
		1, 0, 0, 0, 4867, 4868, 1, 0, 0, 0, 4868, 571, 1, 0, 0, 0, 4869, 4871,
		5, 277, 0, 0, 4870, 4869, 1, 0, 0, 0, 4870, 4871, 1, 0, 0, 0, 4871, 4872,
		1, 0, 0, 0, 4872, 4874, 5, 265, 0, 0, 4873, 4875, 3, 576, 288, 0, 4874,
		4873, 1, 0, 0, 0, 4874, 4875, 1, 0, 0, 0, 4875, 4876, 1, 0, 0, 0, 4876,
		4878, 5, 776, 0, 0, 4877, 4879, 3, 746, 373, 0, 4878, 4877, 1, 0, 0, 0,
		4878, 4879, 1, 0, 0, 0, 4879, 4880, 1, 0, 0, 0, 4880, 4903, 5, 777, 0,
		0, 4881, 4883, 5, 277, 0, 0, 4882, 4881, 1, 0, 0, 0, 4882, 4883, 1, 0,
		0, 0, 4883, 4884, 1, 0, 0, 0, 4884, 4885, 5, 220, 0, 0, 4885, 4886, 5,
		776, 0, 0, 4886, 4887, 3, 390, 195, 0, 4887, 4888, 5, 777, 0, 0, 4888,
		4903, 1, 0, 0, 0, 4889, 4900, 7, 91, 0, 0, 4890, 4891, 5, 776, 0, 0, 4891,
		4892, 3, 390, 195, 0, 4892, 4893, 5, 777, 0, 0, 4893, 4901, 1, 0, 0, 0,
		4894, 4895, 5, 71, 0, 0, 4895, 4897, 5, 776, 0, 0, 4896, 4898, 3, 746,
		373, 0, 4897, 4896, 1, 0, 0, 0, 4897, 4898, 1, 0, 0, 0, 4898, 4899, 1,
		0, 0, 0, 4899, 4901, 5, 777, 0, 0, 4900, 4890, 1, 0, 0, 0, 4900, 4894,
		1, 0, 0, 0, 4901, 4903, 1, 0, 0, 0, 4902, 4870, 1, 0, 0, 0, 4902, 4882,
		1, 0, 0, 0, 4902, 4889, 1, 0, 0, 0, 4903, 573, 1, 0, 0, 0, 4904, 4905,
		5, 561, 0, 0, 4905, 4907, 5, 45, 0, 0, 4906, 4908, 5, 277, 0, 0, 4907,
		4906, 1, 0, 0, 0, 4907, 4908, 1, 0, 0, 0, 4908, 4919, 1, 0, 0, 0, 4909,
		4910, 5, 220, 0, 0, 4910, 4911, 5, 776, 0, 0, 4911, 4912, 3, 390, 195,
		0, 4912, 4913, 5, 777, 0, 0, 4913, 4920, 1, 0, 0, 0, 4914, 4916, 5, 265,
		0, 0, 4915, 4917, 3, 576, 288, 0, 4916, 4915, 1, 0, 0, 0, 4916, 4917, 1,
		0, 0, 0, 4917, 4918, 1, 0, 0, 0, 4918, 4920, 3, 748, 374, 0, 4919, 4909,
		1, 0, 0, 0, 4919, 4914, 1, 0, 0, 0, 4920, 4923, 1, 0, 0, 0, 4921, 4922,
		5, 560, 0, 0, 4922, 4924, 3, 758, 379, 0, 4923, 4921, 1, 0, 0, 0, 4923,
		4924, 1, 0, 0, 0, 4924, 575, 1, 0, 0, 0, 4925, 4926, 5, 9, 0, 0, 4926,
		4927, 5, 750, 0, 0, 4927, 4928, 3, 758, 379, 0, 4928, 577, 1, 0, 0, 0,
		4929, 4930, 5, 776, 0, 0, 4930, 4935, 3, 580, 290, 0, 4931, 4932, 5, 773,
		0, 0, 4932, 4934, 3, 580, 290, 0, 4933, 4931, 1, 0, 0, 0, 4934, 4937, 1,
		0, 0, 0, 4935, 4933, 1, 0, 0, 0, 4935, 4936, 1, 0, 0, 0, 4936, 4938, 1,
		0, 0, 0, 4937, 4935, 1, 0, 0, 0, 4938, 4939, 5, 777, 0, 0, 4939, 579, 1,
		0, 0, 0, 4940, 4941, 5, 405, 0, 0, 4941, 4952, 3, 744, 372, 0, 4942, 4943,
		5, 626, 0, 0, 4943, 4944, 5, 273, 0, 0, 4944, 4947, 5, 581, 0, 0, 4945,
		4948, 3, 588, 294, 0, 4946, 4948, 5, 329, 0, 0, 4947, 4945, 1, 0, 0, 0,
		4947, 4946, 1, 0, 0, 0, 4948, 4953, 1, 0, 0, 0, 4949, 4950, 5, 626, 0,
		0, 4950, 4951, 5, 251, 0, 0, 4951, 4953, 3, 582, 291, 0, 4952, 4942, 1,
		0, 0, 0, 4952, 4949, 1, 0, 0, 0, 4952, 4953, 1, 0, 0, 0, 4953, 4957, 1,
		0, 0, 0, 4954, 4956, 3, 584, 292, 0, 4955, 4954, 1, 0, 0, 0, 4956, 4959,
		1, 0, 0, 0, 4957, 4955, 1, 0, 0, 0, 4957, 4958, 1, 0, 0, 0, 4958, 4971,
		1, 0, 0, 0, 4959, 4957, 1, 0, 0, 0, 4960, 4961, 5, 776, 0, 0, 4961, 4966,
		3, 586, 293, 0, 4962, 4963, 5, 773, 0, 0, 4963, 4965, 3, 586, 293, 0, 4964,
		4962, 1, 0, 0, 0, 4965, 4968, 1, 0, 0, 0, 4966, 4964, 1, 0, 0, 0, 4966,
		4967, 1, 0, 0, 0, 4967, 4969, 1, 0, 0, 0, 4968, 4966, 1, 0, 0, 0, 4969,
		4970, 5, 777, 0, 0, 4970, 4972, 1, 0, 0, 0, 4971, 4960, 1, 0, 0, 0, 4971,
		4972, 1, 0, 0, 0, 4972, 581, 1, 0, 0, 0, 4973, 4986, 3, 588, 294, 0, 4974,
		4975, 5, 776, 0, 0, 4975, 4980, 3, 588, 294, 0, 4976, 4977, 5, 773, 0,
		0, 4977, 4979, 3, 588, 294, 0, 4978, 4976, 1, 0, 0, 0, 4979, 4982, 1, 0,
		0, 0, 4980, 4978, 1, 0, 0, 0, 4980, 4981, 1, 0, 0, 0, 4981, 4983, 1, 0,
		0, 0, 4982, 4980, 1, 0, 0, 0, 4983, 4984, 5, 777, 0, 0, 4984, 4986, 1,
		0, 0, 0, 4985, 4973, 1, 0, 0, 0, 4985, 4974, 1, 0, 0, 0, 4986, 583, 1,
		0, 0, 0, 4987, 4989, 5, 572, 0, 0, 4988, 4990, 5, 750, 0, 0, 4989, 4988,
		1, 0, 0, 0, 4989, 4990, 1, 0, 0, 0, 4990, 4991, 1, 0, 0, 0, 4991, 5022,
		3, 744, 372, 0, 4992, 4994, 5, 553, 0, 0, 4993, 4992, 1, 0, 0, 0, 4993,
		4994, 1, 0, 0, 0, 4994, 4995, 1, 0, 0, 0, 4995, 4997, 5, 163, 0, 0, 4996,
		4998, 5, 750, 0, 0, 4997, 4996, 1, 0, 0, 0, 4997, 4998, 1, 0, 0, 0, 4998,
		4999, 1, 0, 0, 0, 4999, 5022, 3, 710, 355, 0, 5000, 5002, 5, 368, 0, 0,
		5001, 5003, 5, 750, 0, 0, 5002, 5001, 1, 0, 0, 0, 5002, 5003, 1, 0, 0,
		0, 5003, 5004, 1, 0, 0, 0, 5004, 5022, 3, 758, 379, 0, 5005, 5007, 7, 92,
		0, 0, 5006, 5008, 5, 750, 0, 0, 5007, 5006, 1, 0, 0, 0, 5007, 5008, 1,
		0, 0, 0, 5008, 5009, 1, 0, 0, 0, 5009, 5022, 3, 758, 379, 0, 5010, 5011,
		7, 93, 0, 0, 5011, 5013, 5, 139, 0, 0, 5012, 5014, 5, 750, 0, 0, 5013,
		5012, 1, 0, 0, 0, 5013, 5014, 1, 0, 0, 0, 5014, 5015, 1, 0, 0, 0, 5015,
		5022, 3, 776, 388, 0, 5016, 5018, 5, 75, 0, 0, 5017, 5019, 5, 750, 0, 0,
		5018, 5017, 1, 0, 0, 0, 5018, 5019, 1, 0, 0, 0, 5019, 5020, 1, 0, 0, 0,
		5020, 5022, 3, 776, 388, 0, 5021, 4987, 1, 0, 0, 0, 5021, 4993, 1, 0, 0,
		0, 5021, 5000, 1, 0, 0, 0, 5021, 5005, 1, 0, 0, 0, 5021, 5010, 1, 0, 0,
		0, 5021, 5016, 1, 0, 0, 0, 5022, 585, 1, 0, 0, 0, 5023, 5024, 5, 561, 0,
		0, 5024, 5028, 3, 796, 398, 0, 5025, 5027, 3, 584, 292, 0, 5026, 5025,
		1, 0, 0, 0, 5027, 5030, 1, 0, 0, 0, 5028, 5026, 1, 0, 0, 0, 5028, 5029,
		1, 0, 0, 0, 5029, 587, 1, 0, 0, 0, 5030, 5028, 1, 0, 0, 0, 5031, 5032,
		5, 776, 0, 0, 5032, 5037, 3, 590, 295, 0, 5033, 5034, 5, 773, 0, 0, 5034,
		5036, 3, 590, 295, 0, 5035, 5033, 1, 0, 0, 0, 5036, 5039, 1, 0, 0, 0, 5037,
		5035, 1, 0, 0, 0, 5037, 5038, 1, 0, 0, 0, 5038, 5040, 1, 0, 0, 0, 5039,
		5037, 1, 0, 0, 0, 5040, 5041, 5, 777, 0, 0, 5041, 589, 1, 0, 0, 0, 5042,
		5045, 3, 390, 195, 0, 5043, 5045, 5, 329, 0, 0, 5044, 5042, 1, 0, 0, 0,
		5044, 5043, 1, 0, 0, 0, 5045, 591, 1, 0, 0, 0, 5046, 5047, 5, 130, 0, 0,
		5047, 5048, 5, 750, 0, 0, 5048, 5049, 3, 642, 321, 0, 5049, 593, 1, 0,
		0, 0, 5050, 5051, 5, 231, 0, 0, 5051, 5052, 5, 174, 0, 0, 5052, 595, 1,
		0, 0, 0, 5053, 5054, 5, 231, 0, 0, 5054, 5055, 3, 472, 236, 0, 5055, 5056,
		5, 174, 0, 0, 5056, 597, 1, 0, 0, 0, 5057, 5059, 7, 94, 0, 0, 5058, 5057,
		1, 0, 0, 0, 5058, 5059, 1, 0, 0, 0, 5059, 5060, 1, 0, 0, 0, 5060, 5061,
		3, 600, 300, 0, 5061, 599, 1, 0, 0, 0, 5062, 5063, 3, 724, 362, 0, 5063,
		5064, 3, 604, 302, 0, 5064, 601, 1, 0, 0, 0, 5065, 5066, 5, 69, 0, 0, 5066,
		5067, 3, 554, 277, 0, 5067, 603, 1, 0, 0, 0, 5068, 5070, 3, 532, 266, 0,
		5069, 5071, 3, 602, 301, 0, 5070, 5069, 1, 0, 0, 0, 5070, 5071, 1, 0, 0,
		0, 5071, 605, 1, 0, 0, 0, 5072, 5073, 5, 776, 0, 0, 5073, 5074, 3, 674,
		337, 0, 5074, 5075, 5, 773, 0, 0, 5075, 5076, 3, 674, 337, 0, 5076, 5077,
		5, 777, 0, 0, 5077, 607, 1, 0, 0, 0, 5078, 5083, 3, 690, 345, 0, 5079,
		5080, 5, 773, 0, 0, 5080, 5082, 3, 690, 345, 0, 5081, 5079, 1, 0, 0, 0,
		5082, 5085, 1, 0, 0, 0, 5083, 5081, 1, 0, 0, 0, 5083, 5084, 1, 0, 0, 0,
		5084, 609, 1, 0, 0, 0, 5085, 5083, 1, 0, 0, 0, 5086, 5091, 3, 612, 306,
		0, 5087, 5088, 5, 773, 0, 0, 5088, 5090, 3, 612, 306, 0, 5089, 5087, 1,
		0, 0, 0, 5090, 5093, 1, 0, 0, 0, 5091, 5089, 1, 0, 0, 0, 5091, 5092, 1,
		0, 0, 0, 5092, 611, 1, 0, 0, 0, 5093, 5091, 1, 0, 0, 0, 5094, 5095, 3,
		662, 331, 0, 5095, 5098, 5, 750, 0, 0, 5096, 5099, 3, 380, 190, 0, 5097,
		5099, 5, 128, 0, 0, 5098, 5096, 1, 0, 0, 0, 5098, 5097, 1, 0, 0, 0, 5099,
		613, 1, 0, 0, 0, 5100, 5101, 3, 470, 235, 0, 5101, 5102, 3, 552, 276, 0,
		5102, 615, 1, 0, 0, 0, 5103, 5105, 5, 71, 0, 0, 5104, 5106, 3, 618, 309,
		0, 5105, 5104, 1, 0, 0, 0, 5106, 5107, 1, 0, 0, 0, 5107, 5105, 1, 0, 0,
		0, 5107, 5108, 1, 0, 0, 0, 5108, 617, 1, 0, 0, 0, 5109, 5110, 5, 579, 0,
		0, 5110, 5111, 5, 45, 0, 0, 5111, 5122, 3, 772, 386, 0, 5112, 5114, 5,
		392, 0, 0, 5113, 5112, 1, 0, 0, 0, 5113, 5114, 1, 0, 0, 0, 5114, 5115,
		1, 0, 0, 0, 5115, 5116, 5, 157, 0, 0, 5116, 5117, 5, 45, 0, 0, 5117, 5122,
		3, 772, 386, 0, 5118, 5119, 5, 167, 0, 0, 5119, 5120, 5, 45, 0, 0, 5120,
		5122, 3, 772, 386, 0, 5121, 5109, 1, 0, 0, 0, 5121, 5113, 1, 0, 0, 0, 5121,
		5118, 1, 0, 0, 0, 5122, 619, 1, 0, 0, 0, 5123, 5125, 5, 278, 0, 0, 5124,
		5126, 3, 622, 311, 0, 5125, 5124, 1, 0, 0, 0, 5126, 5127, 1, 0, 0, 0, 5127,
		5125, 1, 0, 0, 0, 5127, 5128, 1, 0, 0, 0, 5128, 621, 1, 0, 0, 0, 5129,
		5130, 7, 95, 0, 0, 5130, 5131, 5, 45, 0, 0, 5131, 5132, 3, 772, 386, 0,
		5132, 623, 1, 0, 0, 0, 5133, 5138, 3, 642, 321, 0, 5134, 5135, 5, 773,
		0, 0, 5135, 5137, 3, 642, 321, 0, 5136, 5134, 1, 0, 0, 0, 5137, 5140, 1,
		0, 0, 0, 5138, 5136, 1, 0, 0, 0, 5138, 5139, 1, 0, 0, 0, 5139, 625, 1,
		0, 0, 0, 5140, 5138, 1, 0, 0, 0, 5141, 5146, 3, 630, 315, 0, 5142, 5143,
		5, 773, 0, 0, 5143, 5145, 3, 630, 315, 0, 5144, 5142, 1, 0, 0, 0, 5145,
		5148, 1, 0, 0, 0, 5146, 5144, 1, 0, 0, 0, 5146, 5147, 1, 0, 0, 0, 5147,
		627, 1, 0, 0, 0, 5148, 5146, 1, 0, 0, 0, 5149, 5154, 3, 632, 316, 0, 5150,
		5151, 5, 773, 0, 0, 5151, 5153, 3, 632, 316, 0, 5152, 5150, 1, 0, 0, 0,
		5153, 5156, 1, 0, 0, 0, 5154, 5152, 1, 0, 0, 0, 5154, 5155, 1, 0, 0, 0,
		5155, 629, 1, 0, 0, 0, 5156, 5154, 1, 0, 0, 0, 5157, 5181, 3, 642, 321,
		0, 5158, 5179, 5, 230, 0, 0, 5159, 5161, 5, 45, 0, 0, 5160, 5162, 5, 406,
		0, 0, 5161, 5160, 1, 0, 0, 0, 5161, 5162, 1, 0, 0, 0, 5162, 5163, 1, 0,
		0, 0, 5163, 5180, 3, 772, 386, 0, 5164, 5165, 5, 645, 0, 0, 5165, 5170,
		3, 796, 398, 0, 5166, 5167, 5, 17, 0, 0, 5167, 5171, 3, 774, 387, 0, 5168,
		5169, 5, 45, 0, 0, 5169, 5171, 3, 772, 386, 0, 5170, 5166, 1, 0, 0, 0,
		5170, 5168, 1, 0, 0, 0, 5170, 5171, 1, 0, 0, 0, 5171, 5180, 1, 0, 0, 0,
		5172, 5173, 5, 645, 0, 0, 5173, 5175, 3, 796, 398, 0, 5174, 5172, 1, 0,
		0, 0, 5174, 5175, 1, 0, 0, 0, 5175, 5176, 1, 0, 0, 0, 5176, 5177, 5, 45,
		0, 0, 5177, 5178, 5, 734, 0, 0, 5178, 5180, 5, 406, 0, 0, 5179, 5159, 1,
		0, 0, 0, 5179, 5164, 1, 0, 0, 0, 5179, 5174, 1, 0, 0, 0, 5180, 5182, 1,
		0, 0, 0, 5181, 5158, 1, 0, 0, 0, 5181, 5182, 1, 0, 0, 0, 5182, 631, 1,
		0, 0, 0, 5183, 5212, 3, 642, 321, 0, 5184, 5207, 5, 230, 0, 0, 5185, 5186,
		5, 645, 0, 0, 5186, 5188, 3, 796, 398, 0, 5187, 5185, 1, 0, 0, 0, 5187,
		5188, 1, 0, 0, 0, 5188, 5189, 1, 0, 0, 0, 5189, 5190, 5, 45, 0, 0, 5190,
		5193, 3, 772, 386, 0, 5191, 5192, 5, 458, 0, 0, 5192, 5194, 3, 772, 386,
		0, 5193, 5191, 1, 0, 0, 0, 5193, 5194, 1, 0, 0, 0, 5194, 5196, 1, 0, 0,
		0, 5195, 5197, 3, 634, 317, 0, 5196, 5195, 1, 0, 0, 0, 5196, 5197, 1, 0,
		0, 0, 5197, 5208, 1, 0, 0, 0, 5198, 5199, 5, 645, 0, 0, 5199, 5205, 3,
		796, 398, 0, 5200, 5201, 5, 17, 0, 0, 5201, 5203, 3, 774, 387, 0, 5202,
		5204, 3, 634, 317, 0, 5203, 5202, 1, 0, 0, 0, 5203, 5204, 1, 0, 0, 0, 5204,
		5206, 1, 0, 0, 0, 5205, 5200, 1, 0, 0, 0, 5205, 5206, 1, 0, 0, 0, 5206,
		5208, 1, 0, 0, 0, 5207, 5187, 1, 0, 0, 0, 5207, 5198, 1, 0, 0, 0, 5207,
		5208, 1, 0, 0, 0, 5208, 5213, 1, 0, 0, 0, 5209, 5211, 3, 636, 318, 0, 5210,
		5209, 1, 0, 0, 0, 5210, 5211, 1, 0, 0, 0, 5211, 5213, 1, 0, 0, 0, 5212,
		5184, 1, 0, 0, 0, 5212, 5210, 1, 0, 0, 0, 5213, 633, 1, 0, 0, 0, 5214,
		5215, 5, 727, 0, 0, 5215, 5216, 5, 101, 0, 0, 5216, 5217, 5, 406, 0, 0,
		5217, 635, 1, 0, 0, 0, 5218, 5219, 5, 141, 0, 0, 5219, 5220, 5, 728, 0,
		0, 5220, 5221, 5, 406, 0, 0, 5221, 637, 1, 0, 0, 0, 5222, 5223, 5, 458,
		0, 0, 5223, 5224, 3, 772, 386, 0, 5224, 639, 1, 0, 0, 0, 5225, 5229, 3,
		796, 398, 0, 5226, 5227, 5, 783, 0, 0, 5227, 5230, 3, 796, 398, 0, 5228,
		5230, 5, 784, 0, 0, 5229, 5226, 1, 0, 0, 0, 5229, 5228, 1, 0, 0, 0, 5229,
		5230, 1, 0, 0, 0, 5230, 641, 1, 0, 0, 0, 5231, 5237, 3, 640, 320, 0, 5232,
		5234, 5, 105, 0, 0, 5233, 5235, 3, 804, 402, 0, 5234, 5233, 1, 0, 0, 0,
		5234, 5235, 1, 0, 0, 0, 5235, 5237, 1, 0, 0, 0, 5236, 5231, 1, 0, 0, 0,
		5236, 5232, 1, 0, 0, 0, 5237, 643, 1, 0, 0, 0, 5238, 5239, 5, 275, 0, 0,
		5239, 5240, 3, 770, 385, 0, 5240, 645, 1, 0, 0, 0, 5241, 5244, 3, 644,
		322, 0, 5242, 5244, 3, 106, 53, 0, 5243, 5241, 1, 0, 0, 0, 5243, 5242,
		1, 0, 0, 0, 5244, 647, 1, 0, 0, 0, 5245, 5246, 7, 96, 0, 0, 5246, 649,
		1, 0, 0, 0, 5247, 5248, 7, 97, 0, 0, 5248, 651, 1, 0, 0, 0, 5249, 5250,
		5, 405, 0, 0, 5250, 5251, 3, 748, 374, 0, 5251, 653, 1, 0, 0, 0, 5252,
		5258, 3, 754, 377, 0, 5253, 5255, 3, 750, 375, 0, 5254, 5256, 3, 754, 377,
		0, 5255, 5254, 1, 0, 0, 0, 5255, 5256, 1, 0, 0, 0, 5256, 5258, 1, 0, 0,
		0, 5257, 5252, 1, 0, 0, 0, 5257, 5253, 1, 0, 0, 0, 5258, 655, 1, 0, 0,
		0, 5259, 5262, 3, 744, 372, 0, 5260, 5262, 3, 654, 327, 0, 5261, 5259,
		1, 0, 0, 0, 5261, 5260, 1, 0, 0, 0, 5262, 657, 1, 0, 0, 0, 5263, 5264,
		3, 744, 372, 0, 5264, 659, 1, 0, 0, 0, 5265, 5266, 5, 776, 0, 0, 5266,
		5271, 3, 658, 329, 0, 5267, 5268, 5, 773, 0, 0, 5268, 5270, 3, 658, 329,
		0, 5269, 5267, 1, 0, 0, 0, 5270, 5273, 1, 0, 0, 0, 5271, 5269, 1, 0, 0,
		0, 5271, 5272, 1, 0, 0, 0, 5272, 5274, 1, 0, 0, 0, 5273, 5271, 1, 0, 0,
		0, 5274, 5275, 5, 777, 0, 0, 5275, 661, 1, 0, 0, 0, 5276, 5277, 3, 654,
		327, 0, 5277, 663, 1, 0, 0, 0, 5278, 5281, 3, 662, 331, 0, 5279, 5281,
		3, 670, 335, 0, 5280, 5278, 1, 0, 0, 0, 5280, 5279, 1, 0, 0, 0, 5281, 665,
		1, 0, 0, 0, 5282, 5283, 3, 744, 372, 0, 5283, 667, 1, 0, 0, 0, 5284, 5285,
		3, 654, 327, 0, 5285, 669, 1, 0, 0, 0, 5286, 5287, 3, 744, 372, 0, 5287,
		5291, 5, 772, 0, 0, 5288, 5289, 3, 744, 372, 0, 5289, 5290, 5, 772, 0,
		0, 5290, 5292, 1, 0, 0, 0, 5291, 5288, 1, 0, 0, 0, 5291, 5292, 1, 0, 0,
		0, 5292, 5293, 1, 0, 0, 0, 5293, 5294, 5, 760, 0, 0, 5294, 671, 1, 0, 0,
		0, 5295, 5296, 3, 744, 372, 0, 5296, 673, 1, 0, 0, 0, 5297, 5298, 3, 744,
		372, 0, 5298, 675, 1, 0, 0, 0, 5299, 5300, 3, 750, 375, 0, 5300, 677, 1,
		0, 0, 0, 5301, 5302, 3, 750, 375, 0, 5302, 679, 1, 0, 0, 0, 5303, 5304,
		3, 750, 375, 0, 5304, 681, 1, 0, 0, 0, 5305, 5306, 3, 750, 375, 0, 5306,
		683, 1, 0, 0, 0, 5307, 5308, 3, 750, 375, 0, 5308, 685, 1, 0, 0, 0, 5309,
		5310, 3, 750, 375, 0, 5310, 687, 1, 0, 0, 0, 5311, 5314, 3, 750, 375, 0,
		5312, 5314, 3, 754, 377, 0, 5313, 5311, 1, 0, 0, 0, 5313, 5312, 1, 0, 0,
		0, 5314, 689, 1, 0, 0, 0, 5315, 5318, 3, 750, 375, 0, 5316, 5318, 3, 754,
		377, 0, 5317, 5315, 1, 0, 0, 0, 5317, 5316, 1, 0, 0, 0, 5318, 691, 1, 0,
		0, 0, 5319, 5320, 3, 744, 372, 0, 5320, 693, 1, 0, 0, 0, 5321, 5322, 3,
		744, 372, 0, 5322, 695, 1, 0, 0, 0, 5323, 5324, 3, 744, 372, 0, 5324, 697,
		1, 0, 0, 0, 5325, 5326, 3, 744, 372, 0, 5326, 699, 1, 0, 0, 0, 5327, 5328,
		3, 750, 375, 0, 5328, 701, 1, 0, 0, 0, 5329, 5330, 3, 750, 375, 0, 5330,
		703, 1, 0, 0, 0, 5331, 5332, 3, 744, 372, 0, 5332, 705, 1, 0, 0, 0, 5333,
		5334, 3, 796, 398, 0, 5334, 707, 1, 0, 0, 0, 5335, 5336, 3, 796, 398, 0,
		5336, 709, 1, 0, 0, 0, 5337, 5338, 3, 796, 398, 0, 5338, 711, 1, 0, 0,
		0, 5339, 5342, 3, 750, 375, 0, 5340, 5342, 3, 754, 377, 0, 5341, 5339,
		1, 0, 0, 0, 5341, 5340, 1, 0, 0, 0, 5342, 713, 1, 0, 0, 0, 5343, 5344,
		3, 674, 337, 0, 5344, 5345, 3, 754, 377, 0, 5345, 715, 1, 0, 0, 0, 5346,
		5354, 3, 744, 372, 0, 5347, 5348, 5, 772, 0, 0, 5348, 5355, 5, 760, 0,
		0, 5349, 5352, 3, 754, 377, 0, 5350, 5351, 5, 772, 0, 0, 5351, 5353, 5,
		760, 0, 0, 5352, 5350, 1, 0, 0, 0, 5352, 5353, 1, 0, 0, 0, 5353, 5355,
		1, 0, 0, 0, 5354, 5347, 1, 0, 0, 0, 5354, 5349, 1, 0, 0, 0, 5354, 5355,
		1, 0, 0, 0, 5355, 717, 1, 0, 0, 0, 5356, 5359, 3, 750, 375, 0, 5357, 5359,
		3, 754, 377, 0, 5358, 5356, 1, 0, 0, 0, 5358, 5357, 1, 0, 0, 0, 5359, 719,
		1, 0, 0, 0, 5360, 5365, 3, 718, 359, 0, 5361, 5362, 5, 773, 0, 0, 5362,
		5364, 3, 718, 359, 0, 5363, 5361, 1, 0, 0, 0, 5364, 5367, 1, 0, 0, 0, 5365,
		5363, 1, 0, 0, 0, 5365, 5366, 1, 0, 0, 0, 5366, 721, 1, 0, 0, 0, 5367,
		5365, 1, 0, 0, 0, 5368, 5373, 3, 716, 358, 0, 5369, 5370, 5, 773, 0, 0,
		5370, 5372, 3, 716, 358, 0, 5371, 5369, 1, 0, 0, 0, 5372, 5375, 1, 0, 0,
		0, 5373, 5371, 1, 0, 0, 0, 5373, 5374, 1, 0, 0, 0, 5374, 723, 1, 0, 0,
		0, 5375, 5373, 1, 0, 0, 0, 5376, 5377, 3, 744, 372, 0, 5377, 725, 1, 0,
		0, 0, 5378, 5381, 3, 742, 371, 0, 5379, 5381, 3, 820, 410, 0, 5380, 5378,
		1, 0, 0, 0, 5380, 5379, 1, 0, 0, 0, 5381, 727, 1, 0, 0, 0, 5382, 5383,
		3, 726, 363, 0, 5383, 729, 1, 0, 0, 0, 5384, 5387, 3, 742, 371, 0, 5385,
		5387, 3, 826, 413, 0, 5386, 5384, 1, 0, 0, 0, 5386, 5385, 1, 0, 0, 0, 5387,
		731, 1, 0, 0, 0, 5388, 5389, 3, 730, 365, 0, 5389, 733, 1, 0, 0, 0, 5390,
		5391, 3, 744, 372, 0, 5391, 735, 1, 0, 0, 0, 5392, 5393, 3, 770, 385, 0,
		5393, 737, 1, 0, 0, 0, 5394, 5395, 3, 744, 372, 0, 5395, 739, 1, 0, 0,
		0, 5396, 5397, 3, 744, 372, 0, 5397, 741, 1, 0, 0, 0, 5398, 5399, 7, 98,
		0, 0, 5399, 743, 1, 0, 0, 0, 5400, 5403, 3, 742, 371, 0, 5401, 5403, 3,
		814, 407, 0, 5402, 5400, 1, 0, 0, 0, 5402, 5401, 1, 0, 0, 0, 5403, 745,
		1, 0, 0, 0, 5404, 5409, 3, 744, 372, 0, 5405, 5406, 5, 773, 0, 0, 5406,
		5408, 3, 744, 372, 0, 5407, 5405, 1, 0, 0, 0, 5408, 5411, 1, 0, 0, 0, 5409,
		5407, 1, 0, 0, 0, 5409, 5410, 1, 0, 0, 0, 5410, 747, 1, 0, 0, 0, 5411,
		5409, 1, 0, 0, 0, 5412, 5413, 5, 776, 0, 0, 5413, 5414, 3, 746, 373, 0,
		5414, 5415, 5, 777, 0, 0, 5415, 749, 1, 0, 0, 0, 5416, 5418, 3, 744, 372,
		0, 5417, 5419, 3, 754, 377, 0, 5418, 5417, 1, 0, 0, 0, 5418, 5419, 1, 0,
		0, 0, 5419, 751, 1, 0, 0, 0, 5420, 5425, 3, 744, 372, 0, 5421, 5423, 3,
		754, 377, 0, 5422, 5424, 3, 754, 377, 0, 5423, 5422, 1, 0, 0, 0, 5423,
		5424, 1, 0, 0, 0, 5424, 5426, 1, 0, 0, 0, 5425, 5421, 1, 0, 0, 0, 5425,
		5426, 1, 0, 0, 0, 5426, 5431, 1, 0, 0, 0, 5427, 5428, 3, 754, 377, 0, 5428,
		5429, 3, 754, 377, 0, 5429, 5431, 1, 0, 0, 0, 5430, 5420, 1, 0, 0, 0, 5430,
		5427, 1, 0, 0, 0, 5431, 753, 1, 0, 0, 0, 5432, 5433, 5, 772, 0, 0, 5433,
		5434, 3, 744, 372, 0, 5434, 755, 1, 0, 0, 0, 5435, 5436, 7, 99, 0, 0, 5436,
		757, 1, 0, 0, 0, 5437, 5438, 7, 100, 0, 0, 5438, 759, 1, 0, 0, 0, 5439,
		5440, 7, 101, 0, 0, 5440, 761, 1, 0, 0, 0, 5441, 5442, 7, 100, 0, 0, 5442,
		763, 1, 0, 0, 0, 5443, 5453, 3, 776, 388, 0, 5444, 5453, 3, 782, 391, 0,
		5445, 5453, 3, 788, 394, 0, 5446, 5453, 3, 786, 393, 0, 5447, 5453, 3,
		784, 392, 0, 5448, 5450, 5, 802, 0, 0, 5449, 5448, 1, 0, 0, 0, 5449, 5450,
		1, 0, 0, 0, 5450, 5451, 1, 0, 0, 0, 5451, 5453, 7, 102, 0, 0, 5452, 5443,
		1, 0, 0, 0, 5452, 5444, 1, 0, 0, 0, 5452, 5445, 1, 0, 0, 0, 5452, 5446,
		1, 0, 0, 0, 5452, 5447, 1, 0, 0, 0, 5452, 5449, 1, 0, 0, 0, 5453, 765,
		1, 0, 0, 0, 5454, 5460, 3, 764, 382, 0, 5455, 5456, 5, 758, 0, 0, 5456,
		5460, 3, 756, 378, 0, 5457, 5458, 5, 759, 0, 0, 5458, 5460, 3, 756, 378,
		0, 5459, 5454, 1, 0, 0, 0, 5459, 5455, 1, 0, 0, 0, 5459, 5457, 1, 0, 0,
		0, 5460, 767, 1, 0, 0, 0, 5461, 5462, 5, 776, 0, 0, 5462, 5467, 3, 772,
		386, 0, 5463, 5464, 5, 773, 0, 0, 5464, 5466, 3, 772, 386, 0, 5465, 5463,
		1, 0, 0, 0, 5466, 5469, 1, 0, 0, 0, 5467, 5465, 1, 0, 0, 0, 5467, 5468,
		1, 0, 0, 0, 5468, 5470, 1, 0, 0, 0, 5469, 5467, 1, 0, 0, 0, 5470, 5471,
		5, 777, 0, 0, 5471, 769, 1, 0, 0, 0, 5472, 5475, 5, 807, 0, 0, 5473, 5475,
		5, 806, 0, 0, 5474, 5472, 1, 0, 0, 0, 5474, 5473, 1, 0, 0, 0, 5475, 771,
		1, 0, 0, 0, 5476, 5480, 3, 770, 385, 0, 5477, 5480, 5, 788, 0, 0, 5478,
		5480, 5, 789, 0, 0, 5479, 5476, 1, 0, 0, 0, 5479, 5477, 1, 0, 0, 0, 5479,
		5478, 1, 0, 0, 0, 5480, 773, 1, 0, 0, 0, 5481, 5484, 3, 770, 385, 0, 5482,
		5484, 5, 788, 0, 0, 5483, 5481, 1, 0, 0, 0, 5483, 5482, 1, 0, 0, 0, 5484,
		775, 1, 0, 0, 0, 5485, 5487, 5, 802, 0, 0, 5486, 5485, 1, 0, 0, 0, 5486,
		5487, 1, 0, 0, 0, 5487, 5488, 1, 0, 0, 0, 5488, 5491, 3, 770, 385, 0, 5489,
		5491, 5, 804, 0, 0, 5490, 5486, 1, 0, 0, 0, 5490, 5489, 1, 0, 0, 0, 5491,
		5495, 1, 0, 0, 0, 5492, 5494, 3, 770, 385, 0, 5493, 5492, 1, 0, 0, 0, 5494,
		5497, 1, 0, 0, 0, 5495, 5493, 1, 0, 0, 0, 5495, 5496, 1, 0, 0, 0, 5496,
		777, 1, 0, 0, 0, 5497, 5495, 1, 0, 0, 0, 5498, 5499, 3, 770, 385, 0, 5499,
		779, 1, 0, 0, 0, 5500, 5505, 3, 770, 385, 0, 5501, 5502, 5, 773, 0, 0,
		5502, 5504, 3, 770, 385, 0, 5503, 5501, 1, 0, 0, 0, 5504, 5507, 1, 0, 0,
		0, 5505, 5503, 1, 0, 0, 0, 5505, 5506, 1, 0, 0, 0, 5506, 781, 1, 0, 0,
		0, 5507, 5505, 1, 0, 0, 0, 5508, 5509, 7, 101, 0, 0, 5509, 783, 1, 0, 0,
		0, 5510, 5511, 7, 103, 0, 0, 5511, 785, 1, 0, 0, 0, 5512, 5513, 7, 104,
		0, 0, 5513, 787, 1, 0, 0, 0, 5514, 5515, 5, 116, 0, 0, 5515, 5521, 5, 807,
		0, 0, 5516, 5517, 5, 586, 0, 0, 5517, 5521, 5, 807, 0, 0, 5518, 5519, 5,
		583, 0, 0, 5519, 5521, 5, 807, 0, 0, 5520, 5514, 1, 0, 0, 0, 5520, 5516,
		1, 0, 0, 0, 5520, 5518, 1, 0, 0, 0, 5521, 789, 1, 0, 0, 0, 5522, 5525,
		3, 538, 269, 0, 5523, 5525, 3, 794, 397, 0, 5524, 5522, 1, 0, 0, 0, 5524,
		5523, 1, 0, 0, 0, 5525, 791, 1, 0, 0, 0, 5526, 5527, 3, 794, 397, 0, 5527,
		793, 1, 0, 0, 0, 5528, 5529, 5, 776, 0, 0, 5529, 5530, 5, 747, 0, 0, 5530,
		5531, 5, 773, 0, 0, 5531, 5532, 5, 747, 0, 0, 5532, 5533, 5, 777, 0, 0,
		5533, 795, 1, 0, 0, 0, 5534, 5537, 3, 744, 372, 0, 5535, 5537, 3, 770,
		385, 0, 5536, 5534, 1, 0, 0, 0, 5536, 5535, 1, 0, 0, 0, 5537, 797, 1, 0,
		0, 0, 5538, 5541, 3, 742, 371, 0, 5539, 5541, 3, 828, 414, 0, 5540, 5538,
		1, 0, 0, 0, 5540, 5539, 1, 0, 0, 0, 5541, 799, 1, 0, 0, 0, 5542, 5545,
		3, 730, 365, 0, 5543, 5545, 3, 770, 385, 0, 5544, 5542, 1, 0, 0, 0, 5544,
		5543, 1, 0, 0, 0, 5545, 801, 1, 0, 0, 0, 5546, 5549, 3, 762, 381, 0, 5547,
		5549, 3, 742, 371, 0, 5548, 5546, 1, 0, 0, 0, 5548, 5547, 1, 0, 0, 0, 5549,
		803, 1, 0, 0, 0, 5550, 5551, 5, 776, 0, 0, 5551, 5552, 5, 777, 0, 0, 5552,
		805, 1, 0, 0, 0, 5553, 5554, 7, 105, 0, 0, 5554, 807, 1, 0, 0, 0, 5555,
		5556, 7, 106, 0, 0, 5556, 809, 1, 0, 0, 0, 5557, 5558, 5, 214, 0, 0, 5558,
		5564, 5, 772, 0, 0, 5559, 5560, 5, 284, 0, 0, 5560, 5564, 5, 772, 0, 0,
		5561, 5562, 5, 502, 0, 0, 5562, 5564, 5, 772, 0, 0, 5563, 5557, 1, 0, 0,
		0, 5563, 5559, 1, 0, 0, 0, 5563, 5561, 1, 0, 0, 0, 5564, 811, 1, 0, 0,
		0, 5565, 5566, 5, 658, 0, 0, 5566, 5576, 5, 772, 0, 0, 5567, 5568, 5, 673,
		0, 0, 5568, 5576, 5, 772, 0, 0, 5569, 5570, 5, 214, 0, 0, 5570, 5576, 5,
		772, 0, 0, 5571, 5572, 5, 284, 0, 0, 5572, 5576, 5, 772, 0, 0, 5573, 5574,
		5, 502, 0, 0, 5574, 5576, 5, 772, 0, 0, 5575, 5565, 1, 0, 0, 0, 5575, 5567,
		1, 0, 0, 0, 5575, 5569, 1, 0, 0, 0, 5575, 5571, 1, 0, 0, 0, 5575, 5573,
		1, 0, 0, 0, 5576, 813, 1, 0, 0, 0, 5577, 5583, 3, 820, 410, 0, 5578, 5583,
		3, 832, 416, 0, 5579, 5583, 5, 173, 0, 0, 5580, 5583, 5, 510, 0, 0, 5581,
		5583, 5, 714, 0, 0, 5582, 5577, 1, 0, 0, 0, 5582, 5578, 1, 0, 0, 0, 5582,
		5579, 1, 0, 0, 0, 5582, 5580, 1, 0, 0, 0, 5582, 5581, 1, 0, 0, 0, 5583,
		5593, 1, 0, 0, 0, 5584, 5590, 3, 824, 412, 0, 5585, 5590, 3, 816, 408,
		0, 5586, 5590, 3, 818, 409, 0, 5587, 5590, 3, 822, 411, 0, 5588, 5590,
		3, 830, 415, 0, 5589, 5584, 1, 0, 0, 0, 5589, 5585, 1, 0, 0, 0, 5589, 5586,
		1, 0, 0, 0, 5589, 5587, 1, 0, 0, 0, 5589, 5588, 1, 0, 0, 0, 5590, 5593,
		1, 0, 0, 0, 5591, 5593, 7, 107, 0, 0, 5592, 5582, 1, 0, 0, 0, 5592, 5589,
		1, 0, 0, 0, 5592, 5591, 1, 0, 0, 0, 5593, 815, 1, 0, 0, 0, 5594, 5595,
		7, 108, 0, 0, 5595, 817, 1, 0, 0, 0, 5596, 5597, 7, 109, 0, 0, 5597, 819,
		1, 0, 0, 0, 5598, 5609, 3, 834, 417, 0, 5599, 5609, 5, 170, 0, 0, 5600,
		5609, 5, 188, 0, 0, 5601, 5609, 5, 369, 0, 0, 5602, 5609, 5, 423, 0, 0,
		5603, 5609, 5, 427, 0, 0, 5604, 5609, 5, 451, 0, 0, 5605, 5609, 5, 459,
		0, 0, 5606, 5609, 5, 709, 0, 0, 5607, 5609, 5, 565, 0, 0, 5608, 5598, 1,
		0, 0, 0, 5608, 5599, 1, 0, 0, 0, 5608, 5600, 1, 0, 0, 0, 5608, 5601, 1,
		0, 0, 0, 5608, 5602, 1, 0, 0, 0, 5608, 5603, 1, 0, 0, 0, 5608, 5604, 1,
		0, 0, 0, 5608, 5605, 1, 0, 0, 0, 5608, 5606, 1, 0, 0, 0, 5608, 5607, 1,
		0, 0, 0, 5609, 5616, 1, 0, 0, 0, 5610, 5614, 3, 824, 412, 0, 5611, 5614,
		3, 822, 411, 0, 5612, 5614, 3, 830, 415, 0, 5613, 5610, 1, 0, 0, 0, 5613,
		5611, 1, 0, 0, 0, 5613, 5612, 1, 0, 0, 0, 5614, 5616, 1, 0, 0, 0, 5615,
		5608, 1, 0, 0, 0, 5615, 5613, 1, 0, 0, 0, 5616, 821, 1, 0, 0, 0, 5617,
		5618, 7, 110, 0, 0, 5618, 823, 1, 0, 0, 0, 5619, 5622, 7, 111, 0, 0, 5620,
		5622, 7, 112, 0, 0, 5621, 5619, 1, 0, 0, 0, 5621, 5620, 1, 0, 0, 0, 5622,
		825, 1, 0, 0, 0, 5623, 5626, 3, 834, 417, 0, 5624, 5626, 3, 832, 416, 0,
		5625, 5623, 1, 0, 0, 0, 5625, 5624, 1, 0, 0, 0, 5626, 5633, 1, 0, 0, 0,
		5627, 5631, 3, 824, 412, 0, 5628, 5631, 3, 818, 409, 0, 5629, 5631, 3,
		830, 415, 0, 5630, 5627, 1, 0, 0, 0, 5630, 5628, 1, 0, 0, 0, 5630, 5629,
		1, 0, 0, 0, 5631, 5633, 1, 0, 0, 0, 5632, 5625, 1, 0, 0, 0, 5632, 5630,
		1, 0, 0, 0, 5633, 827, 1, 0, 0, 0, 5634, 5639, 3, 824, 412, 0, 5635, 5639,
		3, 816, 408, 0, 5636, 5639, 3, 818, 409, 0, 5637, 5639, 3, 822, 411, 0,
		5638, 5634, 1, 0, 0, 0, 5638, 5635, 1, 0, 0, 0, 5638, 5636, 1, 0, 0, 0,
		5638, 5637, 1, 0, 0, 0, 5639, 829, 1, 0, 0, 0, 5640, 5641, 7, 106, 0, 0,
		5641, 831, 1, 0, 0, 0, 5642, 5646, 7, 113, 0, 0, 5643, 5646, 5, 510, 0,
		0, 5644, 5646, 5, 234, 0, 0, 5645, 5642, 1, 0, 0, 0, 5645, 5643, 1, 0,
		0, 0, 5645, 5644, 1, 0, 0, 0, 5646, 833, 1, 0, 0, 0, 5647, 5653, 7, 114,
		0, 0, 5648, 5653, 5, 510, 0, 0, 5649, 5653, 7, 115, 0, 0, 5650, 5653, 7,
		116, 0, 0, 5651, 5653, 5, 660, 0, 0, 5652, 5647, 1, 0, 0, 0, 5652, 5648,
		1, 0, 0, 0, 5652, 5649, 1, 0, 0, 0, 5652, 5650, 1, 0, 0, 0, 5652, 5651,
		1, 0, 0, 0, 5653, 835, 1, 0, 0, 0, 762, 838, 845, 850, 853, 858, 863, 869,
		872, 881, 886, 893, 897, 904, 915, 917, 921, 924, 930, 934, 943, 948, 951,
		955, 958, 962, 965, 967, 970, 976, 980, 982, 986, 990, 994, 1001, 1003,
		1010, 1016, 1021, 1024, 1027, 1030, 1033, 1036, 1051, 1055, 1061, 1064,
		1067, 1073, 1078, 1082, 1085, 1093, 1095, 1108, 1120, 1125, 1128, 1131,
		1136, 1142, 1158, 1178, 1187, 1191, 1198, 1203, 1212, 1218, 1229, 1236,
		1245, 1254, 1260, 1265, 1269, 1278, 1283, 1289, 1292, 1298, 1305, 1309,
		1315, 1321, 1323, 1326, 1330, 1339, 1344, 1349, 1356, 1365, 1373, 1378,
		1382, 1388, 1391, 1394, 1398, 1402, 1411, 1415, 1418, 1421, 1426, 1432,
		1435, 1440, 1443, 1445, 1450, 1462, 1471, 1483, 1486, 1491, 1498, 1502,
		1506, 1508, 1522, 1529, 1538, 1544, 1553, 1557, 1561, 1571, 1573, 1581,
		1588, 1593, 1596, 1600, 1603, 1609, 1612, 1615, 1621, 1628, 1633, 1637,
		1640, 1643, 1646, 1648, 1652, 1659, 1665, 1669, 1674, 1677, 1680, 1683,
		1685, 1690, 1699, 1708, 1712, 1718, 1721, 1724, 1730, 1737, 1739, 1747,
		1753, 1757, 1760, 1767, 1769, 1778, 1787, 1795, 1801, 1805, 1811, 1814,
		1816, 1821, 1827, 1837, 1844, 1938, 1942, 1948, 1962, 1970, 1973, 1985,
		1989, 1995, 2002, 2009, 2016, 2023, 2030, 2037, 2040, 2047, 2055, 2063,
		2073, 2079, 2083, 2087, 2092, 2095, 2097, 2104, 2110, 2116, 2121, 2126,
		2131, 2134, 2141, 2154, 2160, 2166, 2173, 2181, 2187, 2198, 2200, 2206,
		2210, 2212, 2216, 2227, 2232, 2238, 2247, 2250, 2261, 2267, 2273, 2280,
		2282, 2291, 2298, 2301, 2306, 2313, 2316, 2321, 2324, 2329, 2340, 2342,
		2354, 2359, 2367, 2372, 2374, 2376, 2381, 2392, 2397, 2399, 2403, 2409,
		2412, 2415, 2425, 2427, 2431, 2437, 2442, 2452, 2456, 2461, 2477, 2492,
		2496, 2504, 2512, 2516, 2521, 2524, 2526, 2535, 2540, 2546, 2548, 2552,
		2563, 2573, 2585, 2590, 2595, 2602, 2606, 2611, 2620, 2632, 2646, 2655,
		2657, 2664, 2671, 2675, 2680, 2688, 2695, 2699, 2705, 2712, 2715, 2724,
		2730, 2735, 2758, 2761, 2777, 2782, 2785, 2789, 2792, 2804, 2809, 2814,
		2817, 2819, 2823, 2828, 2830, 2842, 2848, 2870, 2873, 2875, 2883, 2887,
		2896, 2905, 2911, 2914, 2918, 2921, 2924, 2928, 2931, 2935, 2938, 2943,
		2946, 2951, 2954, 2960, 2964, 2970, 2973, 2982, 2984, 2990, 2994, 2997,
		3000, 3003, 3009, 3012, 3015, 3025, 3029, 3038, 3041, 3046, 3049, 3052,
		3056, 3059, 3064, 3068, 3075, 3088, 3105, 3110, 3115, 3123, 3128, 3130,
		3133, 3136, 3150, 3156, 3164, 3168, 3171, 3174, 3178, 3182, 3187, 3193,
		3197, 3208, 3211, 3214, 3217, 3225, 3229, 3234, 3242, 3248, 3251, 3255,
		3266, 3268, 3277, 3289, 3291, 3298, 3303, 3309, 3317, 3328, 3332, 3361,
		3363, 3371, 3375, 3390, 3397, 3411, 3423, 3429, 3436, 3439, 3474, 3482,
		3484, 3493, 3498, 3503, 3510, 3516, 3521, 3526, 3532, 3536, 3541, 3546,
		3551, 3556, 3563, 3570, 3577, 3584, 3589, 3594, 3599, 3603, 3607, 3611,
		3613, 3632, 3636, 3643, 3655, 3658, 3662, 3667, 3672, 3676, 3686, 3695,
		3697, 3700, 3709, 3716, 3729, 3734, 3741, 3747, 3773, 3804, 3824, 3830,
		3834, 3861, 3873, 3886, 3890, 3894, 3922, 3976, 3986, 3989, 4001, 4006,
		4018, 4038, 4042, 4058, 4061, 4066, 4069, 4078, 4082, 4088, 4094, 4098,
		4109, 4115, 4117, 4124, 4131, 4135, 4143, 4146, 4149, 4160, 4169, 4179,
		4184, 4188, 4193, 4197, 4201, 4205, 4209, 4211, 4215, 4228, 4232, 4235,
		4239, 4243, 4247, 4252, 4256, 4260, 4266, 4268, 4275, 4281, 4289, 4310,
		4315, 4322, 4337, 4342, 4346, 4349, 4354, 4358, 4366, 4374, 4376, 4385,
		4393, 4400, 4403, 4411, 4419, 4421, 4425, 4431, 4435, 4441, 4452, 4461,
		4464, 4469, 4471, 4474, 4477, 4481, 4484, 4488, 4493, 4496, 4500, 4503,
		4507, 4512, 4516, 4528, 4532, 4538, 4541, 4546, 4550, 4554, 4559, 4568,
		4571, 4575, 4579, 4582, 4586, 4590, 4595, 4600, 4605, 4610, 4615, 4617,
		4622, 4629, 4637, 4643, 4645, 4649, 4653, 4657, 4661, 4674, 4679, 4683,
		4688, 4694, 4698, 4703, 4707, 4711, 4716, 4721, 4726, 4731, 4736, 4741,
		4746, 4751, 4756, 4761, 4766, 4771, 4776, 4786, 4792, 4798, 4803, 4806,
		4813, 4818, 4823, 4827, 4830, 4834, 4839, 4843, 4848, 4852, 4861, 4864,
		4867, 4870, 4874, 4878, 4882, 4897, 4900, 4902, 4907, 4916, 4919, 4923,
		4935, 4947, 4952, 4957, 4966, 4971, 4980, 4985, 4989, 4993, 4997, 5002,
		5007, 5013, 5018, 5021, 5028, 5037, 5044, 5058, 5070, 5083, 5091, 5098,
		5107, 5113, 5121, 5127, 5138, 5146, 5154, 5161, 5170, 5174, 5179, 5181,
		5187, 5193, 5196, 5203, 5205, 5207, 5210, 5212, 5229, 5234, 5236, 5243,
		5255, 5257, 5261, 5271, 5280, 5291, 5313, 5317, 5341, 5352, 5354, 5358,
		5365, 5373, 5380, 5386, 5402, 5409, 5418, 5423, 5425, 5430, 5449, 5452,
		5459, 5467, 5474, 5479, 5483, 5486, 5490, 5495, 5505, 5520, 5524, 5536,
		5540, 5544, 5548, 5563, 5575, 5582, 5589, 5592, 5608, 5613, 5615, 5621,
		5625, 5630, 5632, 5638, 5645, 5652,
	}
	deserializer := antlr.NewATNDeserializer(nil)
	staticData.atn = deserializer.Deserialize(staticData.serializedATN)
	atn := staticData.atn
	staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
	decisionToDFA := staticData.decisionToDFA
	for index, state := range atn.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(state, index)
	}
}

// TiDBParserInit initializes any static state used to implement TiDBParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewTiDBParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func TiDBParserInit() {
	staticData := &TiDBParserParserStaticData
	staticData.once.Do(tidbparserParserInit)
}

// NewTiDBParser produces a new parser instance for the optional input antlr.TokenStream.
func NewTiDBParser(input antlr.TokenStream) *TiDBParser {
	TiDBParserInit()
	this := new(TiDBParser)
	this.BaseParser = antlr.NewBaseParser(input)
	staticData := &TiDBParserParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "TiDBParser.g4"

	return this
}

// TiDBParser tokens.
const (
	TiDBParserEOF                                    = antlr.TokenEOF
	TiDBParserACCESSIBLE_SYMBOL                      = 1
	TiDBParserACCOUNT_SYMBOL                         = 2
	TiDBParserACTION_SYMBOL                          = 3
	TiDBParserADD_SYMBOL                             = 4
	TiDBParserADDDATE_SYMBOL                         = 5
	TiDBParserAFTER_SYMBOL                           = 6
	TiDBParserAGAINST_SYMBOL                         = 7
	TiDBParserAGGREGATE_SYMBOL                       = 8
	TiDBParserALGORITHM_SYMBOL                       = 9
	TiDBParserALL_SYMBOL                             = 10
	TiDBParserALTER_SYMBOL                           = 11
	TiDBParserALWAYS_SYMBOL                          = 12
	TiDBParserANALYSE_SYMBOL                         = 13
	TiDBParserANALYZE_SYMBOL                         = 14
	TiDBParserAND_SYMBOL                             = 15
	TiDBParserANY_SYMBOL                             = 16
	TiDBParserAS_SYMBOL                              = 17
	TiDBParserASC_SYMBOL                             = 18
	TiDBParserASCII_SYMBOL                           = 19
	TiDBParserASENSITIVE_SYMBOL                      = 20
	TiDBParserAT_SYMBOL                              = 21
	TiDBParserAUTHORS_SYMBOL                         = 22
	TiDBParserAUTOEXTEND_SIZE_SYMBOL                 = 23
	TiDBParserAUTO_INCREMENT_SYMBOL                  = 24
	TiDBParserAVG_ROW_LENGTH_SYMBOL                  = 25
	TiDBParserAVG_SYMBOL                             = 26
	TiDBParserBACKUP_SYMBOL                          = 27
	TiDBParserBEFORE_SYMBOL                          = 28
	TiDBParserBEGIN_SYMBOL                           = 29
	TiDBParserBETWEEN_SYMBOL                         = 30
	TiDBParserBIGINT_SYMBOL                          = 31
	TiDBParserBINARY_SYMBOL                          = 32
	TiDBParserBINLOG_SYMBOL                          = 33
	TiDBParserBIN_NUM_SYMBOL                         = 34
	TiDBParserBIT_AND_SYMBOL                         = 35
	TiDBParserBIT_OR_SYMBOL                          = 36
	TiDBParserBIT_SYMBOL                             = 37
	TiDBParserBIT_XOR_SYMBOL                         = 38
	TiDBParserBLOB_SYMBOL                            = 39
	TiDBParserBLOCK_SYMBOL                           = 40
	TiDBParserBOOLEAN_SYMBOL                         = 41
	TiDBParserBOOL_SYMBOL                            = 42
	TiDBParserBOTH_SYMBOL                            = 43
	TiDBParserBTREE_SYMBOL                           = 44
	TiDBParserBY_SYMBOL                              = 45
	TiDBParserBYTE_SYMBOL                            = 46
	TiDBParserCACHE_SYMBOL                           = 47
	TiDBParserCALL_SYMBOL                            = 48
	TiDBParserCASCADE_SYMBOL                         = 49
	TiDBParserCASCADED_SYMBOL                        = 50
	TiDBParserCASE_SYMBOL                            = 51
	TiDBParserCAST_SYMBOL                            = 52
	TiDBParserCATALOG_NAME_SYMBOL                    = 53
	TiDBParserCHAIN_SYMBOL                           = 54
	TiDBParserCHANGE_SYMBOL                          = 55
	TiDBParserCHANGED_SYMBOL                         = 56
	TiDBParserCHANNEL_SYMBOL                         = 57
	TiDBParserCHARSET_SYMBOL                         = 58
	TiDBParserCHARACTER_SYMBOL                       = 59
	TiDBParserCHAR_SYMBOL                            = 60
	TiDBParserCHECKSUM_SYMBOL                        = 61
	TiDBParserCHECK_SYMBOL                           = 62
	TiDBParserCIPHER_SYMBOL                          = 63
	TiDBParserCLASS_ORIGIN_SYMBOL                    = 64
	TiDBParserCLIENT_SYMBOL                          = 65
	TiDBParserCLOSE_SYMBOL                           = 66
	TiDBParserCOALESCE_SYMBOL                        = 67
	TiDBParserCODE_SYMBOL                            = 68
	TiDBParserCOLLATE_SYMBOL                         = 69
	TiDBParserCOLLATION_SYMBOL                       = 70
	TiDBParserCOLUMNS_SYMBOL                         = 71
	TiDBParserCOLUMN_SYMBOL                          = 72
	TiDBParserCOLUMN_NAME_SYMBOL                     = 73
	TiDBParserCOLUMN_FORMAT_SYMBOL                   = 74
	TiDBParserCOMMENT_SYMBOL                         = 75
	TiDBParserCOMMITTED_SYMBOL                       = 76
	TiDBParserCOMMIT_SYMBOL                          = 77
	TiDBParserCOMPACT_SYMBOL                         = 78
	TiDBParserCOMPLETION_SYMBOL                      = 79
	TiDBParserCOMPRESSED_SYMBOL                      = 80
	TiDBParserCOMPRESSION_SYMBOL                     = 81
	TiDBParserCONCURRENT_SYMBOL                      = 82
	TiDBParserCONDITION_SYMBOL                       = 83
	TiDBParserCONNECTION_SYMBOL                      = 84
	TiDBParserCONSISTENT_SYMBOL                      = 85
	TiDBParserCONSTRAINT_SYMBOL                      = 86
	TiDBParserCONSTRAINT_CATALOG_SYMBOL              = 87
	TiDBParserCONSTRAINT_NAME_SYMBOL                 = 88
	TiDBParserCONSTRAINT_SCHEMA_SYMBOL               = 89
	TiDBParserCONTAINS_SYMBOL                        = 90
	TiDBParserCONTEXT_SYMBOL                         = 91
	TiDBParserCONTINUE_SYMBOL                        = 92
	TiDBParserCONTRIBUTORS_SYMBOL                    = 93
	TiDBParserCONVERT_SYMBOL                         = 94
	TiDBParserCOUNT_SYMBOL                           = 95
	TiDBParserCPU_SYMBOL                             = 96
	TiDBParserCREATE_SYMBOL                          = 97
	TiDBParserCROSS_SYMBOL                           = 98
	TiDBParserCUBE_SYMBOL                            = 99
	TiDBParserCURDATE_SYMBOL                         = 100
	TiDBParserCURRENT_SYMBOL                         = 101
	TiDBParserCURRENT_DATE_SYMBOL                    = 102
	TiDBParserCURRENT_TIME_SYMBOL                    = 103
	TiDBParserCURRENT_TIMESTAMP_SYMBOL               = 104
	TiDBParserCURRENT_USER_SYMBOL                    = 105
	TiDBParserCURSOR_SYMBOL                          = 106
	TiDBParserCURSOR_NAME_SYMBOL                     = 107
	TiDBParserCURTIME_SYMBOL                         = 108
	TiDBParserDATABASE_SYMBOL                        = 109
	TiDBParserDATABASES_SYMBOL                       = 110
	TiDBParserDATAFILE_SYMBOL                        = 111
	TiDBParserDATA_SYMBOL                            = 112
	TiDBParserDATETIME_SYMBOL                        = 113
	TiDBParserDATE_ADD_SYMBOL                        = 114
	TiDBParserDATE_SUB_SYMBOL                        = 115
	TiDBParserDATE_SYMBOL                            = 116
	TiDBParserDAYOFMONTH_SYMBOL                      = 117
	TiDBParserDAY_HOUR_SYMBOL                        = 118
	TiDBParserDAY_MICROSECOND_SYMBOL                 = 119
	TiDBParserDAY_MINUTE_SYMBOL                      = 120
	TiDBParserDAY_SECOND_SYMBOL                      = 121
	TiDBParserDAY_SYMBOL                             = 122
	TiDBParserDEALLOCATE_SYMBOL                      = 123
	TiDBParserDEC_SYMBOL                             = 124
	TiDBParserDECIMAL_NUM_SYMBOL                     = 125
	TiDBParserDECIMAL_SYMBOL                         = 126
	TiDBParserDECLARE_SYMBOL                         = 127
	TiDBParserDEFAULT_SYMBOL                         = 128
	TiDBParserDEFAULT_AUTH_SYMBOL                    = 129
	TiDBParserDEFINER_SYMBOL                         = 130
	TiDBParserDELAYED_SYMBOL                         = 131
	TiDBParserDELAY_KEY_WRITE_SYMBOL                 = 132
	TiDBParserDELETE_SYMBOL                          = 133
	TiDBParserDESC_SYMBOL                            = 134
	TiDBParserDESCRIBE_SYMBOL                        = 135
	TiDBParserDES_KEY_FILE_SYMBOL                    = 136
	TiDBParserDETERMINISTIC_SYMBOL                   = 137
	TiDBParserDIAGNOSTICS_SYMBOL                     = 138
	TiDBParserDIRECTORY_SYMBOL                       = 139
	TiDBParserDISABLE_SYMBOL                         = 140
	TiDBParserDISCARD_SYMBOL                         = 141
	TiDBParserDISK_SYMBOL                            = 142
	TiDBParserDISTINCT_SYMBOL                        = 143
	TiDBParserDISTINCTROW_SYMBOL                     = 144
	TiDBParserDIV_SYMBOL                             = 145
	TiDBParserDOUBLE_SYMBOL                          = 146
	TiDBParserDO_SYMBOL                              = 147
	TiDBParserDROP_SYMBOL                            = 148
	TiDBParserDUAL_SYMBOL                            = 149
	TiDBParserDUMPFILE_SYMBOL                        = 150
	TiDBParserDUPLICATE_SYMBOL                       = 151
	TiDBParserDYNAMIC_SYMBOL                         = 152
	TiDBParserEACH_SYMBOL                            = 153
	TiDBParserELSE_SYMBOL                            = 154
	TiDBParserELSEIF_SYMBOL                          = 155
	TiDBParserENABLE_SYMBOL                          = 156
	TiDBParserENCLOSED_SYMBOL                        = 157
	TiDBParserENCRYPTION_SYMBOL                      = 158
	TiDBParserEND_SYMBOL                             = 159
	TiDBParserENDS_SYMBOL                            = 160
	TiDBParserEND_OF_INPUT_SYMBOL                    = 161
	TiDBParserENGINES_SYMBOL                         = 162
	TiDBParserENGINE_SYMBOL                          = 163
	TiDBParserENUM_SYMBOL                            = 164
	TiDBParserERROR_SYMBOL                           = 165
	TiDBParserERRORS_SYMBOL                          = 166
	TiDBParserESCAPED_SYMBOL                         = 167
	TiDBParserESCAPE_SYMBOL                          = 168
	TiDBParserEVENTS_SYMBOL                          = 169
	TiDBParserEVENT_SYMBOL                           = 170
	TiDBParserEVERY_SYMBOL                           = 171
	TiDBParserEXCHANGE_SYMBOL                        = 172
	TiDBParserEXECUTE_SYMBOL                         = 173
	TiDBParserEXISTS_SYMBOL                          = 174
	TiDBParserEXIT_SYMBOL                            = 175
	TiDBParserEXPANSION_SYMBOL                       = 176
	TiDBParserEXPIRE_SYMBOL                          = 177
	TiDBParserEXPLAIN_SYMBOL                         = 178
	TiDBParserEXPORT_SYMBOL                          = 179
	TiDBParserEXTENDED_SYMBOL                        = 180
	TiDBParserEXTENT_SIZE_SYMBOL                     = 181
	TiDBParserEXTRACT_SYMBOL                         = 182
	TiDBParserFALSE_SYMBOL                           = 183
	TiDBParserFAST_SYMBOL                            = 184
	TiDBParserFAULTS_SYMBOL                          = 185
	TiDBParserFETCH_SYMBOL                           = 186
	TiDBParserFIELDS_SYMBOL                          = 187
	TiDBParserFILE_SYMBOL                            = 188
	TiDBParserFILE_BLOCK_SIZE_SYMBOL                 = 189
	TiDBParserFILTER_SYMBOL                          = 190
	TiDBParserFIRST_SYMBOL                           = 191
	TiDBParserFIXED_SYMBOL                           = 192
	TiDBParserFLOAT4_SYMBOL                          = 193
	TiDBParserFLOAT8_SYMBOL                          = 194
	TiDBParserFLOAT_SYMBOL                           = 195
	TiDBParserFLUSH_SYMBOL                           = 196
	TiDBParserFOLLOWS_SYMBOL                         = 197
	TiDBParserFORCE_SYMBOL                           = 198
	TiDBParserFOREIGN_SYMBOL                         = 199
	TiDBParserFOR_SYMBOL                             = 200
	TiDBParserFORMAT_SYMBOL                          = 201
	TiDBParserFOUND_SYMBOL                           = 202
	TiDBParserFROM_SYMBOL                            = 203
	TiDBParserFULL_SYMBOL                            = 204
	TiDBParserFULLTEXT_SYMBOL                        = 205
	TiDBParserFUNCTION_SYMBOL                        = 206
	TiDBParserGET_SYMBOL                             = 207
	TiDBParserGENERAL_SYMBOL                         = 208
	TiDBParserGENERATED_SYMBOL                       = 209
	TiDBParserGROUP_REPLICATION_SYMBOL               = 210
	TiDBParserGEOMETRYCOLLECTION_SYMBOL              = 211
	TiDBParserGEOMETRY_SYMBOL                        = 212
	TiDBParserGET_FORMAT_SYMBOL                      = 213
	TiDBParserGLOBAL_SYMBOL                          = 214
	TiDBParserGRANT_SYMBOL                           = 215
	TiDBParserGRANTS_SYMBOL                          = 216
	TiDBParserGROUP_SYMBOL                           = 217
	TiDBParserGROUP_CONCAT_SYMBOL                    = 218
	TiDBParserHANDLER_SYMBOL                         = 219
	TiDBParserHASH_SYMBOL                            = 220
	TiDBParserHAVING_SYMBOL                          = 221
	TiDBParserHELP_SYMBOL                            = 222
	TiDBParserHIGH_PRIORITY_SYMBOL                   = 223
	TiDBParserHOST_SYMBOL                            = 224
	TiDBParserHOSTS_SYMBOL                           = 225
	TiDBParserHOUR_MICROSECOND_SYMBOL                = 226
	TiDBParserHOUR_MINUTE_SYMBOL                     = 227
	TiDBParserHOUR_SECOND_SYMBOL                     = 228
	TiDBParserHOUR_SYMBOL                            = 229
	TiDBParserIDENTIFIED_SYMBOL                      = 230
	TiDBParserIF_SYMBOL                              = 231
	TiDBParserIGNORE_SYMBOL                          = 232
	TiDBParserIGNORE_SERVER_IDS_SYMBOL               = 233
	TiDBParserIMPORT_SYMBOL                          = 234
	TiDBParserINDEXES_SYMBOL                         = 235
	TiDBParserINDEX_SYMBOL                           = 236
	TiDBParserINFILE_SYMBOL                          = 237
	TiDBParserINITIAL_SIZE_SYMBOL                    = 238
	TiDBParserINNER_SYMBOL                           = 239
	TiDBParserINOUT_SYMBOL                           = 240
	TiDBParserINSENSITIVE_SYMBOL                     = 241
	TiDBParserINSERT_SYMBOL                          = 242
	TiDBParserINSERT_METHOD_SYMBOL                   = 243
	TiDBParserINSTANCE_SYMBOL                        = 244
	TiDBParserINSTALL_SYMBOL                         = 245
	TiDBParserINTEGER_SYMBOL                         = 246
	TiDBParserINTERVAL_SYMBOL                        = 247
	TiDBParserINTO_SYMBOL                            = 248
	TiDBParserINT_SYMBOL                             = 249
	TiDBParserINVOKER_SYMBOL                         = 250
	TiDBParserIN_SYMBOL                              = 251
	TiDBParserIO_AFTER_GTIDS_SYMBOL                  = 252
	TiDBParserIO_BEFORE_GTIDS_SYMBOL                 = 253
	TiDBParserIO_THREAD_SYMBOL                       = 254
	TiDBParserIO_SYMBOL                              = 255
	TiDBParserIPC_SYMBOL                             = 256
	TiDBParserIS_SYMBOL                              = 257
	TiDBParserISOLATION_SYMBOL                       = 258
	TiDBParserISSUER_SYMBOL                          = 259
	TiDBParserITERATE_SYMBOL                         = 260
	TiDBParserJOIN_SYMBOL                            = 261
	TiDBParserJSON_SYMBOL                            = 262
	TiDBParserKEYS_SYMBOL                            = 263
	TiDBParserKEY_BLOCK_SIZE_SYMBOL                  = 264
	TiDBParserKEY_SYMBOL                             = 265
	TiDBParserKILL_SYMBOL                            = 266
	TiDBParserLANGUAGE_SYMBOL                        = 267
	TiDBParserLAST_SYMBOL                            = 268
	TiDBParserLEADING_SYMBOL                         = 269
	TiDBParserLEAVES_SYMBOL                          = 270
	TiDBParserLEAVE_SYMBOL                           = 271
	TiDBParserLEFT_SYMBOL                            = 272
	TiDBParserLESS_SYMBOL                            = 273
	TiDBParserLEVEL_SYMBOL                           = 274
	TiDBParserLIKE_SYMBOL                            = 275
	TiDBParserLIMIT_SYMBOL                           = 276
	TiDBParserLINEAR_SYMBOL                          = 277
	TiDBParserLINES_SYMBOL                           = 278
	TiDBParserLINESTRING_SYMBOL                      = 279
	TiDBParserLIST_SYMBOL                            = 280
	TiDBParserLOAD_SYMBOL                            = 281
	TiDBParserLOCALTIME_SYMBOL                       = 282
	TiDBParserLOCALTIMESTAMP_SYMBOL                  = 283
	TiDBParserLOCAL_SYMBOL                           = 284
	TiDBParserLOCATOR_SYMBOL                         = 285
	TiDBParserLOCKS_SYMBOL                           = 286
	TiDBParserLOCK_SYMBOL                            = 287
	TiDBParserLOGFILE_SYMBOL                         = 288
	TiDBParserLOGS_SYMBOL                            = 289
	TiDBParserLONGBLOB_SYMBOL                        = 290
	TiDBParserLONGTEXT_SYMBOL                        = 291
	TiDBParserLONG_NUM_SYMBOL                        = 292
	TiDBParserLONG_SYMBOL                            = 293
	TiDBParserLOOP_SYMBOL                            = 294
	TiDBParserLOW_PRIORITY_SYMBOL                    = 295
	TiDBParserMASTER_AUTO_POSITION_SYMBOL            = 296
	TiDBParserMASTER_BIND_SYMBOL                     = 297
	TiDBParserMASTER_CONNECT_RETRY_SYMBOL            = 298
	TiDBParserMASTER_DELAY_SYMBOL                    = 299
	TiDBParserMASTER_HOST_SYMBOL                     = 300
	TiDBParserMASTER_LOG_FILE_SYMBOL                 = 301
	TiDBParserMASTER_LOG_POS_SYMBOL                  = 302
	TiDBParserMASTER_PASSWORD_SYMBOL                 = 303
	TiDBParserMASTER_PORT_SYMBOL                     = 304
	TiDBParserMASTER_RETRY_COUNT_SYMBOL              = 305
	TiDBParserMASTER_SERVER_ID_SYMBOL                = 306
	TiDBParserMASTER_SSL_CAPATH_SYMBOL               = 307
	TiDBParserMASTER_SSL_CA_SYMBOL                   = 308
	TiDBParserMASTER_SSL_CERT_SYMBOL                 = 309
	TiDBParserMASTER_SSL_CIPHER_SYMBOL               = 310
	TiDBParserMASTER_SSL_CRL_SYMBOL                  = 311
	TiDBParserMASTER_SSL_CRLPATH_SYMBOL              = 312
	TiDBParserMASTER_SSL_KEY_SYMBOL                  = 313
	TiDBParserMASTER_SSL_SYMBOL                      = 314
	TiDBParserMASTER_SSL_VERIFY_SERVER_CERT_SYMBOL   = 315
	TiDBParserMASTER_SYMBOL                          = 316
	TiDBParserMASTER_TLS_VERSION_SYMBOL              = 317
	TiDBParserMASTER_USER_SYMBOL                     = 318
	TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL         = 319
	TiDBParserMATCH_SYMBOL                           = 320
	TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL        = 321
	TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL            = 322
	TiDBParserMAX_ROWS_SYMBOL                        = 323
	TiDBParserMAX_SIZE_SYMBOL                        = 324
	TiDBParserMAX_STATEMENT_TIME_SYMBOL              = 325
	TiDBParserMAX_SYMBOL                             = 326
	TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL            = 327
	TiDBParserMAX_USER_CONNECTIONS_SYMBOL            = 328
	TiDBParserMAXVALUE_SYMBOL                        = 329
	TiDBParserMEDIUMBLOB_SYMBOL                      = 330
	TiDBParserMEDIUMINT_SYMBOL                       = 331
	TiDBParserMEDIUMTEXT_SYMBOL                      = 332
	TiDBParserMEDIUM_SYMBOL                          = 333
	TiDBParserMEMORY_SYMBOL                          = 334
	TiDBParserMERGE_SYMBOL                           = 335
	TiDBParserMESSAGE_TEXT_SYMBOL                    = 336
	TiDBParserMICROSECOND_SYMBOL                     = 337
	TiDBParserMID_SYMBOL                             = 338
	TiDBParserMIDDLEINT_SYMBOL                       = 339
	TiDBParserMIGRATE_SYMBOL                         = 340
	TiDBParserMINUTE_MICROSECOND_SYMBOL              = 341
	TiDBParserMINUTE_SECOND_SYMBOL                   = 342
	TiDBParserMINUTE_SYMBOL                          = 343
	TiDBParserMIN_ROWS_SYMBOL                        = 344
	TiDBParserMIN_SYMBOL                             = 345
	TiDBParserMODE_SYMBOL                            = 346
	TiDBParserMODIFIES_SYMBOL                        = 347
	TiDBParserMODIFY_SYMBOL                          = 348
	TiDBParserMOD_SYMBOL                             = 349
	TiDBParserMONTH_SYMBOL                           = 350
	TiDBParserMULTILINESTRING_SYMBOL                 = 351
	TiDBParserMULTIPOINT_SYMBOL                      = 352
	TiDBParserMULTIPOLYGON_SYMBOL                    = 353
	TiDBParserMUTEX_SYMBOL                           = 354
	TiDBParserMYSQL_ERRNO_SYMBOL                     = 355
	TiDBParserNAMES_SYMBOL                           = 356
	TiDBParserNAME_SYMBOL                            = 357
	TiDBParserNATIONAL_SYMBOL                        = 358
	TiDBParserNATURAL_SYMBOL                         = 359
	TiDBParserNCHAR_STRING_SYMBOL                    = 360
	TiDBParserNCHAR_SYMBOL                           = 361
	TiDBParserNDB_SYMBOL                             = 362
	TiDBParserNDBCLUSTER_SYMBOL                      = 363
	TiDBParserNEG_SYMBOL                             = 364
	TiDBParserNEVER_SYMBOL                           = 365
	TiDBParserNEW_SYMBOL                             = 366
	TiDBParserNEXT_SYMBOL                            = 367
	TiDBParserNODEGROUP_SYMBOL                       = 368
	TiDBParserNONE_SYMBOL                            = 369
	TiDBParserNONBLOCKING_SYMBOL                     = 370
	TiDBParserNOT_SYMBOL                             = 371
	TiDBParserNOW_SYMBOL                             = 372
	TiDBParserNO_SYMBOL                              = 373
	TiDBParserNO_WAIT_SYMBOL                         = 374
	TiDBParserNO_WRITE_TO_BINLOG_SYMBOL              = 375
	TiDBParserNULL_SYMBOL                            = 376
	TiDBParserNUMBER_SYMBOL                          = 377
	TiDBParserNUMERIC_SYMBOL                         = 378
	TiDBParserNVARCHAR_SYMBOL                        = 379
	TiDBParserOFFLINE_SYMBOL                         = 380
	TiDBParserOFFSET_SYMBOL                          = 381
	TiDBParserOLD_PASSWORD_SYMBOL                    = 382
	TiDBParserON_SYMBOL                              = 383
	TiDBParserONE_SYMBOL                             = 384
	TiDBParserONLINE_SYMBOL                          = 385
	TiDBParserONLY_SYMBOL                            = 386
	TiDBParserOPEN_SYMBOL                            = 387
	TiDBParserOPTIMIZE_SYMBOL                        = 388
	TiDBParserOPTIMIZER_COSTS_SYMBOL                 = 389
	TiDBParserOPTIONS_SYMBOL                         = 390
	TiDBParserOPTION_SYMBOL                          = 391
	TiDBParserOPTIONALLY_SYMBOL                      = 392
	TiDBParserORDER_SYMBOL                           = 393
	TiDBParserOR_SYMBOL                              = 394
	TiDBParserOUTER_SYMBOL                           = 395
	TiDBParserOUTFILE_SYMBOL                         = 396
	TiDBParserOUT_SYMBOL                             = 397
	TiDBParserOWNER_SYMBOL                           = 398
	TiDBParserPACK_KEYS_SYMBOL                       = 399
	TiDBParserPAGE_SYMBOL                            = 400
	TiDBParserPARSER_SYMBOL                          = 401
	TiDBParserPARTIAL_SYMBOL                         = 402
	TiDBParserPARTITIONING_SYMBOL                    = 403
	TiDBParserPARTITIONS_SYMBOL                      = 404
	TiDBParserPARTITION_SYMBOL                       = 405
	TiDBParserPASSWORD_SYMBOL                        = 406
	TiDBParserPHASE_SYMBOL                           = 407
	TiDBParserPLUGINS_SYMBOL                         = 408
	TiDBParserPLUGIN_DIR_SYMBOL                      = 409
	TiDBParserPLUGIN_SYMBOL                          = 410
	TiDBParserPOINT_SYMBOL                           = 411
	TiDBParserPOLYGON_SYMBOL                         = 412
	TiDBParserPORT_SYMBOL                            = 413
	TiDBParserPOSITION_SYMBOL                        = 414
	TiDBParserPRECEDES_SYMBOL                        = 415
	TiDBParserPRECISION_SYMBOL                       = 416
	TiDBParserPREPARE_SYMBOL                         = 417
	TiDBParserPRESERVE_SYMBOL                        = 418
	TiDBParserPREV_SYMBOL                            = 419
	TiDBParserPRIMARY_SYMBOL                         = 420
	TiDBParserPRIVILEGES_SYMBOL                      = 421
	TiDBParserPROCEDURE_SYMBOL                       = 422
	TiDBParserPROCESS_SYMBOL                         = 423
	TiDBParserPROCESSLIST_SYMBOL                     = 424
	TiDBParserPROFILE_SYMBOL                         = 425
	TiDBParserPROFILES_SYMBOL                        = 426
	TiDBParserPROXY_SYMBOL                           = 427
	TiDBParserPURGE_SYMBOL                           = 428
	TiDBParserQUARTER_SYMBOL                         = 429
	TiDBParserQUERY_SYMBOL                           = 430
	TiDBParserQUICK_SYMBOL                           = 431
	TiDBParserRANGE_SYMBOL                           = 432
	TiDBParserREADS_SYMBOL                           = 433
	TiDBParserREAD_ONLY_SYMBOL                       = 434
	TiDBParserREAD_SYMBOL                            = 435
	TiDBParserREAD_WRITE_SYMBOL                      = 436
	TiDBParserREAL_SYMBOL                            = 437
	TiDBParserREBUILD_SYMBOL                         = 438
	TiDBParserRECOVER_SYMBOL                         = 439
	TiDBParserREDOFILE_SYMBOL                        = 440
	TiDBParserREDO_BUFFER_SIZE_SYMBOL                = 441
	TiDBParserREDUNDANT_SYMBOL                       = 442
	TiDBParserREFERENCES_SYMBOL                      = 443
	TiDBParserREGEXP_SYMBOL                          = 444
	TiDBParserRELAY_SYMBOL                           = 445
	TiDBParserRELAYLOG_SYMBOL                        = 446
	TiDBParserRELAY_LOG_FILE_SYMBOL                  = 447
	TiDBParserRELAY_LOG_POS_SYMBOL                   = 448
	TiDBParserRELAY_THREAD_SYMBOL                    = 449
	TiDBParserRELEASE_SYMBOL                         = 450
	TiDBParserRELOAD_SYMBOL                          = 451
	TiDBParserREMOVE_SYMBOL                          = 452
	TiDBParserRENAME_SYMBOL                          = 453
	TiDBParserREORGANIZE_SYMBOL                      = 454
	TiDBParserREPAIR_SYMBOL                          = 455
	TiDBParserREPEATABLE_SYMBOL                      = 456
	TiDBParserREPEAT_SYMBOL                          = 457
	TiDBParserREPLACE_SYMBOL                         = 458
	TiDBParserREPLICATION_SYMBOL                     = 459
	TiDBParserREPLICATE_DO_DB_SYMBOL                 = 460
	TiDBParserREPLICATE_IGNORE_DB_SYMBOL             = 461
	TiDBParserREPLICATE_DO_TABLE_SYMBOL              = 462
	TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL          = 463
	TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL         = 464
	TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL     = 465
	TiDBParserREPLICATE_REWRITE_DB_SYMBOL            = 466
	TiDBParserREQUIRE_SYMBOL                         = 467
	TiDBParserRESET_SYMBOL                           = 468
	TiDBParserRESIGNAL_SYMBOL                        = 469
	TiDBParserRESTORE_SYMBOL                         = 470
	TiDBParserRESTRICT_SYMBOL                        = 471
	TiDBParserRESUME_SYMBOL                          = 472
	TiDBParserRETURNED_SQLSTATE_SYMBOL               = 473
	TiDBParserRETURNS_SYMBOL                         = 474
	TiDBParserRETURN_SYMBOL                          = 475
	TiDBParserREVERSE_SYMBOL                         = 476
	TiDBParserREVOKE_SYMBOL                          = 477
	TiDBParserRIGHT_SYMBOL                           = 478
	TiDBParserRLIKE_SYMBOL                           = 479
	TiDBParserROLLBACK_SYMBOL                        = 480
	TiDBParserROLLUP_SYMBOL                          = 481
	TiDBParserROTATE_SYMBOL                          = 482
	TiDBParserROUTINE_SYMBOL                         = 483
	TiDBParserROWS_SYMBOL                            = 484
	TiDBParserROW_COUNT_SYMBOL                       = 485
	TiDBParserROW_FORMAT_SYMBOL                      = 486
	TiDBParserROW_SYMBOL                             = 487
	TiDBParserRTREE_SYMBOL                           = 488
	TiDBParserSAVEPOINT_SYMBOL                       = 489
	TiDBParserSCHEDULE_SYMBOL                        = 490
	TiDBParserSCHEMA_SYMBOL                          = 491
	TiDBParserSCHEMA_NAME_SYMBOL                     = 492
	TiDBParserSCHEMAS_SYMBOL                         = 493
	TiDBParserSECOND_MICROSECOND_SYMBOL              = 494
	TiDBParserSECOND_SYMBOL                          = 495
	TiDBParserSECURITY_SYMBOL                        = 496
	TiDBParserSELECT_SYMBOL                          = 497
	TiDBParserSENSITIVE_SYMBOL                       = 498
	TiDBParserSEPARATOR_SYMBOL                       = 499
	TiDBParserSERIALIZABLE_SYMBOL                    = 500
	TiDBParserSERIAL_SYMBOL                          = 501
	TiDBParserSESSION_SYMBOL                         = 502
	TiDBParserSERVER_SYMBOL                          = 503
	TiDBParserSERVER_OPTIONS_SYMBOL                  = 504
	TiDBParserSESSION_USER_SYMBOL                    = 505
	TiDBParserSET_SYMBOL                             = 506
	TiDBParserSET_VAR_SYMBOL                         = 507
	TiDBParserSHARE_SYMBOL                           = 508
	TiDBParserSHOW_SYMBOL                            = 509
	TiDBParserSHUTDOWN_SYMBOL                        = 510
	TiDBParserSIGNAL_SYMBOL                          = 511
	TiDBParserSIGNED_SYMBOL                          = 512
	TiDBParserSIMPLE_SYMBOL                          = 513
	TiDBParserSLAVE_SYMBOL                           = 514
	TiDBParserSLOW_SYMBOL                            = 515
	TiDBParserSMALLINT_SYMBOL                        = 516
	TiDBParserSNAPSHOT_SYMBOL                        = 517
	TiDBParserSOME_SYMBOL                            = 518
	TiDBParserSOCKET_SYMBOL                          = 519
	TiDBParserSONAME_SYMBOL                          = 520
	TiDBParserSOUNDS_SYMBOL                          = 521
	TiDBParserSOURCE_SYMBOL                          = 522
	TiDBParserSPATIAL_SYMBOL                         = 523
	TiDBParserSPECIFIC_SYMBOL                        = 524
	TiDBParserSQLEXCEPTION_SYMBOL                    = 525
	TiDBParserSQLSTATE_SYMBOL                        = 526
	TiDBParserSQLWARNING_SYMBOL                      = 527
	TiDBParserSQL_AFTER_GTIDS_SYMBOL                 = 528
	TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL              = 529
	TiDBParserSQL_BEFORE_GTIDS_SYMBOL                = 530
	TiDBParserSQL_BIG_RESULT_SYMBOL                  = 531
	TiDBParserSQL_BUFFER_RESULT_SYMBOL               = 532
	TiDBParserSQL_CACHE_SYMBOL                       = 533
	TiDBParserSQL_CALC_FOUND_ROWS_SYMBOL             = 534
	TiDBParserSQL_NO_CACHE_SYMBOL                    = 535
	TiDBParserSQL_SMALL_RESULT_SYMBOL                = 536
	TiDBParserSQL_SYMBOL                             = 537
	TiDBParserSQL_THREAD_SYMBOL                      = 538
	TiDBParserSSL_SYMBOL                             = 539
	TiDBParserSTACKED_SYMBOL                         = 540
	TiDBParserSTARTING_SYMBOL                        = 541
	TiDBParserSTARTS_SYMBOL                          = 542
	TiDBParserSTART_SYMBOL                           = 543
	TiDBParserSTATS_AUTO_RECALC_SYMBOL               = 544
	TiDBParserSTATS_PERSISTENT_SYMBOL                = 545
	TiDBParserSTATS_SAMPLE_PAGES_SYMBOL              = 546
	TiDBParserSTATUS_SYMBOL                          = 547
	TiDBParserSTDDEV_SAMP_SYMBOL                     = 548
	TiDBParserSTDDEV_SYMBOL                          = 549
	TiDBParserSTDDEV_POP_SYMBOL                      = 550
	TiDBParserSTD_SYMBOL                             = 551
	TiDBParserSTOP_SYMBOL                            = 552
	TiDBParserSTORAGE_SYMBOL                         = 553
	TiDBParserSTORED_SYMBOL                          = 554
	TiDBParserSTRAIGHT_JOIN_SYMBOL                   = 555
	TiDBParserSTRING_SYMBOL                          = 556
	TiDBParserSUBCLASS_ORIGIN_SYMBOL                 = 557
	TiDBParserSUBDATE_SYMBOL                         = 558
	TiDBParserSUBJECT_SYMBOL                         = 559
	TiDBParserSUBPARTITIONS_SYMBOL                   = 560
	TiDBParserSUBPARTITION_SYMBOL                    = 561
	TiDBParserSUBSTR_SYMBOL                          = 562
	TiDBParserSUBSTRING_SYMBOL                       = 563
	TiDBParserSUM_SYMBOL                             = 564
	TiDBParserSUPER_SYMBOL                           = 565
	TiDBParserSUSPEND_SYMBOL                         = 566
	TiDBParserSWAPS_SYMBOL                           = 567
	TiDBParserSWITCHES_SYMBOL                        = 568
	TiDBParserSYSDATE_SYMBOL                         = 569
	TiDBParserSYSTEM_USER_SYMBOL                     = 570
	TiDBParserTABLES_SYMBOL                          = 571
	TiDBParserTABLESPACE_SYMBOL                      = 572
	TiDBParserTABLE_REF_PRIORITY_SYMBOL              = 573
	TiDBParserTABLE_SYMBOL                           = 574
	TiDBParserTABLE_CHECKSUM_SYMBOL                  = 575
	TiDBParserTABLE_NAME_SYMBOL                      = 576
	TiDBParserTEMPORARY_SYMBOL                       = 577
	TiDBParserTEMPTABLE_SYMBOL                       = 578
	TiDBParserTERMINATED_SYMBOL                      = 579
	TiDBParserTEXT_SYMBOL                            = 580
	TiDBParserTHAN_SYMBOL                            = 581
	TiDBParserTHEN_SYMBOL                            = 582
	TiDBParserTIMESTAMP_SYMBOL                       = 583
	TiDBParserTIMESTAMP_ADD_SYMBOL                   = 584
	TiDBParserTIMESTAMP_DIFF_SYMBOL                  = 585
	TiDBParserTIME_SYMBOL                            = 586
	TiDBParserTINYBLOB_SYMBOL                        = 587
	TiDBParserTINYINT_SYMBOL                         = 588
	TiDBParserTINYTEXT_SYMBOL                        = 589
	TiDBParserTO_SYMBOL                              = 590
	TiDBParserTRAILING_SYMBOL                        = 591
	TiDBParserTRANSACTION_SYMBOL                     = 592
	TiDBParserTRIGGERS_SYMBOL                        = 593
	TiDBParserTRIGGER_SYMBOL                         = 594
	TiDBParserTRIM_SYMBOL                            = 595
	TiDBParserTRUE_SYMBOL                            = 596
	TiDBParserTRUNCATE_SYMBOL                        = 597
	TiDBParserTYPES_SYMBOL                           = 598
	TiDBParserTYPE_SYMBOL                            = 599
	TiDBParserUDF_RETURNS_SYMBOL                     = 600
	TiDBParserUNCOMMITTED_SYMBOL                     = 601
	TiDBParserUNDEFINED_SYMBOL                       = 602
	TiDBParserUNDOFILE_SYMBOL                        = 603
	TiDBParserUNDO_BUFFER_SIZE_SYMBOL                = 604
	TiDBParserUNDO_SYMBOL                            = 605
	TiDBParserUNICODE_SYMBOL                         = 606
	TiDBParserUNINSTALL_SYMBOL                       = 607
	TiDBParserUNION_SYMBOL                           = 608
	TiDBParserUNIQUE_SYMBOL                          = 609
	TiDBParserUNKNOWN_SYMBOL                         = 610
	TiDBParserUNLOCK_SYMBOL                          = 611
	TiDBParserUNSIGNED_SYMBOL                        = 612
	TiDBParserUNTIL_SYMBOL                           = 613
	TiDBParserUPDATE_SYMBOL                          = 614
	TiDBParserUPGRADE_SYMBOL                         = 615
	TiDBParserUSAGE_SYMBOL                           = 616
	TiDBParserUSER_RESOURCES_SYMBOL                  = 617
	TiDBParserUSER_SYMBOL                            = 618
	TiDBParserUSE_FRM_SYMBOL                         = 619
	TiDBParserUSE_SYMBOL                             = 620
	TiDBParserUSING_SYMBOL                           = 621
	TiDBParserUTC_DATE_SYMBOL                        = 622
	TiDBParserUTC_TIMESTAMP_SYMBOL                   = 623
	TiDBParserUTC_TIME_SYMBOL                        = 624
	TiDBParserVALIDATION_SYMBOL                      = 625
	TiDBParserVALUES_SYMBOL                          = 626
	TiDBParserVALUE_SYMBOL                           = 627
	TiDBParserVARBINARY_SYMBOL                       = 628
	TiDBParserVARCHAR_SYMBOL                         = 629
	TiDBParserVARCHARACTER_SYMBOL                    = 630
	TiDBParserVARIABLES_SYMBOL                       = 631
	TiDBParserVARIANCE_SYMBOL                        = 632
	TiDBParserVARYING_SYMBOL                         = 633
	TiDBParserVAR_POP_SYMBOL                         = 634
	TiDBParserVAR_SAMP_SYMBOL                        = 635
	TiDBParserVIEW_SYMBOL                            = 636
	TiDBParserVIRTUAL_SYMBOL                         = 637
	TiDBParserWAIT_SYMBOL                            = 638
	TiDBParserWARNINGS_SYMBOL                        = 639
	TiDBParserWEEK_SYMBOL                            = 640
	TiDBParserWEIGHT_STRING_SYMBOL                   = 641
	TiDBParserWHEN_SYMBOL                            = 642
	TiDBParserWHERE_SYMBOL                           = 643
	TiDBParserWHILE_SYMBOL                           = 644
	TiDBParserWITH_SYMBOL                            = 645
	TiDBParserWITHOUT_SYMBOL                         = 646
	TiDBParserWORK_SYMBOL                            = 647
	TiDBParserWRAPPER_SYMBOL                         = 648
	TiDBParserWRITE_SYMBOL                           = 649
	TiDBParserX509_SYMBOL                            = 650
	TiDBParserXA_SYMBOL                              = 651
	TiDBParserXID_SYMBOL                             = 652
	TiDBParserXML_SYMBOL                             = 653
	TiDBParserXOR_SYMBOL                             = 654
	TiDBParserYEAR_MONTH_SYMBOL                      = 655
	TiDBParserYEAR_SYMBOL                            = 656
	TiDBParserZEROFILL_SYMBOL                        = 657
	TiDBParserPERSIST_SYMBOL                         = 658
	TiDBParserROLE_SYMBOL                            = 659
	TiDBParserADMIN_SYMBOL                           = 660
	TiDBParserINVISIBLE_SYMBOL                       = 661
	TiDBParserVISIBLE_SYMBOL                         = 662
	TiDBParserEXCEPT_SYMBOL                          = 663
	TiDBParserCOMPONENT_SYMBOL                       = 664
	TiDBParserRECURSIVE_SYMBOL                       = 665
	TiDBParserJSON_OBJECTAGG_SYMBOL                  = 666
	TiDBParserJSON_ARRAYAGG_SYMBOL                   = 667
	TiDBParserOF_SYMBOL                              = 668
	TiDBParserSKIP_SYMBOL                            = 669
	TiDBParserLOCKED_SYMBOL                          = 670
	TiDBParserNOWAIT_SYMBOL                          = 671
	TiDBParserGROUPING_SYMBOL                        = 672
	TiDBParserPERSIST_ONLY_SYMBOL                    = 673
	TiDBParserHISTOGRAM_SYMBOL                       = 674
	TiDBParserBUCKETS_SYMBOL                         = 675
	TiDBParserREMOTE_SYMBOL                          = 676
	TiDBParserCLONE_SYMBOL                           = 677
	TiDBParserCUME_DIST_SYMBOL                       = 678
	TiDBParserDENSE_RANK_SYMBOL                      = 679
	TiDBParserEXCLUDE_SYMBOL                         = 680
	TiDBParserFIRST_VALUE_SYMBOL                     = 681
	TiDBParserFOLLOWING_SYMBOL                       = 682
	TiDBParserGROUPS_SYMBOL                          = 683
	TiDBParserLAG_SYMBOL                             = 684
	TiDBParserLAST_VALUE_SYMBOL                      = 685
	TiDBParserLEAD_SYMBOL                            = 686
	TiDBParserNTH_VALUE_SYMBOL                       = 687
	TiDBParserNTILE_SYMBOL                           = 688
	TiDBParserNULLS_SYMBOL                           = 689
	TiDBParserOTHERS_SYMBOL                          = 690
	TiDBParserOVER_SYMBOL                            = 691
	TiDBParserPERCENT_RANK_SYMBOL                    = 692
	TiDBParserPRECEDING_SYMBOL                       = 693
	TiDBParserRANK_SYMBOL                            = 694
	TiDBParserRESPECT_SYMBOL                         = 695
	TiDBParserROW_NUMBER_SYMBOL                      = 696
	TiDBParserTIES_SYMBOL                            = 697
	TiDBParserUNBOUNDED_SYMBOL                       = 698
	TiDBParserWINDOW_SYMBOL                          = 699
	TiDBParserEMPTY_SYMBOL                           = 700
	TiDBParserJSON_TABLE_SYMBOL                      = 701
	TiDBParserNESTED_SYMBOL                          = 702
	TiDBParserORDINALITY_SYMBOL                      = 703
	TiDBParserPATH_SYMBOL                            = 704
	TiDBParserHISTORY_SYMBOL                         = 705
	TiDBParserREUSE_SYMBOL                           = 706
	TiDBParserSRID_SYMBOL                            = 707
	TiDBParserTHREAD_PRIORITY_SYMBOL                 = 708
	TiDBParserRESOURCE_SYMBOL                        = 709
	TiDBParserSYSTEM_SYMBOL                          = 710
	TiDBParserVCPU_SYMBOL                            = 711
	TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL          = 712
	TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL           = 713
	TiDBParserRESTART_SYMBOL                         = 714
	TiDBParserDEFINITION_SYMBOL                      = 715
	TiDBParserDESCRIPTION_SYMBOL                     = 716
	TiDBParserORGANIZATION_SYMBOL                    = 717
	TiDBParserREFERENCE_SYMBOL                       = 718
	TiDBParserOPTIONAL_SYMBOL                        = 719
	TiDBParserSECONDARY_SYMBOL                       = 720
	TiDBParserSECONDARY_ENGINE_SYMBOL                = 721
	TiDBParserSECONDARY_LOAD_SYMBOL                  = 722
	TiDBParserSECONDARY_UNLOAD_SYMBOL                = 723
	TiDBParserACTIVE_SYMBOL                          = 724
	TiDBParserINACTIVE_SYMBOL                        = 725
	TiDBParserLATERAL_SYMBOL                         = 726
	TiDBParserRETAIN_SYMBOL                          = 727
	TiDBParserOLD_SYMBOL                             = 728
	TiDBParserNETWORK_NAMESPACE_SYMBOL               = 729
	TiDBParserENFORCED_SYMBOL                        = 730
	TiDBParserARRAY_SYMBOL                           = 731
	TiDBParserOJ_SYMBOL                              = 732
	TiDBParserMEMBER_SYMBOL                          = 733
	TiDBParserRANDOM_SYMBOL                          = 734
	TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL    = 735
	TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL   = 736
	TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL           = 737
	TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL         = 738
	TiDBParserREQUIRE_ROW_FORMAT_SYMBOL              = 739
	TiDBParserPASSWORD_LOCK_TIME_SYMBOL              = 740
	TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL           = 741
	TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL = 742
	TiDBParserSTREAM_SYMBOL                          = 743
	TiDBParserOFF_SYMBOL                             = 744
	TiDBParserNOT2_SYMBOL                            = 745
	TiDBParserCONCAT_PIPES_SYMBOL                    = 746
	TiDBParserINT_NUMBER                             = 747
	TiDBParserLONG_NUMBER                            = 748
	TiDBParserULONGLONG_NUMBER                       = 749
	TiDBParserEQUAL_OPERATOR                         = 750
	TiDBParserASSIGN_OPERATOR                        = 751
	TiDBParserNULL_SAFE_EQUAL_OPERATOR               = 752
	TiDBParserGREATER_OR_EQUAL_OPERATOR              = 753
	TiDBParserGREATER_THAN_OPERATOR                  = 754
	TiDBParserLESS_OR_EQUAL_OPERATOR                 = 755
	TiDBParserLESS_THAN_OPERATOR                     = 756
	TiDBParserNOT_EQUAL_OPERATOR                     = 757
	TiDBParserPLUS_OPERATOR                          = 758
	TiDBParserMINUS_OPERATOR                         = 759
	TiDBParserMULT_OPERATOR                          = 760
	TiDBParserDIV_OPERATOR                           = 761
	TiDBParserMOD_OPERATOR                           = 762
	TiDBParserLOGICAL_NOT_OPERATOR                   = 763
	TiDBParserBITWISE_NOT_OPERATOR                   = 764
	TiDBParserSHIFT_LEFT_OPERATOR                    = 765
	TiDBParserSHIFT_RIGHT_OPERATOR                   = 766
	TiDBParserLOGICAL_AND_OPERATOR                   = 767
	TiDBParserBITWISE_AND_OPERATOR                   = 768
	TiDBParserBITWISE_XOR_OPERATOR                   = 769
	TiDBParserLOGICAL_OR_OPERATOR                    = 770
	TiDBParserBITWISE_OR_OPERATOR                    = 771
	TiDBParserDOT_SYMBOL                             = 772
	TiDBParserCOMMA_SYMBOL                           = 773
	TiDBParserSEMICOLON_SYMBOL                       = 774
	TiDBParserCOLON_SYMBOL                           = 775
	TiDBParserOPEN_PAR_SYMBOL                        = 776
	TiDBParserCLOSE_PAR_SYMBOL                       = 777
	TiDBParserOPEN_CURLY_SYMBOL                      = 778
	TiDBParserCLOSE_CURLY_SYMBOL                     = 779
	TiDBParserUNDERLINE_SYMBOL                       = 780
	TiDBParserJSON_SEPARATOR_SYMBOL                  = 781
	TiDBParserJSON_UNQUOTED_SEPARATOR_SYMBOL         = 782
	TiDBParserAT_SIGN_SYMBOL                         = 783
	TiDBParserAT_TEXT_SUFFIX                         = 784
	TiDBParserAT_AT_SIGN_SYMBOL                      = 785
	TiDBParserNULL2_SYMBOL                           = 786
	TiDBParserPARAM_MARKER                           = 787
	TiDBParserHEX_NUMBER                             = 788
	TiDBParserBIN_NUMBER                             = 789
	TiDBParserDECIMAL_NUMBER                         = 790
	TiDBParserFLOAT_NUMBER                           = 791
	TiDBParserAUTO_RANDOM_SYMBOL                     = 792
	TiDBParserWHITESPACE                             = 793
	TiDBParserINVALID_INPUT                          = 794
	TiDBParserS3_SYMBOL                              = 795
	TiDBParserINVOKE_SYMBOL                          = 796
	TiDBParserLAMBDA_SYMBOL                          = 797
	TiDBParserATTRIBUTE_SYMBOL                       = 798
	TiDBParserJSON_VALUE_SYMBOL                      = 799
	TiDBParserRETURNING_SYMBOL                       = 800
	TiDBParserINTERSECT_SYMBOL                       = 801
	TiDBParserUNDERSCORE_CHARSET                     = 802
	TiDBParserIDENTIFIER                             = 803
	TiDBParserNCHAR_TEXT                             = 804
	TiDBParserBACK_TICK_QUOTED_ID                    = 805
	TiDBParserDOUBLE_QUOTED_TEXT                     = 806
	TiDBParserSINGLE_QUOTED_TEXT                     = 807
	TiDBParserVERSION_COMMENT_START                  = 808
	TiDBParserMYSQL_COMMENT_START                    = 809
	TiDBParserVERSION_COMMENT_END                    = 810
	TiDBParserBLOCK_COMMENT                          = 811
	TiDBParserPOUND_COMMENT                          = 812
	TiDBParserDASHDASH_COMMENT                       = 813
	TiDBParserNOT_EQUAL2_OPERATOR                    = 814
)

// TiDBParser rules.
const (
	TiDBParserRULE_singleColumnDef                             = 0
	TiDBParserRULE_columnDef                                   = 1
	TiDBParserRULE_columnOptionList                            = 2
	TiDBParserRULE_columnOption                                = 3
	TiDBParserRULE_constraintName                              = 4
	TiDBParserRULE_constraintEnforcement                       = 5
	TiDBParserRULE_selectStatement                             = 6
	TiDBParserRULE_selectStatementWithInto                     = 7
	TiDBParserRULE_queryExpression                             = 8
	TiDBParserRULE_queryExpressionBody                         = 9
	TiDBParserRULE_queryExpressionParens                       = 10
	TiDBParserRULE_queryPrimary                                = 11
	TiDBParserRULE_querySpecification                          = 12
	TiDBParserRULE_subquery                                    = 13
	TiDBParserRULE_querySpecOption                             = 14
	TiDBParserRULE_limitClause                                 = 15
	TiDBParserRULE_simpleLimitClause                           = 16
	TiDBParserRULE_limitOptions                                = 17
	TiDBParserRULE_limitOption                                 = 18
	TiDBParserRULE_intoClause                                  = 19
	TiDBParserRULE_procedureAnalyseClause                      = 20
	TiDBParserRULE_havingClause                                = 21
	TiDBParserRULE_windowClause                                = 22
	TiDBParserRULE_windowDefinition                            = 23
	TiDBParserRULE_windowSpec                                  = 24
	TiDBParserRULE_windowSpecDetails                           = 25
	TiDBParserRULE_windowFrameClause                           = 26
	TiDBParserRULE_windowFrameUnits                            = 27
	TiDBParserRULE_windowFrameExtent                           = 28
	TiDBParserRULE_windowFrameStart                            = 29
	TiDBParserRULE_windowFrameBetween                          = 30
	TiDBParserRULE_windowFrameBound                            = 31
	TiDBParserRULE_windowFrameExclusion                        = 32
	TiDBParserRULE_withClause                                  = 33
	TiDBParserRULE_commonTableExpression                       = 34
	TiDBParserRULE_groupByClause                               = 35
	TiDBParserRULE_olapOption                                  = 36
	TiDBParserRULE_orderClause                                 = 37
	TiDBParserRULE_direction                                   = 38
	TiDBParserRULE_fromClause                                  = 39
	TiDBParserRULE_tableReferenceList                          = 40
	TiDBParserRULE_tableValueConstructor                       = 41
	TiDBParserRULE_explicitTable                               = 42
	TiDBParserRULE_rowValueExplicit                            = 43
	TiDBParserRULE_values                                      = 44
	TiDBParserRULE_selectOption                                = 45
	TiDBParserRULE_lockingClauseList                           = 46
	TiDBParserRULE_lockingClause                               = 47
	TiDBParserRULE_lockStrengh                                 = 48
	TiDBParserRULE_lockedRowAction                             = 49
	TiDBParserRULE_selectItemList                              = 50
	TiDBParserRULE_selectItem                                  = 51
	TiDBParserRULE_selectAlias                                 = 52
	TiDBParserRULE_whereClause                                 = 53
	TiDBParserRULE_tableReference                              = 54
	TiDBParserRULE_escapedTableReference                       = 55
	TiDBParserRULE_joinedTable                                 = 56
	TiDBParserRULE_naturalJoinType                             = 57
	TiDBParserRULE_innerJoinType                               = 58
	TiDBParserRULE_outerJoinType                               = 59
	TiDBParserRULE_tableFactor                                 = 60
	TiDBParserRULE_singleTable                                 = 61
	TiDBParserRULE_singleTableParens                           = 62
	TiDBParserRULE_derivedTable                                = 63
	TiDBParserRULE_tableReferenceListParens                    = 64
	TiDBParserRULE_tableFunction                               = 65
	TiDBParserRULE_columnsClause                               = 66
	TiDBParserRULE_jtColumn                                    = 67
	TiDBParserRULE_onEmptyOrError                              = 68
	TiDBParserRULE_onEmpty                                     = 69
	TiDBParserRULE_onError                                     = 70
	TiDBParserRULE_jtOnResponse                                = 71
	TiDBParserRULE_setOprSymbol                                = 72
	TiDBParserRULE_setOprOption                                = 73
	TiDBParserRULE_tableAlias                                  = 74
	TiDBParserRULE_indexHintList                               = 75
	TiDBParserRULE_indexHint                                   = 76
	TiDBParserRULE_indexHintType                               = 77
	TiDBParserRULE_keyOrIndex                                  = 78
	TiDBParserRULE_constraintKeyType                           = 79
	TiDBParserRULE_indexHintClause                             = 80
	TiDBParserRULE_indexList                                   = 81
	TiDBParserRULE_indexListElement                            = 82
	TiDBParserRULE_updateStatement                             = 83
	TiDBParserRULE_transactionOrLockingStatement               = 84
	TiDBParserRULE_transactionStatement                        = 85
	TiDBParserRULE_beginWork                                   = 86
	TiDBParserRULE_transactionCharacteristic                   = 87
	TiDBParserRULE_savepointStatement                          = 88
	TiDBParserRULE_lockStatement                               = 89
	TiDBParserRULE_lockItem                                    = 90
	TiDBParserRULE_lockOption                                  = 91
	TiDBParserRULE_xaStatement                                 = 92
	TiDBParserRULE_xaConvert                                   = 93
	TiDBParserRULE_xid                                         = 94
	TiDBParserRULE_replicationStatement                        = 95
	TiDBParserRULE_resetOption                                 = 96
	TiDBParserRULE_masterResetOptions                          = 97
	TiDBParserRULE_replicationLoad                             = 98
	TiDBParserRULE_changeMaster                                = 99
	TiDBParserRULE_changeMasterOptions                         = 100
	TiDBParserRULE_masterOption                                = 101
	TiDBParserRULE_privilegeCheckDef                           = 102
	TiDBParserRULE_tablePrimaryKeyCheckDef                     = 103
	TiDBParserRULE_masterTlsCiphersuitesDef                    = 104
	TiDBParserRULE_masterFileDef                               = 105
	TiDBParserRULE_serverIdList                                = 106
	TiDBParserRULE_changeReplication                           = 107
	TiDBParserRULE_filterDefinition                            = 108
	TiDBParserRULE_filterDbList                                = 109
	TiDBParserRULE_filterTableList                             = 110
	TiDBParserRULE_filterStringList                            = 111
	TiDBParserRULE_filterWildDbTableString                     = 112
	TiDBParserRULE_filterDbPairList                            = 113
	TiDBParserRULE_slave                                       = 114
	TiDBParserRULE_slaveUntilOptions                           = 115
	TiDBParserRULE_slaveConnectionOptions                      = 116
	TiDBParserRULE_slaveThreadOptions                          = 117
	TiDBParserRULE_slaveThreadOption                           = 118
	TiDBParserRULE_groupReplication                            = 119
	TiDBParserRULE_preparedStatement                           = 120
	TiDBParserRULE_executeStatement                            = 121
	TiDBParserRULE_executeVarList                              = 122
	TiDBParserRULE_cloneStatement                              = 123
	TiDBParserRULE_dataDirSSL                                  = 124
	TiDBParserRULE_ssl                                         = 125
	TiDBParserRULE_accountManagementStatement                  = 126
	TiDBParserRULE_alterUser                                   = 127
	TiDBParserRULE_alterUserTail                               = 128
	TiDBParserRULE_userFunction                                = 129
	TiDBParserRULE_createUser                                  = 130
	TiDBParserRULE_createUserTail                              = 131
	TiDBParserRULE_defaultRoleClause                           = 132
	TiDBParserRULE_requireClause                               = 133
	TiDBParserRULE_connectOptions                              = 134
	TiDBParserRULE_accountLockPasswordExpireOptions            = 135
	TiDBParserRULE_dropUser                                    = 136
	TiDBParserRULE_grant                                       = 137
	TiDBParserRULE_grantTargetList                             = 138
	TiDBParserRULE_grantOptions                                = 139
	TiDBParserRULE_exceptRoleList                              = 140
	TiDBParserRULE_withRoles                                   = 141
	TiDBParserRULE_grantAs                                     = 142
	TiDBParserRULE_versionedRequireClause                      = 143
	TiDBParserRULE_renameUser                                  = 144
	TiDBParserRULE_revoke                                      = 145
	TiDBParserRULE_onTypeTo                                    = 146
	TiDBParserRULE_aclType                                     = 147
	TiDBParserRULE_roleOrPrivilegesList                        = 148
	TiDBParserRULE_roleOrPrivilege                             = 149
	TiDBParserRULE_grantIdentifier                             = 150
	TiDBParserRULE_requireList                                 = 151
	TiDBParserRULE_requireListElement                          = 152
	TiDBParserRULE_grantOption                                 = 153
	TiDBParserRULE_setRole                                     = 154
	TiDBParserRULE_roleList                                    = 155
	TiDBParserRULE_role                                        = 156
	TiDBParserRULE_tableAdministrationStatement                = 157
	TiDBParserRULE_histogram                                   = 158
	TiDBParserRULE_checkOption                                 = 159
	TiDBParserRULE_repairType                                  = 160
	TiDBParserRULE_installUninstallStatment                    = 161
	TiDBParserRULE_setStatement                                = 162
	TiDBParserRULE_startOptionValueList                        = 163
	TiDBParserRULE_transactionCharacteristics                  = 164
	TiDBParserRULE_transactionAccessMode                       = 165
	TiDBParserRULE_isolationLevel                              = 166
	TiDBParserRULE_optionValueListContinued                    = 167
	TiDBParserRULE_optionValueNoOptionType                     = 168
	TiDBParserRULE_optionValue                                 = 169
	TiDBParserRULE_setSystemVariable                           = 170
	TiDBParserRULE_startOptionValueListFollowingOptionType     = 171
	TiDBParserRULE_optionValueFollowingOptionType              = 172
	TiDBParserRULE_setExprOrDefault                            = 173
	TiDBParserRULE_showStatement                               = 174
	TiDBParserRULE_showCommandType                             = 175
	TiDBParserRULE_nonBlocking                                 = 176
	TiDBParserRULE_fromOrIn                                    = 177
	TiDBParserRULE_inDb                                        = 178
	TiDBParserRULE_profileType                                 = 179
	TiDBParserRULE_resourceGroupManagement                     = 180
	TiDBParserRULE_createResourceGroup                         = 181
	TiDBParserRULE_resourceGroupVcpuList                       = 182
	TiDBParserRULE_vcpuNumOrRange                              = 183
	TiDBParserRULE_resourceGroupPriority                       = 184
	TiDBParserRULE_resourceGroupEnableDisable                  = 185
	TiDBParserRULE_alterResourceGroup                          = 186
	TiDBParserRULE_setResourceGroup                            = 187
	TiDBParserRULE_threadIdList                                = 188
	TiDBParserRULE_dropResourceGroup                           = 189
	TiDBParserRULE_expr                                        = 190
	TiDBParserRULE_boolPri                                     = 191
	TiDBParserRULE_compOp                                      = 192
	TiDBParserRULE_predicate                                   = 193
	TiDBParserRULE_predicateOperations                         = 194
	TiDBParserRULE_bitExpr                                     = 195
	TiDBParserRULE_simpleExpr                                  = 196
	TiDBParserRULE_arrayCast                                   = 197
	TiDBParserRULE_jsonOperator                                = 198
	TiDBParserRULE_sumExpr                                     = 199
	TiDBParserRULE_groupingOperation                           = 200
	TiDBParserRULE_windowFunctionCall                          = 201
	TiDBParserRULE_windowingClause                             = 202
	TiDBParserRULE_leadLagInfo                                 = 203
	TiDBParserRULE_nullTreatment                               = 204
	TiDBParserRULE_jsonFunction                                = 205
	TiDBParserRULE_inSumExpr                                   = 206
	TiDBParserRULE_identListArg                                = 207
	TiDBParserRULE_identList                                   = 208
	TiDBParserRULE_fulltextOptions                             = 209
	TiDBParserRULE_runtimeFunctionCall                         = 210
	TiDBParserRULE_geometryFunction                            = 211
	TiDBParserRULE_timeFunctionParameters                      = 212
	TiDBParserRULE_fractionalPrecision                         = 213
	TiDBParserRULE_weightStringLevels                          = 214
	TiDBParserRULE_weightStringLevelListItem                   = 215
	TiDBParserRULE_dateTimeTtype                               = 216
	TiDBParserRULE_trimFunction                                = 217
	TiDBParserRULE_substringFunction                           = 218
	TiDBParserRULE_functionCall                                = 219
	TiDBParserRULE_searchJsonFunction                          = 220
	TiDBParserRULE_jsonValueReturning                          = 221
	TiDBParserRULE_jsonValueOnEmpty                            = 222
	TiDBParserRULE_jsonValueOnError                            = 223
	TiDBParserRULE_udfExprList                                 = 224
	TiDBParserRULE_udfExpr                                     = 225
	TiDBParserRULE_variable                                    = 226
	TiDBParserRULE_userVariable                                = 227
	TiDBParserRULE_systemVariable                              = 228
	TiDBParserRULE_internalVariableName                        = 229
	TiDBParserRULE_whenExpression                              = 230
	TiDBParserRULE_thenExpression                              = 231
	TiDBParserRULE_elseExpression                              = 232
	TiDBParserRULE_castType                                    = 233
	TiDBParserRULE_exprList                                    = 234
	TiDBParserRULE_charset                                     = 235
	TiDBParserRULE_notRule                                     = 236
	TiDBParserRULE_not2Rule                                    = 237
	TiDBParserRULE_interval                                    = 238
	TiDBParserRULE_intervalTimeStamp                           = 239
	TiDBParserRULE_exprListWithParentheses                     = 240
	TiDBParserRULE_exprWithParentheses                         = 241
	TiDBParserRULE_simpleExprWithParentheses                   = 242
	TiDBParserRULE_orderList                                   = 243
	TiDBParserRULE_orderExpression                             = 244
	TiDBParserRULE_groupList                                   = 245
	TiDBParserRULE_groupingExpression                          = 246
	TiDBParserRULE_channel                                     = 247
	TiDBParserRULE_columnFormat                                = 248
	TiDBParserRULE_storageMedia                                = 249
	TiDBParserRULE_gcolAttribute                               = 250
	TiDBParserRULE_references                                  = 251
	TiDBParserRULE_deleteOption                                = 252
	TiDBParserRULE_keyList                                     = 253
	TiDBParserRULE_keyPart                                     = 254
	TiDBParserRULE_keyListWithExpression                       = 255
	TiDBParserRULE_keyPartOrExpression                         = 256
	TiDBParserRULE_keyListVariants                             = 257
	TiDBParserRULE_indexType                                   = 258
	TiDBParserRULE_indexOption                                 = 259
	TiDBParserRULE_commonIndexOption                           = 260
	TiDBParserRULE_visibility                                  = 261
	TiDBParserRULE_indexTypeClause                             = 262
	TiDBParserRULE_fulltextIndexOption                         = 263
	TiDBParserRULE_spatialIndexOption                          = 264
	TiDBParserRULE_dataTypeDefinition                          = 265
	TiDBParserRULE_dataType                                    = 266
	TiDBParserRULE_nchar                                       = 267
	TiDBParserRULE_realType                                    = 268
	TiDBParserRULE_fieldLength                                 = 269
	TiDBParserRULE_fieldOptions                                = 270
	TiDBParserRULE_charsetWithOptBinary                        = 271
	TiDBParserRULE_ascii                                       = 272
	TiDBParserRULE_unicode                                     = 273
	TiDBParserRULE_wsNumCodepoints                             = 274
	TiDBParserRULE_typeDatetimePrecision                       = 275
	TiDBParserRULE_charsetName                                 = 276
	TiDBParserRULE_collationName                               = 277
	TiDBParserRULE_createTableOptions                          = 278
	TiDBParserRULE_createTableOptionsSpaceSeparated            = 279
	TiDBParserRULE_createTableOption                           = 280
	TiDBParserRULE_ternaryOption                               = 281
	TiDBParserRULE_defaultCollation                            = 282
	TiDBParserRULE_defaultEncryption                           = 283
	TiDBParserRULE_defaultCharset                              = 284
	TiDBParserRULE_partitionClause                             = 285
	TiDBParserRULE_partitionTypeDef                            = 286
	TiDBParserRULE_subPartitions                               = 287
	TiDBParserRULE_partitionKeyAlgorithm                       = 288
	TiDBParserRULE_partitionDefinitions                        = 289
	TiDBParserRULE_partitionDefinition                         = 290
	TiDBParserRULE_partitionValuesIn                           = 291
	TiDBParserRULE_partitionOption                             = 292
	TiDBParserRULE_subpartitionDefinition                      = 293
	TiDBParserRULE_partitionValueItemListParen                 = 294
	TiDBParserRULE_partitionValueItem                          = 295
	TiDBParserRULE_definerClause                               = 296
	TiDBParserRULE_ifExists                                    = 297
	TiDBParserRULE_ifNotExists                                 = 298
	TiDBParserRULE_procedureParameter                          = 299
	TiDBParserRULE_functionParameter                           = 300
	TiDBParserRULE_collate                                     = 301
	TiDBParserRULE_typeWithOptCollate                          = 302
	TiDBParserRULE_schemaIdentifierPair                        = 303
	TiDBParserRULE_viewRefList                                 = 304
	TiDBParserRULE_updateList                                  = 305
	TiDBParserRULE_updateElement                               = 306
	TiDBParserRULE_charsetClause                               = 307
	TiDBParserRULE_fieldsClause                                = 308
	TiDBParserRULE_fieldTerm                                   = 309
	TiDBParserRULE_linesClause                                 = 310
	TiDBParserRULE_lineTerm                                    = 311
	TiDBParserRULE_userList                                    = 312
	TiDBParserRULE_createUserList                              = 313
	TiDBParserRULE_alterUserList                               = 314
	TiDBParserRULE_createUserEntry                             = 315
	TiDBParserRULE_alterUserEntry                              = 316
	TiDBParserRULE_retainCurrentPassword                       = 317
	TiDBParserRULE_discardOldPassword                          = 318
	TiDBParserRULE_replacePassword                             = 319
	TiDBParserRULE_userIdentifierOrText                        = 320
	TiDBParserRULE_user                                        = 321
	TiDBParserRULE_likeClause                                  = 322
	TiDBParserRULE_likeOrWhere                                 = 323
	TiDBParserRULE_onlineOption                                = 324
	TiDBParserRULE_noWriteToBinLog                             = 325
	TiDBParserRULE_usePartition                                = 326
	TiDBParserRULE_fieldIdentifier                             = 327
	TiDBParserRULE_columnName                                  = 328
	TiDBParserRULE_columnInternalRef                           = 329
	TiDBParserRULE_columnInternalRefList                       = 330
	TiDBParserRULE_columnRef                                   = 331
	TiDBParserRULE_insertIdentifier                            = 332
	TiDBParserRULE_indexName                                   = 333
	TiDBParserRULE_indexRef                                    = 334
	TiDBParserRULE_tableWild                                   = 335
	TiDBParserRULE_schemaName                                  = 336
	TiDBParserRULE_schemaRef                                   = 337
	TiDBParserRULE_procedureName                               = 338
	TiDBParserRULE_procedureRef                                = 339
	TiDBParserRULE_functionName                                = 340
	TiDBParserRULE_functionRef                                 = 341
	TiDBParserRULE_triggerName                                 = 342
	TiDBParserRULE_triggerRef                                  = 343
	TiDBParserRULE_viewName                                    = 344
	TiDBParserRULE_viewRef                                     = 345
	TiDBParserRULE_tablespaceName                              = 346
	TiDBParserRULE_tablespaceRef                               = 347
	TiDBParserRULE_logfileGroupName                            = 348
	TiDBParserRULE_logfileGroupRef                             = 349
	TiDBParserRULE_eventName                                   = 350
	TiDBParserRULE_eventRef                                    = 351
	TiDBParserRULE_udfName                                     = 352
	TiDBParserRULE_serverName                                  = 353
	TiDBParserRULE_serverRef                                   = 354
	TiDBParserRULE_engineRef                                   = 355
	TiDBParserRULE_tableName                                   = 356
	TiDBParserRULE_filterTableRef                              = 357
	TiDBParserRULE_tableRefWithWildcard                        = 358
	TiDBParserRULE_tableRef                                    = 359
	TiDBParserRULE_tableRefList                                = 360
	TiDBParserRULE_tableAliasRefList                           = 361
	TiDBParserRULE_parameterName                               = 362
	TiDBParserRULE_labelIdentifier                             = 363
	TiDBParserRULE_labelRef                                    = 364
	TiDBParserRULE_roleIdentifier                              = 365
	TiDBParserRULE_roleRef                                     = 366
	TiDBParserRULE_pluginRef                                   = 367
	TiDBParserRULE_componentRef                                = 368
	TiDBParserRULE_resourceGroupRef                            = 369
	TiDBParserRULE_windowName                                  = 370
	TiDBParserRULE_pureIdentifier                              = 371
	TiDBParserRULE_identifier                                  = 372
	TiDBParserRULE_identifierList                              = 373
	TiDBParserRULE_identifierListWithParentheses               = 374
	TiDBParserRULE_qualifiedIdentifier                         = 375
	TiDBParserRULE_simpleIdentifier                            = 376
	TiDBParserRULE_dotIdentifier                               = 377
	TiDBParserRULE_ulong_number                                = 378
	TiDBParserRULE_real_ulong_number                           = 379
	TiDBParserRULE_ulonglong_number                            = 380
	TiDBParserRULE_real_ulonglong_number                       = 381
	TiDBParserRULE_literal                                     = 382
	TiDBParserRULE_signedLiteral                               = 383
	TiDBParserRULE_stringList                                  = 384
	TiDBParserRULE_textStringLiteral                           = 385
	TiDBParserRULE_textString                                  = 386
	TiDBParserRULE_textStringHash                              = 387
	TiDBParserRULE_textLiteral                                 = 388
	TiDBParserRULE_textStringNoLinebreak                       = 389
	TiDBParserRULE_textStringLiteralList                       = 390
	TiDBParserRULE_numLiteral                                  = 391
	TiDBParserRULE_boolLiteral                                 = 392
	TiDBParserRULE_nullLiteral                                 = 393
	TiDBParserRULE_temporalLiteral                             = 394
	TiDBParserRULE_floatOptions                                = 395
	TiDBParserRULE_standardFloatOptions                        = 396
	TiDBParserRULE_precision                                   = 397
	TiDBParserRULE_textOrIdentifier                            = 398
	TiDBParserRULE_lValueIdentifier                            = 399
	TiDBParserRULE_roleIdentifierOrText                        = 400
	TiDBParserRULE_sizeNumber                                  = 401
	TiDBParserRULE_parentheses                                 = 402
	TiDBParserRULE_equal                                       = 403
	TiDBParserRULE_optionType                                  = 404
	TiDBParserRULE_varIdentType                                = 405
	TiDBParserRULE_setVarIdentType                             = 406
	TiDBParserRULE_identifierKeyword                           = 407
	TiDBParserRULE_identifierKeywordsAmbiguous1RolesAndLabels  = 408
	TiDBParserRULE_identifierKeywordsAmbiguous2Labels          = 409
	TiDBParserRULE_labelKeyword                                = 410
	TiDBParserRULE_identifierKeywordsAmbiguous3Roles           = 411
	TiDBParserRULE_identifierKeywordsUnambiguous               = 412
	TiDBParserRULE_roleKeyword                                 = 413
	TiDBParserRULE_lValueKeyword                               = 414
	TiDBParserRULE_identifierKeywordsAmbiguous4SystemVariables = 415
	TiDBParserRULE_roleOrIdentifierKeyword                     = 416
	TiDBParserRULE_roleOrLabelKeyword                          = 417
)

// ISingleColumnDefContext is an interface to support dynamic dispatch.
type ISingleColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnDef() IColumnDefContext
	EOF() antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode

	// IsSingleColumnDefContext differentiates from other interfaces.
	IsSingleColumnDefContext()
}

type SingleColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleColumnDefContext() *SingleColumnDefContext {
	var p = new(SingleColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_singleColumnDef
	return p
}

func InitEmptySingleColumnDefContext(p *SingleColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_singleColumnDef
}

func (*SingleColumnDefContext) IsSingleColumnDefContext() {}

func NewSingleColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleColumnDefContext {
	var p = new(SingleColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_singleColumnDef

	return p
}

func (s *SingleColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleColumnDefContext) ColumnDef() IColumnDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnDefContext)
}

func (s *SingleColumnDefContext) EOF() antlr.TerminalNode {
	return s.GetToken(TiDBParserEOF, 0)
}

func (s *SingleColumnDefContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *SingleColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleColumnDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSingleColumnDef(s)
	}
}

func (s *SingleColumnDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSingleColumnDef(s)
	}
}

func (s *SingleColumnDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSingleColumnDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SingleColumnDef() (localctx ISingleColumnDefContext) {
	localctx = NewSingleColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, TiDBParserRULE_singleColumnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(836)
		p.ColumnDef()
	}
	p.SetState(838)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(837)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(840)
		p.Match(TiDBParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnDefContext is an interface to support dynamic dispatch.
type IColumnDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnName() IColumnNameContext
	DataType() IDataTypeContext
	ColumnOptionList() IColumnOptionListContext

	// IsColumnDefContext differentiates from other interfaces.
	IsColumnDefContext()
}

type ColumnDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnDefContext() *ColumnDefContext {
	var p = new(ColumnDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnDef
	return p
}

func InitEmptyColumnDefContext(p *ColumnDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnDef
}

func (*ColumnDefContext) IsColumnDefContext() {}

func NewColumnDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnDefContext {
	var p = new(ColumnDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_columnDef

	return p
}

func (s *ColumnDefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnDefContext) ColumnName() IColumnNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnNameContext)
}

func (s *ColumnDefContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *ColumnDefContext) ColumnOptionList() IColumnOptionListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnOptionListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnOptionListContext)
}

func (s *ColumnDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterColumnDef(s)
	}
}

func (s *ColumnDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitColumnDef(s)
	}
}

func (s *ColumnDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitColumnDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ColumnDef() (localctx IColumnDefContext) {
	localctx = NewColumnDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, TiDBParserRULE_columnDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(842)
		p.ColumnName()
	}
	{
		p.SetState(843)
		p.DataType()
	}
	p.SetState(845)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4611686018444296192) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&576460752303554657) != 0) || _la == TiDBParserGENERATED_SYMBOL || _la == TiDBParserKEY_SYMBOL || ((int64((_la-371)) & ^0x3f) == 0 && ((int64(1)<<(_la-371))&562949953425441) != 0) || _la == TiDBParserREFERENCES_SYMBOL || _la == TiDBParserSERIAL_SYMBOL || _la == TiDBParserSTORAGE_SYMBOL || _la == TiDBParserUNIQUE_SYMBOL || _la == TiDBParserAUTO_RANDOM_SYMBOL {
		{
			p.SetState(844)
			p.ColumnOptionList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnOptionListContext is an interface to support dynamic dispatch.
type IColumnOptionListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllColumnOption() []IColumnOptionContext
	ColumnOption(i int) IColumnOptionContext

	// IsColumnOptionListContext differentiates from other interfaces.
	IsColumnOptionListContext()
}

type ColumnOptionListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnOptionListContext() *ColumnOptionListContext {
	var p = new(ColumnOptionListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnOptionList
	return p
}

func InitEmptyColumnOptionListContext(p *ColumnOptionListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnOptionList
}

func (*ColumnOptionListContext) IsColumnOptionListContext() {}

func NewColumnOptionListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnOptionListContext {
	var p = new(ColumnOptionListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_columnOptionList

	return p
}

func (s *ColumnOptionListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnOptionListContext) AllColumnOption() []IColumnOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnOptionContext); ok {
			len++
		}
	}

	tst := make([]IColumnOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnOptionContext); ok {
			tst[i] = t.(IColumnOptionContext)
			i++
		}
	}

	return tst
}

func (s *ColumnOptionListContext) ColumnOption(i int) IColumnOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnOptionContext)
}

func (s *ColumnOptionListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnOptionListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnOptionListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterColumnOptionList(s)
	}
}

func (s *ColumnOptionListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitColumnOptionList(s)
	}
}

func (s *ColumnOptionListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitColumnOptionList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ColumnOptionList() (localctx IColumnOptionListContext) {
	localctx = NewColumnOptionListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, TiDBParserRULE_columnOptionList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&4611686018444296192) != 0) || ((int64((_la-69)) & ^0x3f) == 0 && ((int64(1)<<(_la-69))&576460752303554657) != 0) || _la == TiDBParserGENERATED_SYMBOL || _la == TiDBParserKEY_SYMBOL || ((int64((_la-371)) & ^0x3f) == 0 && ((int64(1)<<(_la-371))&562949953425441) != 0) || _la == TiDBParserREFERENCES_SYMBOL || _la == TiDBParserSERIAL_SYMBOL || _la == TiDBParserSTORAGE_SYMBOL || _la == TiDBParserUNIQUE_SYMBOL || _la == TiDBParserAUTO_RANDOM_SYMBOL {
		{
			p.SetState(847)
			p.ColumnOption()
		}

		p.SetState(850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnOptionContext is an interface to support dynamic dispatch.
type IColumnOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_SYMBOL() antlr.TerminalNode
	NOT_SYMBOL() antlr.TerminalNode
	AUTO_INCREMENT_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	PRIMARY_SYMBOL() antlr.TerminalNode
	UNIQUE_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	SignedLiteral() ISignedLiteralContext
	NOW_SYMBOL() antlr.TerminalNode
	ExprWithParentheses() IExprWithParenthesesContext
	TimeFunctionParameters() ITimeFunctionParametersContext
	SERIAL_SYMBOL() antlr.TerminalNode
	VALUE_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	UPDATE_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	CHECK_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	ConstraintName() IConstraintNameContext
	ConstraintEnforcement() IConstraintEnforcementContext
	AS_SYMBOL() antlr.TerminalNode
	GENERATED_SYMBOL() antlr.TerminalNode
	ALWAYS_SYMBOL() antlr.TerminalNode
	VIRTUAL_SYMBOL() antlr.TerminalNode
	STORED_SYMBOL() antlr.TerminalNode
	References() IReferencesContext
	COLLATE_SYMBOL() antlr.TerminalNode
	CollationName() ICollationNameContext
	COLUMN_FORMAT_SYMBOL() antlr.TerminalNode
	ColumnFormat() IColumnFormatContext
	STORAGE_SYMBOL() antlr.TerminalNode
	StorageMedia() IStorageMediaContext
	AUTO_RANDOM_SYMBOL() antlr.TerminalNode
	FieldLength() IFieldLengthContext

	// IsColumnOptionContext differentiates from other interfaces.
	IsColumnOptionContext()
}

type ColumnOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnOptionContext() *ColumnOptionContext {
	var p = new(ColumnOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnOption
	return p
}

func InitEmptyColumnOptionContext(p *ColumnOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnOption
}

func (*ColumnOptionContext) IsColumnOptionContext() {}

func NewColumnOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnOptionContext {
	var p = new(ColumnOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_columnOption

	return p
}

func (s *ColumnOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnOptionContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL_SYMBOL, 0)
}

func (s *ColumnOptionContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOT_SYMBOL, 0)
}

func (s *ColumnOptionContext) AUTO_INCREMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAUTO_INCREMENT_SYMBOL, 0)
}

func (s *ColumnOptionContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_SYMBOL, 0)
}

func (s *ColumnOptionContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIMARY_SYMBOL, 0)
}

func (s *ColumnOptionContext) UNIQUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNIQUE_SYMBOL, 0)
}

func (s *ColumnOptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *ColumnOptionContext) SignedLiteral() ISignedLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISignedLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISignedLiteralContext)
}

func (s *ColumnOptionContext) NOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOW_SYMBOL, 0)
}

func (s *ColumnOptionContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *ColumnOptionContext) TimeFunctionParameters() ITimeFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeFunctionParametersContext)
}

func (s *ColumnOptionContext) SERIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSERIAL_SYMBOL, 0)
}

func (s *ColumnOptionContext) VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVALUE_SYMBOL, 0)
}

func (s *ColumnOptionContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *ColumnOptionContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUPDATE_SYMBOL, 0)
}

func (s *ColumnOptionContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMENT_SYMBOL, 0)
}

func (s *ColumnOptionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *ColumnOptionContext) CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHECK_SYMBOL, 0)
}

func (s *ColumnOptionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *ColumnOptionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ColumnOptionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ColumnOptionContext) ConstraintName() IConstraintNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintNameContext)
}

func (s *ColumnOptionContext) ConstraintEnforcement() IConstraintEnforcementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConstraintEnforcementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConstraintEnforcementContext)
}

func (s *ColumnOptionContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *ColumnOptionContext) GENERATED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGENERATED_SYMBOL, 0)
}

func (s *ColumnOptionContext) ALWAYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALWAYS_SYMBOL, 0)
}

func (s *ColumnOptionContext) VIRTUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVIRTUAL_SYMBOL, 0)
}

func (s *ColumnOptionContext) STORED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTORED_SYMBOL, 0)
}

func (s *ColumnOptionContext) References() IReferencesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferencesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferencesContext)
}

func (s *ColumnOptionContext) COLLATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLLATE_SYMBOL, 0)
}

func (s *ColumnOptionContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *ColumnOptionContext) COLUMN_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMN_FORMAT_SYMBOL, 0)
}

func (s *ColumnOptionContext) ColumnFormat() IColumnFormatContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnFormatContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnFormatContext)
}

func (s *ColumnOptionContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTORAGE_SYMBOL, 0)
}

func (s *ColumnOptionContext) StorageMedia() IStorageMediaContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStorageMediaContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStorageMediaContext)
}

func (s *ColumnOptionContext) AUTO_RANDOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAUTO_RANDOM_SYMBOL, 0)
}

func (s *ColumnOptionContext) FieldLength() IFieldLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *ColumnOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterColumnOption(s)
	}
}

func (s *ColumnOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitColumnOption(s)
	}
}

func (s *ColumnOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitColumnOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ColumnOption() (localctx IColumnOptionContext) {
	localctx = NewColumnOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, TiDBParserRULE_columnOption)
	var _la int

	p.SetState(917)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserNOT_SYMBOL, TiDBParserNULL_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(853)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserNOT_SYMBOL {
			{
				p.SetState(852)
				p.Match(TiDBParserNOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(855)
			p.Match(TiDBParserNULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserAUTO_INCREMENT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(856)
			p.Match(TiDBParserAUTO_INCREMENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserKEY_SYMBOL, TiDBParserPRIMARY_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(858)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserPRIMARY_SYMBOL {
			{
				p.SetState(857)
				p.Match(TiDBParserPRIMARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(860)
			p.Match(TiDBParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserUNIQUE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(861)
			p.Match(TiDBParserUNIQUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(863)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 5, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(862)
				p.Match(TiDBParserKEY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserDEFAULT_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(865)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(872)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserDATE_SYMBOL, TiDBParserFALSE_SYMBOL, TiDBParserNULL_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRUE_SYMBOL, TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserPLUS_OPERATOR, TiDBParserMINUS_OPERATOR, TiDBParserNULL2_SYMBOL, TiDBParserHEX_NUMBER, TiDBParserBIN_NUMBER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER, TiDBParserUNDERSCORE_CHARSET, TiDBParserNCHAR_TEXT, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
			{
				p.SetState(866)
				p.SignedLiteral()
			}

		case TiDBParserNOW_SYMBOL:
			{
				p.SetState(867)
				p.Match(TiDBParserNOW_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(869)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserOPEN_PAR_SYMBOL {
				{
					p.SetState(868)
					p.TimeFunctionParameters()
				}

			}

		case TiDBParserOPEN_PAR_SYMBOL:
			{
				p.SetState(871)
				p.ExprWithParentheses()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case TiDBParserSERIAL_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(874)
			p.Match(TiDBParserSERIAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(875)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(876)
			p.Match(TiDBParserVALUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserON_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(877)
			p.Match(TiDBParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(878)
			p.Match(TiDBParserUPDATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(879)
			p.Match(TiDBParserNOW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(881)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(880)
				p.TimeFunctionParameters()
			}

		}

	case TiDBParserCOMMENT_SYMBOL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(883)
			p.Match(TiDBParserCOMMENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(884)
			p.TextLiteral()
		}

	case TiDBParserCHECK_SYMBOL, TiDBParserCONSTRAINT_SYMBOL:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(886)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCONSTRAINT_SYMBOL {
			{
				p.SetState(885)
				p.ConstraintName()
			}

		}
		{
			p.SetState(888)
			p.Match(TiDBParserCHECK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(889)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(890)
			p.expr(0)
		}
		{
			p.SetState(891)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(893)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(892)
				p.ConstraintEnforcement()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserAS_SYMBOL, TiDBParserGENERATED_SYMBOL:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(897)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserGENERATED_SYMBOL {
			{
				p.SetState(895)
				p.Match(TiDBParserGENERATED_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(896)
				p.Match(TiDBParserALWAYS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(899)
			p.Match(TiDBParserAS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(900)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(901)
			p.expr(0)
		}
		{
			p.SetState(902)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(904)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSTORED_SYMBOL || _la == TiDBParserVIRTUAL_SYMBOL {
			{
				p.SetState(903)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TiDBParserSTORED_SYMBOL || _la == TiDBParserVIRTUAL_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case TiDBParserREFERENCES_SYMBOL:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(906)
			p.References()
		}

	case TiDBParserCOLLATE_SYMBOL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(907)
			p.Match(TiDBParserCOLLATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(908)
			p.CollationName()
		}

	case TiDBParserCOLUMN_FORMAT_SYMBOL:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(909)
			p.Match(TiDBParserCOLUMN_FORMAT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(910)
			p.ColumnFormat()
		}

	case TiDBParserSTORAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(911)
			p.Match(TiDBParserSTORAGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(912)
			p.StorageMedia()
		}

	case TiDBParserAUTO_RANDOM_SYMBOL:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(913)
			p.Match(TiDBParserAUTO_RANDOM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(915)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(914)
				p.FieldLength()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintNameContext is an interface to support dynamic dispatch.
type IConstraintNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONSTRAINT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsConstraintNameContext differentiates from other interfaces.
	IsConstraintNameContext()
}

type ConstraintNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintNameContext() *ConstraintNameContext {
	var p = new(ConstraintNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_constraintName
	return p
}

func InitEmptyConstraintNameContext(p *ConstraintNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_constraintName
}

func (*ConstraintNameContext) IsConstraintNameContext() {}

func NewConstraintNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintNameContext {
	var p = new(ConstraintNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_constraintName

	return p
}

func (s *ConstraintNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintNameContext) CONSTRAINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSTRAINT_SYMBOL, 0)
}

func (s *ConstraintNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConstraintNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterConstraintName(s)
	}
}

func (s *ConstraintNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitConstraintName(s)
	}
}

func (s *ConstraintNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitConstraintName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ConstraintName() (localctx IConstraintNameContext) {
	localctx = NewConstraintNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, TiDBParserRULE_constraintName)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(919)
		p.Match(TiDBParserCONSTRAINT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871848468) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
		{
			p.SetState(920)
			p.Identifier()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintEnforcementContext is an interface to support dynamic dispatch.
type IConstraintEnforcementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENFORCED_SYMBOL() antlr.TerminalNode
	NOT_SYMBOL() antlr.TerminalNode

	// IsConstraintEnforcementContext differentiates from other interfaces.
	IsConstraintEnforcementContext()
}

type ConstraintEnforcementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintEnforcementContext() *ConstraintEnforcementContext {
	var p = new(ConstraintEnforcementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_constraintEnforcement
	return p
}

func InitEmptyConstraintEnforcementContext(p *ConstraintEnforcementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_constraintEnforcement
}

func (*ConstraintEnforcementContext) IsConstraintEnforcementContext() {}

func NewConstraintEnforcementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintEnforcementContext {
	var p = new(ConstraintEnforcementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_constraintEnforcement

	return p
}

func (s *ConstraintEnforcementContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintEnforcementContext) ENFORCED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENFORCED_SYMBOL, 0)
}

func (s *ConstraintEnforcementContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOT_SYMBOL, 0)
}

func (s *ConstraintEnforcementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintEnforcementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintEnforcementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterConstraintEnforcement(s)
	}
}

func (s *ConstraintEnforcementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitConstraintEnforcement(s)
	}
}

func (s *ConstraintEnforcementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitConstraintEnforcement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ConstraintEnforcement() (localctx IConstraintEnforcementContext) {
	localctx = NewConstraintEnforcementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, TiDBParserRULE_constraintEnforcement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(924)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserNOT_SYMBOL {
		{
			p.SetState(923)
			p.Match(TiDBParserNOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(926)
		p.Match(TiDBParserENFORCED_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementContext is an interface to support dynamic dispatch.
type ISelectStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpression() IQueryExpressionContext
	LockingClauseList() ILockingClauseListContext
	QueryExpressionParens() IQueryExpressionParensContext
	SelectStatementWithInto() ISelectStatementWithIntoContext

	// IsSelectStatementContext differentiates from other interfaces.
	IsSelectStatementContext()
}

type SelectStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementContext() *SelectStatementContext {
	var p = new(SelectStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectStatement
	return p
}

func InitEmptySelectStatementContext(p *SelectStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectStatement
}

func (*SelectStatementContext) IsSelectStatementContext() {}

func NewSelectStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementContext {
	var p = new(SelectStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_selectStatement

	return p
}

func (s *SelectStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *SelectStatementContext) LockingClauseList() ILockingClauseListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockingClauseListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockingClauseListContext)
}

func (s *SelectStatementContext) QueryExpressionParens() IQueryExpressionParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *SelectStatementContext) SelectStatementWithInto() ISelectStatementWithIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementWithIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementWithIntoContext)
}

func (s *SelectStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSelectStatement(s)
	}
}

func (s *SelectStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSelectStatement(s)
	}
}

func (s *SelectStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSelectStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SelectStatement() (localctx ISelectStatementContext) {
	localctx = NewSelectStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, TiDBParserRULE_selectStatement)
	var _la int

	p.SetState(934)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(928)
			p.QueryExpression()
		}
		p.SetState(930)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL || _la == TiDBParserLOCK_SYMBOL {
			{
				p.SetState(929)
				p.LockingClauseList()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(932)
			p.QueryExpressionParens()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(933)
			p.SelectStatementWithInto()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectStatementWithIntoContext is an interface to support dynamic dispatch.
type ISelectStatementWithIntoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	SelectStatementWithInto() ISelectStatementWithIntoContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	QueryExpression() IQueryExpressionContext
	IntoClause() IIntoClauseContext
	LockingClauseList() ILockingClauseListContext

	// IsSelectStatementWithIntoContext differentiates from other interfaces.
	IsSelectStatementWithIntoContext()
}

type SelectStatementWithIntoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectStatementWithIntoContext() *SelectStatementWithIntoContext {
	var p = new(SelectStatementWithIntoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectStatementWithInto
	return p
}

func InitEmptySelectStatementWithIntoContext(p *SelectStatementWithIntoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectStatementWithInto
}

func (*SelectStatementWithIntoContext) IsSelectStatementWithIntoContext() {}

func NewSelectStatementWithIntoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectStatementWithIntoContext {
	var p = new(SelectStatementWithIntoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_selectStatementWithInto

	return p
}

func (s *SelectStatementWithIntoContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectStatementWithIntoContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SelectStatementWithIntoContext) SelectStatementWithInto() ISelectStatementWithIntoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectStatementWithIntoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectStatementWithIntoContext)
}

func (s *SelectStatementWithIntoContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SelectStatementWithIntoContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *SelectStatementWithIntoContext) IntoClause() IIntoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntoClauseContext)
}

func (s *SelectStatementWithIntoContext) LockingClauseList() ILockingClauseListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockingClauseListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockingClauseListContext)
}

func (s *SelectStatementWithIntoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectStatementWithIntoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectStatementWithIntoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSelectStatementWithInto(s)
	}
}

func (s *SelectStatementWithIntoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSelectStatementWithInto(s)
	}
}

func (s *SelectStatementWithIntoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSelectStatementWithInto(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SelectStatementWithInto() (localctx ISelectStatementWithIntoContext) {
	localctx = NewSelectStatementWithIntoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, TiDBParserRULE_selectStatementWithInto)
	var _la int

	p.SetState(948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 20, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(936)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(937)
			p.SelectStatementWithInto()
		}
		{
			p.SetState(938)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(940)
			p.QueryExpression()
		}
		{
			p.SetState(941)
			p.IntoClause()
		}
		p.SetState(943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL || _la == TiDBParserLOCK_SYMBOL {
			{
				p.SetState(942)
				p.LockingClauseList()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(945)
			p.LockingClauseList()
		}
		{
			p.SetState(946)
			p.IntoClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionContext is an interface to support dynamic dispatch.
type IQueryExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpressionBody() IQueryExpressionBodyContext
	QueryExpressionParens() IQueryExpressionParensContext
	WithClause() IWithClauseContext
	ProcedureAnalyseClause() IProcedureAnalyseClauseContext
	OrderClause() IOrderClauseContext
	LimitClause() ILimitClauseContext

	// IsQueryExpressionContext differentiates from other interfaces.
	IsQueryExpressionContext()
}

type QueryExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionContext() *QueryExpressionContext {
	var p = new(QueryExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_queryExpression
	return p
}

func InitEmptyQueryExpressionContext(p *QueryExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_queryExpression
}

func (*QueryExpressionContext) IsQueryExpressionContext() {}

func NewQueryExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_queryExpression

	return p
}

func (s *QueryExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionContext) QueryExpressionBody() IQueryExpressionBodyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionBodyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionBodyContext)
}

func (s *QueryExpressionContext) QueryExpressionParens() IQueryExpressionParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *QueryExpressionContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryExpressionContext) ProcedureAnalyseClause() IProcedureAnalyseClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureAnalyseClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureAnalyseClauseContext)
}

func (s *QueryExpressionContext) OrderClause() IOrderClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *QueryExpressionContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterQueryExpression(s)
	}
}

func (s *QueryExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitQueryExpression(s)
	}
}

func (s *QueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) QueryExpression() (localctx IQueryExpressionContext) {
	localctx = NewQueryExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, TiDBParserRULE_queryExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(951)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserWITH_SYMBOL {
		{
			p.SetState(950)
			p.WithClause()
		}

	}
	p.SetState(967)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(953)
			p.QueryExpressionBody()
		}
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserORDER_SYMBOL {
			{
				p.SetState(954)
				p.OrderClause()
			}

		}
		p.SetState(958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIMIT_SYMBOL {
			{
				p.SetState(957)
				p.LimitClause()
			}

		}

	case 2:
		{
			p.SetState(960)
			p.QueryExpressionParens()
		}
		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserORDER_SYMBOL {
			{
				p.SetState(961)
				p.OrderClause()
			}

		}
		p.SetState(965)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIMIT_SYMBOL {
			{
				p.SetState(964)
				p.LimitClause()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(970)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserPROCEDURE_SYMBOL {
		{
			p.SetState(969)
			p.ProcedureAnalyseClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionBodyContext is an interface to support dynamic dispatch.
type IQueryExpressionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQueryPrimary() []IQueryPrimaryContext
	QueryPrimary(i int) IQueryPrimaryContext
	AllQueryExpressionParens() []IQueryExpressionParensContext
	QueryExpressionParens(i int) IQueryExpressionParensContext
	AllSetOprSymbol() []ISetOprSymbolContext
	SetOprSymbol(i int) ISetOprSymbolContext
	AllSetOprOption() []ISetOprOptionContext
	SetOprOption(i int) ISetOprOptionContext

	// IsQueryExpressionBodyContext differentiates from other interfaces.
	IsQueryExpressionBodyContext()
}

type QueryExpressionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionBodyContext() *QueryExpressionBodyContext {
	var p = new(QueryExpressionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_queryExpressionBody
	return p
}

func InitEmptyQueryExpressionBodyContext(p *QueryExpressionBodyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_queryExpressionBody
}

func (*QueryExpressionBodyContext) IsQueryExpressionBodyContext() {}

func NewQueryExpressionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionBodyContext {
	var p = new(QueryExpressionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_queryExpressionBody

	return p
}

func (s *QueryExpressionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionBodyContext) AllQueryPrimary() []IQueryPrimaryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			len++
		}
	}

	tst := make([]IQueryPrimaryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryPrimaryContext); ok {
			tst[i] = t.(IQueryPrimaryContext)
			i++
		}
	}

	return tst
}

func (s *QueryExpressionBodyContext) QueryPrimary(i int) IQueryPrimaryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryPrimaryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryPrimaryContext)
}

func (s *QueryExpressionBodyContext) AllQueryExpressionParens() []IQueryExpressionParensContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			len++
		}
	}

	tst := make([]IQueryExpressionParensContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryExpressionParensContext); ok {
			tst[i] = t.(IQueryExpressionParensContext)
			i++
		}
	}

	return tst
}

func (s *QueryExpressionBodyContext) QueryExpressionParens(i int) IQueryExpressionParensContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *QueryExpressionBodyContext) AllSetOprSymbol() []ISetOprSymbolContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetOprSymbolContext); ok {
			len++
		}
	}

	tst := make([]ISetOprSymbolContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetOprSymbolContext); ok {
			tst[i] = t.(ISetOprSymbolContext)
			i++
		}
	}

	return tst
}

func (s *QueryExpressionBodyContext) SetOprSymbol(i int) ISetOprSymbolContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetOprSymbolContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetOprSymbolContext)
}

func (s *QueryExpressionBodyContext) AllSetOprOption() []ISetOprOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISetOprOptionContext); ok {
			len++
		}
	}

	tst := make([]ISetOprOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISetOprOptionContext); ok {
			tst[i] = t.(ISetOprOptionContext)
			i++
		}
	}

	return tst
}

func (s *QueryExpressionBodyContext) SetOprOption(i int) ISetOprOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetOprOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetOprOptionContext)
}

func (s *QueryExpressionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionBodyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterQueryExpressionBody(s)
	}
}

func (s *QueryExpressionBodyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitQueryExpressionBody(s)
	}
}

func (s *QueryExpressionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitQueryExpressionBody(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) QueryExpressionBody() (localctx IQueryExpressionBodyContext) {
	localctx = NewQueryExpressionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, TiDBParserRULE_queryExpressionBody)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(982)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserSELECT_SYMBOL, TiDBParserTABLE_SYMBOL, TiDBParserVALUES_SYMBOL:
		{
			p.SetState(972)
			p.QueryPrimary()
		}

	case TiDBParserOPEN_PAR_SYMBOL:
		{
			p.SetState(973)
			p.QueryExpressionParens()
		}
		{
			p.SetState(974)
			p.SetOprSymbol()
		}
		p.SetState(976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserALL_SYMBOL || _la == TiDBParserDISTINCT_SYMBOL {
			{
				p.SetState(975)
				p.SetOprOption()
			}

		}
		p.SetState(980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserSELECT_SYMBOL, TiDBParserTABLE_SYMBOL, TiDBParserVALUES_SYMBOL:
			{
				p.SetState(978)
				p.QueryPrimary()
			}

		case TiDBParserOPEN_PAR_SYMBOL:
			{
				p.SetState(979)
				p.QueryExpressionParens()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(994)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserUNION_SYMBOL || _la == TiDBParserEXCEPT_SYMBOL || _la == TiDBParserINTERSECT_SYMBOL {
		{
			p.SetState(984)
			p.SetOprSymbol()
		}
		p.SetState(986)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserALL_SYMBOL || _la == TiDBParserDISTINCT_SYMBOL {
			{
				p.SetState(985)
				p.SetOprOption()
			}

		}
		p.SetState(990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserSELECT_SYMBOL, TiDBParserTABLE_SYMBOL, TiDBParserVALUES_SYMBOL:
			{
				p.SetState(988)
				p.QueryPrimary()
			}

		case TiDBParserOPEN_PAR_SYMBOL:
			{
				p.SetState(989)
				p.QueryExpressionParens()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(996)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryExpressionParensContext is an interface to support dynamic dispatch.
type IQueryExpressionParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	QueryExpressionParens() IQueryExpressionParensContext
	QueryExpression() IQueryExpressionContext
	LockingClauseList() ILockingClauseListContext

	// IsQueryExpressionParensContext differentiates from other interfaces.
	IsQueryExpressionParensContext()
}

type QueryExpressionParensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryExpressionParensContext() *QueryExpressionParensContext {
	var p = new(QueryExpressionParensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_queryExpressionParens
	return p
}

func InitEmptyQueryExpressionParensContext(p *QueryExpressionParensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_queryExpressionParens
}

func (*QueryExpressionParensContext) IsQueryExpressionParensContext() {}

func NewQueryExpressionParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryExpressionParensContext {
	var p = new(QueryExpressionParensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_queryExpressionParens

	return p
}

func (s *QueryExpressionParensContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryExpressionParensContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *QueryExpressionParensContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *QueryExpressionParensContext) QueryExpressionParens() IQueryExpressionParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *QueryExpressionParensContext) QueryExpression() IQueryExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionContext)
}

func (s *QueryExpressionParensContext) LockingClauseList() ILockingClauseListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockingClauseListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockingClauseListContext)
}

func (s *QueryExpressionParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryExpressionParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterQueryExpressionParens(s)
	}
}

func (s *QueryExpressionParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitQueryExpressionParens(s)
	}
}

func (s *QueryExpressionParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitQueryExpressionParens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) QueryExpressionParens() (localctx IQueryExpressionParensContext) {
	localctx = NewQueryExpressionParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, TiDBParserRULE_queryExpressionParens)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(997)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 35, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(998)
			p.QueryExpressionParens()
		}

	case 2:
		{
			p.SetState(999)
			p.QueryExpression()
		}
		p.SetState(1001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL || _la == TiDBParserLOCK_SYMBOL {
			{
				p.SetState(1000)
				p.LockingClauseList()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1005)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQueryPrimaryContext is an interface to support dynamic dispatch.
type IQueryPrimaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuerySpecification() IQuerySpecificationContext
	TableValueConstructor() ITableValueConstructorContext
	ExplicitTable() IExplicitTableContext

	// IsQueryPrimaryContext differentiates from other interfaces.
	IsQueryPrimaryContext()
}

type QueryPrimaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryPrimaryContext() *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_queryPrimary
	return p
}

func InitEmptyQueryPrimaryContext(p *QueryPrimaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_queryPrimary
}

func (*QueryPrimaryContext) IsQueryPrimaryContext() {}

func NewQueryPrimaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryPrimaryContext {
	var p = new(QueryPrimaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_queryPrimary

	return p
}

func (s *QueryPrimaryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryPrimaryContext) QuerySpecification() IQuerySpecificationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecificationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecificationContext)
}

func (s *QueryPrimaryContext) TableValueConstructor() ITableValueConstructorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableValueConstructorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableValueConstructorContext)
}

func (s *QueryPrimaryContext) ExplicitTable() IExplicitTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExplicitTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExplicitTableContext)
}

func (s *QueryPrimaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryPrimaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QueryPrimaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterQueryPrimary(s)
	}
}

func (s *QueryPrimaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitQueryPrimary(s)
	}
}

func (s *QueryPrimaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitQueryPrimary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) QueryPrimary() (localctx IQueryPrimaryContext) {
	localctx = NewQueryPrimaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, TiDBParserRULE_queryPrimary)
	p.SetState(1010)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserSELECT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1007)
			p.QuerySpecification()
		}

	case TiDBParserVALUES_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1008)
			p.TableValueConstructor()
		}

	case TiDBParserTABLE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1009)
			p.ExplicitTable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecificationContext is an interface to support dynamic dispatch.
type IQuerySpecificationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SELECT_SYMBOL() antlr.TerminalNode
	SelectItemList() ISelectItemListContext
	AllSelectOption() []ISelectOptionContext
	SelectOption(i int) ISelectOptionContext
	IntoClause() IIntoClauseContext
	FromClause() IFromClauseContext
	WhereClause() IWhereClauseContext
	GroupByClause() IGroupByClauseContext
	HavingClause() IHavingClauseContext
	WindowClause() IWindowClauseContext

	// IsQuerySpecificationContext differentiates from other interfaces.
	IsQuerySpecificationContext()
}

type QuerySpecificationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecificationContext() *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_querySpecification
	return p
}

func InitEmptyQuerySpecificationContext(p *QuerySpecificationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_querySpecification
}

func (*QuerySpecificationContext) IsQuerySpecificationContext() {}

func NewQuerySpecificationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecificationContext {
	var p = new(QuerySpecificationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_querySpecification

	return p
}

func (s *QuerySpecificationContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecificationContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSELECT_SYMBOL, 0)
}

func (s *QuerySpecificationContext) SelectItemList() ISelectItemListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemListContext)
}

func (s *QuerySpecificationContext) AllSelectOption() []ISelectOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectOptionContext); ok {
			len++
		}
	}

	tst := make([]ISelectOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectOptionContext); ok {
			tst[i] = t.(ISelectOptionContext)
			i++
		}
	}

	return tst
}

func (s *QuerySpecificationContext) SelectOption(i int) ISelectOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectOptionContext)
}

func (s *QuerySpecificationContext) IntoClause() IIntoClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntoClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntoClauseContext)
}

func (s *QuerySpecificationContext) FromClause() IFromClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromClauseContext)
}

func (s *QuerySpecificationContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *QuerySpecificationContext) GroupByClause() IGroupByClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupByClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupByClauseContext)
}

func (s *QuerySpecificationContext) HavingClause() IHavingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHavingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHavingClauseContext)
}

func (s *QuerySpecificationContext) WindowClause() IWindowClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowClauseContext)
}

func (s *QuerySpecificationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecificationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecificationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitQuerySpecification(s)
	}
}

func (s *QuerySpecificationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitQuerySpecification(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) QuerySpecification() (localctx IQuerySpecificationContext) {
	localctx = NewQuerySpecificationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, TiDBParserRULE_querySpecification)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1012)
		p.Match(TiDBParserSELECT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1016)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1013)
				p.SelectOption()
			}

		}
		p.SetState(1018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 37, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(1019)
		p.SelectItemList()
	}
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 38, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1020)
			p.IntoClause()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1024)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserFROM_SYMBOL {
		{
			p.SetState(1023)
			p.FromClause()
		}

	}
	p.SetState(1027)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserWHERE_SYMBOL {
		{
			p.SetState(1026)
			p.WhereClause()
		}

	}
	p.SetState(1030)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserGROUP_SYMBOL {
		{
			p.SetState(1029)
			p.GroupByClause()
		}

	}
	p.SetState(1033)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserHAVING_SYMBOL {
		{
			p.SetState(1032)
			p.HavingClause()
		}

	}
	p.SetState(1036)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserWINDOW_SYMBOL {
		{
			p.SetState(1035)
			p.WindowClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubqueryContext is an interface to support dynamic dispatch.
type ISubqueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QueryExpressionParens() IQueryExpressionParensContext

	// IsSubqueryContext differentiates from other interfaces.
	IsSubqueryContext()
}

type SubqueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubqueryContext() *SubqueryContext {
	var p = new(SubqueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_subquery
	return p
}

func InitEmptySubqueryContext(p *SubqueryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_subquery
}

func (*SubqueryContext) IsSubqueryContext() {}

func NewSubqueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubqueryContext {
	var p = new(SubqueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_subquery

	return p
}

func (s *SubqueryContext) GetParser() antlr.Parser { return s.parser }

func (s *SubqueryContext) QueryExpressionParens() IQueryExpressionParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryExpressionParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryExpressionParensContext)
}

func (s *SubqueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubqueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubqueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSubquery(s)
	}
}

func (s *SubqueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSubquery(s)
	}
}

func (s *SubqueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSubquery(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Subquery() (localctx ISubqueryContext) {
	localctx = NewSubqueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, TiDBParserRULE_subquery)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1038)
		p.QueryExpressionParens()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQuerySpecOptionContext is an interface to support dynamic dispatch.
type IQuerySpecOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALL_SYMBOL() antlr.TerminalNode
	DISTINCT_SYMBOL() antlr.TerminalNode
	STRAIGHT_JOIN_SYMBOL() antlr.TerminalNode
	HIGH_PRIORITY_SYMBOL() antlr.TerminalNode
	SQL_SMALL_RESULT_SYMBOL() antlr.TerminalNode
	SQL_BIG_RESULT_SYMBOL() antlr.TerminalNode
	SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode
	SQL_CALC_FOUND_ROWS_SYMBOL() antlr.TerminalNode

	// IsQuerySpecOptionContext differentiates from other interfaces.
	IsQuerySpecOptionContext()
}

type QuerySpecOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySpecOptionContext() *QuerySpecOptionContext {
	var p = new(QuerySpecOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_querySpecOption
	return p
}

func InitEmptyQuerySpecOptionContext(p *QuerySpecOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_querySpecOption
}

func (*QuerySpecOptionContext) IsQuerySpecOptionContext() {}

func NewQuerySpecOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySpecOptionContext {
	var p = new(QuerySpecOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_querySpecOption

	return p
}

func (s *QuerySpecOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySpecOptionContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) DISTINCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISTINCT_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) STRAIGHT_JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTRAIGHT_JOIN_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) HIGH_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHIGH_PRIORITY_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) SQL_SMALL_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_SMALL_RESULT_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) SQL_BIG_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_BIG_RESULT_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_BUFFER_RESULT_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) SQL_CALC_FOUND_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_CALC_FOUND_ROWS_SYMBOL, 0)
}

func (s *QuerySpecOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySpecOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QuerySpecOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterQuerySpecOption(s)
	}
}

func (s *QuerySpecOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitQuerySpecOption(s)
	}
}

func (s *QuerySpecOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitQuerySpecOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) QuerySpecOption() (localctx IQuerySpecOptionContext) {
	localctx = NewQuerySpecOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, TiDBParserRULE_querySpecOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1040)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserALL_SYMBOL || _la == TiDBParserDISTINCT_SYMBOL || _la == TiDBParserHIGH_PRIORITY_SYMBOL || ((int64((_la-531)) & ^0x3f) == 0 && ((int64(1)<<(_la-531))&16777259) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitClauseContext is an interface to support dynamic dispatch.
type ILimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT_SYMBOL() antlr.TerminalNode
	LimitOptions() ILimitOptionsContext

	// IsLimitClauseContext differentiates from other interfaces.
	IsLimitClauseContext()
}

type LimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitClauseContext() *LimitClauseContext {
	var p = new(LimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_limitClause
	return p
}

func InitEmptyLimitClauseContext(p *LimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_limitClause
}

func (*LimitClauseContext) IsLimitClauseContext() {}

func NewLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitClauseContext {
	var p = new(LimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_limitClause

	return p
}

func (s *LimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitClauseContext) LIMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLIMIT_SYMBOL, 0)
}

func (s *LimitClauseContext) LimitOptions() ILimitOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitOptionsContext)
}

func (s *LimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLimitClause(s)
	}
}

func (s *LimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLimitClause(s)
	}
}

func (s *LimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LimitClause() (localctx ILimitClauseContext) {
	localctx = NewLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, TiDBParserRULE_limitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1042)
		p.Match(TiDBParserLIMIT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1043)
		p.LimitOptions()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleLimitClauseContext is an interface to support dynamic dispatch.
type ISimpleLimitClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIMIT_SYMBOL() antlr.TerminalNode
	LimitOption() ILimitOptionContext

	// IsSimpleLimitClauseContext differentiates from other interfaces.
	IsSimpleLimitClauseContext()
}

type SimpleLimitClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLimitClauseContext() *SimpleLimitClauseContext {
	var p = new(SimpleLimitClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_simpleLimitClause
	return p
}

func InitEmptySimpleLimitClauseContext(p *SimpleLimitClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_simpleLimitClause
}

func (*SimpleLimitClauseContext) IsSimpleLimitClauseContext() {}

func NewSimpleLimitClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLimitClauseContext {
	var p = new(SimpleLimitClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_simpleLimitClause

	return p
}

func (s *SimpleLimitClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLimitClauseContext) LIMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLIMIT_SYMBOL, 0)
}

func (s *SimpleLimitClauseContext) LimitOption() ILimitOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitOptionContext)
}

func (s *SimpleLimitClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLimitClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleLimitClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleLimitClause(s)
	}
}

func (s *SimpleLimitClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleLimitClause(s)
	}
}

func (s *SimpleLimitClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleLimitClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SimpleLimitClause() (localctx ISimpleLimitClauseContext) {
	localctx = NewSimpleLimitClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, TiDBParserRULE_simpleLimitClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1045)
		p.Match(TiDBParserLIMIT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1046)
		p.LimitOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitOptionsContext is an interface to support dynamic dispatch.
type ILimitOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLimitOption() []ILimitOptionContext
	LimitOption(i int) ILimitOptionContext
	COMMA_SYMBOL() antlr.TerminalNode
	OFFSET_SYMBOL() antlr.TerminalNode

	// IsLimitOptionsContext differentiates from other interfaces.
	IsLimitOptionsContext()
}

type LimitOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitOptionsContext() *LimitOptionsContext {
	var p = new(LimitOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_limitOptions
	return p
}

func InitEmptyLimitOptionsContext(p *LimitOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_limitOptions
}

func (*LimitOptionsContext) IsLimitOptionsContext() {}

func NewLimitOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitOptionsContext {
	var p = new(LimitOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_limitOptions

	return p
}

func (s *LimitOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitOptionsContext) AllLimitOption() []ILimitOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILimitOptionContext); ok {
			len++
		}
	}

	tst := make([]ILimitOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILimitOptionContext); ok {
			tst[i] = t.(ILimitOptionContext)
			i++
		}
	}

	return tst
}

func (s *LimitOptionsContext) LimitOption(i int) ILimitOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitOptionContext)
}

func (s *LimitOptionsContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *LimitOptionsContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOFFSET_SYMBOL, 0)
}

func (s *LimitOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLimitOptions(s)
	}
}

func (s *LimitOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLimitOptions(s)
	}
}

func (s *LimitOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLimitOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LimitOptions() (localctx ILimitOptionsContext) {
	localctx = NewLimitOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, TiDBParserRULE_limitOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1048)
		p.LimitOption()
	}
	p.SetState(1051)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserOFFSET_SYMBOL || _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1049)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserOFFSET_SYMBOL || _la == TiDBParserCOMMA_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1050)
			p.LimitOption()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILimitOptionContext is an interface to support dynamic dispatch.
type ILimitOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	PARAM_MARKER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode

	// IsLimitOptionContext differentiates from other interfaces.
	IsLimitOptionContext()
}

type LimitOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLimitOptionContext() *LimitOptionContext {
	var p = new(LimitOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_limitOption
	return p
}

func InitEmptyLimitOptionContext(p *LimitOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_limitOption
}

func (*LimitOptionContext) IsLimitOptionContext() {}

func NewLimitOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LimitOptionContext {
	var p = new(LimitOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_limitOption

	return p
}

func (s *LimitOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LimitOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LimitOptionContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARAM_MARKER, 0)
}

func (s *LimitOptionContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserULONGLONG_NUMBER, 0)
}

func (s *LimitOptionContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserLONG_NUMBER, 0)
}

func (s *LimitOptionContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *LimitOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LimitOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LimitOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLimitOption(s)
	}
}

func (s *LimitOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLimitOption(s)
	}
}

func (s *LimitOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLimitOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LimitOption() (localctx ILimitOptionContext) {
	localctx = NewLimitOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, TiDBParserRULE_limitOption)
	var _la int

	p.SetState(1055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1053)
			p.Identifier()
		}

	case TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserPARAM_MARKER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1054)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&1099511627783) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntoClauseContext is an interface to support dynamic dispatch.
type IIntoClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INTO_SYMBOL() antlr.TerminalNode
	OUTFILE_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	DUMPFILE_SYMBOL() antlr.TerminalNode
	AllTextOrIdentifier() []ITextOrIdentifierContext
	TextOrIdentifier(i int) ITextOrIdentifierContext
	AllUserVariable() []IUserVariableContext
	UserVariable(i int) IUserVariableContext
	CharsetClause() ICharsetClauseContext
	FieldsClause() IFieldsClauseContext
	LinesClause() ILinesClauseContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIntoClauseContext differentiates from other interfaces.
	IsIntoClauseContext()
}

type IntoClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntoClauseContext() *IntoClauseContext {
	var p = new(IntoClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_intoClause
	return p
}

func InitEmptyIntoClauseContext(p *IntoClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_intoClause
}

func (*IntoClauseContext) IsIntoClauseContext() {}

func NewIntoClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntoClauseContext {
	var p = new(IntoClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_intoClause

	return p
}

func (s *IntoClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntoClauseContext) INTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTO_SYMBOL, 0)
}

func (s *IntoClauseContext) OUTFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOUTFILE_SYMBOL, 0)
}

func (s *IntoClauseContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *IntoClauseContext) DUMPFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDUMPFILE_SYMBOL, 0)
}

func (s *IntoClauseContext) AllTextOrIdentifier() []ITextOrIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITextOrIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextOrIdentifierContext); ok {
			tst[i] = t.(ITextOrIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) TextOrIdentifier(i int) ITextOrIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *IntoClauseContext) AllUserVariable() []IUserVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserVariableContext); ok {
			len++
		}
	}

	tst := make([]IUserVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserVariableContext); ok {
			tst[i] = t.(IUserVariableContext)
			i++
		}
	}

	return tst
}

func (s *IntoClauseContext) UserVariable(i int) IUserVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *IntoClauseContext) CharsetClause() ICharsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetClauseContext)
}

func (s *IntoClauseContext) FieldsClause() IFieldsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldsClauseContext)
}

func (s *IntoClauseContext) LinesClause() ILinesClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILinesClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILinesClauseContext)
}

func (s *IntoClauseContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *IntoClauseContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *IntoClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntoClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntoClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIntoClause(s)
	}
}

func (s *IntoClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIntoClause(s)
	}
}

func (s *IntoClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIntoClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IntoClause() (localctx IIntoClauseContext) {
	localctx = NewIntoClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, TiDBParserRULE_intoClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1057)
		p.Match(TiDBParserINTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1058)
			p.Match(TiDBParserOUTFILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1059)
			p.TextStringLiteral()
		}
		p.SetState(1061)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCHARSET_SYMBOL || _la == TiDBParserCHAR_SYMBOL {
			{
				p.SetState(1060)
				p.CharsetClause()
			}

		}
		p.SetState(1064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOLUMNS_SYMBOL {
			{
				p.SetState(1063)
				p.FieldsClause()
			}

		}
		p.SetState(1067)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLINES_SYMBOL {
			{
				p.SetState(1066)
				p.LinesClause()
			}

		}

	case 2:
		{
			p.SetState(1069)
			p.Match(TiDBParserDUMPFILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1070)
			p.TextStringLiteral()
		}

	case 3:
		p.SetState(1073)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
			{
				p.SetState(1071)
				p.TextOrIdentifier()
			}

		case TiDBParserAT_SIGN_SYMBOL, TiDBParserAT_TEXT_SUFFIX:
			{
				p.SetState(1072)
				p.UserVariable()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(1075)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1078)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
				{
					p.SetState(1076)
					p.TextOrIdentifier()
				}

			case TiDBParserAT_SIGN_SYMBOL, TiDBParserAT_TEXT_SUFFIX:
				{
					p.SetState(1077)
					p.UserVariable()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

			p.SetState(1084)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureAnalyseClauseContext is an interface to support dynamic dispatch.
type IProcedureAnalyseClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PROCEDURE_SYMBOL() antlr.TerminalNode
	ANALYSE_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllINT_NUMBER() []antlr.TerminalNode
	INT_NUMBER(i int) antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode

	// IsProcedureAnalyseClauseContext differentiates from other interfaces.
	IsProcedureAnalyseClauseContext()
}

type ProcedureAnalyseClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureAnalyseClauseContext() *ProcedureAnalyseClauseContext {
	var p = new(ProcedureAnalyseClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_procedureAnalyseClause
	return p
}

func InitEmptyProcedureAnalyseClauseContext(p *ProcedureAnalyseClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_procedureAnalyseClause
}

func (*ProcedureAnalyseClauseContext) IsProcedureAnalyseClauseContext() {}

func NewProcedureAnalyseClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureAnalyseClauseContext {
	var p = new(ProcedureAnalyseClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_procedureAnalyseClause

	return p
}

func (s *ProcedureAnalyseClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureAnalyseClauseContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROCEDURE_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) ANALYSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserANALYSE_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) AllINT_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserINT_NUMBER)
}

func (s *ProcedureAnalyseClauseContext) INT_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, i)
}

func (s *ProcedureAnalyseClauseContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *ProcedureAnalyseClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureAnalyseClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureAnalyseClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterProcedureAnalyseClause(s)
	}
}

func (s *ProcedureAnalyseClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitProcedureAnalyseClause(s)
	}
}

func (s *ProcedureAnalyseClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitProcedureAnalyseClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ProcedureAnalyseClause() (localctx IProcedureAnalyseClauseContext) {
	localctx = NewProcedureAnalyseClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, TiDBParserRULE_procedureAnalyseClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1087)
		p.Match(TiDBParserPROCEDURE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1088)
		p.Match(TiDBParserANALYSE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1089)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1095)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserINT_NUMBER {
		{
			p.SetState(1090)
			p.Match(TiDBParserINT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(1091)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1092)
				p.Match(TiDBParserINT_NUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1097)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHavingClauseContext is an interface to support dynamic dispatch.
type IHavingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	HAVING_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsHavingClauseContext differentiates from other interfaces.
	IsHavingClauseContext()
}

type HavingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHavingClauseContext() *HavingClauseContext {
	var p = new(HavingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_havingClause
	return p
}

func InitEmptyHavingClauseContext(p *HavingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_havingClause
}

func (*HavingClauseContext) IsHavingClauseContext() {}

func NewHavingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HavingClauseContext {
	var p = new(HavingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_havingClause

	return p
}

func (s *HavingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *HavingClauseContext) HAVING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHAVING_SYMBOL, 0)
}

func (s *HavingClauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *HavingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HavingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HavingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterHavingClause(s)
	}
}

func (s *HavingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitHavingClause(s)
	}
}

func (s *HavingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitHavingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) HavingClause() (localctx IHavingClauseContext) {
	localctx = NewHavingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, TiDBParserRULE_havingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1099)
		p.Match(TiDBParserHAVING_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1100)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowClauseContext is an interface to support dynamic dispatch.
type IWindowClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WINDOW_SYMBOL() antlr.TerminalNode
	AllWindowDefinition() []IWindowDefinitionContext
	WindowDefinition(i int) IWindowDefinitionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsWindowClauseContext differentiates from other interfaces.
	IsWindowClauseContext()
}

type WindowClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowClauseContext() *WindowClauseContext {
	var p = new(WindowClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowClause
	return p
}

func InitEmptyWindowClauseContext(p *WindowClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowClause
}

func (*WindowClauseContext) IsWindowClauseContext() {}

func NewWindowClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowClauseContext {
	var p = new(WindowClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowClause

	return p
}

func (s *WindowClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowClauseContext) WINDOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWINDOW_SYMBOL, 0)
}

func (s *WindowClauseContext) AllWindowDefinition() []IWindowDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IWindowDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowDefinitionContext); ok {
			tst[i] = t.(IWindowDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *WindowClauseContext) WindowDefinition(i int) IWindowDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowDefinitionContext)
}

func (s *WindowClauseContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *WindowClauseContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *WindowClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowClause(s)
	}
}

func (s *WindowClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowClause(s)
	}
}

func (s *WindowClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowClause() (localctx IWindowClauseContext) {
	localctx = NewWindowClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, TiDBParserRULE_windowClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1102)
		p.Match(TiDBParserWINDOW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1103)
		p.WindowDefinition()
	}
	p.SetState(1108)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1104)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1105)
			p.WindowDefinition()
		}

		p.SetState(1110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowDefinitionContext is an interface to support dynamic dispatch.
type IWindowDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowName() IWindowNameContext
	AS_SYMBOL() antlr.TerminalNode
	WindowSpec() IWindowSpecContext

	// IsWindowDefinitionContext differentiates from other interfaces.
	IsWindowDefinitionContext()
}

type WindowDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowDefinitionContext() *WindowDefinitionContext {
	var p = new(WindowDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowDefinition
	return p
}

func InitEmptyWindowDefinitionContext(p *WindowDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowDefinition
}

func (*WindowDefinitionContext) IsWindowDefinitionContext() {}

func NewWindowDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowDefinitionContext {
	var p = new(WindowDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowDefinition

	return p
}

func (s *WindowDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowDefinitionContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowDefinitionContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *WindowDefinitionContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *WindowDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowDefinition(s)
	}
}

func (s *WindowDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowDefinition(s)
	}
}

func (s *WindowDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowDefinition() (localctx IWindowDefinitionContext) {
	localctx = NewWindowDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, TiDBParserRULE_windowDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1111)
		p.WindowName()
	}
	{
		p.SetState(1112)
		p.Match(TiDBParserAS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1113)
		p.WindowSpec()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecContext is an interface to support dynamic dispatch.
type IWindowSpecContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	WindowSpecDetails() IWindowSpecDetailsContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsWindowSpecContext differentiates from other interfaces.
	IsWindowSpecContext()
}

type WindowSpecContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecContext() *WindowSpecContext {
	var p = new(WindowSpecContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowSpec
	return p
}

func InitEmptyWindowSpecContext(p *WindowSpecContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowSpec
}

func (*WindowSpecContext) IsWindowSpecContext() {}

func NewWindowSpecContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecContext {
	var p = new(WindowSpecContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowSpec

	return p
}

func (s *WindowSpecContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *WindowSpecContext) WindowSpecDetails() IWindowSpecDetailsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecDetailsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecDetailsContext)
}

func (s *WindowSpecContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *WindowSpecContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowSpec(s)
	}
}

func (s *WindowSpecContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowSpec(s)
	}
}

func (s *WindowSpecContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowSpec(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowSpec() (localctx IWindowSpecContext) {
	localctx = NewWindowSpecContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, TiDBParserRULE_windowSpec)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1115)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1116)
		p.WindowSpecDetails()
	}
	{
		p.SetState(1117)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowSpecDetailsContext is an interface to support dynamic dispatch.
type IWindowSpecDetailsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowName() IWindowNameContext
	PARTITION_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	OrderList() IOrderListContext
	OrderClause() IOrderClauseContext
	WindowFrameClause() IWindowFrameClauseContext

	// IsWindowSpecDetailsContext differentiates from other interfaces.
	IsWindowSpecDetailsContext()
}

type WindowSpecDetailsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowSpecDetailsContext() *WindowSpecDetailsContext {
	var p = new(WindowSpecDetailsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowSpecDetails
	return p
}

func InitEmptyWindowSpecDetailsContext(p *WindowSpecDetailsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowSpecDetails
}

func (*WindowSpecDetailsContext) IsWindowSpecDetailsContext() {}

func NewWindowSpecDetailsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowSpecDetailsContext {
	var p = new(WindowSpecDetailsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowSpecDetails

	return p
}

func (s *WindowSpecDetailsContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowSpecDetailsContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowSpecDetailsContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITION_SYMBOL, 0)
}

func (s *WindowSpecDetailsContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *WindowSpecDetailsContext) OrderList() IOrderListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderListContext)
}

func (s *WindowSpecDetailsContext) OrderClause() IOrderClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *WindowSpecDetailsContext) WindowFrameClause() IWindowFrameClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameClauseContext)
}

func (s *WindowSpecDetailsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowSpecDetailsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowSpecDetailsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowSpecDetails(s)
	}
}

func (s *WindowSpecDetailsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowSpecDetails(s)
	}
}

func (s *WindowSpecDetailsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowSpecDetails(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowSpecDetails() (localctx IWindowSpecDetailsContext) {
	localctx = NewWindowSpecDetailsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, TiDBParserRULE_windowSpecDetails)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1120)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1119)
			p.WindowName()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserPARTITION_SYMBOL {
		{
			p.SetState(1122)
			p.Match(TiDBParserPARTITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1123)
			p.Match(TiDBParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1124)
			p.OrderList()
		}

	}
	p.SetState(1128)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserORDER_SYMBOL {
		{
			p.SetState(1127)
			p.OrderClause()
		}

	}
	p.SetState(1131)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserRANGE_SYMBOL || _la == TiDBParserROWS_SYMBOL || _la == TiDBParserGROUPS_SYMBOL {
		{
			p.SetState(1130)
			p.WindowFrameClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameClauseContext is an interface to support dynamic dispatch.
type IWindowFrameClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowFrameUnits() IWindowFrameUnitsContext
	WindowFrameExtent() IWindowFrameExtentContext
	WindowFrameExclusion() IWindowFrameExclusionContext

	// IsWindowFrameClauseContext differentiates from other interfaces.
	IsWindowFrameClauseContext()
}

type WindowFrameClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameClauseContext() *WindowFrameClauseContext {
	var p = new(WindowFrameClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameClause
	return p
}

func InitEmptyWindowFrameClauseContext(p *WindowFrameClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameClause
}

func (*WindowFrameClauseContext) IsWindowFrameClauseContext() {}

func NewWindowFrameClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameClauseContext {
	var p = new(WindowFrameClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowFrameClause

	return p
}

func (s *WindowFrameClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameClauseContext) WindowFrameUnits() IWindowFrameUnitsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameUnitsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameUnitsContext)
}

func (s *WindowFrameClauseContext) WindowFrameExtent() IWindowFrameExtentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameExtentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameExtentContext)
}

func (s *WindowFrameClauseContext) WindowFrameExclusion() IWindowFrameExclusionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameExclusionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameExclusionContext)
}

func (s *WindowFrameClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowFrameClause(s)
	}
}

func (s *WindowFrameClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowFrameClause(s)
	}
}

func (s *WindowFrameClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowFrameClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowFrameClause() (localctx IWindowFrameClauseContext) {
	localctx = NewWindowFrameClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, TiDBParserRULE_windowFrameClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1133)
		p.WindowFrameUnits()
	}
	{
		p.SetState(1134)
		p.WindowFrameExtent()
	}
	p.SetState(1136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserEXCLUDE_SYMBOL {
		{
			p.SetState(1135)
			p.WindowFrameExclusion()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameUnitsContext is an interface to support dynamic dispatch.
type IWindowFrameUnitsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROWS_SYMBOL() antlr.TerminalNode
	RANGE_SYMBOL() antlr.TerminalNode
	GROUPS_SYMBOL() antlr.TerminalNode

	// IsWindowFrameUnitsContext differentiates from other interfaces.
	IsWindowFrameUnitsContext()
}

type WindowFrameUnitsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameUnitsContext() *WindowFrameUnitsContext {
	var p = new(WindowFrameUnitsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameUnits
	return p
}

func InitEmptyWindowFrameUnitsContext(p *WindowFrameUnitsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameUnits
}

func (*WindowFrameUnitsContext) IsWindowFrameUnitsContext() {}

func NewWindowFrameUnitsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameUnitsContext {
	var p = new(WindowFrameUnitsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowFrameUnits

	return p
}

func (s *WindowFrameUnitsContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameUnitsContext) ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROWS_SYMBOL, 0)
}

func (s *WindowFrameUnitsContext) RANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRANGE_SYMBOL, 0)
}

func (s *WindowFrameUnitsContext) GROUPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUPS_SYMBOL, 0)
}

func (s *WindowFrameUnitsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameUnitsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameUnitsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowFrameUnits(s)
	}
}

func (s *WindowFrameUnitsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowFrameUnits(s)
	}
}

func (s *WindowFrameUnitsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowFrameUnits(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowFrameUnits() (localctx IWindowFrameUnitsContext) {
	localctx = NewWindowFrameUnitsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, TiDBParserRULE_windowFrameUnits)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1138)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserRANGE_SYMBOL || _la == TiDBParserROWS_SYMBOL || _la == TiDBParserGROUPS_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameExtentContext is an interface to support dynamic dispatch.
type IWindowFrameExtentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowFrameStart() IWindowFrameStartContext
	WindowFrameBetween() IWindowFrameBetweenContext

	// IsWindowFrameExtentContext differentiates from other interfaces.
	IsWindowFrameExtentContext()
}

type WindowFrameExtentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameExtentContext() *WindowFrameExtentContext {
	var p = new(WindowFrameExtentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameExtent
	return p
}

func InitEmptyWindowFrameExtentContext(p *WindowFrameExtentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameExtent
}

func (*WindowFrameExtentContext) IsWindowFrameExtentContext() {}

func NewWindowFrameExtentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameExtentContext {
	var p = new(WindowFrameExtentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowFrameExtent

	return p
}

func (s *WindowFrameExtentContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameExtentContext) WindowFrameStart() IWindowFrameStartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameStartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameStartContext)
}

func (s *WindowFrameExtentContext) WindowFrameBetween() IWindowFrameBetweenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameBetweenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameBetweenContext)
}

func (s *WindowFrameExtentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameExtentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameExtentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowFrameExtent(s)
	}
}

func (s *WindowFrameExtentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowFrameExtent(s)
	}
}

func (s *WindowFrameExtentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowFrameExtent(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowFrameExtent() (localctx IWindowFrameExtentContext) {
	localctx = NewWindowFrameExtentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, TiDBParserRULE_windowFrameExtent)
	p.SetState(1142)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCURRENT_SYMBOL, TiDBParserINTERVAL_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserPARAM_MARKER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1140)
			p.WindowFrameStart()
		}

	case TiDBParserBETWEEN_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1141)
			p.WindowFrameBetween()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameStartContext is an interface to support dynamic dispatch.
type IWindowFrameStartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNBOUNDED_SYMBOL() antlr.TerminalNode
	PRECEDING_SYMBOL() antlr.TerminalNode
	Ulonglong_number() IUlonglong_numberContext
	PARAM_MARKER() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	Interval() IIntervalContext
	CURRENT_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode

	// IsWindowFrameStartContext differentiates from other interfaces.
	IsWindowFrameStartContext()
}

type WindowFrameStartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameStartContext() *WindowFrameStartContext {
	var p = new(WindowFrameStartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameStart
	return p
}

func InitEmptyWindowFrameStartContext(p *WindowFrameStartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameStart
}

func (*WindowFrameStartContext) IsWindowFrameStartContext() {}

func NewWindowFrameStartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameStartContext {
	var p = new(WindowFrameStartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowFrameStart

	return p
}

func (s *WindowFrameStartContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameStartContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNBOUNDED_SYMBOL, 0)
}

func (s *WindowFrameStartContext) PRECEDING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRECEDING_SYMBOL, 0)
}

func (s *WindowFrameStartContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *WindowFrameStartContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARAM_MARKER, 0)
}

func (s *WindowFrameStartContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTERVAL_SYMBOL, 0)
}

func (s *WindowFrameStartContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WindowFrameStartContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *WindowFrameStartContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURRENT_SYMBOL, 0)
}

func (s *WindowFrameStartContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_SYMBOL, 0)
}

func (s *WindowFrameStartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameStartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameStartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowFrameStart(s)
	}
}

func (s *WindowFrameStartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowFrameStart(s)
	}
}

func (s *WindowFrameStartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowFrameStart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowFrameStart() (localctx IWindowFrameStartContext) {
	localctx = NewWindowFrameStartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, TiDBParserRULE_windowFrameStart)
	p.SetState(1158)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserUNBOUNDED_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1144)
			p.Match(TiDBParserUNBOUNDED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1145)
			p.Match(TiDBParserPRECEDING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1146)
			p.Ulonglong_number()
		}
		{
			p.SetState(1147)
			p.Match(TiDBParserPRECEDING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserPARAM_MARKER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1149)
			p.Match(TiDBParserPARAM_MARKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1150)
			p.Match(TiDBParserPRECEDING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserINTERVAL_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1151)
			p.Match(TiDBParserINTERVAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1152)
			p.expr(0)
		}
		{
			p.SetState(1153)
			p.Interval()
		}
		{
			p.SetState(1154)
			p.Match(TiDBParserPRECEDING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserCURRENT_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1156)
			p.Match(TiDBParserCURRENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1157)
			p.Match(TiDBParserROW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameBetweenContext is an interface to support dynamic dispatch.
type IWindowFrameBetweenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BETWEEN_SYMBOL() antlr.TerminalNode
	AllWindowFrameBound() []IWindowFrameBoundContext
	WindowFrameBound(i int) IWindowFrameBoundContext
	AND_SYMBOL() antlr.TerminalNode

	// IsWindowFrameBetweenContext differentiates from other interfaces.
	IsWindowFrameBetweenContext()
}

type WindowFrameBetweenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameBetweenContext() *WindowFrameBetweenContext {
	var p = new(WindowFrameBetweenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameBetween
	return p
}

func InitEmptyWindowFrameBetweenContext(p *WindowFrameBetweenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameBetween
}

func (*WindowFrameBetweenContext) IsWindowFrameBetweenContext() {}

func NewWindowFrameBetweenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameBetweenContext {
	var p = new(WindowFrameBetweenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowFrameBetween

	return p
}

func (s *WindowFrameBetweenContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameBetweenContext) BETWEEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBETWEEN_SYMBOL, 0)
}

func (s *WindowFrameBetweenContext) AllWindowFrameBound() []IWindowFrameBoundContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWindowFrameBoundContext); ok {
			len++
		}
	}

	tst := make([]IWindowFrameBoundContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWindowFrameBoundContext); ok {
			tst[i] = t.(IWindowFrameBoundContext)
			i++
		}
	}

	return tst
}

func (s *WindowFrameBetweenContext) WindowFrameBound(i int) IWindowFrameBoundContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameBoundContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameBoundContext)
}

func (s *WindowFrameBetweenContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAND_SYMBOL, 0)
}

func (s *WindowFrameBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameBetweenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowFrameBetween(s)
	}
}

func (s *WindowFrameBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowFrameBetween(s)
	}
}

func (s *WindowFrameBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowFrameBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowFrameBetween() (localctx IWindowFrameBetweenContext) {
	localctx = NewWindowFrameBetweenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, TiDBParserRULE_windowFrameBetween)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1160)
		p.Match(TiDBParserBETWEEN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1161)
		p.WindowFrameBound()
	}
	{
		p.SetState(1162)
		p.Match(TiDBParserAND_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1163)
		p.WindowFrameBound()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameBoundContext is an interface to support dynamic dispatch.
type IWindowFrameBoundContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WindowFrameStart() IWindowFrameStartContext
	UNBOUNDED_SYMBOL() antlr.TerminalNode
	FOLLOWING_SYMBOL() antlr.TerminalNode
	Ulonglong_number() IUlonglong_numberContext
	PARAM_MARKER() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	Interval() IIntervalContext

	// IsWindowFrameBoundContext differentiates from other interfaces.
	IsWindowFrameBoundContext()
}

type WindowFrameBoundContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameBoundContext() *WindowFrameBoundContext {
	var p = new(WindowFrameBoundContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameBound
	return p
}

func InitEmptyWindowFrameBoundContext(p *WindowFrameBoundContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameBound
}

func (*WindowFrameBoundContext) IsWindowFrameBoundContext() {}

func NewWindowFrameBoundContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameBoundContext {
	var p = new(WindowFrameBoundContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowFrameBound

	return p
}

func (s *WindowFrameBoundContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameBoundContext) WindowFrameStart() IWindowFrameStartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFrameStartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFrameStartContext)
}

func (s *WindowFrameBoundContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNBOUNDED_SYMBOL, 0)
}

func (s *WindowFrameBoundContext) FOLLOWING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOLLOWING_SYMBOL, 0)
}

func (s *WindowFrameBoundContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *WindowFrameBoundContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARAM_MARKER, 0)
}

func (s *WindowFrameBoundContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTERVAL_SYMBOL, 0)
}

func (s *WindowFrameBoundContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WindowFrameBoundContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *WindowFrameBoundContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameBoundContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameBoundContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowFrameBound(s)
	}
}

func (s *WindowFrameBoundContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowFrameBound(s)
	}
}

func (s *WindowFrameBoundContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowFrameBound(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowFrameBound() (localctx IWindowFrameBoundContext) {
	localctx = NewWindowFrameBoundContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, TiDBParserRULE_windowFrameBound)
	p.SetState(1178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 63, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1165)
			p.WindowFrameStart()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1166)
			p.Match(TiDBParserUNBOUNDED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1167)
			p.Match(TiDBParserFOLLOWING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1168)
			p.Ulonglong_number()
		}
		{
			p.SetState(1169)
			p.Match(TiDBParserFOLLOWING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1171)
			p.Match(TiDBParserPARAM_MARKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1172)
			p.Match(TiDBParserFOLLOWING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1173)
			p.Match(TiDBParserINTERVAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1174)
			p.expr(0)
		}
		{
			p.SetState(1175)
			p.Interval()
		}
		{
			p.SetState(1176)
			p.Match(TiDBParserFOLLOWING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFrameExclusionContext is an interface to support dynamic dispatch.
type IWindowFrameExclusionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCLUDE_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	TIES_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	OTHERS_SYMBOL() antlr.TerminalNode

	// IsWindowFrameExclusionContext differentiates from other interfaces.
	IsWindowFrameExclusionContext()
}

type WindowFrameExclusionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFrameExclusionContext() *WindowFrameExclusionContext {
	var p = new(WindowFrameExclusionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameExclusion
	return p
}

func InitEmptyWindowFrameExclusionContext(p *WindowFrameExclusionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFrameExclusion
}

func (*WindowFrameExclusionContext) IsWindowFrameExclusionContext() {}

func NewWindowFrameExclusionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFrameExclusionContext {
	var p = new(WindowFrameExclusionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowFrameExclusion

	return p
}

func (s *WindowFrameExclusionContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFrameExclusionContext) EXCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXCLUDE_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURRENT_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) TIES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIES_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) OTHERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOTHERS_SYMBOL, 0)
}

func (s *WindowFrameExclusionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFrameExclusionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFrameExclusionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowFrameExclusion(s)
	}
}

func (s *WindowFrameExclusionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowFrameExclusion(s)
	}
}

func (s *WindowFrameExclusionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowFrameExclusion(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowFrameExclusion() (localctx IWindowFrameExclusionContext) {
	localctx = NewWindowFrameExclusionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, TiDBParserRULE_windowFrameExclusion)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1180)
		p.Match(TiDBParserEXCLUDE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCURRENT_SYMBOL:
		{
			p.SetState(1181)
			p.Match(TiDBParserCURRENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1182)
			p.Match(TiDBParserROW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserGROUP_SYMBOL:
		{
			p.SetState(1183)
			p.Match(TiDBParserGROUP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserTIES_SYMBOL:
		{
			p.SetState(1184)
			p.Match(TiDBParserTIES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserNO_SYMBOL:
		{
			p.SetState(1185)
			p.Match(TiDBParserNO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1186)
			p.Match(TiDBParserOTHERS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	AllCommonTableExpression() []ICommonTableExpressionContext
	CommonTableExpression(i int) ICommonTableExpressionContext
	RECURSIVE_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *WithClauseContext) AllCommonTableExpression() []ICommonTableExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			len++
		}
	}

	tst := make([]ICommonTableExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICommonTableExpressionContext); ok {
			tst[i] = t.(ICommonTableExpressionContext)
			i++
		}
	}

	return tst
}

func (s *WithClauseContext) CommonTableExpression(i int) ICommonTableExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonTableExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonTableExpressionContext)
}

func (s *WithClauseContext) RECURSIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRECURSIVE_SYMBOL, 0)
}

func (s *WithClauseContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *WithClauseContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWithClause(s)
	}
}

func (s *WithClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWithClause(s)
	}
}

func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, TiDBParserRULE_withClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1189)
		p.Match(TiDBParserWITH_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1191)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserRECURSIVE_SYMBOL {
		{
			p.SetState(1190)
			p.Match(TiDBParserRECURSIVE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1193)
		p.CommonTableExpression()
	}
	p.SetState(1198)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1194)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1195)
			p.CommonTableExpression()
		}

		p.SetState(1200)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonTableExpressionContext is an interface to support dynamic dispatch.
type ICommonTableExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS_SYMBOL() antlr.TerminalNode
	Subquery() ISubqueryContext
	ColumnInternalRefList() IColumnInternalRefListContext

	// IsCommonTableExpressionContext differentiates from other interfaces.
	IsCommonTableExpressionContext()
}

type CommonTableExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonTableExpressionContext() *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_commonTableExpression
	return p
}

func InitEmptyCommonTableExpressionContext(p *CommonTableExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_commonTableExpression
}

func (*CommonTableExpressionContext) IsCommonTableExpressionContext() {}

func NewCommonTableExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonTableExpressionContext {
	var p = new(CommonTableExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_commonTableExpression

	return p
}

func (s *CommonTableExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonTableExpressionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CommonTableExpressionContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *CommonTableExpressionContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *CommonTableExpressionContext) ColumnInternalRefList() IColumnInternalRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefListContext)
}

func (s *CommonTableExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonTableExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonTableExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCommonTableExpression(s)
	}
}

func (s *CommonTableExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCommonTableExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CommonTableExpression() (localctx ICommonTableExpressionContext) {
	localctx = NewCommonTableExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, TiDBParserRULE_commonTableExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1201)
		p.Identifier()
	}
	p.SetState(1203)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserOPEN_PAR_SYMBOL {
		{
			p.SetState(1202)
			p.ColumnInternalRefList()
		}

	}
	{
		p.SetState(1205)
		p.Match(TiDBParserAS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1206)
		p.Subquery()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupByClauseContext is an interface to support dynamic dispatch.
type IGroupByClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	OrderList() IOrderListContext
	OlapOption() IOlapOptionContext

	// IsGroupByClauseContext differentiates from other interfaces.
	IsGroupByClauseContext()
}

type GroupByClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupByClauseContext() *GroupByClauseContext {
	var p = new(GroupByClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupByClause
	return p
}

func InitEmptyGroupByClauseContext(p *GroupByClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupByClause
}

func (*GroupByClauseContext) IsGroupByClauseContext() {}

func NewGroupByClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupByClauseContext {
	var p = new(GroupByClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_groupByClause

	return p
}

func (s *GroupByClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupByClauseContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_SYMBOL, 0)
}

func (s *GroupByClauseContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *GroupByClauseContext) OrderList() IOrderListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderListContext)
}

func (s *GroupByClauseContext) OlapOption() IOlapOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOlapOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOlapOptionContext)
}

func (s *GroupByClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupByClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupByClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGroupByClause(s)
	}
}

func (s *GroupByClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGroupByClause(s)
	}
}

func (s *GroupByClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGroupByClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GroupByClause() (localctx IGroupByClauseContext) {
	localctx = NewGroupByClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, TiDBParserRULE_groupByClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1208)
		p.Match(TiDBParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1209)
		p.Match(TiDBParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1210)
		p.OrderList()
	}
	p.SetState(1212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserWITH_SYMBOL {
		{
			p.SetState(1211)
			p.OlapOption()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOlapOptionContext is an interface to support dynamic dispatch.
type IOlapOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	ROLLUP_SYMBOL() antlr.TerminalNode
	CUBE_SYMBOL() antlr.TerminalNode

	// IsOlapOptionContext differentiates from other interfaces.
	IsOlapOptionContext()
}

type OlapOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOlapOptionContext() *OlapOptionContext {
	var p = new(OlapOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_olapOption
	return p
}

func InitEmptyOlapOptionContext(p *OlapOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_olapOption
}

func (*OlapOptionContext) IsOlapOptionContext() {}

func NewOlapOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OlapOptionContext {
	var p = new(OlapOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_olapOption

	return p
}

func (s *OlapOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OlapOptionContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *OlapOptionContext) ROLLUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLLUP_SYMBOL, 0)
}

func (s *OlapOptionContext) CUBE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCUBE_SYMBOL, 0)
}

func (s *OlapOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OlapOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OlapOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOlapOption(s)
	}
}

func (s *OlapOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOlapOption(s)
	}
}

func (s *OlapOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOlapOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OlapOption() (localctx IOlapOptionContext) {
	localctx = NewOlapOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, TiDBParserRULE_olapOption)
	p.SetState(1218)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1214)
			p.Match(TiDBParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1215)
			p.Match(TiDBParserROLLUP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1216)
			p.Match(TiDBParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1217)
			p.Match(TiDBParserCUBE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderClauseContext is an interface to support dynamic dispatch.
type IOrderClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ORDER_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	OrderList() IOrderListContext

	// IsOrderClauseContext differentiates from other interfaces.
	IsOrderClauseContext()
}

type OrderClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderClauseContext() *OrderClauseContext {
	var p = new(OrderClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_orderClause
	return p
}

func InitEmptyOrderClauseContext(p *OrderClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_orderClause
}

func (*OrderClauseContext) IsOrderClauseContext() {}

func NewOrderClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderClauseContext {
	var p = new(OrderClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_orderClause

	return p
}

func (s *OrderClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderClauseContext) ORDER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserORDER_SYMBOL, 0)
}

func (s *OrderClauseContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *OrderClauseContext) OrderList() IOrderListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderListContext)
}

func (s *OrderClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOrderClause(s)
	}
}

func (s *OrderClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOrderClause(s)
	}
}

func (s *OrderClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOrderClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OrderClause() (localctx IOrderClauseContext) {
	localctx = NewOrderClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, TiDBParserRULE_orderClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1220)
		p.Match(TiDBParserORDER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1221)
		p.Match(TiDBParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1222)
		p.OrderList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDirectionContext is an interface to support dynamic dispatch.
type IDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASC_SYMBOL() antlr.TerminalNode
	DESC_SYMBOL() antlr.TerminalNode

	// IsDirectionContext differentiates from other interfaces.
	IsDirectionContext()
}

type DirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDirectionContext() *DirectionContext {
	var p = new(DirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_direction
	return p
}

func InitEmptyDirectionContext(p *DirectionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_direction
}

func (*DirectionContext) IsDirectionContext() {}

func NewDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DirectionContext {
	var p = new(DirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_direction

	return p
}

func (s *DirectionContext) GetParser() antlr.Parser { return s.parser }

func (s *DirectionContext) ASC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserASC_SYMBOL, 0)
}

func (s *DirectionContext) DESC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDESC_SYMBOL, 0)
}

func (s *DirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DirectionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDirection(s)
	}
}

func (s *DirectionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDirection(s)
	}
}

func (s *DirectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDirection(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Direction() (localctx IDirectionContext) {
	localctx = NewDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, TiDBParserRULE_direction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1224)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserASC_SYMBOL || _la == TiDBParserDESC_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromClauseContext is an interface to support dynamic dispatch.
type IFromClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM_SYMBOL() antlr.TerminalNode
	DUAL_SYMBOL() antlr.TerminalNode
	TableReferenceList() ITableReferenceListContext

	// IsFromClauseContext differentiates from other interfaces.
	IsFromClauseContext()
}

type FromClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromClauseContext() *FromClauseContext {
	var p = new(FromClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fromClause
	return p
}

func InitEmptyFromClauseContext(p *FromClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fromClause
}

func (*FromClauseContext) IsFromClauseContext() {}

func NewFromClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromClauseContext {
	var p = new(FromClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fromClause

	return p
}

func (s *FromClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FromClauseContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *FromClauseContext) DUAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDUAL_SYMBOL, 0)
}

func (s *FromClauseContext) TableReferenceList() ITableReferenceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListContext)
}

func (s *FromClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFromClause(s)
	}
}

func (s *FromClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFromClause(s)
	}
}

func (s *FromClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFromClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FromClause() (localctx IFromClauseContext) {
	localctx = NewFromClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, TiDBParserRULE_fromClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1226)
		p.Match(TiDBParserFROM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserDUAL_SYMBOL:
		{
			p.SetState(1227)
			p.Match(TiDBParserDUAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserJSON_TABLE_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserLATERAL_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserDOT_SYMBOL, TiDBParserOPEN_PAR_SYMBOL, TiDBParserOPEN_CURLY_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		{
			p.SetState(1228)
			p.TableReferenceList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableReferenceListContext is an interface to support dynamic dispatch.
type ITableReferenceListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableReference() []ITableReferenceContext
	TableReference(i int) ITableReferenceContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTableReferenceListContext differentiates from other interfaces.
	IsTableReferenceListContext()
}

type TableReferenceListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceListContext() *TableReferenceListContext {
	var p = new(TableReferenceListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableReferenceList
	return p
}

func InitEmptyTableReferenceListContext(p *TableReferenceListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableReferenceList
}

func (*TableReferenceListContext) IsTableReferenceListContext() {}

func NewTableReferenceListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceListContext {
	var p = new(TableReferenceListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableReferenceList

	return p
}

func (s *TableReferenceListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceListContext) AllTableReference() []ITableReferenceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableReferenceContext); ok {
			len++
		}
	}

	tst := make([]ITableReferenceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableReferenceContext); ok {
			tst[i] = t.(ITableReferenceContext)
			i++
		}
	}

	return tst
}

func (s *TableReferenceListContext) TableReference(i int) ITableReferenceContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceContext)
}

func (s *TableReferenceListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *TableReferenceListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *TableReferenceListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableReferenceList(s)
	}
}

func (s *TableReferenceListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableReferenceList(s)
	}
}

func (s *TableReferenceListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableReferenceList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableReferenceList() (localctx ITableReferenceListContext) {
	localctx = NewTableReferenceListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, TiDBParserRULE_tableReferenceList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1231)
		p.TableReference()
	}
	p.SetState(1236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1232)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1233)
			p.TableReference()
		}

		p.SetState(1238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableValueConstructorContext is an interface to support dynamic dispatch.
type ITableValueConstructorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VALUES_SYMBOL() antlr.TerminalNode
	AllRowValueExplicit() []IRowValueExplicitContext
	RowValueExplicit(i int) IRowValueExplicitContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTableValueConstructorContext differentiates from other interfaces.
	IsTableValueConstructorContext()
}

type TableValueConstructorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableValueConstructorContext() *TableValueConstructorContext {
	var p = new(TableValueConstructorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableValueConstructor
	return p
}

func InitEmptyTableValueConstructorContext(p *TableValueConstructorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableValueConstructor
}

func (*TableValueConstructorContext) IsTableValueConstructorContext() {}

func NewTableValueConstructorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableValueConstructorContext {
	var p = new(TableValueConstructorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableValueConstructor

	return p
}

func (s *TableValueConstructorContext) GetParser() antlr.Parser { return s.parser }

func (s *TableValueConstructorContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVALUES_SYMBOL, 0)
}

func (s *TableValueConstructorContext) AllRowValueExplicit() []IRowValueExplicitContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRowValueExplicitContext); ok {
			len++
		}
	}

	tst := make([]IRowValueExplicitContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRowValueExplicitContext); ok {
			tst[i] = t.(IRowValueExplicitContext)
			i++
		}
	}

	return tst
}

func (s *TableValueConstructorContext) RowValueExplicit(i int) IRowValueExplicitContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRowValueExplicitContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRowValueExplicitContext)
}

func (s *TableValueConstructorContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *TableValueConstructorContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *TableValueConstructorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableValueConstructorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableValueConstructorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableValueConstructor(s)
	}
}

func (s *TableValueConstructorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableValueConstructor(s)
	}
}

func (s *TableValueConstructorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableValueConstructor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableValueConstructor() (localctx ITableValueConstructorContext) {
	localctx = NewTableValueConstructorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, TiDBParserRULE_tableValueConstructor)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1239)
		p.Match(TiDBParserVALUES_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1240)
		p.RowValueExplicit()
	}
	p.SetState(1245)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1241)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1242)
			p.RowValueExplicit()
		}

		p.SetState(1247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExplicitTableContext is an interface to support dynamic dispatch.
type IExplicitTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext

	// IsExplicitTableContext differentiates from other interfaces.
	IsExplicitTableContext()
}

type ExplicitTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExplicitTableContext() *ExplicitTableContext {
	var p = new(ExplicitTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_explicitTable
	return p
}

func InitEmptyExplicitTableContext(p *ExplicitTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_explicitTable
}

func (*ExplicitTableContext) IsExplicitTableContext() {}

func NewExplicitTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExplicitTableContext {
	var p = new(ExplicitTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_explicitTable

	return p
}

func (s *ExplicitTableContext) GetParser() antlr.Parser { return s.parser }

func (s *ExplicitTableContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_SYMBOL, 0)
}

func (s *ExplicitTableContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *ExplicitTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExplicitTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExplicitTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExplicitTable(s)
	}
}

func (s *ExplicitTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExplicitTable(s)
	}
}

func (s *ExplicitTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExplicitTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ExplicitTable() (localctx IExplicitTableContext) {
	localctx = NewExplicitTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, TiDBParserRULE_explicitTable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1248)
		p.Match(TiDBParserTABLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1249)
		p.TableRef()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRowValueExplicitContext is an interface to support dynamic dispatch.
type IRowValueExplicitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ROW_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	Values() IValuesContext

	// IsRowValueExplicitContext differentiates from other interfaces.
	IsRowValueExplicitContext()
}

type RowValueExplicitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRowValueExplicitContext() *RowValueExplicitContext {
	var p = new(RowValueExplicitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_rowValueExplicit
	return p
}

func InitEmptyRowValueExplicitContext(p *RowValueExplicitContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_rowValueExplicit
}

func (*RowValueExplicitContext) IsRowValueExplicitContext() {}

func NewRowValueExplicitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RowValueExplicitContext {
	var p = new(RowValueExplicitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_rowValueExplicit

	return p
}

func (s *RowValueExplicitContext) GetParser() antlr.Parser { return s.parser }

func (s *RowValueExplicitContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_SYMBOL, 0)
}

func (s *RowValueExplicitContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *RowValueExplicitContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *RowValueExplicitContext) Values() IValuesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesContext)
}

func (s *RowValueExplicitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RowValueExplicitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RowValueExplicitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRowValueExplicit(s)
	}
}

func (s *RowValueExplicitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRowValueExplicit(s)
	}
}

func (s *RowValueExplicitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRowValueExplicit(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RowValueExplicit() (localctx IRowValueExplicitContext) {
	localctx = NewRowValueExplicitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, TiDBParserRULE_rowValueExplicit)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1251)
		p.Match(TiDBParserROW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1252)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1254)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5225064543571856404) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&873621610730880735) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-865958324971471593) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-8882137626648422863) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-576464036585580211) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&7745041819529110015) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&-1746007220614610867) != 0) || ((int64((_la-448)) & ^0x3f) == 0 && ((int64(1)<<(_la-448))&5832610115359342555) != 0) || ((int64((_la-512)) & ^0x3f) == 0 && ((int64(1)<<(_la-512))&-7206898910882232401) != 0) || ((int64((_la-576)) & ^0x3f) == 0 && ((int64(1)<<(_la-576))&-2769768038281836617) != 0) || ((int64((_la-640)) & ^0x3f) == 0 && ((int64(1)<<(_la-640))&-4037485862341231165) != 0) || ((int64((_la-704)) & ^0x3f) == 0 && ((int64(1)<<(_la-704))&1783491423132188607) != 0) || ((int64((_la-772)) & ^0x3f) == 0 && ((int64(1)<<(_la-772))&68712134993) != 0) {
		{
			p.SetState(1253)
			p.Values()
		}

	}
	{
		p.SetState(1256)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IValuesContext is an interface to support dynamic dispatch.
type IValuesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllDEFAULT_SYMBOL() []antlr.TerminalNode
	DEFAULT_SYMBOL(i int) antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsValuesContext differentiates from other interfaces.
	IsValuesContext()
}

type ValuesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesContext() *ValuesContext {
	var p = new(ValuesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_values
	return p
}

func InitEmptyValuesContext(p *ValuesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_values
}

func (*ValuesContext) IsValuesContext() {}

func NewValuesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesContext {
	var p = new(ValuesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_values

	return p
}

func (s *ValuesContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ValuesContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ValuesContext) AllDEFAULT_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserDEFAULT_SYMBOL)
}

func (s *ValuesContext) DEFAULT_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, i)
}

func (s *ValuesContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ValuesContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterValues(s)
	}
}

func (s *ValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitValues(s)
	}
}

func (s *ValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitValues(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Values() (localctx IValuesContext) {
	localctx = NewValuesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, TiDBParserRULE_values)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1260)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 74, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1258)
			p.expr(0)
		}

	case 2:
		{
			p.SetState(1259)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.SetState(1269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1262)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1265)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1263)
				p.expr(0)
			}

		case 2:
			{
				p.SetState(1264)
				p.Match(TiDBParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

		p.SetState(1271)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectOptionContext is an interface to support dynamic dispatch.
type ISelectOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuerySpecOption() IQuerySpecOptionContext
	SQL_NO_CACHE_SYMBOL() antlr.TerminalNode
	SQL_CACHE_SYMBOL() antlr.TerminalNode
	MAX_STATEMENT_TIME_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext

	// IsSelectOptionContext differentiates from other interfaces.
	IsSelectOptionContext()
}

type SelectOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectOptionContext() *SelectOptionContext {
	var p = new(SelectOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectOption
	return p
}

func InitEmptySelectOptionContext(p *SelectOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectOption
}

func (*SelectOptionContext) IsSelectOptionContext() {}

func NewSelectOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectOptionContext {
	var p = new(SelectOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_selectOption

	return p
}

func (s *SelectOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectOptionContext) QuerySpecOption() IQuerySpecOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySpecOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySpecOptionContext)
}

func (s *SelectOptionContext) SQL_NO_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_NO_CACHE_SYMBOL, 0)
}

func (s *SelectOptionContext) SQL_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_CACHE_SYMBOL, 0)
}

func (s *SelectOptionContext) MAX_STATEMENT_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_STATEMENT_TIME_SYMBOL, 0)
}

func (s *SelectOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *SelectOptionContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *SelectOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSelectOption(s)
	}
}

func (s *SelectOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSelectOption(s)
	}
}

func (s *SelectOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSelectOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SelectOption() (localctx ISelectOptionContext) {
	localctx = NewSelectOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, TiDBParserRULE_selectOption)
	p.SetState(1278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserALL_SYMBOL, TiDBParserDISTINCT_SYMBOL, TiDBParserHIGH_PRIORITY_SYMBOL, TiDBParserSQL_BIG_RESULT_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CALC_FOUND_ROWS_SYMBOL, TiDBParserSQL_SMALL_RESULT_SYMBOL, TiDBParserSTRAIGHT_JOIN_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1272)
			p.QuerySpecOption()
		}

	case TiDBParserSQL_NO_CACHE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1273)
			p.Match(TiDBParserSQL_NO_CACHE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserSQL_CACHE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1274)
			p.Match(TiDBParserSQL_CACHE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserMAX_STATEMENT_TIME_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1275)
			p.Match(TiDBParserMAX_STATEMENT_TIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1276)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1277)
			p.Real_ulong_number()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockingClauseListContext is an interface to support dynamic dispatch.
type ILockingClauseListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLockingClause() []ILockingClauseContext
	LockingClause(i int) ILockingClauseContext

	// IsLockingClauseListContext differentiates from other interfaces.
	IsLockingClauseListContext()
}

type LockingClauseListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockingClauseListContext() *LockingClauseListContext {
	var p = new(LockingClauseListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockingClauseList
	return p
}

func InitEmptyLockingClauseListContext(p *LockingClauseListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockingClauseList
}

func (*LockingClauseListContext) IsLockingClauseListContext() {}

func NewLockingClauseListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockingClauseListContext {
	var p = new(LockingClauseListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lockingClauseList

	return p
}

func (s *LockingClauseListContext) GetParser() antlr.Parser { return s.parser }

func (s *LockingClauseListContext) AllLockingClause() []ILockingClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockingClauseContext); ok {
			len++
		}
	}

	tst := make([]ILockingClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockingClauseContext); ok {
			tst[i] = t.(ILockingClauseContext)
			i++
		}
	}

	return tst
}

func (s *LockingClauseListContext) LockingClause(i int) ILockingClauseContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockingClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockingClauseContext)
}

func (s *LockingClauseListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockingClauseListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockingClauseListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLockingClauseList(s)
	}
}

func (s *LockingClauseListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLockingClauseList(s)
	}
}

func (s *LockingClauseListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLockingClauseList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LockingClauseList() (localctx ILockingClauseListContext) {
	localctx = NewLockingClauseListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, TiDBParserRULE_lockingClauseList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == TiDBParserFOR_SYMBOL || _la == TiDBParserLOCK_SYMBOL {
		{
			p.SetState(1280)
			p.LockingClause()
		}

		p.SetState(1283)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockingClauseContext is an interface to support dynamic dispatch.
type ILockingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	LockStrengh() ILockStrenghContext
	OF_SYMBOL() antlr.TerminalNode
	TableAliasRefList() ITableAliasRefListContext
	LockedRowAction() ILockedRowActionContext
	LOCK_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode
	SHARE_SYMBOL() antlr.TerminalNode
	MODE_SYMBOL() antlr.TerminalNode

	// IsLockingClauseContext differentiates from other interfaces.
	IsLockingClauseContext()
}

type LockingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockingClauseContext() *LockingClauseContext {
	var p = new(LockingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockingClause
	return p
}

func InitEmptyLockingClauseContext(p *LockingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockingClause
}

func (*LockingClauseContext) IsLockingClauseContext() {}

func NewLockingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockingClauseContext {
	var p = new(LockingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lockingClause

	return p
}

func (s *LockingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LockingClauseContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *LockingClauseContext) LockStrengh() ILockStrenghContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockStrenghContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockStrenghContext)
}

func (s *LockingClauseContext) OF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOF_SYMBOL, 0)
}

func (s *LockingClauseContext) TableAliasRefList() ITableAliasRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasRefListContext)
}

func (s *LockingClauseContext) LockedRowAction() ILockedRowActionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockedRowActionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockedRowActionContext)
}

func (s *LockingClauseContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCK_SYMBOL, 0)
}

func (s *LockingClauseContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIN_SYMBOL, 0)
}

func (s *LockingClauseContext) SHARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHARE_SYMBOL, 0)
}

func (s *LockingClauseContext) MODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMODE_SYMBOL, 0)
}

func (s *LockingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLockingClause(s)
	}
}

func (s *LockingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLockingClause(s)
	}
}

func (s *LockingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLockingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LockingClause() (localctx ILockingClauseContext) {
	localctx = NewLockingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, TiDBParserRULE_lockingClause)
	var _la int

	p.SetState(1298)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserFOR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1285)
			p.Match(TiDBParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1286)
			p.LockStrengh()
		}
		p.SetState(1289)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOF_SYMBOL {
			{
				p.SetState(1287)
				p.Match(TiDBParserOF_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1288)
				p.TableAliasRefList()
			}

		}
		p.SetState(1292)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSKIP_SYMBOL || _la == TiDBParserNOWAIT_SYMBOL {
			{
				p.SetState(1291)
				p.LockedRowAction()
			}

		}

	case TiDBParserLOCK_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1294)
			p.Match(TiDBParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1295)
			p.Match(TiDBParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1296)
			p.Match(TiDBParserSHARE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1297)
			p.Match(TiDBParserMODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockStrenghContext is an interface to support dynamic dispatch.
type ILockStrenghContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE_SYMBOL() antlr.TerminalNode
	SHARE_SYMBOL() antlr.TerminalNode

	// IsLockStrenghContext differentiates from other interfaces.
	IsLockStrenghContext()
}

type LockStrenghContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockStrenghContext() *LockStrenghContext {
	var p = new(LockStrenghContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockStrengh
	return p
}

func InitEmptyLockStrenghContext(p *LockStrenghContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockStrengh
}

func (*LockStrenghContext) IsLockStrenghContext() {}

func NewLockStrenghContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockStrenghContext {
	var p = new(LockStrenghContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lockStrengh

	return p
}

func (s *LockStrenghContext) GetParser() antlr.Parser { return s.parser }

func (s *LockStrenghContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUPDATE_SYMBOL, 0)
}

func (s *LockStrenghContext) SHARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHARE_SYMBOL, 0)
}

func (s *LockStrenghContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockStrenghContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockStrenghContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLockStrengh(s)
	}
}

func (s *LockStrenghContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLockStrengh(s)
	}
}

func (s *LockStrenghContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLockStrengh(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LockStrengh() (localctx ILockStrenghContext) {
	localctx = NewLockStrenghContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, TiDBParserRULE_lockStrengh)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1300)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserSHARE_SYMBOL || _la == TiDBParserUPDATE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockedRowActionContext is an interface to support dynamic dispatch.
type ILockedRowActionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SKIP_SYMBOL() antlr.TerminalNode
	LOCKED_SYMBOL() antlr.TerminalNode
	NOWAIT_SYMBOL() antlr.TerminalNode

	// IsLockedRowActionContext differentiates from other interfaces.
	IsLockedRowActionContext()
}

type LockedRowActionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockedRowActionContext() *LockedRowActionContext {
	var p = new(LockedRowActionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockedRowAction
	return p
}

func InitEmptyLockedRowActionContext(p *LockedRowActionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockedRowAction
}

func (*LockedRowActionContext) IsLockedRowActionContext() {}

func NewLockedRowActionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockedRowActionContext {
	var p = new(LockedRowActionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lockedRowAction

	return p
}

func (s *LockedRowActionContext) GetParser() antlr.Parser { return s.parser }

func (s *LockedRowActionContext) SKIP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSKIP_SYMBOL, 0)
}

func (s *LockedRowActionContext) LOCKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCKED_SYMBOL, 0)
}

func (s *LockedRowActionContext) NOWAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOWAIT_SYMBOL, 0)
}

func (s *LockedRowActionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockedRowActionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockedRowActionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLockedRowAction(s)
	}
}

func (s *LockedRowActionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLockedRowAction(s)
	}
}

func (s *LockedRowActionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLockedRowAction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LockedRowAction() (localctx ILockedRowActionContext) {
	localctx = NewLockedRowActionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, TiDBParserRULE_lockedRowAction)
	p.SetState(1305)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserSKIP_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1302)
			p.Match(TiDBParserSKIP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1303)
			p.Match(TiDBParserLOCKED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserNOWAIT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1304)
			p.Match(TiDBParserNOWAIT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemListContext is an interface to support dynamic dispatch.
type ISelectItemListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSelectItem() []ISelectItemContext
	SelectItem(i int) ISelectItemContext
	MULT_OPERATOR() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsSelectItemListContext differentiates from other interfaces.
	IsSelectItemListContext()
}

type SelectItemListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemListContext() *SelectItemListContext {
	var p = new(SelectItemListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectItemList
	return p
}

func InitEmptySelectItemListContext(p *SelectItemListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectItemList
}

func (*SelectItemListContext) IsSelectItemListContext() {}

func NewSelectItemListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemListContext {
	var p = new(SelectItemListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_selectItemList

	return p
}

func (s *SelectItemListContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemListContext) AllSelectItem() []ISelectItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISelectItemContext); ok {
			len++
		}
	}

	tst := make([]ISelectItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISelectItemContext); ok {
			tst[i] = t.(ISelectItemContext)
			i++
		}
	}

	return tst
}

func (s *SelectItemListContext) SelectItem(i int) ISelectItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectItemContext)
}

func (s *SelectItemListContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULT_OPERATOR, 0)
}

func (s *SelectItemListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *SelectItemListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *SelectItemListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectItemListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSelectItemList(s)
	}
}

func (s *SelectItemListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSelectItemList(s)
	}
}

func (s *SelectItemListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSelectItemList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SelectItemList() (localctx ISelectItemListContext) {
	localctx = NewSelectItemListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, TiDBParserRULE_selectItemList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1309)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINARY_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_AND_SYMBOL, TiDBParserBIT_OR_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBIT_XOR_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCASE_SYMBOL, TiDBParserCAST_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHAR_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCONVERT_SYMBOL, TiDBParserCOUNT_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURDATE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURRENT_USER_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserCURTIME_SYMBOL, TiDBParserDATABASE_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_ADD_SYMBOL, TiDBParserDATE_SUB_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXISTS_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserEXTRACT_SYMBOL, TiDBParserFALSE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserGROUP_CONCAT_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIF_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINTERVAL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLEFT_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMATCH_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMIN_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMOD_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNOT_SYMBOL, TiDBParserNOW_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNULL_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPOSITION_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPEAT_SYMBOL, TiDBParserREPLACE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserRIGHT_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTDDEV_SAMP_SYMBOL, TiDBParserSTD_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUBSTRING_SYMBOL, TiDBParserSUM_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserSYSDATE_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRIM_SYMBOL, TiDBParserTRUE_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserUTC_DATE_SYMBOL, TiDBParserUTC_TIMESTAMP_SYMBOL, TiDBParserUTC_TIME_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUES_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVARIANCE_SYMBOL, TiDBParserVAR_SAMP_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserJSON_OBJECTAGG_SYMBOL, TiDBParserJSON_ARRAYAGG_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserGROUPING_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserCUME_DIST_SYMBOL, TiDBParserDENSE_RANK_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFIRST_VALUE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserLAG_SYMBOL, TiDBParserLAST_VALUE_SYMBOL, TiDBParserLEAD_SYMBOL, TiDBParserNTH_VALUE_SYMBOL, TiDBParserNTILE_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPERCENT_RANK_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRANK_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserROW_NUMBER_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserNOT2_SYMBOL, TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserPLUS_OPERATOR, TiDBParserMINUS_OPERATOR, TiDBParserLOGICAL_NOT_OPERATOR, TiDBParserBITWISE_NOT_OPERATOR, TiDBParserDOT_SYMBOL, TiDBParserOPEN_PAR_SYMBOL, TiDBParserOPEN_CURLY_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserAT_SIGN_SYMBOL, TiDBParserAT_TEXT_SUFFIX, TiDBParserAT_AT_SIGN_SYMBOL, TiDBParserNULL2_SYMBOL, TiDBParserPARAM_MARKER, TiDBParserHEX_NUMBER, TiDBParserBIN_NUMBER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserUNDERSCORE_CHARSET, TiDBParserIDENTIFIER, TiDBParserNCHAR_TEXT, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		{
			p.SetState(1307)
			p.SelectItem()
		}

	case TiDBParserMULT_OPERATOR:
		{
			p.SetState(1308)
			p.Match(TiDBParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1311)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1312)
			p.SelectItem()
		}

		p.SetState(1317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectItemContext is an interface to support dynamic dispatch.
type ISelectItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableWild() ITableWildContext
	Expr() IExprContext
	SelectAlias() ISelectAliasContext

	// IsSelectItemContext differentiates from other interfaces.
	IsSelectItemContext()
}

type SelectItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectItemContext() *SelectItemContext {
	var p = new(SelectItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectItem
	return p
}

func InitEmptySelectItemContext(p *SelectItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectItem
}

func (*SelectItemContext) IsSelectItemContext() {}

func NewSelectItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectItemContext {
	var p = new(SelectItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_selectItem

	return p
}

func (s *SelectItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectItemContext) TableWild() ITableWildContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableWildContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableWildContext)
}

func (s *SelectItemContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SelectItemContext) SelectAlias() ISelectAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectAliasContext)
}

func (s *SelectItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSelectItem(s)
	}
}

func (s *SelectItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSelectItem(s)
	}
}

func (s *SelectItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSelectItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SelectItem() (localctx ISelectItemContext) {
	localctx = NewSelectItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, TiDBParserRULE_selectItem)
	p.SetState(1323)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 86, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1318)
			p.TableWild()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1319)
			p.expr(0)
		}
		p.SetState(1321)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 85, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1320)
				p.SelectAlias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISelectAliasContext is an interface to support dynamic dispatch.
type ISelectAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	TextStringLiteral() ITextStringLiteralContext
	AS_SYMBOL() antlr.TerminalNode

	// IsSelectAliasContext differentiates from other interfaces.
	IsSelectAliasContext()
}

type SelectAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySelectAliasContext() *SelectAliasContext {
	var p = new(SelectAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectAlias
	return p
}

func InitEmptySelectAliasContext(p *SelectAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_selectAlias
}

func (*SelectAliasContext) IsSelectAliasContext() {}

func NewSelectAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SelectAliasContext {
	var p = new(SelectAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_selectAlias

	return p
}

func (s *SelectAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *SelectAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SelectAliasContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *SelectAliasContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *SelectAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SelectAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SelectAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSelectAlias(s)
	}
}

func (s *SelectAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSelectAlias(s)
	}
}

func (s *SelectAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSelectAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SelectAlias() (localctx ISelectAliasContext) {
	localctx = NewSelectAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, TiDBParserRULE_selectAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1326)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserAS_SYMBOL {
		{
			p.SetState(1325)
			p.Match(TiDBParserAS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1330)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		{
			p.SetState(1328)
			p.Identifier()
		}

	case TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		{
			p.SetState(1329)
			p.TextStringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHERE_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) WHERE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWHERE_SYMBOL, 0)
}

func (s *WhereClauseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhereClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWhereClause(s)
	}
}

func (s *WhereClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWhereClause(s)
	}
}

func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, TiDBParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1332)
		p.Match(TiDBParserWHERE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1333)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableReferenceContext is an interface to support dynamic dispatch.
type ITableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableFactor() ITableFactorContext
	OPEN_CURLY_SYMBOL() antlr.TerminalNode
	EscapedTableReference() IEscapedTableReferenceContext
	CLOSE_CURLY_SYMBOL() antlr.TerminalNode
	AllJoinedTable() []IJoinedTableContext
	JoinedTable(i int) IJoinedTableContext
	Identifier() IIdentifierContext
	OJ_SYMBOL() antlr.TerminalNode

	// IsTableReferenceContext differentiates from other interfaces.
	IsTableReferenceContext()
}

type TableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceContext() *TableReferenceContext {
	var p = new(TableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableReference
	return p
}

func InitEmptyTableReferenceContext(p *TableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableReference
}

func (*TableReferenceContext) IsTableReferenceContext() {}

func NewTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceContext {
	var p = new(TableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableReference

	return p
}

func (s *TableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceContext) TableFactor() ITableFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *TableReferenceContext) OPEN_CURLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_CURLY_SYMBOL, 0)
}

func (s *TableReferenceContext) EscapedTableReference() IEscapedTableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEscapedTableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEscapedTableReferenceContext)
}

func (s *TableReferenceContext) CLOSE_CURLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_CURLY_SYMBOL, 0)
}

func (s *TableReferenceContext) AllJoinedTable() []IJoinedTableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinedTableContext); ok {
			len++
		}
	}

	tst := make([]IJoinedTableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinedTableContext); ok {
			tst[i] = t.(IJoinedTableContext)
			i++
		}
	}

	return tst
}

func (s *TableReferenceContext) JoinedTable(i int) IJoinedTableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinedTableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinedTableContext)
}

func (s *TableReferenceContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableReferenceContext) OJ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOJ_SYMBOL, 0)
}

func (s *TableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableReference(s)
	}
}

func (s *TableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableReference(s)
	}
}

func (s *TableReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableReference() (localctx ITableReferenceContext) {
	localctx = NewTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, TiDBParserRULE_tableReference)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1344)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserJSON_TABLE_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserLATERAL_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserDOT_SYMBOL, TiDBParserOPEN_PAR_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		{
			p.SetState(1335)
			p.TableFactor()
		}

	case TiDBParserOPEN_CURLY_SYMBOL:
		{
			p.SetState(1336)
			p.Match(TiDBParserOPEN_CURLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1339)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 89, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(1337)
				p.Identifier()
			}

		case 2:
			{
				p.SetState(1338)
				p.Match(TiDBParserOJ_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(1341)
			p.EscapedTableReference()
		}
		{
			p.SetState(1342)
			p.Match(TiDBParserCLOSE_CURLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(1349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1346)
				p.JoinedTable()
			}

		}
		p.SetState(1351)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEscapedTableReferenceContext is an interface to support dynamic dispatch.
type IEscapedTableReferenceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableFactor() ITableFactorContext
	AllJoinedTable() []IJoinedTableContext
	JoinedTable(i int) IJoinedTableContext

	// IsEscapedTableReferenceContext differentiates from other interfaces.
	IsEscapedTableReferenceContext()
}

type EscapedTableReferenceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEscapedTableReferenceContext() *EscapedTableReferenceContext {
	var p = new(EscapedTableReferenceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_escapedTableReference
	return p
}

func InitEmptyEscapedTableReferenceContext(p *EscapedTableReferenceContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_escapedTableReference
}

func (*EscapedTableReferenceContext) IsEscapedTableReferenceContext() {}

func NewEscapedTableReferenceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EscapedTableReferenceContext {
	var p = new(EscapedTableReferenceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_escapedTableReference

	return p
}

func (s *EscapedTableReferenceContext) GetParser() antlr.Parser { return s.parser }

func (s *EscapedTableReferenceContext) TableFactor() ITableFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *EscapedTableReferenceContext) AllJoinedTable() []IJoinedTableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJoinedTableContext); ok {
			len++
		}
	}

	tst := make([]IJoinedTableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJoinedTableContext); ok {
			tst[i] = t.(IJoinedTableContext)
			i++
		}
	}

	return tst
}

func (s *EscapedTableReferenceContext) JoinedTable(i int) IJoinedTableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJoinedTableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJoinedTableContext)
}

func (s *EscapedTableReferenceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EscapedTableReferenceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EscapedTableReferenceContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterEscapedTableReference(s)
	}
}

func (s *EscapedTableReferenceContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitEscapedTableReference(s)
	}
}

func (s *EscapedTableReferenceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitEscapedTableReference(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) EscapedTableReference() (localctx IEscapedTableReferenceContext) {
	localctx = NewEscapedTableReferenceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, TiDBParserRULE_escapedTableReference)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1352)
		p.TableFactor()
	}
	p.SetState(1356)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCROSS_SYMBOL || ((int64((_la-239)) & ^0x3f) == 0 && ((int64(1)<<(_la-239))&8594128897) != 0) || _la == TiDBParserNATURAL_SYMBOL || _la == TiDBParserRIGHT_SYMBOL || _la == TiDBParserSTRAIGHT_JOIN_SYMBOL {
		{
			p.SetState(1353)
			p.JoinedTable()
		}

		p.SetState(1358)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJoinedTableContext is an interface to support dynamic dispatch.
type IJoinedTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InnerJoinType() IInnerJoinTypeContext
	TableReference() ITableReferenceContext
	ON_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	USING_SYMBOL() antlr.TerminalNode
	IdentifierListWithParentheses() IIdentifierListWithParenthesesContext
	OuterJoinType() IOuterJoinTypeContext
	NaturalJoinType() INaturalJoinTypeContext
	TableFactor() ITableFactorContext

	// IsJoinedTableContext differentiates from other interfaces.
	IsJoinedTableContext()
}

type JoinedTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJoinedTableContext() *JoinedTableContext {
	var p = new(JoinedTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_joinedTable
	return p
}

func InitEmptyJoinedTableContext(p *JoinedTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_joinedTable
}

func (*JoinedTableContext) IsJoinedTableContext() {}

func NewJoinedTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JoinedTableContext {
	var p = new(JoinedTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_joinedTable

	return p
}

func (s *JoinedTableContext) GetParser() antlr.Parser { return s.parser }

func (s *JoinedTableContext) InnerJoinType() IInnerJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInnerJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInnerJoinTypeContext)
}

func (s *JoinedTableContext) TableReference() ITableReferenceContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceContext)
}

func (s *JoinedTableContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *JoinedTableContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *JoinedTableContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSING_SYMBOL, 0)
}

func (s *JoinedTableContext) IdentifierListWithParentheses() IIdentifierListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListWithParenthesesContext)
}

func (s *JoinedTableContext) OuterJoinType() IOuterJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOuterJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOuterJoinTypeContext)
}

func (s *JoinedTableContext) NaturalJoinType() INaturalJoinTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INaturalJoinTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INaturalJoinTypeContext)
}

func (s *JoinedTableContext) TableFactor() ITableFactorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFactorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFactorContext)
}

func (s *JoinedTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JoinedTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JoinedTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterJoinedTable(s)
	}
}

func (s *JoinedTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitJoinedTable(s)
	}
}

func (s *JoinedTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitJoinedTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) JoinedTable() (localctx IJoinedTableContext) {
	localctx = NewJoinedTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, TiDBParserRULE_joinedTable)
	p.SetState(1378)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCROSS_SYMBOL, TiDBParserINNER_SYMBOL, TiDBParserJOIN_SYMBOL, TiDBParserSTRAIGHT_JOIN_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1359)
			p.InnerJoinType()
		}
		{
			p.SetState(1360)
			p.TableReference()
		}
		p.SetState(1365)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1361)
				p.Match(TiDBParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1362)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 93, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(1363)
				p.Match(TiDBParserUSING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1364)
				p.IdentifierListWithParentheses()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserLEFT_SYMBOL, TiDBParserRIGHT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1367)
			p.OuterJoinType()
		}
		{
			p.SetState(1368)
			p.TableReference()
		}
		p.SetState(1373)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserON_SYMBOL:
			{
				p.SetState(1369)
				p.Match(TiDBParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1370)
				p.expr(0)
			}

		case TiDBParserUSING_SYMBOL:
			{
				p.SetState(1371)
				p.Match(TiDBParserUSING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1372)
				p.IdentifierListWithParentheses()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case TiDBParserNATURAL_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1375)
			p.NaturalJoinType()
		}
		{
			p.SetState(1376)
			p.TableFactor()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INaturalJoinTypeContext is an interface to support dynamic dispatch.
type INaturalJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NATURAL_SYMBOL() antlr.TerminalNode
	JOIN_SYMBOL() antlr.TerminalNode
	INNER_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode
	RIGHT_SYMBOL() antlr.TerminalNode
	OUTER_SYMBOL() antlr.TerminalNode

	// IsNaturalJoinTypeContext differentiates from other interfaces.
	IsNaturalJoinTypeContext()
}

type NaturalJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNaturalJoinTypeContext() *NaturalJoinTypeContext {
	var p = new(NaturalJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_naturalJoinType
	return p
}

func InitEmptyNaturalJoinTypeContext(p *NaturalJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_naturalJoinType
}

func (*NaturalJoinTypeContext) IsNaturalJoinTypeContext() {}

func NewNaturalJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NaturalJoinTypeContext {
	var p = new(NaturalJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_naturalJoinType

	return p
}

func (s *NaturalJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *NaturalJoinTypeContext) NATURAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNATURAL_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJOIN_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) INNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINNER_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEFT_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) RIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRIGHT_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) OUTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOUTER_SYMBOL, 0)
}

func (s *NaturalJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NaturalJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NaturalJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterNaturalJoinType(s)
	}
}

func (s *NaturalJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitNaturalJoinType(s)
	}
}

func (s *NaturalJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitNaturalJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) NaturalJoinType() (localctx INaturalJoinTypeContext) {
	localctx = NewNaturalJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, TiDBParserRULE_naturalJoinType)
	var _la int

	p.SetState(1391)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1380)
			p.Match(TiDBParserNATURAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1382)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserINNER_SYMBOL {
			{
				p.SetState(1381)
				p.Match(TiDBParserINNER_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1384)
			p.Match(TiDBParserJOIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1385)
			p.Match(TiDBParserNATURAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1386)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserLEFT_SYMBOL || _la == TiDBParserRIGHT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(1388)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOUTER_SYMBOL {
			{
				p.SetState(1387)
				p.Match(TiDBParserOUTER_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1390)
			p.Match(TiDBParserJOIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInnerJoinTypeContext is an interface to support dynamic dispatch.
type IInnerJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	JOIN_SYMBOL() antlr.TerminalNode
	INNER_SYMBOL() antlr.TerminalNode
	CROSS_SYMBOL() antlr.TerminalNode
	STRAIGHT_JOIN_SYMBOL() antlr.TerminalNode

	// IsInnerJoinTypeContext differentiates from other interfaces.
	IsInnerJoinTypeContext()
}

type InnerJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyInnerJoinTypeContext() *InnerJoinTypeContext {
	var p = new(InnerJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_innerJoinType
	return p
}

func InitEmptyInnerJoinTypeContext(p *InnerJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_innerJoinType
}

func (*InnerJoinTypeContext) IsInnerJoinTypeContext() {}

func NewInnerJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InnerJoinTypeContext {
	var p = new(InnerJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_innerJoinType

	return p
}

func (s *InnerJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *InnerJoinTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *InnerJoinTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *InnerJoinTypeContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJOIN_SYMBOL, 0)
}

func (s *InnerJoinTypeContext) INNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINNER_SYMBOL, 0)
}

func (s *InnerJoinTypeContext) CROSS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCROSS_SYMBOL, 0)
}

func (s *InnerJoinTypeContext) STRAIGHT_JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTRAIGHT_JOIN_SYMBOL, 0)
}

func (s *InnerJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InnerJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InnerJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterInnerJoinType(s)
	}
}

func (s *InnerJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitInnerJoinType(s)
	}
}

func (s *InnerJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitInnerJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) InnerJoinType() (localctx IInnerJoinTypeContext) {
	localctx = NewInnerJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, TiDBParserRULE_innerJoinType)
	var _la int

	p.SetState(1398)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCROSS_SYMBOL, TiDBParserINNER_SYMBOL, TiDBParserJOIN_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1394)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCROSS_SYMBOL || _la == TiDBParserINNER_SYMBOL {
			{
				p.SetState(1393)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*InnerJoinTypeContext).type_ = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == TiDBParserCROSS_SYMBOL || _la == TiDBParserINNER_SYMBOL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*InnerJoinTypeContext).type_ = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(1396)
			p.Match(TiDBParserJOIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserSTRAIGHT_JOIN_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1397)

			var _m = p.Match(TiDBParserSTRAIGHT_JOIN_SYMBOL)

			localctx.(*InnerJoinTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOuterJoinTypeContext is an interface to support dynamic dispatch.
type IOuterJoinTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	JOIN_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode
	RIGHT_SYMBOL() antlr.TerminalNode
	OUTER_SYMBOL() antlr.TerminalNode

	// IsOuterJoinTypeContext differentiates from other interfaces.
	IsOuterJoinTypeContext()
}

type OuterJoinTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyOuterJoinTypeContext() *OuterJoinTypeContext {
	var p = new(OuterJoinTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_outerJoinType
	return p
}

func InitEmptyOuterJoinTypeContext(p *OuterJoinTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_outerJoinType
}

func (*OuterJoinTypeContext) IsOuterJoinTypeContext() {}

func NewOuterJoinTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OuterJoinTypeContext {
	var p = new(OuterJoinTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_outerJoinType

	return p
}

func (s *OuterJoinTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OuterJoinTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *OuterJoinTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *OuterJoinTypeContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJOIN_SYMBOL, 0)
}

func (s *OuterJoinTypeContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEFT_SYMBOL, 0)
}

func (s *OuterJoinTypeContext) RIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRIGHT_SYMBOL, 0)
}

func (s *OuterJoinTypeContext) OUTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOUTER_SYMBOL, 0)
}

func (s *OuterJoinTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OuterJoinTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OuterJoinTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOuterJoinType(s)
	}
}

func (s *OuterJoinTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOuterJoinType(s)
	}
}

func (s *OuterJoinTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOuterJoinType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OuterJoinType() (localctx IOuterJoinTypeContext) {
	localctx = NewOuterJoinTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, TiDBParserRULE_outerJoinType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1400)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*OuterJoinTypeContext).type_ = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserLEFT_SYMBOL || _la == TiDBParserRIGHT_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*OuterJoinTypeContext).type_ = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(1402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserOUTER_SYMBOL {
		{
			p.SetState(1401)
			p.Match(TiDBParserOUTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1404)
		p.Match(TiDBParserJOIN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableFactorContext is an interface to support dynamic dispatch.
type ITableFactorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SingleTable() ISingleTableContext
	SingleTableParens() ISingleTableParensContext
	DerivedTable() IDerivedTableContext
	TableReferenceListParens() ITableReferenceListParensContext
	TableFunction() ITableFunctionContext

	// IsTableFactorContext differentiates from other interfaces.
	IsTableFactorContext()
}

type TableFactorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFactorContext() *TableFactorContext {
	var p = new(TableFactorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableFactor
	return p
}

func InitEmptyTableFactorContext(p *TableFactorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableFactor
}

func (*TableFactorContext) IsTableFactorContext() {}

func NewTableFactorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFactorContext {
	var p = new(TableFactorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableFactor

	return p
}

func (s *TableFactorContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFactorContext) SingleTable() ISingleTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTableContext)
}

func (s *TableFactorContext) SingleTableParens() ISingleTableParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTableParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTableParensContext)
}

func (s *TableFactorContext) DerivedTable() IDerivedTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDerivedTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDerivedTableContext)
}

func (s *TableFactorContext) TableReferenceListParens() ITableReferenceListParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListParensContext)
}

func (s *TableFactorContext) TableFunction() ITableFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableFunctionContext)
}

func (s *TableFactorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFactorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFactorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableFactor(s)
	}
}

func (s *TableFactorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableFactor(s)
	}
}

func (s *TableFactorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableFactor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableFactor() (localctx ITableFactorContext) {
	localctx = NewTableFactorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, TiDBParserRULE_tableFactor)
	p.SetState(1411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 102, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1406)
			p.SingleTable()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1407)
			p.SingleTableParens()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1408)
			p.DerivedTable()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1409)
			p.TableReferenceListParens()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1410)
			p.TableFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTableContext is an interface to support dynamic dispatch.
type ISingleTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	UsePartition() IUsePartitionContext
	TableAlias() ITableAliasContext
	IndexHintList() IIndexHintListContext

	// IsSingleTableContext differentiates from other interfaces.
	IsSingleTableContext()
}

type SingleTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTableContext() *SingleTableContext {
	var p = new(SingleTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_singleTable
	return p
}

func InitEmptySingleTableContext(p *SingleTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_singleTable
}

func (*SingleTableContext) IsSingleTableContext() {}

func NewSingleTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTableContext {
	var p = new(SingleTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_singleTable

	return p
}

func (s *SingleTableContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTableContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *SingleTableContext) UsePartition() IUsePartitionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsePartitionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsePartitionContext)
}

func (s *SingleTableContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *SingleTableContext) IndexHintList() IIndexHintListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintListContext)
}

func (s *SingleTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSingleTable(s)
	}
}

func (s *SingleTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSingleTable(s)
	}
}

func (s *SingleTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSingleTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SingleTable() (localctx ISingleTableContext) {
	localctx = NewSingleTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, TiDBParserRULE_singleTable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1413)
		p.TableRef()
	}
	p.SetState(1415)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1414)
			p.UsePartition()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1418)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 104, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1417)
			p.TableAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(1421)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserFORCE_SYMBOL || _la == TiDBParserIGNORE_SYMBOL || _la == TiDBParserUSE_SYMBOL {
		{
			p.SetState(1420)
			p.IndexHintList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISingleTableParensContext is an interface to support dynamic dispatch.
type ISingleTableParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	SingleTable() ISingleTableContext
	SingleTableParens() ISingleTableParensContext

	// IsSingleTableParensContext differentiates from other interfaces.
	IsSingleTableParensContext()
}

type SingleTableParensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySingleTableParensContext() *SingleTableParensContext {
	var p = new(SingleTableParensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_singleTableParens
	return p
}

func InitEmptySingleTableParensContext(p *SingleTableParensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_singleTableParens
}

func (*SingleTableParensContext) IsSingleTableParensContext() {}

func NewSingleTableParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SingleTableParensContext {
	var p = new(SingleTableParensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_singleTableParens

	return p
}

func (s *SingleTableParensContext) GetParser() antlr.Parser { return s.parser }

func (s *SingleTableParensContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SingleTableParensContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SingleTableParensContext) SingleTable() ISingleTableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTableContext)
}

func (s *SingleTableParensContext) SingleTableParens() ISingleTableParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISingleTableParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISingleTableParensContext)
}

func (s *SingleTableParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SingleTableParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SingleTableParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSingleTableParens(s)
	}
}

func (s *SingleTableParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSingleTableParens(s)
	}
}

func (s *SingleTableParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSingleTableParens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SingleTableParens() (localctx ISingleTableParensContext) {
	localctx = NewSingleTableParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, TiDBParserRULE_singleTableParens)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1423)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1426)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserDOT_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		{
			p.SetState(1424)
			p.SingleTable()
		}

	case TiDBParserOPEN_PAR_SYMBOL:
		{
			p.SetState(1425)
			p.SingleTableParens()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1428)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDerivedTableContext is an interface to support dynamic dispatch.
type IDerivedTableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Subquery() ISubqueryContext
	TableAlias() ITableAliasContext
	ColumnInternalRefList() IColumnInternalRefListContext
	LATERAL_SYMBOL() antlr.TerminalNode

	// IsDerivedTableContext differentiates from other interfaces.
	IsDerivedTableContext()
}

type DerivedTableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDerivedTableContext() *DerivedTableContext {
	var p = new(DerivedTableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_derivedTable
	return p
}

func InitEmptyDerivedTableContext(p *DerivedTableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_derivedTable
}

func (*DerivedTableContext) IsDerivedTableContext() {}

func NewDerivedTableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DerivedTableContext {
	var p = new(DerivedTableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_derivedTable

	return p
}

func (s *DerivedTableContext) GetParser() antlr.Parser { return s.parser }

func (s *DerivedTableContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *DerivedTableContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *DerivedTableContext) ColumnInternalRefList() IColumnInternalRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefListContext)
}

func (s *DerivedTableContext) LATERAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLATERAL_SYMBOL, 0)
}

func (s *DerivedTableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DerivedTableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DerivedTableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDerivedTable(s)
	}
}

func (s *DerivedTableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDerivedTable(s)
	}
}

func (s *DerivedTableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDerivedTable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DerivedTable() (localctx IDerivedTableContext) {
	localctx = NewDerivedTableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, TiDBParserRULE_derivedTable)
	var _la int

	p.SetState(1445)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserOPEN_PAR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1430)
			p.Subquery()
		}
		p.SetState(1432)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1431)
				p.TableAlias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1435)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(1434)
				p.ColumnInternalRefList()
			}

		}

	case TiDBParserLATERAL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1437)
			p.Match(TiDBParserLATERAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1438)
			p.Subquery()
		}
		p.SetState(1440)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(1439)
				p.TableAlias()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(1443)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(1442)
				p.ColumnInternalRefList()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableReferenceListParensContext is an interface to support dynamic dispatch.
type ITableReferenceListParensContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	TableReferenceList() ITableReferenceListContext
	TableReferenceListParens() ITableReferenceListParensContext

	// IsTableReferenceListParensContext differentiates from other interfaces.
	IsTableReferenceListParensContext()
}

type TableReferenceListParensContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableReferenceListParensContext() *TableReferenceListParensContext {
	var p = new(TableReferenceListParensContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableReferenceListParens
	return p
}

func InitEmptyTableReferenceListParensContext(p *TableReferenceListParensContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableReferenceListParens
}

func (*TableReferenceListParensContext) IsTableReferenceListParensContext() {}

func NewTableReferenceListParensContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableReferenceListParensContext {
	var p = new(TableReferenceListParensContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableReferenceListParens

	return p
}

func (s *TableReferenceListParensContext) GetParser() antlr.Parser { return s.parser }

func (s *TableReferenceListParensContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *TableReferenceListParensContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TableReferenceListParensContext) TableReferenceList() ITableReferenceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListContext)
}

func (s *TableReferenceListParensContext) TableReferenceListParens() ITableReferenceListParensContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListParensContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListParensContext)
}

func (s *TableReferenceListParensContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableReferenceListParensContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableReferenceListParensContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableReferenceListParens(s)
	}
}

func (s *TableReferenceListParensContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableReferenceListParens(s)
	}
}

func (s *TableReferenceListParensContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableReferenceListParens(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableReferenceListParens() (localctx ITableReferenceListParensContext) {
	localctx = NewTableReferenceListParensContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, TiDBParserRULE_tableReferenceListParens)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1447)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1450)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1448)
			p.TableReferenceList()
		}

	case 2:
		{
			p.SetState(1449)
			p.TableReferenceListParens()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	{
		p.SetState(1452)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableFunctionContext is an interface to support dynamic dispatch.
type ITableFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_TABLE_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	COMMA_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	ColumnsClause() IColumnsClauseContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	TableAlias() ITableAliasContext

	// IsTableFunctionContext differentiates from other interfaces.
	IsTableFunctionContext()
}

type TableFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableFunctionContext() *TableFunctionContext {
	var p = new(TableFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableFunction
	return p
}

func InitEmptyTableFunctionContext(p *TableFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableFunction
}

func (*TableFunctionContext) IsTableFunctionContext() {}

func NewTableFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableFunctionContext {
	var p = new(TableFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableFunction

	return p
}

func (s *TableFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TableFunctionContext) JSON_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_TABLE_SYMBOL, 0)
}

func (s *TableFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *TableFunctionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TableFunctionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *TableFunctionContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TableFunctionContext) ColumnsClause() IColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsClauseContext)
}

func (s *TableFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TableFunctionContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *TableFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableFunction(s)
	}
}

func (s *TableFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableFunction(s)
	}
}

func (s *TableFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableFunction() (localctx ITableFunctionContext) {
	localctx = NewTableFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, TiDBParserRULE_tableFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1454)
		p.Match(TiDBParserJSON_TABLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1455)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1456)
		p.expr(0)
	}
	{
		p.SetState(1457)
		p.Match(TiDBParserCOMMA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1458)
		p.TextStringLiteral()
	}
	{
		p.SetState(1459)
		p.ColumnsClause()
	}
	{
		p.SetState(1460)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1462)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 113, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1461)
			p.TableAlias()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnsClauseContext is an interface to support dynamic dispatch.
type IColumnsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllJtColumn() []IJtColumnContext
	JtColumn(i int) IJtColumnContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsColumnsClauseContext differentiates from other interfaces.
	IsColumnsClauseContext()
}

type ColumnsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnsClauseContext() *ColumnsClauseContext {
	var p = new(ColumnsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnsClause
	return p
}

func InitEmptyColumnsClauseContext(p *ColumnsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnsClause
}

func (*ColumnsClauseContext) IsColumnsClauseContext() {}

func NewColumnsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnsClauseContext {
	var p = new(ColumnsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_columnsClause

	return p
}

func (s *ColumnsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnsClauseContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMNS_SYMBOL, 0)
}

func (s *ColumnsClauseContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *ColumnsClauseContext) AllJtColumn() []IJtColumnContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IJtColumnContext); ok {
			len++
		}
	}

	tst := make([]IJtColumnContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IJtColumnContext); ok {
			tst[i] = t.(IJtColumnContext)
			i++
		}
	}

	return tst
}

func (s *ColumnsClauseContext) JtColumn(i int) IJtColumnContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJtColumnContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJtColumnContext)
}

func (s *ColumnsClauseContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ColumnsClauseContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ColumnsClauseContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ColumnsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterColumnsClause(s)
	}
}

func (s *ColumnsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitColumnsClause(s)
	}
}

func (s *ColumnsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitColumnsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ColumnsClause() (localctx IColumnsClauseContext) {
	localctx = NewColumnsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, TiDBParserRULE_columnsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1464)
		p.Match(TiDBParserCOLUMNS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1465)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1466)
		p.JtColumn()
	}
	p.SetState(1471)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1467)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1468)
			p.JtColumn()
		}

		p.SetState(1473)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1474)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJtColumnContext is an interface to support dynamic dispatch.
type IJtColumnContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FOR_SYMBOL() antlr.TerminalNode
	ORDINALITY_SYMBOL() antlr.TerminalNode
	DataType() IDataTypeContext
	PATH_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	Collate() ICollateContext
	EXISTS_SYMBOL() antlr.TerminalNode
	OnEmptyOrError() IOnEmptyOrErrorContext
	NESTED_SYMBOL() antlr.TerminalNode
	ColumnsClause() IColumnsClauseContext

	// IsJtColumnContext differentiates from other interfaces.
	IsJtColumnContext()
}

type JtColumnContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJtColumnContext() *JtColumnContext {
	var p = new(JtColumnContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jtColumn
	return p
}

func InitEmptyJtColumnContext(p *JtColumnContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jtColumn
}

func (*JtColumnContext) IsJtColumnContext() {}

func NewJtColumnContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JtColumnContext {
	var p = new(JtColumnContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_jtColumn

	return p
}

func (s *JtColumnContext) GetParser() antlr.Parser { return s.parser }

func (s *JtColumnContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *JtColumnContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *JtColumnContext) ORDINALITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserORDINALITY_SYMBOL, 0)
}

func (s *JtColumnContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *JtColumnContext) PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPATH_SYMBOL, 0)
}

func (s *JtColumnContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *JtColumnContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *JtColumnContext) EXISTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXISTS_SYMBOL, 0)
}

func (s *JtColumnContext) OnEmptyOrError() IOnEmptyOrErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnEmptyOrErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnEmptyOrErrorContext)
}

func (s *JtColumnContext) NESTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNESTED_SYMBOL, 0)
}

func (s *JtColumnContext) ColumnsClause() IColumnsClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnsClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnsClauseContext)
}

func (s *JtColumnContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JtColumnContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JtColumnContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterJtColumn(s)
	}
}

func (s *JtColumnContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitJtColumn(s)
	}
}

func (s *JtColumnContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitJtColumn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) JtColumn() (localctx IJtColumnContext) {
	localctx = NewJtColumnContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, TiDBParserRULE_jtColumn)
	var _la int

	p.SetState(1498)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 118, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1476)
			p.Identifier()
		}
		{
			p.SetState(1477)
			p.Match(TiDBParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1478)
			p.Match(TiDBParserORDINALITY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1480)
			p.Identifier()
		}
		{
			p.SetState(1481)
			p.DataType()
		}
		p.SetState(1483)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOLLATE_SYMBOL {
			{
				p.SetState(1482)
				p.Collate()
			}

		}
		p.SetState(1486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEXISTS_SYMBOL {
			{
				p.SetState(1485)
				p.Match(TiDBParserEXISTS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1488)
			p.Match(TiDBParserPATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1489)
			p.TextStringLiteral()
		}
		p.SetState(1491)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserERROR_SYMBOL || _la == TiDBParserNULL_SYMBOL {
			{
				p.SetState(1490)
				p.OnEmptyOrError()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1493)
			p.Match(TiDBParserNESTED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1494)
			p.Match(TiDBParserPATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1495)
			p.TextStringLiteral()
		}
		{
			p.SetState(1496)
			p.ColumnsClause()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnEmptyOrErrorContext is an interface to support dynamic dispatch.
type IOnEmptyOrErrorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OnEmpty() IOnEmptyContext
	OnError() IOnErrorContext

	// IsOnEmptyOrErrorContext differentiates from other interfaces.
	IsOnEmptyOrErrorContext()
}

type OnEmptyOrErrorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnEmptyOrErrorContext() *OnEmptyOrErrorContext {
	var p = new(OnEmptyOrErrorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onEmptyOrError
	return p
}

func InitEmptyOnEmptyOrErrorContext(p *OnEmptyOrErrorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onEmptyOrError
}

func (*OnEmptyOrErrorContext) IsOnEmptyOrErrorContext() {}

func NewOnEmptyOrErrorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnEmptyOrErrorContext {
	var p = new(OnEmptyOrErrorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_onEmptyOrError

	return p
}

func (s *OnEmptyOrErrorContext) GetParser() antlr.Parser { return s.parser }

func (s *OnEmptyOrErrorContext) OnEmpty() IOnEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnEmptyContext)
}

func (s *OnEmptyOrErrorContext) OnError() IOnErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnErrorContext)
}

func (s *OnEmptyOrErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnEmptyOrErrorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnEmptyOrErrorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOnEmptyOrError(s)
	}
}

func (s *OnEmptyOrErrorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOnEmptyOrError(s)
	}
}

func (s *OnEmptyOrErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOnEmptyOrError(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OnEmptyOrError() (localctx IOnEmptyOrErrorContext) {
	localctx = NewOnEmptyOrErrorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, TiDBParserRULE_onEmptyOrError)
	var _la int

	p.SetState(1508)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 121, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1500)
			p.OnEmpty()
		}
		p.SetState(1502)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserERROR_SYMBOL || _la == TiDBParserNULL_SYMBOL {
			{
				p.SetState(1501)
				p.OnError()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1504)
			p.OnError()
		}
		p.SetState(1506)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserERROR_SYMBOL || _la == TiDBParserNULL_SYMBOL {
			{
				p.SetState(1505)
				p.OnEmpty()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnEmptyContext is an interface to support dynamic dispatch.
type IOnEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JtOnResponse() IJtOnResponseContext
	ON_SYMBOL() antlr.TerminalNode
	EMPTY_SYMBOL() antlr.TerminalNode

	// IsOnEmptyContext differentiates from other interfaces.
	IsOnEmptyContext()
}

type OnEmptyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnEmptyContext() *OnEmptyContext {
	var p = new(OnEmptyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onEmpty
	return p
}

func InitEmptyOnEmptyContext(p *OnEmptyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onEmpty
}

func (*OnEmptyContext) IsOnEmptyContext() {}

func NewOnEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnEmptyContext {
	var p = new(OnEmptyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_onEmpty

	return p
}

func (s *OnEmptyContext) GetParser() antlr.Parser { return s.parser }

func (s *OnEmptyContext) JtOnResponse() IJtOnResponseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJtOnResponseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJtOnResponseContext)
}

func (s *OnEmptyContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *OnEmptyContext) EMPTY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEMPTY_SYMBOL, 0)
}

func (s *OnEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnEmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOnEmpty(s)
	}
}

func (s *OnEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOnEmpty(s)
	}
}

func (s *OnEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOnEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OnEmpty() (localctx IOnEmptyContext) {
	localctx = NewOnEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, TiDBParserRULE_onEmpty)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1510)
		p.JtOnResponse()
	}
	{
		p.SetState(1511)
		p.Match(TiDBParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1512)
		p.Match(TiDBParserEMPTY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnErrorContext is an interface to support dynamic dispatch.
type IOnErrorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JtOnResponse() IJtOnResponseContext
	ON_SYMBOL() antlr.TerminalNode
	ERROR_SYMBOL() antlr.TerminalNode

	// IsOnErrorContext differentiates from other interfaces.
	IsOnErrorContext()
}

type OnErrorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnErrorContext() *OnErrorContext {
	var p = new(OnErrorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onError
	return p
}

func InitEmptyOnErrorContext(p *OnErrorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onError
}

func (*OnErrorContext) IsOnErrorContext() {}

func NewOnErrorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnErrorContext {
	var p = new(OnErrorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_onError

	return p
}

func (s *OnErrorContext) GetParser() antlr.Parser { return s.parser }

func (s *OnErrorContext) JtOnResponse() IJtOnResponseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJtOnResponseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJtOnResponseContext)
}

func (s *OnErrorContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *OnErrorContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserERROR_SYMBOL, 0)
}

func (s *OnErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnErrorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnErrorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOnError(s)
	}
}

func (s *OnErrorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOnError(s)
	}
}

func (s *OnErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOnError(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OnError() (localctx IOnErrorContext) {
	localctx = NewOnErrorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, TiDBParserRULE_onError)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1514)
		p.JtOnResponse()
	}
	{
		p.SetState(1515)
		p.Match(TiDBParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1516)
		p.Match(TiDBParserERROR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJtOnResponseContext is an interface to support dynamic dispatch.
type IJtOnResponseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ERROR_SYMBOL() antlr.TerminalNode
	NULL_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext

	// IsJtOnResponseContext differentiates from other interfaces.
	IsJtOnResponseContext()
}

type JtOnResponseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJtOnResponseContext() *JtOnResponseContext {
	var p = new(JtOnResponseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jtOnResponse
	return p
}

func InitEmptyJtOnResponseContext(p *JtOnResponseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jtOnResponse
}

func (*JtOnResponseContext) IsJtOnResponseContext() {}

func NewJtOnResponseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JtOnResponseContext {
	var p = new(JtOnResponseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_jtOnResponse

	return p
}

func (s *JtOnResponseContext) GetParser() antlr.Parser { return s.parser }

func (s *JtOnResponseContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserERROR_SYMBOL, 0)
}

func (s *JtOnResponseContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL_SYMBOL, 0)
}

func (s *JtOnResponseContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *JtOnResponseContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *JtOnResponseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JtOnResponseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JtOnResponseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterJtOnResponse(s)
	}
}

func (s *JtOnResponseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitJtOnResponse(s)
	}
}

func (s *JtOnResponseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitJtOnResponse(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) JtOnResponse() (localctx IJtOnResponseContext) {
	localctx = NewJtOnResponseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, TiDBParserRULE_jtOnResponse)
	p.SetState(1522)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserERROR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1518)
			p.Match(TiDBParserERROR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserNULL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1519)
			p.Match(TiDBParserNULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserDEFAULT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1520)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1521)
			p.TextStringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetOprSymbolContext is an interface to support dynamic dispatch.
type ISetOprSymbolContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNION_SYMBOL() antlr.TerminalNode
	INTERSECT_SYMBOL() antlr.TerminalNode
	EXCEPT_SYMBOL() antlr.TerminalNode

	// IsSetOprSymbolContext differentiates from other interfaces.
	IsSetOprSymbolContext()
}

type SetOprSymbolContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetOprSymbolContext() *SetOprSymbolContext {
	var p = new(SetOprSymbolContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setOprSymbol
	return p
}

func InitEmptySetOprSymbolContext(p *SetOprSymbolContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setOprSymbol
}

func (*SetOprSymbolContext) IsSetOprSymbolContext() {}

func NewSetOprSymbolContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetOprSymbolContext {
	var p = new(SetOprSymbolContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_setOprSymbol

	return p
}

func (s *SetOprSymbolContext) GetParser() antlr.Parser { return s.parser }

func (s *SetOprSymbolContext) UNION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNION_SYMBOL, 0)
}

func (s *SetOprSymbolContext) INTERSECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTERSECT_SYMBOL, 0)
}

func (s *SetOprSymbolContext) EXCEPT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXCEPT_SYMBOL, 0)
}

func (s *SetOprSymbolContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOprSymbolContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetOprSymbolContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSetOprSymbol(s)
	}
}

func (s *SetOprSymbolContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSetOprSymbol(s)
	}
}

func (s *SetOprSymbolContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSetOprSymbol(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SetOprSymbol() (localctx ISetOprSymbolContext) {
	localctx = NewSetOprSymbolContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, TiDBParserRULE_setOprSymbol)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1524)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserUNION_SYMBOL || _la == TiDBParserEXCEPT_SYMBOL || _la == TiDBParserINTERSECT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetOprOptionContext is an interface to support dynamic dispatch.
type ISetOprOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISTINCT_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode

	// IsSetOprOptionContext differentiates from other interfaces.
	IsSetOprOptionContext()
}

type SetOprOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetOprOptionContext() *SetOprOptionContext {
	var p = new(SetOprOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setOprOption
	return p
}

func InitEmptySetOprOptionContext(p *SetOprOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setOprOption
}

func (*SetOprOptionContext) IsSetOprOptionContext() {}

func NewSetOprOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetOprOptionContext {
	var p = new(SetOprOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_setOprOption

	return p
}

func (s *SetOprOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SetOprOptionContext) DISTINCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISTINCT_SYMBOL, 0)
}

func (s *SetOprOptionContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *SetOprOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetOprOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetOprOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSetOprOption(s)
	}
}

func (s *SetOprOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSetOprOption(s)
	}
}

func (s *SetOprOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSetOprOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SetOprOption() (localctx ISetOprOptionContext) {
	localctx = NewSetOprOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, TiDBParserRULE_setOprOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1526)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserALL_SYMBOL || _la == TiDBParserDISTINCT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasContext is an interface to support dynamic dispatch.
type ITableAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AS_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsTableAliasContext differentiates from other interfaces.
	IsTableAliasContext()
}

type TableAliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasContext() *TableAliasContext {
	var p = new(TableAliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableAlias
	return p
}

func InitEmptyTableAliasContext(p *TableAliasContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableAlias
}

func (*TableAliasContext) IsTableAliasContext() {}

func NewTableAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasContext {
	var p = new(TableAliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableAlias

	return p
}

func (s *TableAliasContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableAliasContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *TableAliasContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *TableAliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableAlias(s)
	}
}

func (s *TableAliasContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableAlias(s)
	}
}

func (s *TableAliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableAlias(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableAlias() (localctx ITableAliasContext) {
	localctx = NewTableAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, TiDBParserRULE_tableAlias)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1529)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserAS_SYMBOL || _la == TiDBParserEQUAL_OPERATOR {
		{
			p.SetState(1528)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserAS_SYMBOL || _la == TiDBParserEQUAL_OPERATOR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(1531)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintListContext is an interface to support dynamic dispatch.
type IIndexHintListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndexHint() []IIndexHintContext
	IndexHint(i int) IIndexHintContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIndexHintListContext differentiates from other interfaces.
	IsIndexHintListContext()
}

type IndexHintListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintListContext() *IndexHintListContext {
	var p = new(IndexHintListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexHintList
	return p
}

func InitEmptyIndexHintListContext(p *IndexHintListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexHintList
}

func (*IndexHintListContext) IsIndexHintListContext() {}

func NewIndexHintListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintListContext {
	var p = new(IndexHintListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexHintList

	return p
}

func (s *IndexHintListContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintListContext) AllIndexHint() []IIndexHintContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexHintContext); ok {
			len++
		}
	}

	tst := make([]IIndexHintContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexHintContext); ok {
			tst[i] = t.(IIndexHintContext)
			i++
		}
	}

	return tst
}

func (s *IndexHintListContext) IndexHint(i int) IIndexHintContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintContext)
}

func (s *IndexHintListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *IndexHintListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *IndexHintListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexHintList(s)
	}
}

func (s *IndexHintListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexHintList(s)
	}
}

func (s *IndexHintListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexHintList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexHintList() (localctx IIndexHintListContext) {
	localctx = NewIndexHintListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, TiDBParserRULE_indexHintList)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1533)
		p.IndexHint()
	}
	p.SetState(1538)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(1534)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1535)
				p.IndexHint()
			}

		}
		p.SetState(1540)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintContext is an interface to support dynamic dispatch.
type IIndexHintContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IndexHintType() IIndexHintTypeContext
	KeyOrIndex() IKeyOrIndexContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	IndexList() IIndexListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	IndexHintClause() IIndexHintClauseContext
	USE_SYMBOL() antlr.TerminalNode

	// IsIndexHintContext differentiates from other interfaces.
	IsIndexHintContext()
}

type IndexHintContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintContext() *IndexHintContext {
	var p = new(IndexHintContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexHint
	return p
}

func InitEmptyIndexHintContext(p *IndexHintContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexHint
}

func (*IndexHintContext) IsIndexHintContext() {}

func NewIndexHintContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintContext {
	var p = new(IndexHintContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexHint

	return p
}

func (s *IndexHintContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintContext) IndexHintType() IIndexHintTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintTypeContext)
}

func (s *IndexHintContext) KeyOrIndex() IKeyOrIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyOrIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyOrIndexContext)
}

func (s *IndexHintContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *IndexHintContext) IndexList() IIndexListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexListContext)
}

func (s *IndexHintContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *IndexHintContext) IndexHintClause() IIndexHintClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexHintClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexHintClauseContext)
}

func (s *IndexHintContext) USE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSE_SYMBOL, 0)
}

func (s *IndexHintContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexHint(s)
	}
}

func (s *IndexHintContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexHint(s)
	}
}

func (s *IndexHintContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexHint(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexHint() (localctx IIndexHintContext) {
	localctx = NewIndexHintContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, TiDBParserRULE_indexHint)
	var _la int

	p.SetState(1561)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserFORCE_SYMBOL, TiDBParserIGNORE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1541)
			p.IndexHintType()
		}
		{
			p.SetState(1542)
			p.KeyOrIndex()
		}
		p.SetState(1544)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(1543)
				p.IndexHintClause()
			}

		}
		{
			p.SetState(1546)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1547)
			p.IndexList()
		}
		{
			p.SetState(1548)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserUSE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1550)
			p.Match(TiDBParserUSE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1551)
			p.KeyOrIndex()
		}
		p.SetState(1553)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(1552)
				p.IndexHintClause()
			}

		}
		{
			p.SetState(1555)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1557)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871848468) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221376000001) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
			{
				p.SetState(1556)
				p.IndexList()
			}

		}
		{
			p.SetState(1559)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintTypeContext is an interface to support dynamic dispatch.
type IIndexHintTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FORCE_SYMBOL() antlr.TerminalNode
	IGNORE_SYMBOL() antlr.TerminalNode

	// IsIndexHintTypeContext differentiates from other interfaces.
	IsIndexHintTypeContext()
}

type IndexHintTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintTypeContext() *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexHintType
	return p
}

func InitEmptyIndexHintTypeContext(p *IndexHintTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexHintType
}

func (*IndexHintTypeContext) IsIndexHintTypeContext() {}

func NewIndexHintTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintTypeContext {
	var p = new(IndexHintTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexHintType

	return p
}

func (s *IndexHintTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintTypeContext) FORCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFORCE_SYMBOL, 0)
}

func (s *IndexHintTypeContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIGNORE_SYMBOL, 0)
}

func (s *IndexHintTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexHintType(s)
	}
}

func (s *IndexHintTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexHintType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexHintType() (localctx IIndexHintTypeContext) {
	localctx = NewIndexHintTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, TiDBParserRULE_indexHintType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1563)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserFORCE_SYMBOL || _la == TiDBParserIGNORE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyOrIndexContext is an interface to support dynamic dispatch.
type IKeyOrIndexContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode

	// IsKeyOrIndexContext differentiates from other interfaces.
	IsKeyOrIndexContext()
}

type KeyOrIndexContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyOrIndexContext() *KeyOrIndexContext {
	var p = new(KeyOrIndexContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyOrIndex
	return p
}

func InitEmptyKeyOrIndexContext(p *KeyOrIndexContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyOrIndex
}

func (*KeyOrIndexContext) IsKeyOrIndexContext() {}

func NewKeyOrIndexContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyOrIndexContext {
	var p = new(KeyOrIndexContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_keyOrIndex

	return p
}

func (s *KeyOrIndexContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyOrIndexContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_SYMBOL, 0)
}

func (s *KeyOrIndexContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINDEX_SYMBOL, 0)
}

func (s *KeyOrIndexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyOrIndexContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyOrIndexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterKeyOrIndex(s)
	}
}

func (s *KeyOrIndexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitKeyOrIndex(s)
	}
}

func (s *KeyOrIndexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitKeyOrIndex(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) KeyOrIndex() (localctx IKeyOrIndexContext) {
	localctx = NewKeyOrIndexContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, TiDBParserRULE_keyOrIndex)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1565)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserINDEX_SYMBOL || _la == TiDBParserKEY_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConstraintKeyTypeContext is an interface to support dynamic dispatch.
type IConstraintKeyTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PRIMARY_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	UNIQUE_SYMBOL() antlr.TerminalNode
	KeyOrIndex() IKeyOrIndexContext

	// IsConstraintKeyTypeContext differentiates from other interfaces.
	IsConstraintKeyTypeContext()
}

type ConstraintKeyTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConstraintKeyTypeContext() *ConstraintKeyTypeContext {
	var p = new(ConstraintKeyTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_constraintKeyType
	return p
}

func InitEmptyConstraintKeyTypeContext(p *ConstraintKeyTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_constraintKeyType
}

func (*ConstraintKeyTypeContext) IsConstraintKeyTypeContext() {}

func NewConstraintKeyTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConstraintKeyTypeContext {
	var p = new(ConstraintKeyTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_constraintKeyType

	return p
}

func (s *ConstraintKeyTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ConstraintKeyTypeContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIMARY_SYMBOL, 0)
}

func (s *ConstraintKeyTypeContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_SYMBOL, 0)
}

func (s *ConstraintKeyTypeContext) UNIQUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNIQUE_SYMBOL, 0)
}

func (s *ConstraintKeyTypeContext) KeyOrIndex() IKeyOrIndexContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyOrIndexContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyOrIndexContext)
}

func (s *ConstraintKeyTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConstraintKeyTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConstraintKeyTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterConstraintKeyType(s)
	}
}

func (s *ConstraintKeyTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitConstraintKeyType(s)
	}
}

func (s *ConstraintKeyTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitConstraintKeyType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ConstraintKeyType() (localctx IConstraintKeyTypeContext) {
	localctx = NewConstraintKeyTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, TiDBParserRULE_constraintKeyType)
	var _la int

	p.SetState(1573)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserPRIMARY_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1567)
			p.Match(TiDBParserPRIMARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1568)
			p.Match(TiDBParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserUNIQUE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1569)
			p.Match(TiDBParserUNIQUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserINDEX_SYMBOL || _la == TiDBParserKEY_SYMBOL {
			{
				p.SetState(1570)
				p.KeyOrIndex()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexHintClauseContext is an interface to support dynamic dispatch.
type IIndexHintClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	JOIN_SYMBOL() antlr.TerminalNode
	ORDER_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode

	// IsIndexHintClauseContext differentiates from other interfaces.
	IsIndexHintClauseContext()
}

type IndexHintClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexHintClauseContext() *IndexHintClauseContext {
	var p = new(IndexHintClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexHintClause
	return p
}

func InitEmptyIndexHintClauseContext(p *IndexHintClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexHintClause
}

func (*IndexHintClauseContext) IsIndexHintClauseContext() {}

func NewIndexHintClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexHintClauseContext {
	var p = new(IndexHintClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexHintClause

	return p
}

func (s *IndexHintClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexHintClauseContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *IndexHintClauseContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJOIN_SYMBOL, 0)
}

func (s *IndexHintClauseContext) ORDER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserORDER_SYMBOL, 0)
}

func (s *IndexHintClauseContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *IndexHintClauseContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_SYMBOL, 0)
}

func (s *IndexHintClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexHintClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexHintClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexHintClause(s)
	}
}

func (s *IndexHintClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexHintClause(s)
	}
}

func (s *IndexHintClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexHintClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexHintClause() (localctx IIndexHintClauseContext) {
	localctx = NewIndexHintClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, TiDBParserRULE_indexHintClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1575)
		p.Match(TiDBParserFOR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1581)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserJOIN_SYMBOL:
		{
			p.SetState(1576)
			p.Match(TiDBParserJOIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserORDER_SYMBOL:
		{
			p.SetState(1577)
			p.Match(TiDBParserORDER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1578)
			p.Match(TiDBParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserGROUP_SYMBOL:
		{
			p.SetState(1579)
			p.Match(TiDBParserGROUP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1580)
			p.Match(TiDBParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexListContext is an interface to support dynamic dispatch.
type IIndexListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIndexListElement() []IIndexListElementContext
	IndexListElement(i int) IIndexListElementContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIndexListContext differentiates from other interfaces.
	IsIndexListContext()
}

type IndexListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexListContext() *IndexListContext {
	var p = new(IndexListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexList
	return p
}

func InitEmptyIndexListContext(p *IndexListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexList
}

func (*IndexListContext) IsIndexListContext() {}

func NewIndexListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexListContext {
	var p = new(IndexListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexList

	return p
}

func (s *IndexListContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexListContext) AllIndexListElement() []IIndexListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIndexListElementContext); ok {
			len++
		}
	}

	tst := make([]IIndexListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIndexListElementContext); ok {
			tst[i] = t.(IIndexListElementContext)
			i++
		}
	}

	return tst
}

func (s *IndexListContext) IndexListElement(i int) IIndexListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexListElementContext)
}

func (s *IndexListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *IndexListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *IndexListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexList(s)
	}
}

func (s *IndexListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexList(s)
	}
}

func (s *IndexListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexList() (localctx IIndexListContext) {
	localctx = NewIndexListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, TiDBParserRULE_indexList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1583)
		p.IndexListElement()
	}
	p.SetState(1588)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1584)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1585)
			p.IndexListElement()
		}

		p.SetState(1590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexListElementContext is an interface to support dynamic dispatch.
type IIndexListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	PRIMARY_SYMBOL() antlr.TerminalNode

	// IsIndexListElementContext differentiates from other interfaces.
	IsIndexListElementContext()
}

type IndexListElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexListElementContext() *IndexListElementContext {
	var p = new(IndexListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexListElement
	return p
}

func InitEmptyIndexListElementContext(p *IndexListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexListElement
}

func (*IndexListElementContext) IsIndexListElementContext() {}

func NewIndexListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexListElementContext {
	var p = new(IndexListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexListElement

	return p
}

func (s *IndexListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexListElementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexListElementContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIMARY_SYMBOL, 0)
}

func (s *IndexListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexListElement(s)
	}
}

func (s *IndexListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexListElement(s)
	}
}

func (s *IndexListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexListElement() (localctx IIndexListElementContext) {
	localctx = NewIndexListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, TiDBParserRULE_indexListElement)
	p.SetState(1593)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1591)
			p.Identifier()
		}

	case TiDBParserPRIMARY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1592)
			p.Match(TiDBParserPRIMARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateStatementContext is an interface to support dynamic dispatch.
type IUpdateStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE_SYMBOL() antlr.TerminalNode
	TableReferenceList() ITableReferenceListContext
	SET_SYMBOL() antlr.TerminalNode
	UpdateList() IUpdateListContext
	WithClause() IWithClauseContext
	LOW_PRIORITY_SYMBOL() antlr.TerminalNode
	IGNORE_SYMBOL() antlr.TerminalNode
	WhereClause() IWhereClauseContext
	OrderClause() IOrderClauseContext
	SimpleLimitClause() ISimpleLimitClauseContext

	// IsUpdateStatementContext differentiates from other interfaces.
	IsUpdateStatementContext()
}

type UpdateStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateStatementContext() *UpdateStatementContext {
	var p = new(UpdateStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_updateStatement
	return p
}

func InitEmptyUpdateStatementContext(p *UpdateStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_updateStatement
}

func (*UpdateStatementContext) IsUpdateStatementContext() {}

func NewUpdateStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateStatementContext {
	var p = new(UpdateStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_updateStatement

	return p
}

func (s *UpdateStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateStatementContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUPDATE_SYMBOL, 0)
}

func (s *UpdateStatementContext) TableReferenceList() ITableReferenceListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableReferenceListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableReferenceListContext)
}

func (s *UpdateStatementContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSET_SYMBOL, 0)
}

func (s *UpdateStatementContext) UpdateList() IUpdateListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateListContext)
}

func (s *UpdateStatementContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *UpdateStatementContext) LOW_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOW_PRIORITY_SYMBOL, 0)
}

func (s *UpdateStatementContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIGNORE_SYMBOL, 0)
}

func (s *UpdateStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *UpdateStatementContext) OrderClause() IOrderClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *UpdateStatementContext) SimpleLimitClause() ISimpleLimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLimitClauseContext)
}

func (s *UpdateStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUpdateStatement(s)
	}
}

func (s *UpdateStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUpdateStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UpdateStatement() (localctx IUpdateStatementContext) {
	localctx = NewUpdateStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, TiDBParserRULE_updateStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1596)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserWITH_SYMBOL {
		{
			p.SetState(1595)
			p.WithClause()
		}

	}
	{
		p.SetState(1598)
		p.Match(TiDBParserUPDATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1600)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserLOW_PRIORITY_SYMBOL {
		{
			p.SetState(1599)
			p.Match(TiDBParserLOW_PRIORITY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(1603)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserIGNORE_SYMBOL {
		{
			p.SetState(1602)
			p.Match(TiDBParserIGNORE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(1605)
		p.TableReferenceList()
	}
	{
		p.SetState(1606)
		p.Match(TiDBParserSET_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1607)
		p.UpdateList()
	}
	p.SetState(1609)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserWHERE_SYMBOL {
		{
			p.SetState(1608)
			p.WhereClause()
		}

	}
	p.SetState(1612)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserORDER_SYMBOL {
		{
			p.SetState(1611)
			p.OrderClause()
		}

	}
	p.SetState(1615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserLIMIT_SYMBOL {
		{
			p.SetState(1614)
			p.SimpleLimitClause()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionOrLockingStatementContext is an interface to support dynamic dispatch.
type ITransactionOrLockingStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TransactionStatement() ITransactionStatementContext
	SavepointStatement() ISavepointStatementContext
	LockStatement() ILockStatementContext
	XaStatement() IXaStatementContext

	// IsTransactionOrLockingStatementContext differentiates from other interfaces.
	IsTransactionOrLockingStatementContext()
}

type TransactionOrLockingStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionOrLockingStatementContext() *TransactionOrLockingStatementContext {
	var p = new(TransactionOrLockingStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionOrLockingStatement
	return p
}

func InitEmptyTransactionOrLockingStatementContext(p *TransactionOrLockingStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionOrLockingStatement
}

func (*TransactionOrLockingStatementContext) IsTransactionOrLockingStatementContext() {}

func NewTransactionOrLockingStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionOrLockingStatementContext {
	var p = new(TransactionOrLockingStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_transactionOrLockingStatement

	return p
}

func (s *TransactionOrLockingStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionOrLockingStatementContext) TransactionStatement() ITransactionStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionStatementContext)
}

func (s *TransactionOrLockingStatementContext) SavepointStatement() ISavepointStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISavepointStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISavepointStatementContext)
}

func (s *TransactionOrLockingStatementContext) LockStatement() ILockStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockStatementContext)
}

func (s *TransactionOrLockingStatementContext) XaStatement() IXaStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaStatementContext)
}

func (s *TransactionOrLockingStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionOrLockingStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionOrLockingStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTransactionOrLockingStatement(s)
	}
}

func (s *TransactionOrLockingStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTransactionOrLockingStatement(s)
	}
}

func (s *TransactionOrLockingStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTransactionOrLockingStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TransactionOrLockingStatement() (localctx ITransactionOrLockingStatementContext) {
	localctx = NewTransactionOrLockingStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, TiDBParserRULE_transactionOrLockingStatement)
	p.SetState(1621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCOMMIT_SYMBOL, TiDBParserSTART_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1617)
			p.TransactionStatement()
		}

	case TiDBParserRELEASE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserSAVEPOINT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1618)
			p.SavepointStatement()
		}

	case TiDBParserLOCK_SYMBOL, TiDBParserUNLOCK_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1619)
			p.LockStatement()
		}

	case TiDBParserXA_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1620)
			p.XaStatement()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionStatementContext is an interface to support dynamic dispatch.
type ITransactionStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START_SYMBOL() antlr.TerminalNode
	TRANSACTION_SYMBOL() antlr.TerminalNode
	AllTransactionCharacteristic() []ITransactionCharacteristicContext
	TransactionCharacteristic(i int) ITransactionCharacteristicContext
	COMMIT_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode
	AND_SYMBOL() antlr.TerminalNode
	CHAIN_SYMBOL() antlr.TerminalNode
	RELEASE_SYMBOL() antlr.TerminalNode
	AllNO_SYMBOL() []antlr.TerminalNode
	NO_SYMBOL(i int) antlr.TerminalNode

	// IsTransactionStatementContext differentiates from other interfaces.
	IsTransactionStatementContext()
}

type TransactionStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionStatementContext() *TransactionStatementContext {
	var p = new(TransactionStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionStatement
	return p
}

func InitEmptyTransactionStatementContext(p *TransactionStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionStatement
}

func (*TransactionStatementContext) IsTransactionStatementContext() {}

func NewTransactionStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionStatementContext {
	var p = new(TransactionStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_transactionStatement

	return p
}

func (s *TransactionStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionStatementContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTART_SYMBOL, 0)
}

func (s *TransactionStatementContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRANSACTION_SYMBOL, 0)
}

func (s *TransactionStatementContext) AllTransactionCharacteristic() []ITransactionCharacteristicContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITransactionCharacteristicContext); ok {
			len++
		}
	}

	tst := make([]ITransactionCharacteristicContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITransactionCharacteristicContext); ok {
			tst[i] = t.(ITransactionCharacteristicContext)
			i++
		}
	}

	return tst
}

func (s *TransactionStatementContext) TransactionCharacteristic(i int) ITransactionCharacteristicContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionCharacteristicContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionCharacteristicContext)
}

func (s *TransactionStatementContext) COMMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMIT_SYMBOL, 0)
}

func (s *TransactionStatementContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWORK_SYMBOL, 0)
}

func (s *TransactionStatementContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAND_SYMBOL, 0)
}

func (s *TransactionStatementContext) CHAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHAIN_SYMBOL, 0)
}

func (s *TransactionStatementContext) RELEASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELEASE_SYMBOL, 0)
}

func (s *TransactionStatementContext) AllNO_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserNO_SYMBOL)
}

func (s *TransactionStatementContext) NO_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_SYMBOL, i)
}

func (s *TransactionStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTransactionStatement(s)
	}
}

func (s *TransactionStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTransactionStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TransactionStatement() (localctx ITransactionStatementContext) {
	localctx = NewTransactionStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, TiDBParserRULE_transactionStatement)
	var _la int

	p.SetState(1648)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserSTART_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1623)
			p.Match(TiDBParserSTART_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1624)
			p.Match(TiDBParserTRANSACTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1628)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserREAD_SYMBOL || _la == TiDBParserWITH_SYMBOL {
			{
				p.SetState(1625)
				p.TransactionCharacteristic()
			}

			p.SetState(1630)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case TiDBParserCOMMIT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1631)
			p.Match(TiDBParserCOMMIT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1633)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWORK_SYMBOL {
			{
				p.SetState(1632)
				p.Match(TiDBParserWORK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1640)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserAND_SYMBOL {
			{
				p.SetState(1635)
				p.Match(TiDBParserAND_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1637)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserNO_SYMBOL {
				{
					p.SetState(1636)
					p.Match(TiDBParserNO_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1639)
				p.Match(TiDBParserCHAIN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserNO_SYMBOL || _la == TiDBParserRELEASE_SYMBOL {
			p.SetState(1643)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserNO_SYMBOL {
				{
					p.SetState(1642)
					p.Match(TiDBParserNO_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(1645)
				p.Match(TiDBParserRELEASE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBeginWorkContext is an interface to support dynamic dispatch.
type IBeginWorkContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BEGIN_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode

	// IsBeginWorkContext differentiates from other interfaces.
	IsBeginWorkContext()
}

type BeginWorkContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBeginWorkContext() *BeginWorkContext {
	var p = new(BeginWorkContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_beginWork
	return p
}

func InitEmptyBeginWorkContext(p *BeginWorkContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_beginWork
}

func (*BeginWorkContext) IsBeginWorkContext() {}

func NewBeginWorkContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BeginWorkContext {
	var p = new(BeginWorkContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_beginWork

	return p
}

func (s *BeginWorkContext) GetParser() antlr.Parser { return s.parser }

func (s *BeginWorkContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBEGIN_SYMBOL, 0)
}

func (s *BeginWorkContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWORK_SYMBOL, 0)
}

func (s *BeginWorkContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeginWorkContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BeginWorkContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterBeginWork(s)
	}
}

func (s *BeginWorkContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitBeginWork(s)
	}
}

func (s *BeginWorkContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitBeginWork(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) BeginWork() (localctx IBeginWorkContext) {
	localctx = NewBeginWorkContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, TiDBParserRULE_beginWork)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1650)
		p.Match(TiDBParserBEGIN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserWORK_SYMBOL {
		{
			p.SetState(1651)
			p.Match(TiDBParserWORK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionCharacteristicContext is an interface to support dynamic dispatch.
type ITransactionCharacteristicContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	CONSISTENT_SYMBOL() antlr.TerminalNode
	SNAPSHOT_SYMBOL() antlr.TerminalNode
	READ_SYMBOL() antlr.TerminalNode
	WRITE_SYMBOL() antlr.TerminalNode
	ONLY_SYMBOL() antlr.TerminalNode

	// IsTransactionCharacteristicContext differentiates from other interfaces.
	IsTransactionCharacteristicContext()
}

type TransactionCharacteristicContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionCharacteristicContext() *TransactionCharacteristicContext {
	var p = new(TransactionCharacteristicContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionCharacteristic
	return p
}

func InitEmptyTransactionCharacteristicContext(p *TransactionCharacteristicContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionCharacteristic
}

func (*TransactionCharacteristicContext) IsTransactionCharacteristicContext() {}

func NewTransactionCharacteristicContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionCharacteristicContext {
	var p = new(TransactionCharacteristicContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_transactionCharacteristic

	return p
}

func (s *TransactionCharacteristicContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionCharacteristicContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) CONSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSISTENT_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) SNAPSHOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSNAPSHOT_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREAD_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWRITE_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserONLY_SYMBOL, 0)
}

func (s *TransactionCharacteristicContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionCharacteristicContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionCharacteristicContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTransactionCharacteristic(s)
	}
}

func (s *TransactionCharacteristicContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTransactionCharacteristic(s)
	}
}

func (s *TransactionCharacteristicContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTransactionCharacteristic(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TransactionCharacteristic() (localctx ITransactionCharacteristicContext) {
	localctx = NewTransactionCharacteristicContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, TiDBParserRULE_transactionCharacteristic)
	var _la int

	p.SetState(1659)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserWITH_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1654)
			p.Match(TiDBParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1655)
			p.Match(TiDBParserCONSISTENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1656)
			p.Match(TiDBParserSNAPSHOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREAD_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1657)
			p.Match(TiDBParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1658)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserONLY_SYMBOL || _la == TiDBParserWRITE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISavepointStatementContext is an interface to support dynamic dispatch.
type ISavepointStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SAVEPOINT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	ROLLBACK_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode
	AND_SYMBOL() antlr.TerminalNode
	CHAIN_SYMBOL() antlr.TerminalNode
	RELEASE_SYMBOL() antlr.TerminalNode
	AllNO_SYMBOL() []antlr.TerminalNode
	NO_SYMBOL(i int) antlr.TerminalNode

	// IsSavepointStatementContext differentiates from other interfaces.
	IsSavepointStatementContext()
}

type SavepointStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySavepointStatementContext() *SavepointStatementContext {
	var p = new(SavepointStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_savepointStatement
	return p
}

func InitEmptySavepointStatementContext(p *SavepointStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_savepointStatement
}

func (*SavepointStatementContext) IsSavepointStatementContext() {}

func NewSavepointStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SavepointStatementContext {
	var p = new(SavepointStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_savepointStatement

	return p
}

func (s *SavepointStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SavepointStatementContext) SAVEPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSAVEPOINT_SYMBOL, 0)
}

func (s *SavepointStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SavepointStatementContext) ROLLBACK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLLBACK_SYMBOL, 0)
}

func (s *SavepointStatementContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTO_SYMBOL, 0)
}

func (s *SavepointStatementContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWORK_SYMBOL, 0)
}

func (s *SavepointStatementContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAND_SYMBOL, 0)
}

func (s *SavepointStatementContext) CHAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHAIN_SYMBOL, 0)
}

func (s *SavepointStatementContext) RELEASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELEASE_SYMBOL, 0)
}

func (s *SavepointStatementContext) AllNO_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserNO_SYMBOL)
}

func (s *SavepointStatementContext) NO_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_SYMBOL, i)
}

func (s *SavepointStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SavepointStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SavepointStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSavepointStatement(s)
	}
}

func (s *SavepointStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSavepointStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SavepointStatement() (localctx ISavepointStatementContext) {
	localctx = NewSavepointStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, TiDBParserRULE_savepointStatement)
	var _la int

	p.SetState(1690)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserSAVEPOINT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1661)
			p.Match(TiDBParserSAVEPOINT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1662)
			p.Identifier()
		}

	case TiDBParserROLLBACK_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1663)
			p.Match(TiDBParserROLLBACK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1665)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWORK_SYMBOL {
			{
				p.SetState(1664)
				p.Match(TiDBParserWORK_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1685)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserTO_SYMBOL:
			{
				p.SetState(1667)
				p.Match(TiDBParserTO_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1669)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 151, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(1668)
					p.Match(TiDBParserSAVEPOINT_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(1671)
				p.Identifier()
			}

		case TiDBParserEOF, TiDBParserAND_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserRELEASE_SYMBOL:
			p.SetState(1677)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserAND_SYMBOL {
				{
					p.SetState(1672)
					p.Match(TiDBParserAND_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(1674)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == TiDBParserNO_SYMBOL {
					{
						p.SetState(1673)
						p.Match(TiDBParserNO_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1676)
					p.Match(TiDBParserCHAIN_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			p.SetState(1683)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserNO_SYMBOL || _la == TiDBParserRELEASE_SYMBOL {
				p.SetState(1680)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == TiDBParserNO_SYMBOL {
					{
						p.SetState(1679)
						p.Match(TiDBParserNO_SYMBOL)
						if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
						}
					}

				}
				{
					p.SetState(1682)
					p.Match(TiDBParserRELEASE_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case TiDBParserRELEASE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1687)
			p.Match(TiDBParserRELEASE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1688)
			p.Match(TiDBParserSAVEPOINT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1689)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockStatementContext is an interface to support dynamic dispatch.
type ILockStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCK_SYMBOL() antlr.TerminalNode
	AllLockItem() []ILockItemContext
	LockItem(i int) ILockItemContext
	TABLES_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	INSTANCE_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode
	BACKUP_SYMBOL() antlr.TerminalNode
	UNLOCK_SYMBOL() antlr.TerminalNode

	// IsLockStatementContext differentiates from other interfaces.
	IsLockStatementContext()
}

type LockStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockStatementContext() *LockStatementContext {
	var p = new(LockStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockStatement
	return p
}

func InitEmptyLockStatementContext(p *LockStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockStatement
}

func (*LockStatementContext) IsLockStatementContext() {}

func NewLockStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockStatementContext {
	var p = new(LockStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lockStatement

	return p
}

func (s *LockStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *LockStatementContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCK_SYMBOL, 0)
}

func (s *LockStatementContext) AllLockItem() []ILockItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILockItemContext); ok {
			len++
		}
	}

	tst := make([]ILockItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILockItemContext); ok {
			tst[i] = t.(ILockItemContext)
			i++
		}
	}

	return tst
}

func (s *LockStatementContext) LockItem(i int) ILockItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockItemContext)
}

func (s *LockStatementContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLES_SYMBOL, 0)
}

func (s *LockStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_SYMBOL, 0)
}

func (s *LockStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *LockStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *LockStatementContext) INSTANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSTANCE_SYMBOL, 0)
}

func (s *LockStatementContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *LockStatementContext) BACKUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBACKUP_SYMBOL, 0)
}

func (s *LockStatementContext) UNLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNLOCK_SYMBOL, 0)
}

func (s *LockStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLockStatement(s)
	}
}

func (s *LockStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLockStatement(s)
	}
}

func (s *LockStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLockStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LockStatement() (localctx ILockStatementContext) {
	localctx = NewLockStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, TiDBParserRULE_lockStatement)
	var _la int

	p.SetState(1708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 159, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1692)
			p.Match(TiDBParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1693)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserTABLES_SYMBOL || _la == TiDBParserTABLE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1694)
			p.LockItem()
		}
		p.SetState(1699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(1695)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1696)
				p.LockItem()
			}

			p.SetState(1701)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1702)
			p.Match(TiDBParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1703)
			p.Match(TiDBParserINSTANCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1704)
			p.Match(TiDBParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1705)
			p.Match(TiDBParserBACKUP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1706)
			p.Match(TiDBParserUNLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1707)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserINSTANCE_SYMBOL || _la == TiDBParserTABLES_SYMBOL || _la == TiDBParserTABLE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockItemContext is an interface to support dynamic dispatch.
type ILockItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TableRef() ITableRefContext
	LockOption() ILockOptionContext
	TableAlias() ITableAliasContext

	// IsLockItemContext differentiates from other interfaces.
	IsLockItemContext()
}

type LockItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockItemContext() *LockItemContext {
	var p = new(LockItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockItem
	return p
}

func InitEmptyLockItemContext(p *LockItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockItem
}

func (*LockItemContext) IsLockItemContext() {}

func NewLockItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockItemContext {
	var p = new(LockItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lockItem

	return p
}

func (s *LockItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LockItemContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *LockItemContext) LockOption() ILockOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILockOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILockOptionContext)
}

func (s *LockItemContext) TableAlias() ITableAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableAliasContext)
}

func (s *LockItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLockItem(s)
	}
}

func (s *LockItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLockItem(s)
	}
}

func (s *LockItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLockItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LockItem() (localctx ILockItemContext) {
	localctx = NewLockItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, TiDBParserRULE_lockItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1710)
		p.TableRef()
	}
	p.SetState(1712)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871717396) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921505714143167) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
		{
			p.SetState(1711)
			p.TableAlias()
		}

	}
	{
		p.SetState(1714)
		p.LockOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILockOptionContext is an interface to support dynamic dispatch.
type ILockOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	WRITE_SYMBOL() antlr.TerminalNode
	LOW_PRIORITY_SYMBOL() antlr.TerminalNode

	// IsLockOptionContext differentiates from other interfaces.
	IsLockOptionContext()
}

type LockOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLockOptionContext() *LockOptionContext {
	var p = new(LockOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockOption
	return p
}

func InitEmptyLockOptionContext(p *LockOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lockOption
}

func (*LockOptionContext) IsLockOptionContext() {}

func NewLockOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LockOptionContext {
	var p = new(LockOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lockOption

	return p
}

func (s *LockOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *LockOptionContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREAD_SYMBOL, 0)
}

func (s *LockOptionContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCAL_SYMBOL, 0)
}

func (s *LockOptionContext) WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWRITE_SYMBOL, 0)
}

func (s *LockOptionContext) LOW_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOW_PRIORITY_SYMBOL, 0)
}

func (s *LockOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LockOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LockOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLockOption(s)
	}
}

func (s *LockOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLockOption(s)
	}
}

func (s *LockOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLockOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LockOption() (localctx ILockOptionContext) {
	localctx = NewLockOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, TiDBParserRULE_lockOption)
	var _la int

	p.SetState(1724)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserREAD_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1716)
			p.Match(TiDBParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1718)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLOCAL_SYMBOL {
			{
				p.SetState(1717)
				p.Match(TiDBParserLOCAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserLOW_PRIORITY_SYMBOL, TiDBParserWRITE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(1721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLOW_PRIORITY_SYMBOL {
			{
				p.SetState(1720)
				p.Match(TiDBParserLOW_PRIORITY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(1723)
			p.Match(TiDBParserWRITE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaStatementContext is an interface to support dynamic dispatch.
type IXaStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	XA_SYMBOL() antlr.TerminalNode
	Xid() IXidContext
	END_SYMBOL() antlr.TerminalNode
	PREPARE_SYMBOL() antlr.TerminalNode
	COMMIT_SYMBOL() antlr.TerminalNode
	ROLLBACK_SYMBOL() antlr.TerminalNode
	RECOVER_SYMBOL() antlr.TerminalNode
	XaConvert() IXaConvertContext
	START_SYMBOL() antlr.TerminalNode
	BEGIN_SYMBOL() antlr.TerminalNode
	SUSPEND_SYMBOL() antlr.TerminalNode
	ONE_SYMBOL() antlr.TerminalNode
	PHASE_SYMBOL() antlr.TerminalNode
	JOIN_SYMBOL() antlr.TerminalNode
	RESUME_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode
	MIGRATE_SYMBOL() antlr.TerminalNode

	// IsXaStatementContext differentiates from other interfaces.
	IsXaStatementContext()
}

type XaStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaStatementContext() *XaStatementContext {
	var p = new(XaStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_xaStatement
	return p
}

func InitEmptyXaStatementContext(p *XaStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_xaStatement
}

func (*XaStatementContext) IsXaStatementContext() {}

func NewXaStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaStatementContext {
	var p = new(XaStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_xaStatement

	return p
}

func (s *XaStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *XaStatementContext) XA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserXA_SYMBOL, 0)
}

func (s *XaStatementContext) Xid() IXidContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXidContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXidContext)
}

func (s *XaStatementContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEND_SYMBOL, 0)
}

func (s *XaStatementContext) PREPARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPREPARE_SYMBOL, 0)
}

func (s *XaStatementContext) COMMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMIT_SYMBOL, 0)
}

func (s *XaStatementContext) ROLLBACK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLLBACK_SYMBOL, 0)
}

func (s *XaStatementContext) RECOVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRECOVER_SYMBOL, 0)
}

func (s *XaStatementContext) XaConvert() IXaConvertContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IXaConvertContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IXaConvertContext)
}

func (s *XaStatementContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTART_SYMBOL, 0)
}

func (s *XaStatementContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBEGIN_SYMBOL, 0)
}

func (s *XaStatementContext) SUSPEND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUSPEND_SYMBOL, 0)
}

func (s *XaStatementContext) ONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserONE_SYMBOL, 0)
}

func (s *XaStatementContext) PHASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPHASE_SYMBOL, 0)
}

func (s *XaStatementContext) JOIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJOIN_SYMBOL, 0)
}

func (s *XaStatementContext) RESUME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESUME_SYMBOL, 0)
}

func (s *XaStatementContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *XaStatementContext) MIGRATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMIGRATE_SYMBOL, 0)
}

func (s *XaStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterXaStatement(s)
	}
}

func (s *XaStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitXaStatement(s)
	}
}

func (s *XaStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitXaStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) XaStatement() (localctx IXaStatementContext) {
	localctx = NewXaStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, TiDBParserRULE_xaStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1726)
		p.Match(TiDBParserXA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1753)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserBEGIN_SYMBOL, TiDBParserSTART_SYMBOL:
		{
			p.SetState(1727)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserBEGIN_SYMBOL || _la == TiDBParserSTART_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1728)
			p.Xid()
		}
		p.SetState(1730)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserJOIN_SYMBOL || _la == TiDBParserRESUME_SYMBOL {
			{
				p.SetState(1729)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TiDBParserJOIN_SYMBOL || _la == TiDBParserRESUME_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case TiDBParserEND_SYMBOL:
		{
			p.SetState(1732)
			p.Match(TiDBParserEND_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1733)
			p.Xid()
		}
		p.SetState(1739)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSUSPEND_SYMBOL {
			{
				p.SetState(1734)
				p.Match(TiDBParserSUSPEND_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(1737)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserFOR_SYMBOL {
				{
					p.SetState(1735)
					p.Match(TiDBParserFOR_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(1736)
					p.Match(TiDBParserMIGRATE_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		}

	case TiDBParserPREPARE_SYMBOL:
		{
			p.SetState(1741)
			p.Match(TiDBParserPREPARE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1742)
			p.Xid()
		}

	case TiDBParserCOMMIT_SYMBOL:
		{
			p.SetState(1743)
			p.Match(TiDBParserCOMMIT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1744)
			p.Xid()
		}
		p.SetState(1747)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserONE_SYMBOL {
			{
				p.SetState(1745)
				p.Match(TiDBParserONE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1746)
				p.Match(TiDBParserPHASE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserROLLBACK_SYMBOL:
		{
			p.SetState(1749)
			p.Match(TiDBParserROLLBACK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1750)
			p.Xid()
		}

	case TiDBParserRECOVER_SYMBOL:
		{
			p.SetState(1751)
			p.Match(TiDBParserRECOVER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1752)
			p.XaConvert()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXaConvertContext is an interface to support dynamic dispatch.
type IXaConvertContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CONVERT_SYMBOL() antlr.TerminalNode
	XID_SYMBOL() antlr.TerminalNode

	// IsXaConvertContext differentiates from other interfaces.
	IsXaConvertContext()
}

type XaConvertContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXaConvertContext() *XaConvertContext {
	var p = new(XaConvertContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_xaConvert
	return p
}

func InitEmptyXaConvertContext(p *XaConvertContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_xaConvert
}

func (*XaConvertContext) IsXaConvertContext() {}

func NewXaConvertContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XaConvertContext {
	var p = new(XaConvertContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_xaConvert

	return p
}

func (s *XaConvertContext) GetParser() antlr.Parser { return s.parser }

func (s *XaConvertContext) CONVERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONVERT_SYMBOL, 0)
}

func (s *XaConvertContext) XID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserXID_SYMBOL, 0)
}

func (s *XaConvertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XaConvertContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XaConvertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterXaConvert(s)
	}
}

func (s *XaConvertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitXaConvert(s)
	}
}

func (s *XaConvertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitXaConvert(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) XaConvert() (localctx IXaConvertContext) {
	localctx = NewXaConvertContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, TiDBParserRULE_xaConvert)
	var _la int

	p.SetState(1760)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 170, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(1757)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCONVERT_SYMBOL {
			{
				p.SetState(1755)
				p.Match(TiDBParserCONVERT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1756)
				p.Match(TiDBParserXID_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IXidContext is an interface to support dynamic dispatch.
type IXidContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTextString() []ITextStringContext
	TextString(i int) ITextStringContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	Ulong_number() IUlong_numberContext

	// IsXidContext differentiates from other interfaces.
	IsXidContext()
}

type XidContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyXidContext() *XidContext {
	var p = new(XidContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_xid
	return p
}

func InitEmptyXidContext(p *XidContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_xid
}

func (*XidContext) IsXidContext() {}

func NewXidContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *XidContext {
	var p = new(XidContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_xid

	return p
}

func (s *XidContext) GetParser() antlr.Parser { return s.parser }

func (s *XidContext) AllTextString() []ITextStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringContext); ok {
			len++
		}
	}

	tst := make([]ITextStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringContext); ok {
			tst[i] = t.(ITextStringContext)
			i++
		}
	}

	return tst
}

func (s *XidContext) TextString(i int) ITextStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *XidContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *XidContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *XidContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *XidContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *XidContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *XidContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterXid(s)
	}
}

func (s *XidContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitXid(s)
	}
}

func (s *XidContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitXid(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Xid() (localctx IXidContext) {
	localctx = NewXidContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, TiDBParserRULE_xid)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1762)
		p.TextString()
	}
	p.SetState(1769)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1763)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1764)
			p.TextString()
		}
		p.SetState(1767)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(1765)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1766)
				p.Ulong_number()
			}

		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationStatementContext is an interface to support dynamic dispatch.
type IReplicationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PURGE_SYMBOL() antlr.TerminalNode
	LOGS_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	BEFORE_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	ChangeMaster() IChangeMasterContext
	RESET_SYMBOL() antlr.TerminalNode
	AllResetOption() []IResetOptionContext
	ResetOption(i int) IResetOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	PERSIST_SYMBOL() antlr.TerminalNode
	IfExists() IIfExistsContext
	Identifier() IIdentifierContext
	Slave() ISlaveContext
	ChangeReplication() IChangeReplicationContext
	ReplicationLoad() IReplicationLoadContext
	GroupReplication() IGroupReplicationContext

	// IsReplicationStatementContext differentiates from other interfaces.
	IsReplicationStatementContext()
}

type ReplicationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationStatementContext() *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_replicationStatement
	return p
}

func InitEmptyReplicationStatementContext(p *ReplicationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_replicationStatement
}

func (*ReplicationStatementContext) IsReplicationStatementContext() {}

func NewReplicationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationStatementContext {
	var p = new(ReplicationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_replicationStatement

	return p
}

func (s *ReplicationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationStatementContext) PURGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPURGE_SYMBOL, 0)
}

func (s *ReplicationStatementContext) LOGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOGS_SYMBOL, 0)
}

func (s *ReplicationStatementContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *ReplicationStatementContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SYMBOL, 0)
}

func (s *ReplicationStatementContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTO_SYMBOL, 0)
}

func (s *ReplicationStatementContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *ReplicationStatementContext) BEFORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBEFORE_SYMBOL, 0)
}

func (s *ReplicationStatementContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ReplicationStatementContext) ChangeMaster() IChangeMasterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeMasterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeMasterContext)
}

func (s *ReplicationStatementContext) RESET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESET_SYMBOL, 0)
}

func (s *ReplicationStatementContext) AllResetOption() []IResetOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IResetOptionContext); ok {
			len++
		}
	}

	tst := make([]IResetOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IResetOptionContext); ok {
			tst[i] = t.(IResetOptionContext)
			i++
		}
	}

	return tst
}

func (s *ReplicationStatementContext) ResetOption(i int) IResetOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResetOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResetOptionContext)
}

func (s *ReplicationStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ReplicationStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ReplicationStatementContext) PERSIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPERSIST_SYMBOL, 0)
}

func (s *ReplicationStatementContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *ReplicationStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReplicationStatementContext) Slave() ISlaveContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveContext)
}

func (s *ReplicationStatementContext) ChangeReplication() IChangeReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeReplicationContext)
}

func (s *ReplicationStatementContext) ReplicationLoad() IReplicationLoadContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplicationLoadContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplicationLoadContext)
}

func (s *ReplicationStatementContext) GroupReplication() IGroupReplicationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupReplicationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupReplicationContext)
}

func (s *ReplicationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitReplicationStatement(s)
	}
}

func (s *ReplicationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitReplicationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ReplicationStatement() (localctx IReplicationStatementContext) {
	localctx = NewReplicationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, TiDBParserRULE_replicationStatement)
	var _la int

	p.SetState(1801)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 176, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1771)
			p.Match(TiDBParserPURGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1772)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserBINARY_SYMBOL || _la == TiDBParserMASTER_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(1773)
			p.Match(TiDBParserLOGS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1778)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserTO_SYMBOL:
			{
				p.SetState(1774)
				p.Match(TiDBParserTO_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1775)
				p.TextLiteral()
			}

		case TiDBParserBEFORE_SYMBOL:
			{
				p.SetState(1776)
				p.Match(TiDBParserBEFORE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1777)
				p.expr(0)
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1780)
			p.ChangeMaster()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1781)
			p.Match(TiDBParserRESET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1782)
			p.ResetOption()
		}
		p.SetState(1787)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(1783)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1784)
				p.ResetOption()
			}

			p.SetState(1789)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1790)
			p.Match(TiDBParserRESET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1791)
			p.Match(TiDBParserPERSIST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1795)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserIF_SYMBOL {
			{
				p.SetState(1792)
				p.IfExists()
			}
			{
				p.SetState(1793)
				p.Identifier()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1797)
			p.Slave()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1798)
			p.ChangeReplication()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1799)
			p.ReplicationLoad()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1800)
			p.GroupReplication()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResetOptionContext is an interface to support dynamic dispatch.
type IResetOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	MASTER_SYMBOL() antlr.TerminalNode
	MasterResetOptions() IMasterResetOptionsContext
	CACHE_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	Channel() IChannelContext

	// IsResetOptionContext differentiates from other interfaces.
	IsResetOptionContext()
}

type ResetOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyResetOptionContext() *ResetOptionContext {
	var p = new(ResetOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resetOption
	return p
}

func InitEmptyResetOptionContext(p *ResetOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resetOption
}

func (*ResetOptionContext) IsResetOptionContext() {}

func NewResetOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResetOptionContext {
	var p = new(ResetOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_resetOption

	return p
}

func (s *ResetOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *ResetOptionContext) GetOption() antlr.Token { return s.option }

func (s *ResetOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *ResetOptionContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SYMBOL, 0)
}

func (s *ResetOptionContext) MasterResetOptions() IMasterResetOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterResetOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterResetOptionsContext)
}

func (s *ResetOptionContext) CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCACHE_SYMBOL, 0)
}

func (s *ResetOptionContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUERY_SYMBOL, 0)
}

func (s *ResetOptionContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSLAVE_SYMBOL, 0)
}

func (s *ResetOptionContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *ResetOptionContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *ResetOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResetOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResetOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterResetOption(s)
	}
}

func (s *ResetOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitResetOption(s)
	}
}

func (s *ResetOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitResetOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ResetOption() (localctx IResetOptionContext) {
	localctx = NewResetOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, TiDBParserRULE_resetOption)
	var _la int

	p.SetState(1816)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserMASTER_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1803)

			var _m = p.Match(TiDBParserMASTER_SYMBOL)

			localctx.(*ResetOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1805)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserTO_SYMBOL {
			{
				p.SetState(1804)
				p.MasterResetOptions()
			}

		}

	case TiDBParserQUERY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1807)

			var _m = p.Match(TiDBParserQUERY_SYMBOL)

			localctx.(*ResetOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1808)
			p.Match(TiDBParserCACHE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserSLAVE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1809)

			var _m = p.Match(TiDBParserSLAVE_SYMBOL)

			localctx.(*ResetOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1811)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserALL_SYMBOL {
			{
				p.SetState(1810)
				p.Match(TiDBParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(1814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(1813)
				p.Channel()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterResetOptionsContext is an interface to support dynamic dispatch.
type IMasterResetOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TO_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	Real_ulonglong_number() IReal_ulonglong_numberContext

	// IsMasterResetOptionsContext differentiates from other interfaces.
	IsMasterResetOptionsContext()
}

type MasterResetOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterResetOptionsContext() *MasterResetOptionsContext {
	var p = new(MasterResetOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_masterResetOptions
	return p
}

func InitEmptyMasterResetOptionsContext(p *MasterResetOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_masterResetOptions
}

func (*MasterResetOptionsContext) IsMasterResetOptionsContext() {}

func NewMasterResetOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterResetOptionsContext {
	var p = new(MasterResetOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_masterResetOptions

	return p
}

func (s *MasterResetOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterResetOptionsContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTO_SYMBOL, 0)
}

func (s *MasterResetOptionsContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *MasterResetOptionsContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *MasterResetOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterResetOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MasterResetOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterMasterResetOptions(s)
	}
}

func (s *MasterResetOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitMasterResetOptions(s)
	}
}

func (s *MasterResetOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitMasterResetOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) MasterResetOptions() (localctx IMasterResetOptionsContext) {
	localctx = NewMasterResetOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, TiDBParserRULE_masterResetOptions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1818)
		p.Match(TiDBParserTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1821)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 181, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(1819)
			p.Real_ulong_number()
		}

	case 2:
		{
			p.SetState(1820)
			p.Real_ulonglong_number()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplicationLoadContext is an interface to support dynamic dispatch.
type IReplicationLoadContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOAD_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext

	// IsReplicationLoadContext differentiates from other interfaces.
	IsReplicationLoadContext()
}

type ReplicationLoadContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplicationLoadContext() *ReplicationLoadContext {
	var p = new(ReplicationLoadContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_replicationLoad
	return p
}

func InitEmptyReplicationLoadContext(p *ReplicationLoadContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_replicationLoad
}

func (*ReplicationLoadContext) IsReplicationLoadContext() {}

func NewReplicationLoadContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplicationLoadContext {
	var p = new(ReplicationLoadContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_replicationLoad

	return p
}

func (s *ReplicationLoadContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplicationLoadContext) LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOAD_SYMBOL, 0)
}

func (s *ReplicationLoadContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *ReplicationLoadContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SYMBOL, 0)
}

func (s *ReplicationLoadContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATA_SYMBOL, 0)
}

func (s *ReplicationLoadContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_SYMBOL, 0)
}

func (s *ReplicationLoadContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *ReplicationLoadContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplicationLoadContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplicationLoadContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterReplicationLoad(s)
	}
}

func (s *ReplicationLoadContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitReplicationLoad(s)
	}
}

func (s *ReplicationLoadContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitReplicationLoad(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ReplicationLoad() (localctx IReplicationLoadContext) {
	localctx = NewReplicationLoadContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, TiDBParserRULE_replicationLoad)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1823)
		p.Match(TiDBParserLOAD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserDATA_SYMBOL:
		{
			p.SetState(1824)
			p.Match(TiDBParserDATA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserTABLE_SYMBOL:
		{
			p.SetState(1825)
			p.Match(TiDBParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1826)
			p.TableRef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1829)
		p.Match(TiDBParserFROM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1830)
		p.Match(TiDBParserMASTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeMasterContext is an interface to support dynamic dispatch.
type IChangeMasterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	ChangeMasterOptions() IChangeMasterOptionsContext
	Channel() IChannelContext

	// IsChangeMasterContext differentiates from other interfaces.
	IsChangeMasterContext()
}

type ChangeMasterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeMasterContext() *ChangeMasterContext {
	var p = new(ChangeMasterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_changeMaster
	return p
}

func InitEmptyChangeMasterContext(p *ChangeMasterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_changeMaster
}

func (*ChangeMasterContext) IsChangeMasterContext() {}

func NewChangeMasterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeMasterContext {
	var p = new(ChangeMasterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_changeMaster

	return p
}

func (s *ChangeMasterContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeMasterContext) CHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHANGE_SYMBOL, 0)
}

func (s *ChangeMasterContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SYMBOL, 0)
}

func (s *ChangeMasterContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTO_SYMBOL, 0)
}

func (s *ChangeMasterContext) ChangeMasterOptions() IChangeMasterOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChangeMasterOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChangeMasterOptionsContext)
}

func (s *ChangeMasterContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *ChangeMasterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeMasterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeMasterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterChangeMaster(s)
	}
}

func (s *ChangeMasterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitChangeMaster(s)
	}
}

func (s *ChangeMasterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitChangeMaster(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ChangeMaster() (localctx IChangeMasterContext) {
	localctx = NewChangeMasterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, TiDBParserRULE_changeMaster)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1832)
		p.Match(TiDBParserCHANGE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1833)
		p.Match(TiDBParserMASTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1834)
		p.Match(TiDBParserTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1835)
		p.ChangeMasterOptions()
	}
	p.SetState(1837)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserFOR_SYMBOL {
		{
			p.SetState(1836)
			p.Channel()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeMasterOptionsContext is an interface to support dynamic dispatch.
type IChangeMasterOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMasterOption() []IMasterOptionContext
	MasterOption(i int) IMasterOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsChangeMasterOptionsContext differentiates from other interfaces.
	IsChangeMasterOptionsContext()
}

type ChangeMasterOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeMasterOptionsContext() *ChangeMasterOptionsContext {
	var p = new(ChangeMasterOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_changeMasterOptions
	return p
}

func InitEmptyChangeMasterOptionsContext(p *ChangeMasterOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_changeMasterOptions
}

func (*ChangeMasterOptionsContext) IsChangeMasterOptionsContext() {}

func NewChangeMasterOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeMasterOptionsContext {
	var p = new(ChangeMasterOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_changeMasterOptions

	return p
}

func (s *ChangeMasterOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeMasterOptionsContext) AllMasterOption() []IMasterOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMasterOptionContext); ok {
			len++
		}
	}

	tst := make([]IMasterOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMasterOptionContext); ok {
			tst[i] = t.(IMasterOptionContext)
			i++
		}
	}

	return tst
}

func (s *ChangeMasterOptionsContext) MasterOption(i int) IMasterOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterOptionContext)
}

func (s *ChangeMasterOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ChangeMasterOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ChangeMasterOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeMasterOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeMasterOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterChangeMasterOptions(s)
	}
}

func (s *ChangeMasterOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitChangeMasterOptions(s)
	}
}

func (s *ChangeMasterOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitChangeMasterOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ChangeMasterOptions() (localctx IChangeMasterOptionsContext) {
	localctx = NewChangeMasterOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, TiDBParserRULE_changeMasterOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1839)
		p.MasterOption()
	}
	p.SetState(1844)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1840)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1841)
			p.MasterOption()
		}

		p.SetState(1846)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterOptionContext is an interface to support dynamic dispatch.
type IMasterOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_HOST_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	TextStringNoLinebreak() ITextStringNoLinebreakContext
	NETWORK_NAMESPACE_SYMBOL() antlr.TerminalNode
	MASTER_BIND_SYMBOL() antlr.TerminalNode
	MASTER_USER_SYMBOL() antlr.TerminalNode
	MASTER_PASSWORD_SYMBOL() antlr.TerminalNode
	MASTER_PORT_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode
	MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode
	MASTER_DELAY_SYMBOL() antlr.TerminalNode
	MASTER_SSL_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CA_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode
	MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode
	MASTER_TLS_CIPHERSUITES_SYMBOL() antlr.TerminalNode
	MasterTlsCiphersuitesDef() IMasterTlsCiphersuitesDefContext
	MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode
	MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode
	MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode
	MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode
	GET_MASTER_PUBLIC_KEY_SYMBOL() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode
	IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode
	ServerIdList() IServerIdListContext
	MASTER_COMPRESSION_ALGORITHM_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() antlr.TerminalNode
	MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode
	PRIVILEGE_CHECKS_USER_SYMBOL() antlr.TerminalNode
	PrivilegeCheckDef() IPrivilegeCheckDefContext
	REQUIRE_ROW_FORMAT_SYMBOL() antlr.TerminalNode
	REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() antlr.TerminalNode
	TablePrimaryKeyCheckDef() ITablePrimaryKeyCheckDefContext
	MasterFileDef() IMasterFileDefContext

	// IsMasterOptionContext differentiates from other interfaces.
	IsMasterOptionContext()
}

type MasterOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterOptionContext() *MasterOptionContext {
	var p = new(MasterOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_masterOption
	return p
}

func InitEmptyMasterOptionContext(p *MasterOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_masterOption
}

func (*MasterOptionContext) IsMasterOptionContext() {}

func NewMasterOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterOptionContext {
	var p = new(MasterOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_masterOption

	return p
}

func (s *MasterOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterOptionContext) MASTER_HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_HOST_SYMBOL, 0)
}

func (s *MasterOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *MasterOptionContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *MasterOptionContext) NETWORK_NAMESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNETWORK_NAMESPACE_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_BIND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_BIND_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_USER_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_PASSWORD_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_PORT_SYMBOL, 0)
}

func (s *MasterOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *MasterOptionContext) MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_CONNECT_RETRY_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_RETRY_COUNT_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_DELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_DELAY_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_CA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CA_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CAPATH_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_TLS_VERSION_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CERT_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_TLS_CIPHERSUITES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, 0)
}

func (s *MasterOptionContext) MasterTlsCiphersuitesDef() IMasterTlsCiphersuitesDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterTlsCiphersuitesDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterTlsCiphersuitesDefContext)
}

func (s *MasterOptionContext) MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CIPHER_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_KEY_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_VERIFY_SERVER_CERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_VERIFY_SERVER_CERT_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CRL_SYMBOL, 0)
}

func (s *MasterOptionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *MasterOptionContext) MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CRLPATH_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, 0)
}

func (s *MasterOptionContext) GET_MASTER_PUBLIC_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, 0)
}

func (s *MasterOptionContext) IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIGNORE_SERVER_IDS_SYMBOL, 0)
}

func (s *MasterOptionContext) ServerIdList() IServerIdListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IServerIdListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IServerIdListContext)
}

func (s *MasterOptionContext) MASTER_COMPRESSION_ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, 0)
}

func (s *MasterOptionContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *MasterOptionContext) MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0)
}

func (s *MasterOptionContext) MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_AUTO_POSITION_SYMBOL, 0)
}

func (s *MasterOptionContext) PRIVILEGE_CHECKS_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, 0)
}

func (s *MasterOptionContext) PrivilegeCheckDef() IPrivilegeCheckDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrivilegeCheckDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrivilegeCheckDefContext)
}

func (s *MasterOptionContext) REQUIRE_ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, 0)
}

func (s *MasterOptionContext) REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, 0)
}

func (s *MasterOptionContext) TablePrimaryKeyCheckDef() ITablePrimaryKeyCheckDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITablePrimaryKeyCheckDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITablePrimaryKeyCheckDefContext)
}

func (s *MasterOptionContext) MasterFileDef() IMasterFileDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterFileDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterFileDefContext)
}

func (s *MasterOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MasterOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterMasterOption(s)
	}
}

func (s *MasterOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitMasterOption(s)
	}
}

func (s *MasterOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitMasterOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) MasterOption() (localctx IMasterOptionContext) {
	localctx = NewMasterOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, TiDBParserRULE_masterOption)
	p.SetState(1938)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserMASTER_HOST_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1847)
			p.Match(TiDBParserMASTER_HOST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1848)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1849)
			p.TextStringNoLinebreak()
		}

	case TiDBParserNETWORK_NAMESPACE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1850)
			p.Match(TiDBParserNETWORK_NAMESPACE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1851)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1852)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_BIND_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1853)
			p.Match(TiDBParserMASTER_BIND_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1854)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1855)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_USER_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1856)
			p.Match(TiDBParserMASTER_USER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1857)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1858)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_PASSWORD_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1859)
			p.Match(TiDBParserMASTER_PASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1860)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1861)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_PORT_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1862)
			p.Match(TiDBParserMASTER_PORT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1863)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1864)
			p.Ulong_number()
		}

	case TiDBParserMASTER_CONNECT_RETRY_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1865)
			p.Match(TiDBParserMASTER_CONNECT_RETRY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1866)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1867)
			p.Ulong_number()
		}

	case TiDBParserMASTER_RETRY_COUNT_SYMBOL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1868)
			p.Match(TiDBParserMASTER_RETRY_COUNT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1869)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1870)
			p.Ulong_number()
		}

	case TiDBParserMASTER_DELAY_SYMBOL:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1871)
			p.Match(TiDBParserMASTER_DELAY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1872)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1873)
			p.Ulong_number()
		}

	case TiDBParserMASTER_SSL_SYMBOL:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1874)
			p.Match(TiDBParserMASTER_SSL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1875)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1876)
			p.Ulong_number()
		}

	case TiDBParserMASTER_SSL_CA_SYMBOL:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(1877)
			p.Match(TiDBParserMASTER_SSL_CA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1878)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1879)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_SSL_CAPATH_SYMBOL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(1880)
			p.Match(TiDBParserMASTER_SSL_CAPATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1881)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1882)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_TLS_VERSION_SYMBOL:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(1883)
			p.Match(TiDBParserMASTER_TLS_VERSION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1884)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1885)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_SSL_CERT_SYMBOL:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(1886)
			p.Match(TiDBParserMASTER_SSL_CERT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1887)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1888)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(1889)
			p.Match(TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1890)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1891)
			p.MasterTlsCiphersuitesDef()
		}

	case TiDBParserMASTER_SSL_CIPHER_SYMBOL:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(1892)
			p.Match(TiDBParserMASTER_SSL_CIPHER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1893)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1894)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_SSL_KEY_SYMBOL:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(1895)
			p.Match(TiDBParserMASTER_SSL_KEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1896)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1897)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_SSL_VERIFY_SERVER_CERT_SYMBOL:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(1898)
			p.Match(TiDBParserMASTER_SSL_VERIFY_SERVER_CERT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1899)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1900)
			p.Ulong_number()
		}

	case TiDBParserMASTER_SSL_CRL_SYMBOL:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(1901)
			p.Match(TiDBParserMASTER_SSL_CRL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1902)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1903)
			p.TextLiteral()
		}

	case TiDBParserMASTER_SSL_CRLPATH_SYMBOL:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(1904)
			p.Match(TiDBParserMASTER_SSL_CRLPATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1905)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1906)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(1907)
			p.Match(TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1908)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1909)
			p.TextStringNoLinebreak()
		}

	case TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(1910)
			p.Match(TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1911)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1912)
			p.Ulong_number()
		}

	case TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(1913)
			p.Match(TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1914)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1915)
			p.Ulong_number()
		}

	case TiDBParserIGNORE_SERVER_IDS_SYMBOL:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(1916)
			p.Match(TiDBParserIGNORE_SERVER_IDS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1917)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1918)
			p.ServerIdList()
		}

	case TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(1919)
			p.Match(TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1920)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1921)
			p.TextStringLiteral()
		}

	case TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(1922)
			p.Match(TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1923)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1924)
			p.Ulong_number()
		}

	case TiDBParserMASTER_AUTO_POSITION_SYMBOL:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(1925)
			p.Match(TiDBParserMASTER_AUTO_POSITION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1926)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1927)
			p.Ulong_number()
		}

	case TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(1928)
			p.Match(TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1929)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1930)
			p.PrivilegeCheckDef()
		}

	case TiDBParserREQUIRE_ROW_FORMAT_SYMBOL:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(1931)
			p.Match(TiDBParserREQUIRE_ROW_FORMAT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1932)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1933)
			p.Ulong_number()
		}

	case TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(1934)
			p.Match(TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1935)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1936)
			p.TablePrimaryKeyCheckDef()
		}

	case TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(1937)
			p.MasterFileDef()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrivilegeCheckDefContext is an interface to support dynamic dispatch.
type IPrivilegeCheckDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserIdentifierOrText() IUserIdentifierOrTextContext
	NULL_SYMBOL() antlr.TerminalNode

	// IsPrivilegeCheckDefContext differentiates from other interfaces.
	IsPrivilegeCheckDefContext()
}

type PrivilegeCheckDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrivilegeCheckDefContext() *PrivilegeCheckDefContext {
	var p = new(PrivilegeCheckDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_privilegeCheckDef
	return p
}

func InitEmptyPrivilegeCheckDefContext(p *PrivilegeCheckDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_privilegeCheckDef
}

func (*PrivilegeCheckDefContext) IsPrivilegeCheckDefContext() {}

func NewPrivilegeCheckDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrivilegeCheckDefContext {
	var p = new(PrivilegeCheckDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_privilegeCheckDef

	return p
}

func (s *PrivilegeCheckDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PrivilegeCheckDefContext) UserIdentifierOrText() IUserIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifierOrTextContext)
}

func (s *PrivilegeCheckDefContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL_SYMBOL, 0)
}

func (s *PrivilegeCheckDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrivilegeCheckDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrivilegeCheckDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPrivilegeCheckDef(s)
	}
}

func (s *PrivilegeCheckDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPrivilegeCheckDef(s)
	}
}

func (s *PrivilegeCheckDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPrivilegeCheckDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PrivilegeCheckDef() (localctx IPrivilegeCheckDefContext) {
	localctx = NewPrivilegeCheckDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, TiDBParserRULE_privilegeCheckDef)
	p.SetState(1942)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1940)
			p.UserIdentifierOrText()
		}

	case TiDBParserNULL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1941)
			p.Match(TiDBParserNULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablePrimaryKeyCheckDefContext is an interface to support dynamic dispatch.
type ITablePrimaryKeyCheckDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STREAM_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	OFF_SYMBOL() antlr.TerminalNode

	// IsTablePrimaryKeyCheckDefContext differentiates from other interfaces.
	IsTablePrimaryKeyCheckDefContext()
}

type TablePrimaryKeyCheckDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablePrimaryKeyCheckDefContext() *TablePrimaryKeyCheckDefContext {
	var p = new(TablePrimaryKeyCheckDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tablePrimaryKeyCheckDef
	return p
}

func InitEmptyTablePrimaryKeyCheckDefContext(p *TablePrimaryKeyCheckDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tablePrimaryKeyCheckDef
}

func (*TablePrimaryKeyCheckDefContext) IsTablePrimaryKeyCheckDefContext() {}

func NewTablePrimaryKeyCheckDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablePrimaryKeyCheckDefContext {
	var p = new(TablePrimaryKeyCheckDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tablePrimaryKeyCheckDef

	return p
}

func (s *TablePrimaryKeyCheckDefContext) GetParser() antlr.Parser { return s.parser }

func (s *TablePrimaryKeyCheckDefContext) STREAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTREAM_SYMBOL, 0)
}

func (s *TablePrimaryKeyCheckDefContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *TablePrimaryKeyCheckDefContext) OFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOFF_SYMBOL, 0)
}

func (s *TablePrimaryKeyCheckDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablePrimaryKeyCheckDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablePrimaryKeyCheckDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTablePrimaryKeyCheckDef(s)
	}
}

func (s *TablePrimaryKeyCheckDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTablePrimaryKeyCheckDef(s)
	}
}

func (s *TablePrimaryKeyCheckDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTablePrimaryKeyCheckDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TablePrimaryKeyCheckDef() (localctx ITablePrimaryKeyCheckDefContext) {
	localctx = NewTablePrimaryKeyCheckDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, TiDBParserRULE_tablePrimaryKeyCheckDef)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1944)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserON_SYMBOL || _la == TiDBParserSTREAM_SYMBOL || _la == TiDBParserOFF_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterTlsCiphersuitesDefContext is an interface to support dynamic dispatch.
type IMasterTlsCiphersuitesDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringNoLinebreak() ITextStringNoLinebreakContext
	NULL_SYMBOL() antlr.TerminalNode

	// IsMasterTlsCiphersuitesDefContext differentiates from other interfaces.
	IsMasterTlsCiphersuitesDefContext()
}

type MasterTlsCiphersuitesDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterTlsCiphersuitesDefContext() *MasterTlsCiphersuitesDefContext {
	var p = new(MasterTlsCiphersuitesDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_masterTlsCiphersuitesDef
	return p
}

func InitEmptyMasterTlsCiphersuitesDefContext(p *MasterTlsCiphersuitesDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_masterTlsCiphersuitesDef
}

func (*MasterTlsCiphersuitesDefContext) IsMasterTlsCiphersuitesDefContext() {}

func NewMasterTlsCiphersuitesDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterTlsCiphersuitesDefContext {
	var p = new(MasterTlsCiphersuitesDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_masterTlsCiphersuitesDef

	return p
}

func (s *MasterTlsCiphersuitesDefContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterTlsCiphersuitesDefContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *MasterTlsCiphersuitesDefContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL_SYMBOL, 0)
}

func (s *MasterTlsCiphersuitesDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterTlsCiphersuitesDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MasterTlsCiphersuitesDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterMasterTlsCiphersuitesDef(s)
	}
}

func (s *MasterTlsCiphersuitesDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitMasterTlsCiphersuitesDef(s)
	}
}

func (s *MasterTlsCiphersuitesDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitMasterTlsCiphersuitesDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) MasterTlsCiphersuitesDef() (localctx IMasterTlsCiphersuitesDefContext) {
	localctx = NewMasterTlsCiphersuitesDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, TiDBParserRULE_masterTlsCiphersuitesDef)
	p.SetState(1948)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1946)
			p.TextStringNoLinebreak()
		}

	case TiDBParserNULL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1947)
			p.Match(TiDBParserNULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IMasterFileDefContext is an interface to support dynamic dispatch.
type IMasterFileDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	TextStringNoLinebreak() ITextStringNoLinebreakContext
	MASTER_LOG_POS_SYMBOL() antlr.TerminalNode
	Ulonglong_number() IUlonglong_numberContext
	RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode
	RELAY_LOG_POS_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext

	// IsMasterFileDefContext differentiates from other interfaces.
	IsMasterFileDefContext()
}

type MasterFileDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMasterFileDefContext() *MasterFileDefContext {
	var p = new(MasterFileDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_masterFileDef
	return p
}

func InitEmptyMasterFileDefContext(p *MasterFileDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_masterFileDef
}

func (*MasterFileDefContext) IsMasterFileDefContext() {}

func NewMasterFileDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MasterFileDefContext {
	var p = new(MasterFileDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_masterFileDef

	return p
}

func (s *MasterFileDefContext) GetParser() antlr.Parser { return s.parser }

func (s *MasterFileDefContext) MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_LOG_FILE_SYMBOL, 0)
}

func (s *MasterFileDefContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *MasterFileDefContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *MasterFileDefContext) MASTER_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_LOG_POS_SYMBOL, 0)
}

func (s *MasterFileDefContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *MasterFileDefContext) RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_LOG_FILE_SYMBOL, 0)
}

func (s *MasterFileDefContext) RELAY_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_LOG_POS_SYMBOL, 0)
}

func (s *MasterFileDefContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *MasterFileDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MasterFileDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MasterFileDefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterMasterFileDef(s)
	}
}

func (s *MasterFileDefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitMasterFileDef(s)
	}
}

func (s *MasterFileDefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitMasterFileDef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) MasterFileDef() (localctx IMasterFileDefContext) {
	localctx = NewMasterFileDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, TiDBParserRULE_masterFileDef)
	p.SetState(1962)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserMASTER_LOG_FILE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1950)
			p.Match(TiDBParserMASTER_LOG_FILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1951)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1952)
			p.TextStringNoLinebreak()
		}

	case TiDBParserMASTER_LOG_POS_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1953)
			p.Match(TiDBParserMASTER_LOG_POS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1954)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1955)
			p.Ulonglong_number()
		}

	case TiDBParserRELAY_LOG_FILE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1956)
			p.Match(TiDBParserRELAY_LOG_FILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1957)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1958)
			p.TextStringNoLinebreak()
		}

	case TiDBParserRELAY_LOG_POS_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1959)
			p.Match(TiDBParserRELAY_LOG_POS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1960)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1961)
			p.Ulong_number()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerIdListContext is an interface to support dynamic dispatch.
type IServerIdListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllUlong_number() []IUlong_numberContext
	Ulong_number(i int) IUlong_numberContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsServerIdListContext differentiates from other interfaces.
	IsServerIdListContext()
}

type ServerIdListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerIdListContext() *ServerIdListContext {
	var p = new(ServerIdListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_serverIdList
	return p
}

func InitEmptyServerIdListContext(p *ServerIdListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_serverIdList
}

func (*ServerIdListContext) IsServerIdListContext() {}

func NewServerIdListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerIdListContext {
	var p = new(ServerIdListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_serverIdList

	return p
}

func (s *ServerIdListContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerIdListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *ServerIdListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ServerIdListContext) AllUlong_number() []IUlong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUlong_numberContext); ok {
			len++
		}
	}

	tst := make([]IUlong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUlong_numberContext); ok {
			tst[i] = t.(IUlong_numberContext)
			i++
		}
	}

	return tst
}

func (s *ServerIdListContext) Ulong_number(i int) IUlong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *ServerIdListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ServerIdListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ServerIdListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerIdListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerIdListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterServerIdList(s)
	}
}

func (s *ServerIdListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitServerIdList(s)
	}
}

func (s *ServerIdListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitServerIdList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ServerIdList() (localctx IServerIdListContext) {
	localctx = NewServerIdListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 212, TiDBParserRULE_serverIdList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1964)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(1973)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if (int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&28587302322183) != 0 {
		{
			p.SetState(1965)
			p.Ulong_number()
		}
		p.SetState(1970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(1966)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(1967)
				p.Ulong_number()
			}

			p.SetState(1972)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1975)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChangeReplicationContext is an interface to support dynamic dispatch.
type IChangeReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHANGE_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	FILTER_SYMBOL() antlr.TerminalNode
	AllFilterDefinition() []IFilterDefinitionContext
	FilterDefinition(i int) IFilterDefinitionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	Channel() IChannelContext

	// IsChangeReplicationContext differentiates from other interfaces.
	IsChangeReplicationContext()
}

type ChangeReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChangeReplicationContext() *ChangeReplicationContext {
	var p = new(ChangeReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_changeReplication
	return p
}

func InitEmptyChangeReplicationContext(p *ChangeReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_changeReplication
}

func (*ChangeReplicationContext) IsChangeReplicationContext() {}

func NewChangeReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChangeReplicationContext {
	var p = new(ChangeReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_changeReplication

	return p
}

func (s *ChangeReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *ChangeReplicationContext) CHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHANGE_SYMBOL, 0)
}

func (s *ChangeReplicationContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATION_SYMBOL, 0)
}

func (s *ChangeReplicationContext) FILTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFILTER_SYMBOL, 0)
}

func (s *ChangeReplicationContext) AllFilterDefinition() []IFilterDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFilterDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IFilterDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFilterDefinitionContext); ok {
			tst[i] = t.(IFilterDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *ChangeReplicationContext) FilterDefinition(i int) IFilterDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterDefinitionContext)
}

func (s *ChangeReplicationContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ChangeReplicationContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ChangeReplicationContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *ChangeReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChangeReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChangeReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterChangeReplication(s)
	}
}

func (s *ChangeReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitChangeReplication(s)
	}
}

func (s *ChangeReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitChangeReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ChangeReplication() (localctx IChangeReplicationContext) {
	localctx = NewChangeReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 214, TiDBParserRULE_changeReplication)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1977)
		p.Match(TiDBParserCHANGE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1978)
		p.Match(TiDBParserREPLICATION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1979)
		p.Match(TiDBParserFILTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(1980)
		p.FilterDefinition()
	}
	p.SetState(1985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(1981)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1982)
			p.FilterDefinition()
		}

		p.SetState(1987)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(1989)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserFOR_SYMBOL {
		{
			p.SetState(1988)
			p.Channel()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterDefinitionContext is an interface to support dynamic dispatch.
type IFilterDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	FilterDbList() IFilterDbListContext
	REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode
	FilterTableList() IFilterTableListContext
	REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode
	FilterStringList() IFilterStringListContext
	REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode
	FilterDbPairList() IFilterDbPairListContext

	// IsFilterDefinitionContext differentiates from other interfaces.
	IsFilterDefinitionContext()
}

type FilterDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterDefinitionContext() *FilterDefinitionContext {
	var p = new(FilterDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterDefinition
	return p
}

func InitEmptyFilterDefinitionContext(p *FilterDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterDefinition
}

func (*FilterDefinitionContext) IsFilterDefinitionContext() {}

func NewFilterDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterDefinitionContext {
	var p = new(FilterDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_filterDefinition

	return p
}

func (s *FilterDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterDefinitionContext) REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_DO_DB_SYMBOL, 0)
}

func (s *FilterDefinitionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *FilterDefinitionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *FilterDefinitionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *FilterDefinitionContext) FilterDbList() IFilterDbListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterDbListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterDbListContext)
}

func (s *FilterDefinitionContext) REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_IGNORE_DB_SYMBOL, 0)
}

func (s *FilterDefinitionContext) REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_DO_TABLE_SYMBOL, 0)
}

func (s *FilterDefinitionContext) FilterTableList() IFilterTableListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterTableListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterTableListContext)
}

func (s *FilterDefinitionContext) REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, 0)
}

func (s *FilterDefinitionContext) REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, 0)
}

func (s *FilterDefinitionContext) FilterStringList() IFilterStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterStringListContext)
}

func (s *FilterDefinitionContext) REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0)
}

func (s *FilterDefinitionContext) REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_REWRITE_DB_SYMBOL, 0)
}

func (s *FilterDefinitionContext) FilterDbPairList() IFilterDbPairListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterDbPairListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterDbPairListContext)
}

func (s *FilterDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFilterDefinition(s)
	}
}

func (s *FilterDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFilterDefinition(s)
	}
}

func (s *FilterDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFilterDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FilterDefinition() (localctx IFilterDefinitionContext) {
	localctx = NewFilterDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 216, TiDBParserRULE_filterDefinition)
	var _la int

	p.SetState(2040)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserREPLICATE_DO_DB_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1991)
			p.Match(TiDBParserREPLICATE_DO_DB_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1992)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1993)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(1995)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871848468) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
			{
				p.SetState(1994)
				p.FilterDbList()
			}

		}
		{
			p.SetState(1997)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREPLICATE_IGNORE_DB_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1998)
			p.Match(TiDBParserREPLICATE_IGNORE_DB_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(1999)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2000)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871848468) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
			{
				p.SetState(2001)
				p.FilterDbList()
			}

		}
		{
			p.SetState(2004)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREPLICATE_DO_TABLE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2005)
			p.Match(TiDBParserREPLICATE_DO_TABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2006)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2007)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871848468) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
			{
				p.SetState(2008)
				p.FilterTableList()
			}

		}
		{
			p.SetState(2011)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2012)
			p.Match(TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2013)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2014)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2016)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871848468) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
			{
				p.SetState(2015)
				p.FilterTableList()
			}

		}
		{
			p.SetState(2018)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2019)
			p.Match(TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2020)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2021)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2023)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDOUBLE_QUOTED_TEXT || _la == TiDBParserSINGLE_QUOTED_TEXT {
			{
				p.SetState(2022)
				p.FilterStringList()
			}

		}
		{
			p.SetState(2025)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2026)
			p.Match(TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2027)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2028)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDOUBLE_QUOTED_TEXT || _la == TiDBParserSINGLE_QUOTED_TEXT {
			{
				p.SetState(2029)
				p.FilterStringList()
			}

		}
		{
			p.SetState(2032)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREPLICATE_REWRITE_DB_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2033)
			p.Match(TiDBParserREPLICATE_REWRITE_DB_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2034)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2035)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2037)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(2036)
				p.FilterDbPairList()
			}

		}
		{
			p.SetState(2039)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterDbListContext is an interface to support dynamic dispatch.
type IFilterDbListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSchemaRef() []ISchemaRefContext
	SchemaRef(i int) ISchemaRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFilterDbListContext differentiates from other interfaces.
	IsFilterDbListContext()
}

type FilterDbListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterDbListContext() *FilterDbListContext {
	var p = new(FilterDbListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterDbList
	return p
}

func InitEmptyFilterDbListContext(p *FilterDbListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterDbList
}

func (*FilterDbListContext) IsFilterDbListContext() {}

func NewFilterDbListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterDbListContext {
	var p = new(FilterDbListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_filterDbList

	return p
}

func (s *FilterDbListContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterDbListContext) AllSchemaRef() []ISchemaRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISchemaRefContext); ok {
			len++
		}
	}

	tst := make([]ISchemaRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISchemaRefContext); ok {
			tst[i] = t.(ISchemaRefContext)
			i++
		}
	}

	return tst
}

func (s *FilterDbListContext) SchemaRef(i int) ISchemaRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *FilterDbListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *FilterDbListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *FilterDbListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterDbListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterDbListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFilterDbList(s)
	}
}

func (s *FilterDbListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFilterDbList(s)
	}
}

func (s *FilterDbListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFilterDbList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FilterDbList() (localctx IFilterDbListContext) {
	localctx = NewFilterDbListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 218, TiDBParserRULE_filterDbList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2042)
		p.SchemaRef()
	}
	p.SetState(2047)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2043)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2044)
			p.SchemaRef()
		}

		p.SetState(2049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterTableListContext is an interface to support dynamic dispatch.
type IFilterTableListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFilterTableRef() []IFilterTableRefContext
	FilterTableRef(i int) IFilterTableRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFilterTableListContext differentiates from other interfaces.
	IsFilterTableListContext()
}

type FilterTableListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterTableListContext() *FilterTableListContext {
	var p = new(FilterTableListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterTableList
	return p
}

func InitEmptyFilterTableListContext(p *FilterTableListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterTableList
}

func (*FilterTableListContext) IsFilterTableListContext() {}

func NewFilterTableListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterTableListContext {
	var p = new(FilterTableListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_filterTableList

	return p
}

func (s *FilterTableListContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterTableListContext) AllFilterTableRef() []IFilterTableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFilterTableRefContext); ok {
			len++
		}
	}

	tst := make([]IFilterTableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFilterTableRefContext); ok {
			tst[i] = t.(IFilterTableRefContext)
			i++
		}
	}

	return tst
}

func (s *FilterTableListContext) FilterTableRef(i int) IFilterTableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterTableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterTableRefContext)
}

func (s *FilterTableListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *FilterTableListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *FilterTableListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterTableListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterTableListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFilterTableList(s)
	}
}

func (s *FilterTableListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFilterTableList(s)
	}
}

func (s *FilterTableListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFilterTableList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FilterTableList() (localctx IFilterTableListContext) {
	localctx = NewFilterTableListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 220, TiDBParserRULE_filterTableList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2050)
		p.FilterTableRef()
	}
	p.SetState(2055)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2051)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2052)
			p.FilterTableRef()
		}

		p.SetState(2057)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterStringListContext is an interface to support dynamic dispatch.
type IFilterStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllFilterWildDbTableString() []IFilterWildDbTableStringContext
	FilterWildDbTableString(i int) IFilterWildDbTableStringContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFilterStringListContext differentiates from other interfaces.
	IsFilterStringListContext()
}

type FilterStringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterStringListContext() *FilterStringListContext {
	var p = new(FilterStringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterStringList
	return p
}

func InitEmptyFilterStringListContext(p *FilterStringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterStringList
}

func (*FilterStringListContext) IsFilterStringListContext() {}

func NewFilterStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterStringListContext {
	var p = new(FilterStringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_filterStringList

	return p
}

func (s *FilterStringListContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterStringListContext) AllFilterWildDbTableString() []IFilterWildDbTableStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFilterWildDbTableStringContext); ok {
			len++
		}
	}

	tst := make([]IFilterWildDbTableStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFilterWildDbTableStringContext); ok {
			tst[i] = t.(IFilterWildDbTableStringContext)
			i++
		}
	}

	return tst
}

func (s *FilterStringListContext) FilterWildDbTableString(i int) IFilterWildDbTableStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFilterWildDbTableStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFilterWildDbTableStringContext)
}

func (s *FilterStringListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *FilterStringListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *FilterStringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterStringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterStringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFilterStringList(s)
	}
}

func (s *FilterStringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFilterStringList(s)
	}
}

func (s *FilterStringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFilterStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FilterStringList() (localctx IFilterStringListContext) {
	localctx = NewFilterStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 222, TiDBParserRULE_filterStringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2058)
		p.FilterWildDbTableString()
	}
	p.SetState(2063)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2059)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2060)
			p.FilterWildDbTableString()
		}

		p.SetState(2065)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterWildDbTableStringContext is an interface to support dynamic dispatch.
type IFilterWildDbTableStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringNoLinebreak() ITextStringNoLinebreakContext

	// IsFilterWildDbTableStringContext differentiates from other interfaces.
	IsFilterWildDbTableStringContext()
}

type FilterWildDbTableStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterWildDbTableStringContext() *FilterWildDbTableStringContext {
	var p = new(FilterWildDbTableStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterWildDbTableString
	return p
}

func InitEmptyFilterWildDbTableStringContext(p *FilterWildDbTableStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterWildDbTableString
}

func (*FilterWildDbTableStringContext) IsFilterWildDbTableStringContext() {}

func NewFilterWildDbTableStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterWildDbTableStringContext {
	var p = new(FilterWildDbTableStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_filterWildDbTableString

	return p
}

func (s *FilterWildDbTableStringContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterWildDbTableStringContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *FilterWildDbTableStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterWildDbTableStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterWildDbTableStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFilterWildDbTableString(s)
	}
}

func (s *FilterWildDbTableStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFilterWildDbTableString(s)
	}
}

func (s *FilterWildDbTableStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFilterWildDbTableString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FilterWildDbTableString() (localctx IFilterWildDbTableStringContext) {
	localctx = NewFilterWildDbTableStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 224, TiDBParserRULE_filterWildDbTableString)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2066)
		p.TextStringNoLinebreak()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterDbPairListContext is an interface to support dynamic dispatch.
type IFilterDbPairListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSchemaIdentifierPair() []ISchemaIdentifierPairContext
	SchemaIdentifierPair(i int) ISchemaIdentifierPairContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsFilterDbPairListContext differentiates from other interfaces.
	IsFilterDbPairListContext()
}

type FilterDbPairListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterDbPairListContext() *FilterDbPairListContext {
	var p = new(FilterDbPairListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterDbPairList
	return p
}

func InitEmptyFilterDbPairListContext(p *FilterDbPairListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterDbPairList
}

func (*FilterDbPairListContext) IsFilterDbPairListContext() {}

func NewFilterDbPairListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterDbPairListContext {
	var p = new(FilterDbPairListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_filterDbPairList

	return p
}

func (s *FilterDbPairListContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterDbPairListContext) AllSchemaIdentifierPair() []ISchemaIdentifierPairContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISchemaIdentifierPairContext); ok {
			len++
		}
	}

	tst := make([]ISchemaIdentifierPairContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISchemaIdentifierPairContext); ok {
			tst[i] = t.(ISchemaIdentifierPairContext)
			i++
		}
	}

	return tst
}

func (s *FilterDbPairListContext) SchemaIdentifierPair(i int) ISchemaIdentifierPairContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaIdentifierPairContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaIdentifierPairContext)
}

func (s *FilterDbPairListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *FilterDbPairListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *FilterDbPairListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterDbPairListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterDbPairListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFilterDbPairList(s)
	}
}

func (s *FilterDbPairListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFilterDbPairList(s)
	}
}

func (s *FilterDbPairListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFilterDbPairList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FilterDbPairList() (localctx IFilterDbPairListContext) {
	localctx = NewFilterDbPairListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 226, TiDBParserRULE_filterDbPairList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2068)
		p.SchemaIdentifierPair()
	}
	p.SetState(2073)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2069)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2070)
			p.SchemaIdentifierPair()
		}

		p.SetState(2075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveContext is an interface to support dynamic dispatch.
type ISlaveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	START_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	SlaveConnectionOptions() ISlaveConnectionOptionsContext
	SlaveThreadOptions() ISlaveThreadOptionsContext
	UNTIL_SYMBOL() antlr.TerminalNode
	SlaveUntilOptions() ISlaveUntilOptionsContext
	Channel() IChannelContext
	STOP_SYMBOL() antlr.TerminalNode

	// IsSlaveContext differentiates from other interfaces.
	IsSlaveContext()
}

type SlaveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveContext() *SlaveContext {
	var p = new(SlaveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slave
	return p
}

func InitEmptySlaveContext(p *SlaveContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slave
}

func (*SlaveContext) IsSlaveContext() {}

func NewSlaveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveContext {
	var p = new(SlaveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_slave

	return p
}

func (s *SlaveContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTART_SYMBOL, 0)
}

func (s *SlaveContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSLAVE_SYMBOL, 0)
}

func (s *SlaveContext) SlaveConnectionOptions() ISlaveConnectionOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveConnectionOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveConnectionOptionsContext)
}

func (s *SlaveContext) SlaveThreadOptions() ISlaveThreadOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveThreadOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveThreadOptionsContext)
}

func (s *SlaveContext) UNTIL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNTIL_SYMBOL, 0)
}

func (s *SlaveContext) SlaveUntilOptions() ISlaveUntilOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveUntilOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveUntilOptionsContext)
}

func (s *SlaveContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *SlaveContext) STOP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTOP_SYMBOL, 0)
}

func (s *SlaveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSlave(s)
	}
}

func (s *SlaveContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSlave(s)
	}
}

func (s *SlaveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSlave(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Slave() (localctx ISlaveContext) {
	localctx = NewSlaveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 228, TiDBParserRULE_slave)
	var _la int

	p.SetState(2097)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserSTART_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2076)
			p.Match(TiDBParserSTART_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2077)
			p.Match(TiDBParserSLAVE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2079)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserRELAY_THREAD_SYMBOL || _la == TiDBParserSQL_THREAD_SYMBOL {
			{
				p.SetState(2078)
				p.SlaveThreadOptions()
			}

		}
		p.SetState(2083)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserUNTIL_SYMBOL {
			{
				p.SetState(2081)
				p.Match(TiDBParserUNTIL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2082)
				p.SlaveUntilOptions()
			}

		}
		{
			p.SetState(2085)
			p.SlaveConnectionOptions()
		}
		p.SetState(2087)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(2086)
				p.Channel()
			}

		}

	case TiDBParserSTOP_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2089)
			p.Match(TiDBParserSTOP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2090)
			p.Match(TiDBParserSLAVE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2092)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserRELAY_THREAD_SYMBOL || _la == TiDBParserSQL_THREAD_SYMBOL {
			{
				p.SetState(2091)
				p.SlaveThreadOptions()
			}

		}
		p.SetState(2095)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(2094)
				p.Channel()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveUntilOptionsContext is an interface to support dynamic dispatch.
type ISlaveUntilOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMasterFileDef() []IMasterFileDefContext
	MasterFileDef(i int) IMasterFileDefContext
	EQUAL_OPERATOR() antlr.TerminalNode
	TextString() ITextStringContext
	SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode
	SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsSlaveUntilOptionsContext differentiates from other interfaces.
	IsSlaveUntilOptionsContext()
}

type SlaveUntilOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveUntilOptionsContext() *SlaveUntilOptionsContext {
	var p = new(SlaveUntilOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slaveUntilOptions
	return p
}

func InitEmptySlaveUntilOptionsContext(p *SlaveUntilOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slaveUntilOptions
}

func (*SlaveUntilOptionsContext) IsSlaveUntilOptionsContext() {}

func NewSlaveUntilOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveUntilOptionsContext {
	var p = new(SlaveUntilOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_slaveUntilOptions

	return p
}

func (s *SlaveUntilOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveUntilOptionsContext) AllMasterFileDef() []IMasterFileDefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IMasterFileDefContext); ok {
			len++
		}
	}

	tst := make([]IMasterFileDefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IMasterFileDefContext); ok {
			tst[i] = t.(IMasterFileDefContext)
			i++
		}
	}

	return tst
}

func (s *SlaveUntilOptionsContext) MasterFileDef(i int) IMasterFileDefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IMasterFileDefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IMasterFileDefContext)
}

func (s *SlaveUntilOptionsContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *SlaveUntilOptionsContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *SlaveUntilOptionsContext) SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, 0)
}

func (s *SlaveUntilOptionsContext) SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_BEFORE_GTIDS_SYMBOL, 0)
}

func (s *SlaveUntilOptionsContext) SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_AFTER_GTIDS_SYMBOL, 0)
}

func (s *SlaveUntilOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *SlaveUntilOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *SlaveUntilOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveUntilOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveUntilOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSlaveUntilOptions(s)
	}
}

func (s *SlaveUntilOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSlaveUntilOptions(s)
	}
}

func (s *SlaveUntilOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSlaveUntilOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SlaveUntilOptions() (localctx ISlaveUntilOptionsContext) {
	localctx = NewSlaveUntilOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 230, TiDBParserRULE_slaveUntilOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2104)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL:
		{
			p.SetState(2099)
			p.MasterFileDef()
		}

	case TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL:
		{
			p.SetState(2100)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserSQL_AFTER_GTIDS_SYMBOL || _la == TiDBParserSQL_BEFORE_GTIDS_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2101)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2102)
			p.TextString()
		}

	case TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL:
		{
			p.SetState(2103)
			p.Match(TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(2110)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2106)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2107)
			p.MasterFileDef()
		}

		p.SetState(2112)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveConnectionOptionsContext is an interface to support dynamic dispatch.
type ISlaveConnectionOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USER_SYMBOL() antlr.TerminalNode
	AllEQUAL_OPERATOR() []antlr.TerminalNode
	EQUAL_OPERATOR(i int) antlr.TerminalNode
	AllTextString() []ITextStringContext
	TextString(i int) ITextStringContext
	PASSWORD_SYMBOL() antlr.TerminalNode
	DEFAULT_AUTH_SYMBOL() antlr.TerminalNode
	PLUGIN_DIR_SYMBOL() antlr.TerminalNode

	// IsSlaveConnectionOptionsContext differentiates from other interfaces.
	IsSlaveConnectionOptionsContext()
}

type SlaveConnectionOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveConnectionOptionsContext() *SlaveConnectionOptionsContext {
	var p = new(SlaveConnectionOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slaveConnectionOptions
	return p
}

func InitEmptySlaveConnectionOptionsContext(p *SlaveConnectionOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slaveConnectionOptions
}

func (*SlaveConnectionOptionsContext) IsSlaveConnectionOptionsContext() {}

func NewSlaveConnectionOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveConnectionOptionsContext {
	var p = new(SlaveConnectionOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_slaveConnectionOptions

	return p
}

func (s *SlaveConnectionOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveConnectionOptionsContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *SlaveConnectionOptionsContext) AllEQUAL_OPERATOR() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserEQUAL_OPERATOR)
}

func (s *SlaveConnectionOptionsContext) EQUAL_OPERATOR(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, i)
}

func (s *SlaveConnectionOptionsContext) AllTextString() []ITextStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringContext); ok {
			len++
		}
	}

	tst := make([]ITextStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringContext); ok {
			tst[i] = t.(ITextStringContext)
			i++
		}
	}

	return tst
}

func (s *SlaveConnectionOptionsContext) TextString(i int) ITextStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *SlaveConnectionOptionsContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *SlaveConnectionOptionsContext) DEFAULT_AUTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_AUTH_SYMBOL, 0)
}

func (s *SlaveConnectionOptionsContext) PLUGIN_DIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUGIN_DIR_SYMBOL, 0)
}

func (s *SlaveConnectionOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveConnectionOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveConnectionOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSlaveConnectionOptions(s)
	}
}

func (s *SlaveConnectionOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSlaveConnectionOptions(s)
	}
}

func (s *SlaveConnectionOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSlaveConnectionOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SlaveConnectionOptions() (localctx ISlaveConnectionOptionsContext) {
	localctx = NewSlaveConnectionOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 232, TiDBParserRULE_slaveConnectionOptions)
	var _la int

	p.SetState(2134)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 217, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2116)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserUSER_SYMBOL {
			{
				p.SetState(2113)
				p.Match(TiDBParserUSER_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2114)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2115)
				p.TextString()
			}

		}
		p.SetState(2121)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserPASSWORD_SYMBOL {
			{
				p.SetState(2118)
				p.Match(TiDBParserPASSWORD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2119)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2120)
				p.TextString()
			}

		}
		p.SetState(2126)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDEFAULT_AUTH_SYMBOL {
			{
				p.SetState(2123)
				p.Match(TiDBParserDEFAULT_AUTH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2124)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2125)
				p.TextString()
			}

		}
		p.SetState(2131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserPLUGIN_DIR_SYMBOL {
			{
				p.SetState(2128)
				p.Match(TiDBParserPLUGIN_DIR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2129)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2130)
				p.TextString()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveThreadOptionsContext is an interface to support dynamic dispatch.
type ISlaveThreadOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSlaveThreadOption() []ISlaveThreadOptionContext
	SlaveThreadOption(i int) ISlaveThreadOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsSlaveThreadOptionsContext differentiates from other interfaces.
	IsSlaveThreadOptionsContext()
}

type SlaveThreadOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveThreadOptionsContext() *SlaveThreadOptionsContext {
	var p = new(SlaveThreadOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slaveThreadOptions
	return p
}

func InitEmptySlaveThreadOptionsContext(p *SlaveThreadOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slaveThreadOptions
}

func (*SlaveThreadOptionsContext) IsSlaveThreadOptionsContext() {}

func NewSlaveThreadOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveThreadOptionsContext {
	var p = new(SlaveThreadOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_slaveThreadOptions

	return p
}

func (s *SlaveThreadOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveThreadOptionsContext) AllSlaveThreadOption() []ISlaveThreadOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISlaveThreadOptionContext); ok {
			len++
		}
	}

	tst := make([]ISlaveThreadOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISlaveThreadOptionContext); ok {
			tst[i] = t.(ISlaveThreadOptionContext)
			i++
		}
	}

	return tst
}

func (s *SlaveThreadOptionsContext) SlaveThreadOption(i int) ISlaveThreadOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISlaveThreadOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISlaveThreadOptionContext)
}

func (s *SlaveThreadOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *SlaveThreadOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *SlaveThreadOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveThreadOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveThreadOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSlaveThreadOptions(s)
	}
}

func (s *SlaveThreadOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSlaveThreadOptions(s)
	}
}

func (s *SlaveThreadOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSlaveThreadOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SlaveThreadOptions() (localctx ISlaveThreadOptionsContext) {
	localctx = NewSlaveThreadOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 234, TiDBParserRULE_slaveThreadOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2136)
		p.SlaveThreadOption()
	}
	p.SetState(2141)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2137)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2138)
			p.SlaveThreadOption()
		}

		p.SetState(2143)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISlaveThreadOptionContext is an interface to support dynamic dispatch.
type ISlaveThreadOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RELAY_THREAD_SYMBOL() antlr.TerminalNode
	SQL_THREAD_SYMBOL() antlr.TerminalNode

	// IsSlaveThreadOptionContext differentiates from other interfaces.
	IsSlaveThreadOptionContext()
}

type SlaveThreadOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySlaveThreadOptionContext() *SlaveThreadOptionContext {
	var p = new(SlaveThreadOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slaveThreadOption
	return p
}

func InitEmptySlaveThreadOptionContext(p *SlaveThreadOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_slaveThreadOption
}

func (*SlaveThreadOptionContext) IsSlaveThreadOptionContext() {}

func NewSlaveThreadOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SlaveThreadOptionContext {
	var p = new(SlaveThreadOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_slaveThreadOption

	return p
}

func (s *SlaveThreadOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SlaveThreadOptionContext) RELAY_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_THREAD_SYMBOL, 0)
}

func (s *SlaveThreadOptionContext) SQL_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_THREAD_SYMBOL, 0)
}

func (s *SlaveThreadOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SlaveThreadOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SlaveThreadOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSlaveThreadOption(s)
	}
}

func (s *SlaveThreadOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSlaveThreadOption(s)
	}
}

func (s *SlaveThreadOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSlaveThreadOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SlaveThreadOption() (localctx ISlaveThreadOptionContext) {
	localctx = NewSlaveThreadOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 236, TiDBParserRULE_slaveThreadOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2144)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserRELAY_THREAD_SYMBOL || _la == TiDBParserSQL_THREAD_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupReplicationContext is an interface to support dynamic dispatch.
type IGroupReplicationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUP_REPLICATION_SYMBOL() antlr.TerminalNode
	START_SYMBOL() antlr.TerminalNode
	STOP_SYMBOL() antlr.TerminalNode

	// IsGroupReplicationContext differentiates from other interfaces.
	IsGroupReplicationContext()
}

type GroupReplicationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupReplicationContext() *GroupReplicationContext {
	var p = new(GroupReplicationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupReplication
	return p
}

func InitEmptyGroupReplicationContext(p *GroupReplicationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupReplication
}

func (*GroupReplicationContext) IsGroupReplicationContext() {}

func NewGroupReplicationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupReplicationContext {
	var p = new(GroupReplicationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_groupReplication

	return p
}

func (s *GroupReplicationContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupReplicationContext) GROUP_REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_REPLICATION_SYMBOL, 0)
}

func (s *GroupReplicationContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTART_SYMBOL, 0)
}

func (s *GroupReplicationContext) STOP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTOP_SYMBOL, 0)
}

func (s *GroupReplicationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupReplicationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupReplicationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGroupReplication(s)
	}
}

func (s *GroupReplicationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGroupReplication(s)
	}
}

func (s *GroupReplicationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGroupReplication(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GroupReplication() (localctx IGroupReplicationContext) {
	localctx = NewGroupReplicationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 238, TiDBParserRULE_groupReplication)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2146)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserSTART_SYMBOL || _la == TiDBParserSTOP_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(2147)
		p.Match(TiDBParserGROUP_REPLICATION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPreparedStatementContext is an interface to support dynamic dispatch.
type IPreparedStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	Identifier() IIdentifierContext
	FROM_SYMBOL() antlr.TerminalNode
	PREPARE_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	UserVariable() IUserVariableContext
	ExecuteStatement() IExecuteStatementContext
	DEALLOCATE_SYMBOL() antlr.TerminalNode
	DROP_SYMBOL() antlr.TerminalNode

	// IsPreparedStatementContext differentiates from other interfaces.
	IsPreparedStatementContext()
}

type PreparedStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyPreparedStatementContext() *PreparedStatementContext {
	var p = new(PreparedStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_preparedStatement
	return p
}

func InitEmptyPreparedStatementContext(p *PreparedStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_preparedStatement
}

func (*PreparedStatementContext) IsPreparedStatementContext() {}

func NewPreparedStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PreparedStatementContext {
	var p = new(PreparedStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_preparedStatement

	return p
}

func (s *PreparedStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *PreparedStatementContext) GetType_() antlr.Token { return s.type_ }

func (s *PreparedStatementContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *PreparedStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PreparedStatementContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *PreparedStatementContext) PREPARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPREPARE_SYMBOL, 0)
}

func (s *PreparedStatementContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *PreparedStatementContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *PreparedStatementContext) ExecuteStatement() IExecuteStatementContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteStatementContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteStatementContext)
}

func (s *PreparedStatementContext) DEALLOCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEALLOCATE_SYMBOL, 0)
}

func (s *PreparedStatementContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDROP_SYMBOL, 0)
}

func (s *PreparedStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PreparedStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PreparedStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPreparedStatement(s)
	}
}

func (s *PreparedStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPreparedStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PreparedStatement() (localctx IPreparedStatementContext) {
	localctx = NewPreparedStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 240, TiDBParserRULE_preparedStatement)
	var _la int

	p.SetState(2160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserPREPARE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2149)

			var _m = p.Match(TiDBParserPREPARE_SYMBOL)

			localctx.(*PreparedStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2150)
			p.Identifier()
		}
		{
			p.SetState(2151)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2154)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserUNDERSCORE_CHARSET, TiDBParserNCHAR_TEXT, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
			{
				p.SetState(2152)
				p.TextLiteral()
			}

		case TiDBParserAT_SIGN_SYMBOL, TiDBParserAT_TEXT_SUFFIX:
			{
				p.SetState(2153)
				p.UserVariable()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case TiDBParserEXECUTE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2156)
			p.ExecuteStatement()
		}

	case TiDBParserDEALLOCATE_SYMBOL, TiDBParserDROP_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2157)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PreparedStatementContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserDEALLOCATE_SYMBOL || _la == TiDBParserDROP_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PreparedStatementContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2158)
			p.Match(TiDBParserPREPARE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2159)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteStatementContext is an interface to support dynamic dispatch.
type IExecuteStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	USING_SYMBOL() antlr.TerminalNode
	ExecuteVarList() IExecuteVarListContext

	// IsExecuteStatementContext differentiates from other interfaces.
	IsExecuteStatementContext()
}

type ExecuteStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteStatementContext() *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_executeStatement
	return p
}

func InitEmptyExecuteStatementContext(p *ExecuteStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_executeStatement
}

func (*ExecuteStatementContext) IsExecuteStatementContext() {}

func NewExecuteStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteStatementContext {
	var p = new(ExecuteStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_executeStatement

	return p
}

func (s *ExecuteStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteStatementContext) EXECUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXECUTE_SYMBOL, 0)
}

func (s *ExecuteStatementContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExecuteStatementContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSING_SYMBOL, 0)
}

func (s *ExecuteStatementContext) ExecuteVarList() IExecuteVarListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExecuteVarListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExecuteVarListContext)
}

func (s *ExecuteStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExecuteStatement(s)
	}
}

func (s *ExecuteStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExecuteStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ExecuteStatement() (localctx IExecuteStatementContext) {
	localctx = NewExecuteStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 242, TiDBParserRULE_executeStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2162)
		p.Match(TiDBParserEXECUTE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2163)
		p.Identifier()
	}
	p.SetState(2166)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserUSING_SYMBOL {
		{
			p.SetState(2164)
			p.Match(TiDBParserUSING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2165)
			p.ExecuteVarList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExecuteVarListContext is an interface to support dynamic dispatch.
type IExecuteVarListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUserVariable() []IUserVariableContext
	UserVariable(i int) IUserVariableContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsExecuteVarListContext differentiates from other interfaces.
	IsExecuteVarListContext()
}

type ExecuteVarListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExecuteVarListContext() *ExecuteVarListContext {
	var p = new(ExecuteVarListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_executeVarList
	return p
}

func InitEmptyExecuteVarListContext(p *ExecuteVarListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_executeVarList
}

func (*ExecuteVarListContext) IsExecuteVarListContext() {}

func NewExecuteVarListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExecuteVarListContext {
	var p = new(ExecuteVarListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_executeVarList

	return p
}

func (s *ExecuteVarListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExecuteVarListContext) AllUserVariable() []IUserVariableContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserVariableContext); ok {
			len++
		}
	}

	tst := make([]IUserVariableContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserVariableContext); ok {
			tst[i] = t.(IUserVariableContext)
			i++
		}
	}

	return tst
}

func (s *ExecuteVarListContext) UserVariable(i int) IUserVariableContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *ExecuteVarListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ExecuteVarListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ExecuteVarListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExecuteVarListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExecuteVarListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExecuteVarList(s)
	}
}

func (s *ExecuteVarListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExecuteVarList(s)
	}
}

func (s *ExecuteVarListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExecuteVarList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ExecuteVarList() (localctx IExecuteVarListContext) {
	localctx = NewExecuteVarListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 244, TiDBParserRULE_executeVarList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2168)
		p.UserVariable()
	}
	p.SetState(2173)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2169)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2170)
			p.UserVariable()
		}

		p.SetState(2175)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICloneStatementContext is an interface to support dynamic dispatch.
type ICloneStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CLONE_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	REMOTE_SYMBOL() antlr.TerminalNode
	INSTANCE_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	User() IUserContext
	COLON_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	Equal() IEqualContext
	FOR_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	DataDirSSL() IDataDirSSLContext

	// IsCloneStatementContext differentiates from other interfaces.
	IsCloneStatementContext()
}

type CloneStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCloneStatementContext() *CloneStatementContext {
	var p = new(CloneStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_cloneStatement
	return p
}

func InitEmptyCloneStatementContext(p *CloneStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_cloneStatement
}

func (*CloneStatementContext) IsCloneStatementContext() {}

func NewCloneStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CloneStatementContext {
	var p = new(CloneStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_cloneStatement

	return p
}

func (s *CloneStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *CloneStatementContext) CLONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLONE_SYMBOL, 0)
}

func (s *CloneStatementContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCAL_SYMBOL, 0)
}

func (s *CloneStatementContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATA_SYMBOL, 0)
}

func (s *CloneStatementContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIRECTORY_SYMBOL, 0)
}

func (s *CloneStatementContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *CloneStatementContext) REMOTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREMOTE_SYMBOL, 0)
}

func (s *CloneStatementContext) INSTANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSTANCE_SYMBOL, 0)
}

func (s *CloneStatementContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *CloneStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CloneStatementContext) COLON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLON_SYMBOL, 0)
}

func (s *CloneStatementContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *CloneStatementContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIDENTIFIED_SYMBOL, 0)
}

func (s *CloneStatementContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *CloneStatementContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *CloneStatementContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *CloneStatementContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATION_SYMBOL, 0)
}

func (s *CloneStatementContext) DataDirSSL() IDataDirSSLContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataDirSSLContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataDirSSLContext)
}

func (s *CloneStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CloneStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CloneStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCloneStatement(s)
	}
}

func (s *CloneStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCloneStatement(s)
	}
}

func (s *CloneStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCloneStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CloneStatement() (localctx ICloneStatementContext) {
	localctx = NewCloneStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 246, TiDBParserRULE_cloneStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2176)
		p.Match(TiDBParserCLONE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2200)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserLOCAL_SYMBOL:
		{
			p.SetState(2177)
			p.Match(TiDBParserLOCAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2178)
			p.Match(TiDBParserDATA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2179)
			p.Match(TiDBParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR || _la == TiDBParserASSIGN_OPERATOR {
			{
				p.SetState(2180)
				p.Equal()
			}

		}
		{
			p.SetState(2183)
			p.TextStringLiteral()
		}

	case TiDBParserREMOTE_SYMBOL:
		{
			p.SetState(2184)
			p.Match(TiDBParserREMOTE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2187)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(2185)
				p.Match(TiDBParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2186)
				p.Match(TiDBParserREPLICATION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserINSTANCE_SYMBOL:
		{
			p.SetState(2189)
			p.Match(TiDBParserINSTANCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2190)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2191)
			p.User()
		}
		{
			p.SetState(2192)
			p.Match(TiDBParserCOLON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2193)
			p.Ulong_number()
		}
		{
			p.SetState(2194)
			p.Match(TiDBParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2195)
			p.Match(TiDBParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2196)
			p.TextStringLiteral()
		}
		p.SetState(2198)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDATA_SYMBOL || _la == TiDBParserREQUIRE_SYMBOL {
			{
				p.SetState(2197)
				p.DataDirSSL()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataDirSSLContext is an interface to support dynamic dispatch.
type IDataDirSSLContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ssl() ISslContext
	DATA_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	Equal() IEqualContext

	// IsDataDirSSLContext differentiates from other interfaces.
	IsDataDirSSLContext()
}

type DataDirSSLContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataDirSSLContext() *DataDirSSLContext {
	var p = new(DataDirSSLContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dataDirSSL
	return p
}

func InitEmptyDataDirSSLContext(p *DataDirSSLContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dataDirSSL
}

func (*DataDirSSLContext) IsDataDirSSLContext() {}

func NewDataDirSSLContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataDirSSLContext {
	var p = new(DataDirSSLContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_dataDirSSL

	return p
}

func (s *DataDirSSLContext) GetParser() antlr.Parser { return s.parser }

func (s *DataDirSSLContext) Ssl() ISslContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISslContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISslContext)
}

func (s *DataDirSSLContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATA_SYMBOL, 0)
}

func (s *DataDirSSLContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIRECTORY_SYMBOL, 0)
}

func (s *DataDirSSLContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *DataDirSSLContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *DataDirSSLContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataDirSSLContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataDirSSLContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDataDirSSL(s)
	}
}

func (s *DataDirSSLContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDataDirSSL(s)
	}
}

func (s *DataDirSSLContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDataDirSSL(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DataDirSSL() (localctx IDataDirSSLContext) {
	localctx = NewDataDirSSLContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 248, TiDBParserRULE_dataDirSSL)
	var _la int

	p.SetState(2212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserREQUIRE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2202)
			p.Ssl()
		}

	case TiDBParserDATA_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2203)
			p.Match(TiDBParserDATA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2204)
			p.Match(TiDBParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2206)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR || _la == TiDBParserASSIGN_OPERATOR {
			{
				p.SetState(2205)
				p.Equal()
			}

		}
		{
			p.SetState(2208)
			p.TextStringLiteral()
		}
		p.SetState(2210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserREQUIRE_SYMBOL {
			{
				p.SetState(2209)
				p.Ssl()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISslContext is an interface to support dynamic dispatch.
type ISslContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REQUIRE_SYMBOL() antlr.TerminalNode
	SSL_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode

	// IsSslContext differentiates from other interfaces.
	IsSslContext()
}

type SslContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySslContext() *SslContext {
	var p = new(SslContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ssl
	return p
}

func InitEmptySslContext(p *SslContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ssl
}

func (*SslContext) IsSslContext() {}

func NewSslContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SslContext {
	var p = new(SslContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_ssl

	return p
}

func (s *SslContext) GetParser() antlr.Parser { return s.parser }

func (s *SslContext) REQUIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREQUIRE_SYMBOL, 0)
}

func (s *SslContext) SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSSL_SYMBOL, 0)
}

func (s *SslContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_SYMBOL, 0)
}

func (s *SslContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SslContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SslContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSsl(s)
	}
}

func (s *SslContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSsl(s)
	}
}

func (s *SslContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSsl(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Ssl() (localctx ISslContext) {
	localctx = NewSslContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 250, TiDBParserRULE_ssl)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2214)
		p.Match(TiDBParserREQUIRE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2216)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserNO_SYMBOL {
		{
			p.SetState(2215)
			p.Match(TiDBParserNO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(2218)
		p.Match(TiDBParserSSL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccountManagementStatementContext is an interface to support dynamic dispatch.
type IAccountManagementStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AlterUser() IAlterUserContext
	CreateUser() ICreateUserContext
	DropUser() IDropUserContext
	Grant() IGrantContext
	RenameUser() IRenameUserContext
	Revoke() IRevokeContext
	SetRole() ISetRoleContext

	// IsAccountManagementStatementContext differentiates from other interfaces.
	IsAccountManagementStatementContext()
}

type AccountManagementStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccountManagementStatementContext() *AccountManagementStatementContext {
	var p = new(AccountManagementStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_accountManagementStatement
	return p
}

func InitEmptyAccountManagementStatementContext(p *AccountManagementStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_accountManagementStatement
}

func (*AccountManagementStatementContext) IsAccountManagementStatementContext() {}

func NewAccountManagementStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccountManagementStatementContext {
	var p = new(AccountManagementStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_accountManagementStatement

	return p
}

func (s *AccountManagementStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *AccountManagementStatementContext) AlterUser() IAlterUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserContext)
}

func (s *AccountManagementStatementContext) CreateUser() ICreateUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserContext)
}

func (s *AccountManagementStatementContext) DropUser() IDropUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropUserContext)
}

func (s *AccountManagementStatementContext) Grant() IGrantContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantContext)
}

func (s *AccountManagementStatementContext) RenameUser() IRenameUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRenameUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRenameUserContext)
}

func (s *AccountManagementStatementContext) Revoke() IRevokeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRevokeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRevokeContext)
}

func (s *AccountManagementStatementContext) SetRole() ISetRoleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetRoleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetRoleContext)
}

func (s *AccountManagementStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccountManagementStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccountManagementStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterAccountManagementStatement(s)
	}
}

func (s *AccountManagementStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitAccountManagementStatement(s)
	}
}

func (s *AccountManagementStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitAccountManagementStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) AccountManagementStatement() (localctx IAccountManagementStatementContext) {
	localctx = NewAccountManagementStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 252, TiDBParserRULE_accountManagementStatement)
	p.SetState(2227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserALTER_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2220)
			p.AlterUser()
		}

	case TiDBParserCREATE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2221)
			p.CreateUser()
		}

	case TiDBParserDROP_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2222)
			p.DropUser()
		}

	case TiDBParserGRANT_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2223)
			p.Grant()
		}

	case TiDBParserRENAME_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2224)
			p.RenameUser()
		}

	case TiDBParserREVOKE_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2225)
			p.Revoke()
		}

	case TiDBParserSET_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2226)
			p.SetRole()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserContext is an interface to support dynamic dispatch.
type IAlterUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	AlterUserTail() IAlterUserTailContext
	IfExists() IIfExistsContext

	// IsAlterUserContext differentiates from other interfaces.
	IsAlterUserContext()
}

type AlterUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserContext() *AlterUserContext {
	var p = new(AlterUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterUser
	return p
}

func InitEmptyAlterUserContext(p *AlterUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterUser
}

func (*AlterUserContext) IsAlterUserContext() {}

func NewAlterUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserContext {
	var p = new(AlterUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_alterUser

	return p
}

func (s *AlterUserContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserContext) ALTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALTER_SYMBOL, 0)
}

func (s *AlterUserContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *AlterUserContext) AlterUserTail() IAlterUserTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserTailContext)
}

func (s *AlterUserContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *AlterUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterAlterUser(s)
	}
}

func (s *AlterUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitAlterUser(s)
	}
}

func (s *AlterUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitAlterUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) AlterUser() (localctx IAlterUserContext) {
	localctx = NewAlterUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 254, TiDBParserRULE_alterUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2229)
		p.Match(TiDBParserALTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2230)
		p.Match(TiDBParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2232)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserIF_SYMBOL {
		{
			p.SetState(2231)
			p.IfExists()
		}

	}
	{
		p.SetState(2234)
		p.AlterUserTail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserTailContext is an interface to support dynamic dispatch.
type IAlterUserTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateUserTail() ICreateUserTailContext
	CreateUserList() ICreateUserListContext
	AlterUserList() IAlterUserListContext
	User() IUserContext
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	ReplacePassword() IReplacePasswordContext
	RetainCurrentPassword() IRetainCurrentPasswordContext
	DiscardOldPassword() IDiscardOldPasswordContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext
	RANDOM_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	FAILED_LOGIN_ATTEMPTS_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	PASSWORD_LOCK_TIME_SYMBOL() antlr.TerminalNode
	UNBOUNDED_SYMBOL() antlr.TerminalNode

	// IsAlterUserTailContext differentiates from other interfaces.
	IsAlterUserTailContext()
}

type AlterUserTailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserTailContext() *AlterUserTailContext {
	var p = new(AlterUserTailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterUserTail
	return p
}

func InitEmptyAlterUserTailContext(p *AlterUserTailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterUserTail
}

func (*AlterUserTailContext) IsAlterUserTailContext() {}

func NewAlterUserTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserTailContext {
	var p = new(AlterUserTailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_alterUserTail

	return p
}

func (s *AlterUserTailContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserTailContext) CreateUserTail() ICreateUserTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserTailContext)
}

func (s *AlterUserTailContext) CreateUserList() ICreateUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserListContext)
}

func (s *AlterUserTailContext) AlterUserList() IAlterUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserListContext)
}

func (s *AlterUserTailContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserTailContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIDENTIFIED_SYMBOL, 0)
}

func (s *AlterUserTailContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *AlterUserTailContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *AlterUserTailContext) ReplacePassword() IReplacePasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePasswordContext)
}

func (s *AlterUserTailContext) RetainCurrentPassword() IRetainCurrentPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainCurrentPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainCurrentPasswordContext)
}

func (s *AlterUserTailContext) DiscardOldPassword() IDiscardOldPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiscardOldPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiscardOldPasswordContext)
}

func (s *AlterUserTailContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *AlterUserTailContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLE_SYMBOL, 0)
}

func (s *AlterUserTailContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *AlterUserTailContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNONE_SYMBOL, 0)
}

func (s *AlterUserTailContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *AlterUserTailContext) RANDOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRANDOM_SYMBOL, 0)
}

func (s *AlterUserTailContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *AlterUserTailContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *AlterUserTailContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *AlterUserTailContext) FAILED_LOGIN_ATTEMPTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, 0)
}

func (s *AlterUserTailContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *AlterUserTailContext) PASSWORD_LOCK_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_LOCK_TIME_SYMBOL, 0)
}

func (s *AlterUserTailContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNBOUNDED_SYMBOL, 0)
}

func (s *AlterUserTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterAlterUserTail(s)
	}
}

func (s *AlterUserTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitAlterUserTail(s)
	}
}

func (s *AlterUserTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitAlterUserTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) AlterUserTail() (localctx IAlterUserTailContext) {
	localctx = NewAlterUserTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 256, TiDBParserRULE_alterUserTail)
	var _la int

	p.SetState(2282)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 240, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2238)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 233, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2236)
				p.CreateUserList()
			}

		case 2:
			{
				p.SetState(2237)
				p.AlterUserList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(2240)
			p.CreateUserTail()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2242)
			p.User()
		}
		{
			p.SetState(2243)
			p.Match(TiDBParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2244)
			p.Match(TiDBParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2245)
			p.TextString()
		}
		p.SetState(2247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserREPLACE_SYMBOL {
			{
				p.SetState(2246)
				p.ReplacePassword()
			}

		}
		p.SetState(2250)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserRETAIN_SYMBOL {
			{
				p.SetState(2249)
				p.RetainCurrentPassword()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2252)
			p.User()
		}
		{
			p.SetState(2253)
			p.DiscardOldPassword()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2255)
			p.User()
		}
		{
			p.SetState(2256)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2257)
			p.Match(TiDBParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2261)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserALL_SYMBOL:
			{
				p.SetState(2258)
				p.Match(TiDBParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TiDBParserNONE_SYMBOL:
			{
				p.SetState(2259)
				p.Match(TiDBParserNONE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
			{
				p.SetState(2260)
				p.RoleList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2263)
			p.User()
		}
		{
			p.SetState(2264)
			p.Match(TiDBParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2267)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWITH_SYMBOL {
			{
				p.SetState(2265)
				p.Match(TiDBParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2266)
				p.TextOrIdentifier()
			}

		}
		{
			p.SetState(2269)
			p.Match(TiDBParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2270)
			p.Match(TiDBParserRANDOM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2271)
			p.Match(TiDBParserPASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserRETAIN_SYMBOL {
			{
				p.SetState(2272)
				p.RetainCurrentPassword()
			}

		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2275)
			p.Match(TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2276)
			p.Real_ulong_number()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2277)
			p.Match(TiDBParserPASSWORD_LOCK_TIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2280)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserHEX_NUMBER:
			{
				p.SetState(2278)
				p.Real_ulong_number()
			}

		case TiDBParserUNBOUNDED_SYMBOL:
			{
				p.SetState(2279)
				p.Match(TiDBParserUNBOUNDED_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserFunctionContext is an interface to support dynamic dispatch.
type IUserFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	USER_SYMBOL() antlr.TerminalNode
	Parentheses() IParenthesesContext

	// IsUserFunctionContext differentiates from other interfaces.
	IsUserFunctionContext()
}

type UserFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserFunctionContext() *UserFunctionContext {
	var p = new(UserFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_userFunction
	return p
}

func InitEmptyUserFunctionContext(p *UserFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_userFunction
}

func (*UserFunctionContext) IsUserFunctionContext() {}

func NewUserFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserFunctionContext {
	var p = new(UserFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_userFunction

	return p
}

func (s *UserFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *UserFunctionContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *UserFunctionContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *UserFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUserFunction(s)
	}
}

func (s *UserFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUserFunction(s)
	}
}

func (s *UserFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUserFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UserFunction() (localctx IUserFunctionContext) {
	localctx = NewUserFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 258, TiDBParserRULE_userFunction)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2284)
		p.Match(TiDBParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2285)
		p.Parentheses()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserContext is an interface to support dynamic dispatch.
type ICreateUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	CreateUserList() ICreateUserListContext
	DefaultRoleClause() IDefaultRoleClauseContext
	CreateUserTail() ICreateUserTailContext
	IfNotExists() IIfNotExistsContext

	// IsCreateUserContext differentiates from other interfaces.
	IsCreateUserContext()
}

type CreateUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserContext() *CreateUserContext {
	var p = new(CreateUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createUser
	return p
}

func InitEmptyCreateUserContext(p *CreateUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createUser
}

func (*CreateUserContext) IsCreateUserContext() {}

func NewCreateUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserContext {
	var p = new(CreateUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_createUser

	return p
}

func (s *CreateUserContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCREATE_SYMBOL, 0)
}

func (s *CreateUserContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *CreateUserContext) CreateUserList() ICreateUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserListContext)
}

func (s *CreateUserContext) DefaultRoleClause() IDefaultRoleClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultRoleClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultRoleClauseContext)
}

func (s *CreateUserContext) CreateUserTail() ICreateUserTailContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserTailContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserTailContext)
}

func (s *CreateUserContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *CreateUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCreateUser(s)
	}
}

func (s *CreateUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCreateUser(s)
	}
}

func (s *CreateUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCreateUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CreateUser() (localctx ICreateUserContext) {
	localctx = NewCreateUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 260, TiDBParserRULE_createUser)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2287)
		p.Match(TiDBParserCREATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2288)
		p.Match(TiDBParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserIF_SYMBOL:
		{
			p.SetState(2289)
			p.IfNotExists()
		}

	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURRENT_USER_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(2293)
		p.CreateUserList()
	}
	{
		p.SetState(2294)
		p.DefaultRoleClause()
	}
	{
		p.SetState(2295)
		p.CreateUserTail()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserTailContext is an interface to support dynamic dispatch.
type ICreateUserTailContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RequireClause() IRequireClauseContext
	ConnectOptions() IConnectOptionsContext
	AllAccountLockPasswordExpireOptions() []IAccountLockPasswordExpireOptionsContext
	AccountLockPasswordExpireOptions(i int) IAccountLockPasswordExpireOptionsContext
	COMMENT_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	ATTRIBUTE_SYMBOL() antlr.TerminalNode

	// IsCreateUserTailContext differentiates from other interfaces.
	IsCreateUserTailContext()
}

type CreateUserTailContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserTailContext() *CreateUserTailContext {
	var p = new(CreateUserTailContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createUserTail
	return p
}

func InitEmptyCreateUserTailContext(p *CreateUserTailContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createUserTail
}

func (*CreateUserTailContext) IsCreateUserTailContext() {}

func NewCreateUserTailContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserTailContext {
	var p = new(CreateUserTailContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_createUserTail

	return p
}

func (s *CreateUserTailContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserTailContext) RequireClause() IRequireClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequireClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequireClauseContext)
}

func (s *CreateUserTailContext) ConnectOptions() IConnectOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConnectOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConnectOptionsContext)
}

func (s *CreateUserTailContext) AllAccountLockPasswordExpireOptions() []IAccountLockPasswordExpireOptionsContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAccountLockPasswordExpireOptionsContext); ok {
			len++
		}
	}

	tst := make([]IAccountLockPasswordExpireOptionsContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAccountLockPasswordExpireOptionsContext); ok {
			tst[i] = t.(IAccountLockPasswordExpireOptionsContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserTailContext) AccountLockPasswordExpireOptions(i int) IAccountLockPasswordExpireOptionsContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccountLockPasswordExpireOptionsContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccountLockPasswordExpireOptionsContext)
}

func (s *CreateUserTailContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMENT_SYMBOL, 0)
}

func (s *CreateUserTailContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *CreateUserTailContext) ATTRIBUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserATTRIBUTE_SYMBOL, 0)
}

func (s *CreateUserTailContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserTailContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserTailContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCreateUserTail(s)
	}
}

func (s *CreateUserTailContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCreateUserTail(s)
	}
}

func (s *CreateUserTailContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCreateUserTail(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CreateUserTail() (localctx ICreateUserTailContext) {
	localctx = NewCreateUserTailContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 262, TiDBParserRULE_createUserTail)
	var _la int

	p.SetState(2316)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 246, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserREQUIRE_SYMBOL {
			{
				p.SetState(2297)
				p.RequireClause()
			}

		}
		p.SetState(2301)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWITH_SYMBOL {
			{
				p.SetState(2300)
				p.ConnectOptions()
			}

		}
		p.SetState(2306)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserACCOUNT_SYMBOL || _la == TiDBParserPASSWORD_SYMBOL {
			{
				p.SetState(2303)
				p.AccountLockPasswordExpireOptions()
			}

			p.SetState(2308)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(2313)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case TiDBParserCOMMENT_SYMBOL:
			{
				p.SetState(2309)
				p.Match(TiDBParserCOMMENT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2310)
				p.TextStringLiteral()
			}

		case TiDBParserATTRIBUTE_SYMBOL:
			{
				p.SetState(2311)
				p.Match(TiDBParserATTRIBUTE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2312)
				p.TextStringLiteral()
			}

		case TiDBParserEOF:

		default:
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultRoleClauseContext is an interface to support dynamic dispatch.
type IDefaultRoleClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFAULT_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsDefaultRoleClauseContext differentiates from other interfaces.
	IsDefaultRoleClauseContext()
}

type DefaultRoleClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultRoleClauseContext() *DefaultRoleClauseContext {
	var p = new(DefaultRoleClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_defaultRoleClause
	return p
}

func InitEmptyDefaultRoleClauseContext(p *DefaultRoleClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_defaultRoleClause
}

func (*DefaultRoleClauseContext) IsDefaultRoleClauseContext() {}

func NewDefaultRoleClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultRoleClauseContext {
	var p = new(DefaultRoleClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_defaultRoleClause

	return p
}

func (s *DefaultRoleClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultRoleClauseContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *DefaultRoleClauseContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLE_SYMBOL, 0)
}

func (s *DefaultRoleClauseContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *DefaultRoleClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultRoleClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultRoleClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDefaultRoleClause(s)
	}
}

func (s *DefaultRoleClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDefaultRoleClause(s)
	}
}

func (s *DefaultRoleClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDefaultRoleClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DefaultRoleClause() (localctx IDefaultRoleClauseContext) {
	localctx = NewDefaultRoleClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 264, TiDBParserRULE_defaultRoleClause)
	var _la int

	p.SetState(2324)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 248, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2321)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDEFAULT_SYMBOL {
			{
				p.SetState(2318)
				p.Match(TiDBParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2319)
				p.Match(TiDBParserROLE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2320)
				p.RoleList()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequireClauseContext is an interface to support dynamic dispatch.
type IRequireClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	REQUIRE_SYMBOL() antlr.TerminalNode
	RequireList() IRequireListContext
	SSL_SYMBOL() antlr.TerminalNode
	X509_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode

	// IsRequireClauseContext differentiates from other interfaces.
	IsRequireClauseContext()
}

type RequireClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyRequireClauseContext() *RequireClauseContext {
	var p = new(RequireClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_requireClause
	return p
}

func InitEmptyRequireClauseContext(p *RequireClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_requireClause
}

func (*RequireClauseContext) IsRequireClauseContext() {}

func NewRequireClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequireClauseContext {
	var p = new(RequireClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_requireClause

	return p
}

func (s *RequireClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *RequireClauseContext) GetOption() antlr.Token { return s.option }

func (s *RequireClauseContext) SetOption(v antlr.Token) { s.option = v }

func (s *RequireClauseContext) REQUIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREQUIRE_SYMBOL, 0)
}

func (s *RequireClauseContext) RequireList() IRequireListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequireListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequireListContext)
}

func (s *RequireClauseContext) SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSSL_SYMBOL, 0)
}

func (s *RequireClauseContext) X509_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserX509_SYMBOL, 0)
}

func (s *RequireClauseContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNONE_SYMBOL, 0)
}

func (s *RequireClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequireClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequireClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRequireClause(s)
	}
}

func (s *RequireClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRequireClause(s)
	}
}

func (s *RequireClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRequireClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RequireClause() (localctx IRequireClauseContext) {
	localctx = NewRequireClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 266, TiDBParserRULE_requireClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2326)
		p.Match(TiDBParserREQUIRE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2329)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCIPHER_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserSUBJECT_SYMBOL:
		{
			p.SetState(2327)
			p.RequireList()
		}

	case TiDBParserNONE_SYMBOL, TiDBParserSSL_SYMBOL, TiDBParserX509_SYMBOL:
		{
			p.SetState(2328)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RequireClauseContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserNONE_SYMBOL || _la == TiDBParserSSL_SYMBOL || _la == TiDBParserX509_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RequireClauseContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IConnectOptionsContext is an interface to support dynamic dispatch.
type IConnectOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	AllMAX_QUERIES_PER_HOUR_SYMBOL() []antlr.TerminalNode
	MAX_QUERIES_PER_HOUR_SYMBOL(i int) antlr.TerminalNode
	AllUlong_number() []IUlong_numberContext
	Ulong_number(i int) IUlong_numberContext
	AllMAX_UPDATES_PER_HOUR_SYMBOL() []antlr.TerminalNode
	MAX_UPDATES_PER_HOUR_SYMBOL(i int) antlr.TerminalNode
	AllMAX_CONNECTIONS_PER_HOUR_SYMBOL() []antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR_SYMBOL(i int) antlr.TerminalNode
	AllMAX_USER_CONNECTIONS_SYMBOL() []antlr.TerminalNode
	MAX_USER_CONNECTIONS_SYMBOL(i int) antlr.TerminalNode

	// IsConnectOptionsContext differentiates from other interfaces.
	IsConnectOptionsContext()
}

type ConnectOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConnectOptionsContext() *ConnectOptionsContext {
	var p = new(ConnectOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_connectOptions
	return p
}

func InitEmptyConnectOptionsContext(p *ConnectOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_connectOptions
}

func (*ConnectOptionsContext) IsConnectOptionsContext() {}

func NewConnectOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConnectOptionsContext {
	var p = new(ConnectOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_connectOptions

	return p
}

func (s *ConnectOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *ConnectOptionsContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *ConnectOptionsContext) AllMAX_QUERIES_PER_HOUR_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL)
}

func (s *ConnectOptionsContext) MAX_QUERIES_PER_HOUR_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, i)
}

func (s *ConnectOptionsContext) AllUlong_number() []IUlong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUlong_numberContext); ok {
			len++
		}
	}

	tst := make([]IUlong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUlong_numberContext); ok {
			tst[i] = t.(IUlong_numberContext)
			i++
		}
	}

	return tst
}

func (s *ConnectOptionsContext) Ulong_number(i int) IUlong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *ConnectOptionsContext) AllMAX_UPDATES_PER_HOUR_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL)
}

func (s *ConnectOptionsContext) MAX_UPDATES_PER_HOUR_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, i)
}

func (s *ConnectOptionsContext) AllMAX_CONNECTIONS_PER_HOUR_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL)
}

func (s *ConnectOptionsContext) MAX_CONNECTIONS_PER_HOUR_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, i)
}

func (s *ConnectOptionsContext) AllMAX_USER_CONNECTIONS_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserMAX_USER_CONNECTIONS_SYMBOL)
}

func (s *ConnectOptionsContext) MAX_USER_CONNECTIONS_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_USER_CONNECTIONS_SYMBOL, i)
}

func (s *ConnectOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConnectOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ConnectOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterConnectOptions(s)
	}
}

func (s *ConnectOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitConnectOptions(s)
	}
}

func (s *ConnectOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitConnectOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ConnectOptions() (localctx IConnectOptionsContext) {
	localctx = NewConnectOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 268, TiDBParserRULE_connectOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2331)
		p.Match(TiDBParserWITH_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2340)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&195) != 0) {
		p.SetState(2340)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL:
			{
				p.SetState(2332)
				p.Match(TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2333)
				p.Ulong_number()
			}

		case TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL:
			{
				p.SetState(2334)
				p.Match(TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2335)
				p.Ulong_number()
			}

		case TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL:
			{
				p.SetState(2336)
				p.Match(TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2337)
				p.Ulong_number()
			}

		case TiDBParserMAX_USER_CONNECTIONS_SYMBOL:
			{
				p.SetState(2338)
				p.Match(TiDBParserMAX_USER_CONNECTIONS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2339)
				p.Ulong_number()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

		p.SetState(2342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAccountLockPasswordExpireOptionsContext is an interface to support dynamic dispatch.
type IAccountLockPasswordExpireOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT_SYMBOL() antlr.TerminalNode
	LOCK_SYMBOL() antlr.TerminalNode
	UNLOCK_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	EXPIRE_SYMBOL() antlr.TerminalNode
	HISTORY_SYMBOL() antlr.TerminalNode
	REUSE_SYMBOL() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	REQUIRE_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	NEVER_SYMBOL() antlr.TerminalNode
	OPTIONAL_SYMBOL() antlr.TerminalNode

	// IsAccountLockPasswordExpireOptionsContext differentiates from other interfaces.
	IsAccountLockPasswordExpireOptionsContext()
}

type AccountLockPasswordExpireOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccountLockPasswordExpireOptionsContext() *AccountLockPasswordExpireOptionsContext {
	var p = new(AccountLockPasswordExpireOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_accountLockPasswordExpireOptions
	return p
}

func InitEmptyAccountLockPasswordExpireOptionsContext(p *AccountLockPasswordExpireOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_accountLockPasswordExpireOptions
}

func (*AccountLockPasswordExpireOptionsContext) IsAccountLockPasswordExpireOptionsContext() {}

func NewAccountLockPasswordExpireOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccountLockPasswordExpireOptionsContext {
	var p = new(AccountLockPasswordExpireOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_accountLockPasswordExpireOptions

	return p
}

func (s *AccountLockPasswordExpireOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *AccountLockPasswordExpireOptionsContext) ACCOUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserACCOUNT_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCK_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) UNLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNLOCK_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) EXPIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXPIRE_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) HISTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHISTORY_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) REUSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREUSE_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTERVAL_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) REQUIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREQUIRE_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURRENT_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *AccountLockPasswordExpireOptionsContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDAY_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) NEVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNEVER_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) OPTIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTIONAL_SYMBOL, 0)
}

func (s *AccountLockPasswordExpireOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccountLockPasswordExpireOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AccountLockPasswordExpireOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterAccountLockPasswordExpireOptions(s)
	}
}

func (s *AccountLockPasswordExpireOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitAccountLockPasswordExpireOptions(s)
	}
}

func (s *AccountLockPasswordExpireOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitAccountLockPasswordExpireOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) AccountLockPasswordExpireOptions() (localctx IAccountLockPasswordExpireOptionsContext) {
	localctx = NewAccountLockPasswordExpireOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 270, TiDBParserRULE_accountLockPasswordExpireOptions)
	var _la int

	p.SetState(2376)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2344)
			p.Match(TiDBParserACCOUNT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2345)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserLOCK_SYMBOL || _la == TiDBParserUNLOCK_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case TiDBParserPASSWORD_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2346)
			p.Match(TiDBParserPASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2374)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserEXPIRE_SYMBOL:
			{
				p.SetState(2347)
				p.Match(TiDBParserEXPIRE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2354)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			switch p.GetTokenStream().LA(1) {
			case TiDBParserINTERVAL_SYMBOL:
				{
					p.SetState(2348)
					p.Match(TiDBParserINTERVAL_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2349)
					p.Real_ulong_number()
				}
				{
					p.SetState(2350)
					p.Match(TiDBParserDAY_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case TiDBParserNEVER_SYMBOL:
				{
					p.SetState(2352)
					p.Match(TiDBParserNEVER_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case TiDBParserDEFAULT_SYMBOL:
				{
					p.SetState(2353)
					p.Match(TiDBParserDEFAULT_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case TiDBParserEOF, TiDBParserACCOUNT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserATTRIBUTE_SYMBOL:

			default:
			}

		case TiDBParserHISTORY_SYMBOL:
			{
				p.SetState(2356)
				p.Match(TiDBParserHISTORY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2359)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserHEX_NUMBER:
				{
					p.SetState(2357)
					p.Real_ulong_number()
				}

			case TiDBParserDEFAULT_SYMBOL:
				{
					p.SetState(2358)
					p.Match(TiDBParserDEFAULT_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		case TiDBParserREUSE_SYMBOL:
			{
				p.SetState(2361)
				p.Match(TiDBParserREUSE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2362)
				p.Match(TiDBParserINTERVAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2367)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserHEX_NUMBER:
				{
					p.SetState(2363)
					p.Real_ulong_number()
				}
				{
					p.SetState(2364)
					p.Match(TiDBParserDAY_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case TiDBParserDEFAULT_SYMBOL:
				{
					p.SetState(2366)
					p.Match(TiDBParserDEFAULT_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		case TiDBParserREQUIRE_SYMBOL:
			{
				p.SetState(2369)
				p.Match(TiDBParserREQUIRE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2370)
				p.Match(TiDBParserCURRENT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2372)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserOPTIONAL_SYMBOL {
				{
					p.SetState(2371)
					_la = p.GetTokenStream().LA(1)

					if !(_la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserOPTIONAL_SYMBOL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropUserContext is an interface to support dynamic dispatch.
type IDropUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	UserList() IUserListContext
	IfExists() IIfExistsContext

	// IsDropUserContext differentiates from other interfaces.
	IsDropUserContext()
}

type DropUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropUserContext() *DropUserContext {
	var p = new(DropUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dropUser
	return p
}

func InitEmptyDropUserContext(p *DropUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dropUser
}

func (*DropUserContext) IsDropUserContext() {}

func NewDropUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropUserContext {
	var p = new(DropUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_dropUser

	return p
}

func (s *DropUserContext) GetParser() antlr.Parser { return s.parser }

func (s *DropUserContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDROP_SYMBOL, 0)
}

func (s *DropUserContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *DropUserContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *DropUserContext) IfExists() IIfExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfExistsContext)
}

func (s *DropUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDropUser(s)
	}
}

func (s *DropUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDropUser(s)
	}
}

func (s *DropUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDropUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DropUser() (localctx IDropUserContext) {
	localctx = NewDropUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 272, TiDBParserRULE_dropUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2378)
		p.Match(TiDBParserDROP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2379)
		p.Match(TiDBParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2381)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserIF_SYMBOL {
		{
			p.SetState(2380)
			p.IfExists()
		}

	}
	{
		p.SetState(2383)
		p.UserList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantContext is an interface to support dynamic dispatch.
type IGrantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGRANT_SYMBOL() []antlr.TerminalNode
	GRANT_SYMBOL(i int) antlr.TerminalNode
	RoleOrPrivilegesList() IRoleOrPrivilegesListContext
	TO_SYMBOL() antlr.TerminalNode
	UserList() IUserListContext
	ON_SYMBOL() antlr.TerminalNode
	GrantIdentifier() IGrantIdentifierContext
	GrantTargetList() IGrantTargetListContext
	PROXY_SYMBOL() antlr.TerminalNode
	User() IUserContext
	ALL_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode
	ADMIN_SYMBOL() antlr.TerminalNode
	OPTION_SYMBOL() antlr.TerminalNode
	AclType() IAclTypeContext
	VersionedRequireClause() IVersionedRequireClauseContext
	GrantOptions() IGrantOptionsContext
	GrantAs() IGrantAsContext
	PRIVILEGES_SYMBOL() antlr.TerminalNode

	// IsGrantContext differentiates from other interfaces.
	IsGrantContext()
}

type GrantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantContext() *GrantContext {
	var p = new(GrantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grant
	return p
}

func InitEmptyGrantContext(p *GrantContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grant
}

func (*GrantContext) IsGrantContext() {}

func NewGrantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantContext {
	var p = new(GrantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_grant

	return p
}

func (s *GrantContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantContext) AllGRANT_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserGRANT_SYMBOL)
}

func (s *GrantContext) GRANT_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserGRANT_SYMBOL, i)
}

func (s *GrantContext) RoleOrPrivilegesList() IRoleOrPrivilegesListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrPrivilegesListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrPrivilegesListContext)
}

func (s *GrantContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTO_SYMBOL, 0)
}

func (s *GrantContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *GrantContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *GrantContext) GrantIdentifier() IGrantIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantIdentifierContext)
}

func (s *GrantContext) GrantTargetList() IGrantTargetListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantTargetListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantTargetListContext)
}

func (s *GrantContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROXY_SYMBOL, 0)
}

func (s *GrantContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *GrantContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *GrantContext) ADMIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserADMIN_SYMBOL, 0)
}

func (s *GrantContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTION_SYMBOL, 0)
}

func (s *GrantContext) AclType() IAclTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAclTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAclTypeContext)
}

func (s *GrantContext) VersionedRequireClause() IVersionedRequireClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionedRequireClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionedRequireClauseContext)
}

func (s *GrantContext) GrantOptions() IGrantOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantOptionsContext)
}

func (s *GrantContext) GrantAs() IGrantAsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantAsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantAsContext)
}

func (s *GrantContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIVILEGES_SYMBOL, 0)
}

func (s *GrantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGrant(s)
	}
}

func (s *GrantContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGrant(s)
	}
}

func (s *GrantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGrant(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Grant() (localctx IGrantContext) {
	localctx = NewGrantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 274, TiDBParserRULE_grant)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2385)
		p.Match(TiDBParserGRANT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2427)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 267, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2386)
			p.RoleOrPrivilegesList()
		}
		{
			p.SetState(2387)
			p.Match(TiDBParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2388)
			p.UserList()
		}
		p.SetState(2392)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWITH_SYMBOL {
			{
				p.SetState(2389)
				p.Match(TiDBParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2390)
				p.Match(TiDBParserADMIN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2391)
				p.Match(TiDBParserOPTION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.SetState(2399)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALTER_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCREATE_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDELETE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDROP_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANT_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINDEX_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOAD_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOCK_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserREFERENCES_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSELECT_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHOW_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRIGGER_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPDATE_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSAGE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
			{
				p.SetState(2394)
				p.RoleOrPrivilegesList()
			}

		case TiDBParserALL_SYMBOL:
			{
				p.SetState(2395)
				p.Match(TiDBParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2397)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserPRIVILEGES_SYMBOL {
				{
					p.SetState(2396)
					p.Match(TiDBParserPRIVILEGES_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2401)
			p.Match(TiDBParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2403)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 262, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2402)
				p.AclType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2405)
			p.GrantIdentifier()
		}
		{
			p.SetState(2406)
			p.Match(TiDBParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2407)
			p.GrantTargetList()
		}
		p.SetState(2409)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserREQUIRE_SYMBOL {
			{
				p.SetState(2408)
				p.VersionedRequireClause()
			}

		}
		p.SetState(2412)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWITH_SYMBOL {
			{
				p.SetState(2411)
				p.GrantOptions()
			}

		}
		p.SetState(2415)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserAS_SYMBOL {
			{
				p.SetState(2414)
				p.GrantAs()
			}

		}

	case 3:
		{
			p.SetState(2417)
			p.Match(TiDBParserPROXY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2418)
			p.Match(TiDBParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2419)
			p.User()
		}
		{
			p.SetState(2420)
			p.Match(TiDBParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2421)
			p.GrantTargetList()
		}
		p.SetState(2425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWITH_SYMBOL {
			{
				p.SetState(2422)
				p.Match(TiDBParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2423)
				p.Match(TiDBParserGRANT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2424)
				p.Match(TiDBParserOPTION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantTargetListContext is an interface to support dynamic dispatch.
type IGrantTargetListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateUserList() ICreateUserListContext
	UserList() IUserListContext

	// IsGrantTargetListContext differentiates from other interfaces.
	IsGrantTargetListContext()
}

type GrantTargetListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantTargetListContext() *GrantTargetListContext {
	var p = new(GrantTargetListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantTargetList
	return p
}

func InitEmptyGrantTargetListContext(p *GrantTargetListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantTargetList
}

func (*GrantTargetListContext) IsGrantTargetListContext() {}

func NewGrantTargetListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantTargetListContext {
	var p = new(GrantTargetListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_grantTargetList

	return p
}

func (s *GrantTargetListContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantTargetListContext) CreateUserList() ICreateUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserListContext)
}

func (s *GrantTargetListContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *GrantTargetListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantTargetListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantTargetListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGrantTargetList(s)
	}
}

func (s *GrantTargetListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGrantTargetList(s)
	}
}

func (s *GrantTargetListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGrantTargetList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GrantTargetList() (localctx IGrantTargetListContext) {
	localctx = NewGrantTargetListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 276, TiDBParserRULE_grantTargetList)
	p.SetState(2431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 268, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2429)
			p.CreateUserList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2430)
			p.UserList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantOptionsContext is an interface to support dynamic dispatch.
type IGrantOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	AllGrantOption() []IGrantOptionContext
	GrantOption(i int) IGrantOptionContext
	GRANT_SYMBOL() antlr.TerminalNode
	OPTION_SYMBOL() antlr.TerminalNode

	// IsGrantOptionsContext differentiates from other interfaces.
	IsGrantOptionsContext()
}

type GrantOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantOptionsContext() *GrantOptionsContext {
	var p = new(GrantOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantOptions
	return p
}

func InitEmptyGrantOptionsContext(p *GrantOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantOptions
}

func (*GrantOptionsContext) IsGrantOptionsContext() {}

func NewGrantOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantOptionsContext {
	var p = new(GrantOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_grantOptions

	return p
}

func (s *GrantOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantOptionsContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *GrantOptionsContext) AllGrantOption() []IGrantOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGrantOptionContext); ok {
			len++
		}
	}

	tst := make([]IGrantOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGrantOptionContext); ok {
			tst[i] = t.(IGrantOptionContext)
			i++
		}
	}

	return tst
}

func (s *GrantOptionsContext) GrantOption(i int) IGrantOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantOptionContext)
}

func (s *GrantOptionsContext) GRANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGRANT_SYMBOL, 0)
}

func (s *GrantOptionsContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTION_SYMBOL, 0)
}

func (s *GrantOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGrantOptions(s)
	}
}

func (s *GrantOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGrantOptions(s)
	}
}

func (s *GrantOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGrantOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GrantOptions() (localctx IGrantOptionsContext) {
	localctx = NewGrantOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 278, TiDBParserRULE_grantOptions)
	var _la int

	p.SetState(2442)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 270, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2433)
			p.Match(TiDBParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2435)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TiDBParserGRANT_SYMBOL || ((int64((_la-321)) & ^0x3f) == 0 && ((int64(1)<<(_la-321))&195) != 0) {
			{
				p.SetState(2434)
				p.GrantOption()
			}

			p.SetState(2437)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2439)
			p.Match(TiDBParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2440)
			p.Match(TiDBParserGRANT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2441)
			p.Match(TiDBParserOPTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExceptRoleListContext is an interface to support dynamic dispatch.
type IExceptRoleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXCEPT_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext

	// IsExceptRoleListContext differentiates from other interfaces.
	IsExceptRoleListContext()
}

type ExceptRoleListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExceptRoleListContext() *ExceptRoleListContext {
	var p = new(ExceptRoleListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_exceptRoleList
	return p
}

func InitEmptyExceptRoleListContext(p *ExceptRoleListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_exceptRoleList
}

func (*ExceptRoleListContext) IsExceptRoleListContext() {}

func NewExceptRoleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExceptRoleListContext {
	var p = new(ExceptRoleListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_exceptRoleList

	return p
}

func (s *ExceptRoleListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExceptRoleListContext) EXCEPT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXCEPT_SYMBOL, 0)
}

func (s *ExceptRoleListContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *ExceptRoleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExceptRoleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExceptRoleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExceptRoleList(s)
	}
}

func (s *ExceptRoleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExceptRoleList(s)
	}
}

func (s *ExceptRoleListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExceptRoleList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ExceptRoleList() (localctx IExceptRoleListContext) {
	localctx = NewExceptRoleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 280, TiDBParserRULE_exceptRoleList)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2444)
		p.Match(TiDBParserEXCEPT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2445)
		p.RoleList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWithRolesContext is an interface to support dynamic dispatch.
type IWithRolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WITH_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	RoleList() IRoleListContext
	ALL_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	ExceptRoleList() IExceptRoleListContext

	// IsWithRolesContext differentiates from other interfaces.
	IsWithRolesContext()
}

type WithRolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithRolesContext() *WithRolesContext {
	var p = new(WithRolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_withRoles
	return p
}

func InitEmptyWithRolesContext(p *WithRolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_withRoles
}

func (*WithRolesContext) IsWithRolesContext() {}

func NewWithRolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithRolesContext {
	var p = new(WithRolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_withRoles

	return p
}

func (s *WithRolesContext) GetParser() antlr.Parser { return s.parser }

func (s *WithRolesContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *WithRolesContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLE_SYMBOL, 0)
}

func (s *WithRolesContext) RoleList() IRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *WithRolesContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *WithRolesContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNONE_SYMBOL, 0)
}

func (s *WithRolesContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *WithRolesContext) ExceptRoleList() IExceptRoleListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExceptRoleListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExceptRoleListContext)
}

func (s *WithRolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithRolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WithRolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWithRoles(s)
	}
}

func (s *WithRolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWithRoles(s)
	}
}

func (s *WithRolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWithRoles(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WithRoles() (localctx IWithRolesContext) {
	localctx = NewWithRolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 282, TiDBParserRULE_withRoles)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2447)
		p.Match(TiDBParserWITH_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2448)
		p.Match(TiDBParserROLE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		{
			p.SetState(2449)
			p.RoleList()
		}

	case TiDBParserALL_SYMBOL:
		{
			p.SetState(2450)
			p.Match(TiDBParserALL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2452)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEXCEPT_SYMBOL {
			{
				p.SetState(2451)
				p.ExceptRoleList()
			}

		}

	case TiDBParserNONE_SYMBOL:
		{
			p.SetState(2454)
			p.Match(TiDBParserNONE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserDEFAULT_SYMBOL:
		{
			p.SetState(2455)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantAsContext is an interface to support dynamic dispatch.
type IGrantAsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AS_SYMBOL() antlr.TerminalNode
	User() IUserContext
	WithRoles() IWithRolesContext

	// IsGrantAsContext differentiates from other interfaces.
	IsGrantAsContext()
}

type GrantAsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantAsContext() *GrantAsContext {
	var p = new(GrantAsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantAs
	return p
}

func InitEmptyGrantAsContext(p *GrantAsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantAs
}

func (*GrantAsContext) IsGrantAsContext() {}

func NewGrantAsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantAsContext {
	var p = new(GrantAsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_grantAs

	return p
}

func (s *GrantAsContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantAsContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *GrantAsContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *GrantAsContext) WithRoles() IWithRolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithRolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithRolesContext)
}

func (s *GrantAsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantAsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantAsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGrantAs(s)
	}
}

func (s *GrantAsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGrantAs(s)
	}
}

func (s *GrantAsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGrantAs(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GrantAs() (localctx IGrantAsContext) {
	localctx = NewGrantAsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 284, TiDBParserRULE_grantAs)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2458)
		p.Match(TiDBParserAS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2459)
		p.User()
	}
	p.SetState(2461)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserWITH_SYMBOL {
		{
			p.SetState(2460)
			p.WithRoles()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVersionedRequireClauseContext is an interface to support dynamic dispatch.
type IVersionedRequireClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RequireClause() IRequireClauseContext

	// IsVersionedRequireClauseContext differentiates from other interfaces.
	IsVersionedRequireClauseContext()
}

type VersionedRequireClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionedRequireClauseContext() *VersionedRequireClauseContext {
	var p = new(VersionedRequireClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_versionedRequireClause
	return p
}

func InitEmptyVersionedRequireClauseContext(p *VersionedRequireClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_versionedRequireClause
}

func (*VersionedRequireClauseContext) IsVersionedRequireClauseContext() {}

func NewVersionedRequireClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionedRequireClauseContext {
	var p = new(VersionedRequireClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_versionedRequireClause

	return p
}

func (s *VersionedRequireClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionedRequireClauseContext) RequireClause() IRequireClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequireClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequireClauseContext)
}

func (s *VersionedRequireClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionedRequireClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VersionedRequireClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterVersionedRequireClause(s)
	}
}

func (s *VersionedRequireClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitVersionedRequireClause(s)
	}
}

func (s *VersionedRequireClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitVersionedRequireClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) VersionedRequireClause() (localctx IVersionedRequireClauseContext) {
	localctx = NewVersionedRequireClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 286, TiDBParserRULE_versionedRequireClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2463)
		p.RequireClause()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRenameUserContext is an interface to support dynamic dispatch.
type IRenameUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RENAME_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	AllUser() []IUserContext
	User(i int) IUserContext
	AllTO_SYMBOL() []antlr.TerminalNode
	TO_SYMBOL(i int) antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsRenameUserContext differentiates from other interfaces.
	IsRenameUserContext()
}

type RenameUserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRenameUserContext() *RenameUserContext {
	var p = new(RenameUserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_renameUser
	return p
}

func InitEmptyRenameUserContext(p *RenameUserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_renameUser
}

func (*RenameUserContext) IsRenameUserContext() {}

func NewRenameUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RenameUserContext {
	var p = new(RenameUserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_renameUser

	return p
}

func (s *RenameUserContext) GetParser() antlr.Parser { return s.parser }

func (s *RenameUserContext) RENAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRENAME_SYMBOL, 0)
}

func (s *RenameUserContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *RenameUserContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *RenameUserContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RenameUserContext) AllTO_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserTO_SYMBOL)
}

func (s *RenameUserContext) TO_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserTO_SYMBOL, i)
}

func (s *RenameUserContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *RenameUserContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *RenameUserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RenameUserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RenameUserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRenameUser(s)
	}
}

func (s *RenameUserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRenameUser(s)
	}
}

func (s *RenameUserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRenameUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RenameUser() (localctx IRenameUserContext) {
	localctx = NewRenameUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 288, TiDBParserRULE_renameUser)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2465)
		p.Match(TiDBParserRENAME_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2466)
		p.Match(TiDBParserUSER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2467)
		p.User()
	}
	{
		p.SetState(2468)
		p.Match(TiDBParserTO_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2469)
		p.User()
	}
	p.SetState(2477)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2470)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2471)
			p.User()
		}
		{
			p.SetState(2472)
			p.Match(TiDBParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2473)
			p.User()
		}

		p.SetState(2479)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRevokeContext is an interface to support dynamic dispatch.
type IRevokeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REVOKE_SYMBOL() antlr.TerminalNode
	RoleOrPrivilegesList() IRoleOrPrivilegesListContext
	FROM_SYMBOL() antlr.TerminalNode
	UserList() IUserListContext
	OnTypeTo() IOnTypeToContext
	ALL_SYMBOL() antlr.TerminalNode
	PROXY_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	User() IUserContext
	GrantIdentifier() IGrantIdentifierContext
	COMMA_SYMBOL() antlr.TerminalNode
	GRANT_SYMBOL() antlr.TerminalNode
	OPTION_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	AclType() IAclTypeContext

	// IsRevokeContext differentiates from other interfaces.
	IsRevokeContext()
}

type RevokeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRevokeContext() *RevokeContext {
	var p = new(RevokeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_revoke
	return p
}

func InitEmptyRevokeContext(p *RevokeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_revoke
}

func (*RevokeContext) IsRevokeContext() {}

func NewRevokeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RevokeContext {
	var p = new(RevokeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_revoke

	return p
}

func (s *RevokeContext) GetParser() antlr.Parser { return s.parser }

func (s *RevokeContext) REVOKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREVOKE_SYMBOL, 0)
}

func (s *RevokeContext) RoleOrPrivilegesList() IRoleOrPrivilegesListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrPrivilegesListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrPrivilegesListContext)
}

func (s *RevokeContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *RevokeContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *RevokeContext) OnTypeTo() IOnTypeToContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOnTypeToContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOnTypeToContext)
}

func (s *RevokeContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *RevokeContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROXY_SYMBOL, 0)
}

func (s *RevokeContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *RevokeContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *RevokeContext) GrantIdentifier() IGrantIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantIdentifierContext)
}

func (s *RevokeContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *RevokeContext) GRANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGRANT_SYMBOL, 0)
}

func (s *RevokeContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTION_SYMBOL, 0)
}

func (s *RevokeContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIVILEGES_SYMBOL, 0)
}

func (s *RevokeContext) AclType() IAclTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAclTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAclTypeContext)
}

func (s *RevokeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RevokeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RevokeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRevoke(s)
	}
}

func (s *RevokeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRevoke(s)
	}
}

func (s *RevokeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRevoke(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Revoke() (localctx IRevokeContext) {
	localctx = NewRevokeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 290, TiDBParserRULE_revoke)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2480)
		p.Match(TiDBParserREVOKE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2512)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 278, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2481)
			p.RoleOrPrivilegesList()
		}
		{
			p.SetState(2482)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2483)
			p.UserList()
		}

	case 2:
		{
			p.SetState(2485)
			p.RoleOrPrivilegesList()
		}
		{
			p.SetState(2486)
			p.OnTypeTo()
		}
		{
			p.SetState(2487)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2488)
			p.UserList()
		}

	case 3:
		{
			p.SetState(2490)
			p.Match(TiDBParserALL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2492)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserPRIVILEGES_SYMBOL {
			{
				p.SetState(2491)
				p.Match(TiDBParserPRIVILEGES_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(2504)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserON_SYMBOL:
			{
				p.SetState(2494)
				p.Match(TiDBParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2496)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 276, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2495)
					p.AclType()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(2498)
				p.GrantIdentifier()
			}

		case TiDBParserCOMMA_SYMBOL:
			{
				p.SetState(2499)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2500)
				p.Match(TiDBParserGRANT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2501)
				p.Match(TiDBParserOPTION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2502)
				p.Match(TiDBParserFROM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2503)
				p.UserList()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 4:
		{
			p.SetState(2506)
			p.Match(TiDBParserPROXY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2507)
			p.Match(TiDBParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2508)
			p.User()
		}
		{
			p.SetState(2509)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2510)
			p.UserList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnTypeToContext is an interface to support dynamic dispatch.
type IOnTypeToContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON_SYMBOL() antlr.TerminalNode
	GrantIdentifier() IGrantIdentifierContext
	AclType() IAclTypeContext

	// IsOnTypeToContext differentiates from other interfaces.
	IsOnTypeToContext()
}

type OnTypeToContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnTypeToContext() *OnTypeToContext {
	var p = new(OnTypeToContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onTypeTo
	return p
}

func InitEmptyOnTypeToContext(p *OnTypeToContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onTypeTo
}

func (*OnTypeToContext) IsOnTypeToContext() {}

func NewOnTypeToContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnTypeToContext {
	var p = new(OnTypeToContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_onTypeTo

	return p
}

func (s *OnTypeToContext) GetParser() antlr.Parser { return s.parser }

func (s *OnTypeToContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *OnTypeToContext) GrantIdentifier() IGrantIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGrantIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGrantIdentifierContext)
}

func (s *OnTypeToContext) AclType() IAclTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAclTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAclTypeContext)
}

func (s *OnTypeToContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnTypeToContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnTypeToContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOnTypeTo(s)
	}
}

func (s *OnTypeToContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOnTypeTo(s)
	}
}

func (s *OnTypeToContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOnTypeTo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OnTypeTo() (localctx IOnTypeToContext) {
	localctx = NewOnTypeToContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 292, TiDBParserRULE_onTypeTo)
	var _la int

	p.SetState(2526)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 282, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2514)
			p.Match(TiDBParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2516)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 279, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(2515)
				p.AclType()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		{
			p.SetState(2518)
			p.GrantIdentifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(2524)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserON_SYMBOL {
			{
				p.SetState(2519)
				p.Match(TiDBParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(2521)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 280, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(2520)
					p.AclType()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}
			{
				p.SetState(2523)
				p.GrantIdentifier()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAclTypeContext is an interface to support dynamic dispatch.
type IAclTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TABLE_SYMBOL() antlr.TerminalNode
	FUNCTION_SYMBOL() antlr.TerminalNode
	PROCEDURE_SYMBOL() antlr.TerminalNode

	// IsAclTypeContext differentiates from other interfaces.
	IsAclTypeContext()
}

type AclTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAclTypeContext() *AclTypeContext {
	var p = new(AclTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_aclType
	return p
}

func InitEmptyAclTypeContext(p *AclTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_aclType
}

func (*AclTypeContext) IsAclTypeContext() {}

func NewAclTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AclTypeContext {
	var p = new(AclTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_aclType

	return p
}

func (s *AclTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *AclTypeContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_SYMBOL, 0)
}

func (s *AclTypeContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFUNCTION_SYMBOL, 0)
}

func (s *AclTypeContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROCEDURE_SYMBOL, 0)
}

func (s *AclTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AclTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AclTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterAclType(s)
	}
}

func (s *AclTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitAclType(s)
	}
}

func (s *AclTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitAclType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) AclType() (localctx IAclTypeContext) {
	localctx = NewAclTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 294, TiDBParserRULE_aclType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2528)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserFUNCTION_SYMBOL || _la == TiDBParserPROCEDURE_SYMBOL || _la == TiDBParserTABLE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOrPrivilegesListContext is an interface to support dynamic dispatch.
type IRoleOrPrivilegesListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRoleOrPrivilege() []IRoleOrPrivilegeContext
	RoleOrPrivilege(i int) IRoleOrPrivilegeContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsRoleOrPrivilegesListContext differentiates from other interfaces.
	IsRoleOrPrivilegesListContext()
}

type RoleOrPrivilegesListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOrPrivilegesListContext() *RoleOrPrivilegesListContext {
	var p = new(RoleOrPrivilegesListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleOrPrivilegesList
	return p
}

func InitEmptyRoleOrPrivilegesListContext(p *RoleOrPrivilegesListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleOrPrivilegesList
}

func (*RoleOrPrivilegesListContext) IsRoleOrPrivilegesListContext() {}

func NewRoleOrPrivilegesListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOrPrivilegesListContext {
	var p = new(RoleOrPrivilegesListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_roleOrPrivilegesList

	return p
}

func (s *RoleOrPrivilegesListContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOrPrivilegesListContext) AllRoleOrPrivilege() []IRoleOrPrivilegeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleOrPrivilegeContext); ok {
			len++
		}
	}

	tst := make([]IRoleOrPrivilegeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleOrPrivilegeContext); ok {
			tst[i] = t.(IRoleOrPrivilegeContext)
			i++
		}
	}

	return tst
}

func (s *RoleOrPrivilegesListContext) RoleOrPrivilege(i int) IRoleOrPrivilegeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrPrivilegeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrPrivilegeContext)
}

func (s *RoleOrPrivilegesListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *RoleOrPrivilegesListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *RoleOrPrivilegesListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOrPrivilegesListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOrPrivilegesListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRoleOrPrivilegesList(s)
	}
}

func (s *RoleOrPrivilegesListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRoleOrPrivilegesList(s)
	}
}

func (s *RoleOrPrivilegesListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRoleOrPrivilegesList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RoleOrPrivilegesList() (localctx IRoleOrPrivilegesListContext) {
	localctx = NewRoleOrPrivilegesListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 296, TiDBParserRULE_roleOrPrivilegesList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2530)
		p.RoleOrPrivilege()
	}
	p.SetState(2535)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2531)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2532)
			p.RoleOrPrivilege()
		}

		p.SetState(2537)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOrPrivilegeContext is an interface to support dynamic dispatch.
type IRoleOrPrivilegeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetObject returns the object token.
	GetObject() antlr.Token

	// SetObject sets the object token.
	SetObject(antlr.Token)

	// Getter signatures
	RoleIdentifierOrText() IRoleIdentifierOrTextContext
	AT_TEXT_SUFFIX() antlr.TerminalNode
	AT_SIGN_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	ColumnInternalRefList() IColumnInternalRefListContext
	SELECT_SYMBOL() antlr.TerminalNode
	INSERT_SYMBOL() antlr.TerminalNode
	UPDATE_SYMBOL() antlr.TerminalNode
	REFERENCES_SYMBOL() antlr.TerminalNode
	DELETE_SYMBOL() antlr.TerminalNode
	USAGE_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	DROP_SYMBOL() antlr.TerminalNode
	EXECUTE_SYMBOL() antlr.TerminalNode
	RELOAD_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode
	PROCESS_SYMBOL() antlr.TerminalNode
	FILE_SYMBOL() antlr.TerminalNode
	PROXY_SYMBOL() antlr.TerminalNode
	SUPER_SYMBOL() antlr.TerminalNode
	EVENT_SYMBOL() antlr.TerminalNode
	TRIGGER_SYMBOL() antlr.TerminalNode
	GRANT_SYMBOL() antlr.TerminalNode
	OPTION_SYMBOL() antlr.TerminalNode
	SHOW_SYMBOL() antlr.TerminalNode
	DATABASES_SYMBOL() antlr.TerminalNode
	CREATE_SYMBOL() antlr.TerminalNode
	TEMPORARY_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	ROUTINE_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	VIEW_SYMBOL() antlr.TerminalNode
	LOCK_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	CLIENT_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	ALTER_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	LOAD_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	S3_SYMBOL() antlr.TerminalNode
	INTO_SYMBOL() antlr.TerminalNode
	INVOKE_SYMBOL() antlr.TerminalNode
	LAMBDA_SYMBOL() antlr.TerminalNode

	// IsRoleOrPrivilegeContext differentiates from other interfaces.
	IsRoleOrPrivilegeContext()
}

type RoleOrPrivilegeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	object antlr.Token
}

func NewEmptyRoleOrPrivilegeContext() *RoleOrPrivilegeContext {
	var p = new(RoleOrPrivilegeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleOrPrivilege
	return p
}

func InitEmptyRoleOrPrivilegeContext(p *RoleOrPrivilegeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleOrPrivilege
}

func (*RoleOrPrivilegeContext) IsRoleOrPrivilegeContext() {}

func NewRoleOrPrivilegeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOrPrivilegeContext {
	var p = new(RoleOrPrivilegeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_roleOrPrivilege

	return p
}

func (s *RoleOrPrivilegeContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOrPrivilegeContext) GetObject() antlr.Token { return s.object }

func (s *RoleOrPrivilegeContext) SetObject(v antlr.Token) { s.object = v }

func (s *RoleOrPrivilegeContext) RoleIdentifierOrText() IRoleIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleIdentifierOrTextContext)
}

func (s *RoleOrPrivilegeContext) AT_TEXT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_TEXT_SUFFIX, 0)
}

func (s *RoleOrPrivilegeContext) AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_SIGN_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *RoleOrPrivilegeContext) ColumnInternalRefList() IColumnInternalRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefListContext)
}

func (s *RoleOrPrivilegeContext) SELECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSELECT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) INSERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSERT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUPDATE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) REFERENCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREFERENCES_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) DELETE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDELETE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) USAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSAGE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINDEX_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDROP_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) EXECUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXECUTE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) RELOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELOAD_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHUTDOWN_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) PROCESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROCESS_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFILE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROXY_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) SUPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUPER_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEVENT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TRIGGER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRIGGER_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) GRANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGRANT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTION_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) SHOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHOW_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) DATABASES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATABASES_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCREATE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TEMPORARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTEMPORARY_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLES_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) ROUTINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROUTINE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLESPACE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVIEW_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) LOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCK_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATION_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) CLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLIENT_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSLAVE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) ALTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALTER_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOAD_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) S3_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserS3_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) INTO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTO_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) INVOKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINVOKE_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) LAMBDA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLAMBDA_SYMBOL, 0)
}

func (s *RoleOrPrivilegeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOrPrivilegeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOrPrivilegeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRoleOrPrivilege(s)
	}
}

func (s *RoleOrPrivilegeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRoleOrPrivilege(s)
	}
}

func (s *RoleOrPrivilegeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRoleOrPrivilege(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RoleOrPrivilege() (localctx IRoleOrPrivilegeContext) {
	localctx = NewRoleOrPrivilegeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 298, TiDBParserRULE_roleOrPrivilege)
	var _la int

	p.SetState(2585)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 290, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(2548)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 286, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2538)
				p.RoleIdentifierOrText()
			}
			p.SetState(2540)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserOPEN_PAR_SYMBOL {
				{
					p.SetState(2539)
					p.ColumnInternalRefList()
				}

			}

		case 2:
			{
				p.SetState(2542)
				p.RoleIdentifierOrText()
			}
			p.SetState(2546)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetTokenStream().LA(1) {
			case TiDBParserAT_TEXT_SUFFIX:
				{
					p.SetState(2543)
					p.Match(TiDBParserAT_TEXT_SUFFIX)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case TiDBParserAT_SIGN_SYMBOL:
				{
					p.SetState(2544)
					p.Match(TiDBParserAT_SIGN_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(2545)
					p.TextOrIdentifier()
				}

			default:
				p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
				goto errorExit
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2550)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserINSERT_SYMBOL || _la == TiDBParserREFERENCES_SYMBOL || _la == TiDBParserSELECT_SYMBOL || _la == TiDBParserUPDATE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(2552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(2551)
				p.ColumnInternalRefList()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2554)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-133)) & ^0x3f) == 0 && ((int64(1)<<(_la-133))&36030033969577985) != 0) || _la == TiDBParserINDEX_SYMBOL || ((int64((_la-423)) & ^0x3f) == 0 && ((int64(1)<<(_la-423))&268435473) != 0) || _la == TiDBParserSHUTDOWN_SYMBOL || _la == TiDBParserSUPER_SYMBOL || _la == TiDBParserTRIGGER_SYMBOL || _la == TiDBParserUSAGE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2555)
			p.Match(TiDBParserGRANT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2556)
			p.Match(TiDBParserOPTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2557)
			p.Match(TiDBParserSHOW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2558)
			p.Match(TiDBParserDATABASES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(2559)
			p.Match(TiDBParserCREATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2563)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		switch p.GetTokenStream().LA(1) {
		case TiDBParserTEMPORARY_SYMBOL:
			{
				p.SetState(2560)
				p.Match(TiDBParserTEMPORARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2561)

				var _m = p.Match(TiDBParserTABLES_SYMBOL)

				localctx.(*RoleOrPrivilegeContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TiDBParserROUTINE_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserVIEW_SYMBOL:
			{
				p.SetState(2562)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*RoleOrPrivilegeContext).object = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == TiDBParserROUTINE_SYMBOL || _la == TiDBParserTABLESPACE_SYMBOL || _la == TiDBParserUSER_SYMBOL || _la == TiDBParserVIEW_SYMBOL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*RoleOrPrivilegeContext).object = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		case TiDBParserFROM_SYMBOL, TiDBParserON_SYMBOL, TiDBParserTO_SYMBOL, TiDBParserCOMMA_SYMBOL:

		default:
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(2565)
			p.Match(TiDBParserLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2566)
			p.Match(TiDBParserTABLES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(2567)
			p.Match(TiDBParserREPLICATION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2568)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RoleOrPrivilegeContext).object = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserCLIENT_SYMBOL || _la == TiDBParserSLAVE_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RoleOrPrivilegeContext).object = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(2569)
			p.Match(TiDBParserSHOW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2570)
			p.Match(TiDBParserVIEW_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(2571)
			p.Match(TiDBParserALTER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserROUTINE_SYMBOL {
			{
				p.SetState(2572)
				p.Match(TiDBParserROUTINE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(2575)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserCREATE_SYMBOL || _la == TiDBParserDROP_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2576)
			p.Match(TiDBParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(2577)
			p.Match(TiDBParserLOAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2578)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2579)
			p.Match(TiDBParserS3_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(2580)
			p.Match(TiDBParserSELECT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2581)
			p.Match(TiDBParserINTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2582)
			p.Match(TiDBParserS3_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(2583)
			p.Match(TiDBParserINVOKE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2584)
			p.Match(TiDBParserLAMBDA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantIdentifierContext is an interface to support dynamic dispatch.
type IGrantIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllMULT_OPERATOR() []antlr.TerminalNode
	MULT_OPERATOR(i int) antlr.TerminalNode
	DOT_SYMBOL() antlr.TerminalNode
	SchemaRef() ISchemaRefContext
	TableRef() ITableRefContext

	// IsGrantIdentifierContext differentiates from other interfaces.
	IsGrantIdentifierContext()
}

type GrantIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGrantIdentifierContext() *GrantIdentifierContext {
	var p = new(GrantIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantIdentifier
	return p
}

func InitEmptyGrantIdentifierContext(p *GrantIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantIdentifier
}

func (*GrantIdentifierContext) IsGrantIdentifierContext() {}

func NewGrantIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantIdentifierContext {
	var p = new(GrantIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_grantIdentifier

	return p
}

func (s *GrantIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantIdentifierContext) AllMULT_OPERATOR() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserMULT_OPERATOR)
}

func (s *GrantIdentifierContext) MULT_OPERATOR(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserMULT_OPERATOR, i)
}

func (s *GrantIdentifierContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDOT_SYMBOL, 0)
}

func (s *GrantIdentifierContext) SchemaRef() ISchemaRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *GrantIdentifierContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *GrantIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGrantIdentifier(s)
	}
}

func (s *GrantIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGrantIdentifier(s)
	}
}

func (s *GrantIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGrantIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GrantIdentifier() (localctx IGrantIdentifierContext) {
	localctx = NewGrantIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 300, TiDBParserRULE_grantIdentifier)
	var _la int

	p.SetState(2602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 293, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2587)
			p.Match(TiDBParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDOT_SYMBOL {
			{
				p.SetState(2588)
				p.Match(TiDBParserDOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2589)
				p.Match(TiDBParserMULT_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2592)
			p.SchemaRef()
		}
		p.SetState(2595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDOT_SYMBOL {
			{
				p.SetState(2593)
				p.Match(TiDBParserDOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2594)
				p.Match(TiDBParserMULT_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2597)
			p.TableRef()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2598)
			p.SchemaRef()
		}
		{
			p.SetState(2599)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2600)
			p.TableRef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequireListContext is an interface to support dynamic dispatch.
type IRequireListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRequireListElement() []IRequireListElementContext
	RequireListElement(i int) IRequireListElementContext
	AllAND_SYMBOL() []antlr.TerminalNode
	AND_SYMBOL(i int) antlr.TerminalNode

	// IsRequireListContext differentiates from other interfaces.
	IsRequireListContext()
}

type RequireListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRequireListContext() *RequireListContext {
	var p = new(RequireListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_requireList
	return p
}

func InitEmptyRequireListContext(p *RequireListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_requireList
}

func (*RequireListContext) IsRequireListContext() {}

func NewRequireListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequireListContext {
	var p = new(RequireListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_requireList

	return p
}

func (s *RequireListContext) GetParser() antlr.Parser { return s.parser }

func (s *RequireListContext) AllRequireListElement() []IRequireListElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRequireListElementContext); ok {
			len++
		}
	}

	tst := make([]IRequireListElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRequireListElementContext); ok {
			tst[i] = t.(IRequireListElementContext)
			i++
		}
	}

	return tst
}

func (s *RequireListContext) RequireListElement(i int) IRequireListElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRequireListElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRequireListElementContext)
}

func (s *RequireListContext) AllAND_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserAND_SYMBOL)
}

func (s *RequireListContext) AND_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserAND_SYMBOL, i)
}

func (s *RequireListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequireListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequireListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRequireList(s)
	}
}

func (s *RequireListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRequireList(s)
	}
}

func (s *RequireListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRequireList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RequireList() (localctx IRequireListContext) {
	localctx = NewRequireListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 302, TiDBParserRULE_requireList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2604)
		p.RequireListElement()
	}
	p.SetState(2611)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserAND_SYMBOL || _la == TiDBParserCIPHER_SYMBOL || _la == TiDBParserISSUER_SYMBOL || _la == TiDBParserSUBJECT_SYMBOL {
		p.SetState(2606)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserAND_SYMBOL {
			{
				p.SetState(2605)
				p.Match(TiDBParserAND_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2608)
			p.RequireListElement()
		}

		p.SetState(2613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRequireListElementContext is an interface to support dynamic dispatch.
type IRequireListElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetElement returns the element token.
	GetElement() antlr.Token

	// SetElement sets the element token.
	SetElement(antlr.Token)

	// Getter signatures
	TextString() ITextStringContext
	CIPHER_SYMBOL() antlr.TerminalNode
	ISSUER_SYMBOL() antlr.TerminalNode
	SUBJECT_SYMBOL() antlr.TerminalNode

	// IsRequireListElementContext differentiates from other interfaces.
	IsRequireListElementContext()
}

type RequireListElementContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	element antlr.Token
}

func NewEmptyRequireListElementContext() *RequireListElementContext {
	var p = new(RequireListElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_requireListElement
	return p
}

func InitEmptyRequireListElementContext(p *RequireListElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_requireListElement
}

func (*RequireListElementContext) IsRequireListElementContext() {}

func NewRequireListElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RequireListElementContext {
	var p = new(RequireListElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_requireListElement

	return p
}

func (s *RequireListElementContext) GetParser() antlr.Parser { return s.parser }

func (s *RequireListElementContext) GetElement() antlr.Token { return s.element }

func (s *RequireListElementContext) SetElement(v antlr.Token) { s.element = v }

func (s *RequireListElementContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *RequireListElementContext) CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCIPHER_SYMBOL, 0)
}

func (s *RequireListElementContext) ISSUER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserISSUER_SYMBOL, 0)
}

func (s *RequireListElementContext) SUBJECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBJECT_SYMBOL, 0)
}

func (s *RequireListElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RequireListElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RequireListElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRequireListElement(s)
	}
}

func (s *RequireListElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRequireListElement(s)
	}
}

func (s *RequireListElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRequireListElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RequireListElement() (localctx IRequireListElementContext) {
	localctx = NewRequireListElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 304, TiDBParserRULE_requireListElement)
	p.SetState(2620)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCIPHER_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2614)

			var _m = p.Match(TiDBParserCIPHER_SYMBOL)

			localctx.(*RequireListElementContext).element = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2615)
			p.TextString()
		}

	case TiDBParserISSUER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2616)

			var _m = p.Match(TiDBParserISSUER_SYMBOL)

			localctx.(*RequireListElementContext).element = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2617)
			p.TextString()
		}

	case TiDBParserSUBJECT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2618)

			var _m = p.Match(TiDBParserSUBJECT_SYMBOL)

			localctx.(*RequireListElementContext).element = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2619)
			p.TextString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGrantOptionContext is an interface to support dynamic dispatch.
type IGrantOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	OPTION_SYMBOL() antlr.TerminalNode
	GRANT_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode

	// IsGrantOptionContext differentiates from other interfaces.
	IsGrantOptionContext()
}

type GrantOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyGrantOptionContext() *GrantOptionContext {
	var p = new(GrantOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantOption
	return p
}

func InitEmptyGrantOptionContext(p *GrantOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_grantOption
}

func (*GrantOptionContext) IsGrantOptionContext() {}

func NewGrantOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GrantOptionContext {
	var p = new(GrantOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_grantOption

	return p
}

func (s *GrantOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *GrantOptionContext) GetOption() antlr.Token { return s.option }

func (s *GrantOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *GrantOptionContext) OPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTION_SYMBOL, 0)
}

func (s *GrantOptionContext) GRANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGRANT_SYMBOL, 0)
}

func (s *GrantOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *GrantOptionContext) MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, 0)
}

func (s *GrantOptionContext) MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, 0)
}

func (s *GrantOptionContext) MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, 0)
}

func (s *GrantOptionContext) MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_USER_CONNECTIONS_SYMBOL, 0)
}

func (s *GrantOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GrantOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GrantOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGrantOption(s)
	}
}

func (s *GrantOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGrantOption(s)
	}
}

func (s *GrantOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGrantOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GrantOption() (localctx IGrantOptionContext) {
	localctx = NewGrantOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 306, TiDBParserRULE_grantOption)
	p.SetState(2632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserGRANT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2622)

			var _m = p.Match(TiDBParserGRANT_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2623)
			p.Match(TiDBParserOPTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2624)

			var _m = p.Match(TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2625)
			p.Ulong_number()
		}

	case TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2626)

			var _m = p.Match(TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2627)
			p.Ulong_number()
		}

	case TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2628)

			var _m = p.Match(TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2629)
			p.Ulong_number()
		}

	case TiDBParserMAX_USER_CONNECTIONS_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2630)

			var _m = p.Match(TiDBParserMAX_USER_CONNECTIONS_SYMBOL)

			localctx.(*GrantOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2631)
			p.Ulong_number()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetRoleContext is an interface to support dynamic dispatch.
type ISetRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	AllRoleList() []IRoleListContext
	RoleList(i int) IRoleListContext
	NONE_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	TO_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	EXCEPT_SYMBOL() antlr.TerminalNode

	// IsSetRoleContext differentiates from other interfaces.
	IsSetRoleContext()
}

type SetRoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetRoleContext() *SetRoleContext {
	var p = new(SetRoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setRole
	return p
}

func InitEmptySetRoleContext(p *SetRoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setRole
}

func (*SetRoleContext) IsSetRoleContext() {}

func NewSetRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetRoleContext {
	var p = new(SetRoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_setRole

	return p
}

func (s *SetRoleContext) GetParser() antlr.Parser { return s.parser }

func (s *SetRoleContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSET_SYMBOL, 0)
}

func (s *SetRoleContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLE_SYMBOL, 0)
}

func (s *SetRoleContext) AllRoleList() []IRoleListContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleListContext); ok {
			len++
		}
	}

	tst := make([]IRoleListContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleListContext); ok {
			tst[i] = t.(IRoleListContext)
			i++
		}
	}

	return tst
}

func (s *SetRoleContext) RoleList(i int) IRoleListContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleListContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleListContext)
}

func (s *SetRoleContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNONE_SYMBOL, 0)
}

func (s *SetRoleContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *SetRoleContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTO_SYMBOL, 0)
}

func (s *SetRoleContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *SetRoleContext) EXCEPT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXCEPT_SYMBOL, 0)
}

func (s *SetRoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetRoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetRoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSetRole(s)
	}
}

func (s *SetRoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSetRole(s)
	}
}

func (s *SetRoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSetRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SetRole() (localctx ISetRoleContext) {
	localctx = NewSetRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 308, TiDBParserRULE_setRole)
	var _la int

	p.SetState(2657)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 300, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2634)
			p.Match(TiDBParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2635)
			p.Match(TiDBParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2636)
			p.RoleList()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2637)
			p.Match(TiDBParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2638)
			p.Match(TiDBParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2639)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserNONE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2640)
			p.Match(TiDBParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2641)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2642)
			p.Match(TiDBParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2646)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
			{
				p.SetState(2643)
				p.RoleList()
			}

		case TiDBParserNONE_SYMBOL:
			{
				p.SetState(2644)
				p.Match(TiDBParserNONE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TiDBParserALL_SYMBOL:
			{
				p.SetState(2645)
				p.Match(TiDBParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2648)
			p.Match(TiDBParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2649)
			p.RoleList()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2650)
			p.Match(TiDBParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2651)
			p.Match(TiDBParserROLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2652)
			p.Match(TiDBParserALL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEXCEPT_SYMBOL {
			{
				p.SetState(2653)
				p.Match(TiDBParserEXCEPT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2654)
				p.RoleList()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleListContext is an interface to support dynamic dispatch.
type IRoleListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllRole() []IRoleContext
	Role(i int) IRoleContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsRoleListContext differentiates from other interfaces.
	IsRoleListContext()
}

type RoleListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleListContext() *RoleListContext {
	var p = new(RoleListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleList
	return p
}

func InitEmptyRoleListContext(p *RoleListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleList
}

func (*RoleListContext) IsRoleListContext() {}

func NewRoleListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleListContext {
	var p = new(RoleListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_roleList

	return p
}

func (s *RoleListContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleListContext) AllRole() []IRoleContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRoleContext); ok {
			len++
		}
	}

	tst := make([]IRoleContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRoleContext); ok {
			tst[i] = t.(IRoleContext)
			i++
		}
	}

	return tst
}

func (s *RoleListContext) Role(i int) IRoleContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleContext)
}

func (s *RoleListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *RoleListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *RoleListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRoleList(s)
	}
}

func (s *RoleListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRoleList(s)
	}
}

func (s *RoleListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRoleList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RoleList() (localctx IRoleListContext) {
	localctx = NewRoleListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 310, TiDBParserRULE_roleList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2659)
		p.Role()
	}
	p.SetState(2664)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2660)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2661)
			p.Role()
		}

		p.SetState(2666)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleContext is an interface to support dynamic dispatch.
type IRoleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleIdentifierOrText() IRoleIdentifierOrTextContext
	AT_SIGN_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	AT_TEXT_SUFFIX() antlr.TerminalNode

	// IsRoleContext differentiates from other interfaces.
	IsRoleContext()
}

type RoleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleContext() *RoleContext {
	var p = new(RoleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_role
	return p
}

func InitEmptyRoleContext(p *RoleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_role
}

func (*RoleContext) IsRoleContext() {}

func NewRoleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleContext {
	var p = new(RoleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_role

	return p
}

func (s *RoleContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleContext) RoleIdentifierOrText() IRoleIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleIdentifierOrTextContext)
}

func (s *RoleContext) AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_SIGN_SYMBOL, 0)
}

func (s *RoleContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *RoleContext) AT_TEXT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_TEXT_SUFFIX, 0)
}

func (s *RoleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRole(s)
	}
}

func (s *RoleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRole(s)
	}
}

func (s *RoleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRole(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Role() (localctx IRoleContext) {
	localctx = NewRoleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 312, TiDBParserRULE_role)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2667)
		p.RoleIdentifierOrText()
	}
	p.SetState(2671)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case TiDBParserAT_SIGN_SYMBOL:
		{
			p.SetState(2668)
			p.Match(TiDBParserAT_SIGN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2669)
			p.TextOrIdentifier()
		}

	case TiDBParserAT_TEXT_SUFFIX:
		{
			p.SetState(2670)
			p.Match(TiDBParserAT_TEXT_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserEOF, TiDBParserACCOUNT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserREQUIRE_SYMBOL, TiDBParserTO_SYMBOL, TiDBParserWITH_SYMBOL, TiDBParserCOMMA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAdministrationStatementContext is an interface to support dynamic dispatch.
type ITableAdministrationStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	TABLE_SYMBOL() antlr.TerminalNode
	TableRefList() ITableRefListContext
	ANALYZE_SYMBOL() antlr.TerminalNode
	NoWriteToBinLog() INoWriteToBinLogContext
	Histogram() IHistogramContext
	CHECK_SYMBOL() antlr.TerminalNode
	AllCheckOption() []ICheckOptionContext
	CheckOption(i int) ICheckOptionContext
	CHECKSUM_SYMBOL() antlr.TerminalNode
	QUICK_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	OPTIMIZE_SYMBOL() antlr.TerminalNode
	REPAIR_SYMBOL() antlr.TerminalNode
	AllRepairType() []IRepairTypeContext
	RepairType(i int) IRepairTypeContext

	// IsTableAdministrationStatementContext differentiates from other interfaces.
	IsTableAdministrationStatementContext()
}

type TableAdministrationStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyTableAdministrationStatementContext() *TableAdministrationStatementContext {
	var p = new(TableAdministrationStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableAdministrationStatement
	return p
}

func InitEmptyTableAdministrationStatementContext(p *TableAdministrationStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableAdministrationStatement
}

func (*TableAdministrationStatementContext) IsTableAdministrationStatementContext() {}

func NewTableAdministrationStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAdministrationStatementContext {
	var p = new(TableAdministrationStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableAdministrationStatement

	return p
}

func (s *TableAdministrationStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAdministrationStatementContext) GetType_() antlr.Token { return s.type_ }

func (s *TableAdministrationStatementContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *TableAdministrationStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) TableRefList() ITableRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefListContext)
}

func (s *TableAdministrationStatementContext) ANALYZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserANALYZE_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) NoWriteToBinLog() INoWriteToBinLogContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INoWriteToBinLogContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INoWriteToBinLogContext)
}

func (s *TableAdministrationStatementContext) Histogram() IHistogramContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IHistogramContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IHistogramContext)
}

func (s *TableAdministrationStatementContext) CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHECK_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) AllCheckOption() []ICheckOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICheckOptionContext); ok {
			len++
		}
	}

	tst := make([]ICheckOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICheckOptionContext); ok {
			tst[i] = t.(ICheckOptionContext)
			i++
		}
	}

	return tst
}

func (s *TableAdministrationStatementContext) CheckOption(i int) ICheckOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICheckOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICheckOptionContext)
}

func (s *TableAdministrationStatementContext) CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHECKSUM_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUICK_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTENDED_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) OPTIMIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTIMIZE_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) REPAIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPAIR_SYMBOL, 0)
}

func (s *TableAdministrationStatementContext) AllRepairType() []IRepairTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IRepairTypeContext); ok {
			len++
		}
	}

	tst := make([]IRepairTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IRepairTypeContext); ok {
			tst[i] = t.(IRepairTypeContext)
			i++
		}
	}

	return tst
}

func (s *TableAdministrationStatementContext) RepairType(i int) IRepairTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRepairTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRepairTypeContext)
}

func (s *TableAdministrationStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAdministrationStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAdministrationStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableAdministrationStatement(s)
	}
}

func (s *TableAdministrationStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableAdministrationStatement(s)
	}
}

func (s *TableAdministrationStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableAdministrationStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableAdministrationStatement() (localctx ITableAdministrationStatementContext) {
	localctx = NewTableAdministrationStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 314, TiDBParserRULE_tableAdministrationStatement)
	var _la int

	p.SetState(2715)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserANALYZE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2673)

			var _m = p.Match(TiDBParserANALYZE_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2675)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLOCAL_SYMBOL || _la == TiDBParserNO_WRITE_TO_BINLOG_SYMBOL {
			{
				p.SetState(2674)
				p.NoWriteToBinLog()
			}

		}
		{
			p.SetState(2677)
			p.Match(TiDBParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2678)
			p.TableRefList()
		}
		p.SetState(2680)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDROP_SYMBOL || _la == TiDBParserUPDATE_SYMBOL {
			{
				p.SetState(2679)
				p.Histogram()
			}

		}

	case TiDBParserCHECK_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2682)

			var _m = p.Match(TiDBParserCHECK_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2683)
			p.Match(TiDBParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2684)
			p.TableRefList()
		}
		p.SetState(2688)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserCHANGED_SYMBOL || ((int64((_la-180)) & ^0x3f) == 0 && ((int64(1)<<(_la-180))&1048593) != 0) || _la == TiDBParserMEDIUM_SYMBOL || _la == TiDBParserQUICK_SYMBOL {
			{
				p.SetState(2685)
				p.CheckOption()
			}

			p.SetState(2690)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case TiDBParserCHECKSUM_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2691)

			var _m = p.Match(TiDBParserCHECKSUM_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2692)
			p.Match(TiDBParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2693)
			p.TableRefList()
		}
		p.SetState(2695)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEXTENDED_SYMBOL || _la == TiDBParserQUICK_SYMBOL {
			{
				p.SetState(2694)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TiDBParserEXTENDED_SYMBOL || _la == TiDBParserQUICK_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}

	case TiDBParserOPTIMIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2697)

			var _m = p.Match(TiDBParserOPTIMIZE_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2699)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLOCAL_SYMBOL || _la == TiDBParserNO_WRITE_TO_BINLOG_SYMBOL {
			{
				p.SetState(2698)
				p.NoWriteToBinLog()
			}

		}
		{
			p.SetState(2701)
			p.Match(TiDBParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2702)
			p.TableRefList()
		}

	case TiDBParserREPAIR_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2703)

			var _m = p.Match(TiDBParserREPAIR_SYMBOL)

			localctx.(*TableAdministrationStatementContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2705)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLOCAL_SYMBOL || _la == TiDBParserNO_WRITE_TO_BINLOG_SYMBOL {
			{
				p.SetState(2704)
				p.NoWriteToBinLog()
			}

		}
		{
			p.SetState(2707)
			p.Match(TiDBParserTABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2708)
			p.TableRefList()
		}
		p.SetState(2712)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserEXTENDED_SYMBOL || _la == TiDBParserQUICK_SYMBOL || _la == TiDBParserUSE_FRM_SYMBOL {
			{
				p.SetState(2709)
				p.RepairType()
			}

			p.SetState(2714)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IHistogramContext is an interface to support dynamic dispatch.
type IHistogramContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UPDATE_SYMBOL() antlr.TerminalNode
	HISTOGRAM_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	WITH_SYMBOL() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	BUCKETS_SYMBOL() antlr.TerminalNode
	DROP_SYMBOL() antlr.TerminalNode

	// IsHistogramContext differentiates from other interfaces.
	IsHistogramContext()
}

type HistogramContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHistogramContext() *HistogramContext {
	var p = new(HistogramContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_histogram
	return p
}

func InitEmptyHistogramContext(p *HistogramContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_histogram
}

func (*HistogramContext) IsHistogramContext() {}

func NewHistogramContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HistogramContext {
	var p = new(HistogramContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_histogram

	return p
}

func (s *HistogramContext) GetParser() antlr.Parser { return s.parser }

func (s *HistogramContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUPDATE_SYMBOL, 0)
}

func (s *HistogramContext) HISTOGRAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHISTOGRAM_SYMBOL, 0)
}

func (s *HistogramContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *HistogramContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *HistogramContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *HistogramContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *HistogramContext) BUCKETS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBUCKETS_SYMBOL, 0)
}

func (s *HistogramContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDROP_SYMBOL, 0)
}

func (s *HistogramContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HistogramContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HistogramContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterHistogram(s)
	}
}

func (s *HistogramContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitHistogram(s)
	}
}

func (s *HistogramContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitHistogram(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Histogram() (localctx IHistogramContext) {
	localctx = NewHistogramContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 316, TiDBParserRULE_histogram)
	var _la int

	p.SetState(2730)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserUPDATE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2717)
			p.Match(TiDBParserUPDATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2718)
			p.Match(TiDBParserHISTOGRAM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2719)
			p.Match(TiDBParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2720)
			p.IdentifierList()
		}
		p.SetState(2724)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWITH_SYMBOL {
			{
				p.SetState(2721)
				p.Match(TiDBParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2722)
				p.Match(TiDBParserINT_NUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2723)
				p.Match(TiDBParserBUCKETS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserDROP_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2726)
			p.Match(TiDBParserDROP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2727)
			p.Match(TiDBParserHISTOGRAM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2728)
			p.Match(TiDBParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2729)
			p.IdentifierList()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICheckOptionContext is an interface to support dynamic dispatch.
type ICheckOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	UPGRADE_SYMBOL() antlr.TerminalNode
	QUICK_SYMBOL() antlr.TerminalNode
	FAST_SYMBOL() antlr.TerminalNode
	MEDIUM_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	CHANGED_SYMBOL() antlr.TerminalNode

	// IsCheckOptionContext differentiates from other interfaces.
	IsCheckOptionContext()
}

type CheckOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCheckOptionContext() *CheckOptionContext {
	var p = new(CheckOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_checkOption
	return p
}

func InitEmptyCheckOptionContext(p *CheckOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_checkOption
}

func (*CheckOptionContext) IsCheckOptionContext() {}

func NewCheckOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CheckOptionContext {
	var p = new(CheckOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_checkOption

	return p
}

func (s *CheckOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CheckOptionContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *CheckOptionContext) UPGRADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUPGRADE_SYMBOL, 0)
}

func (s *CheckOptionContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUICK_SYMBOL, 0)
}

func (s *CheckOptionContext) FAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFAST_SYMBOL, 0)
}

func (s *CheckOptionContext) MEDIUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEDIUM_SYMBOL, 0)
}

func (s *CheckOptionContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTENDED_SYMBOL, 0)
}

func (s *CheckOptionContext) CHANGED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHANGED_SYMBOL, 0)
}

func (s *CheckOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CheckOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CheckOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCheckOption(s)
	}
}

func (s *CheckOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCheckOption(s)
	}
}

func (s *CheckOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCheckOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CheckOption() (localctx ICheckOptionContext) {
	localctx = NewCheckOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 318, TiDBParserRULE_checkOption)
	var _la int

	p.SetState(2735)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserFOR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2732)
			p.Match(TiDBParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2733)
			p.Match(TiDBParserUPGRADE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserCHANGED_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserQUICK_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2734)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserCHANGED_SYMBOL || _la == TiDBParserEXTENDED_SYMBOL || _la == TiDBParserFAST_SYMBOL || _la == TiDBParserMEDIUM_SYMBOL || _la == TiDBParserQUICK_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRepairTypeContext is an interface to support dynamic dispatch.
type IRepairTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QUICK_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	USE_FRM_SYMBOL() antlr.TerminalNode

	// IsRepairTypeContext differentiates from other interfaces.
	IsRepairTypeContext()
}

type RepairTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRepairTypeContext() *RepairTypeContext {
	var p = new(RepairTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_repairType
	return p
}

func InitEmptyRepairTypeContext(p *RepairTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_repairType
}

func (*RepairTypeContext) IsRepairTypeContext() {}

func NewRepairTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RepairTypeContext {
	var p = new(RepairTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_repairType

	return p
}

func (s *RepairTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RepairTypeContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUICK_SYMBOL, 0)
}

func (s *RepairTypeContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTENDED_SYMBOL, 0)
}

func (s *RepairTypeContext) USE_FRM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSE_FRM_SYMBOL, 0)
}

func (s *RepairTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RepairTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RepairTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRepairType(s)
	}
}

func (s *RepairTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRepairType(s)
	}
}

func (s *RepairTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRepairType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RepairType() (localctx IRepairTypeContext) {
	localctx = NewRepairTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 320, TiDBParserRULE_repairType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2737)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserEXTENDED_SYMBOL || _la == TiDBParserQUICK_SYMBOL || _la == TiDBParserUSE_FRM_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInstallUninstallStatmentContext is an interface to support dynamic dispatch.
type IInstallUninstallStatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAction_ returns the action_ token.
	GetAction_() antlr.Token

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetAction_ sets the action_ token.
	SetAction_(antlr.Token)

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	Identifier() IIdentifierContext
	SONAME_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	INSTALL_SYMBOL() antlr.TerminalNode
	PLUGIN_SYMBOL() antlr.TerminalNode
	TextStringLiteralList() ITextStringLiteralListContext
	COMPONENT_SYMBOL() antlr.TerminalNode
	PluginRef() IPluginRefContext
	UNINSTALL_SYMBOL() antlr.TerminalNode
	AllComponentRef() []IComponentRefContext
	ComponentRef(i int) IComponentRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsInstallUninstallStatmentContext differentiates from other interfaces.
	IsInstallUninstallStatmentContext()
}

type InstallUninstallStatmentContext struct {
	antlr.BaseParserRuleContext
	parser  antlr.Parser
	action_ antlr.Token
	type_   antlr.Token
}

func NewEmptyInstallUninstallStatmentContext() *InstallUninstallStatmentContext {
	var p = new(InstallUninstallStatmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_installUninstallStatment
	return p
}

func InitEmptyInstallUninstallStatmentContext(p *InstallUninstallStatmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_installUninstallStatment
}

func (*InstallUninstallStatmentContext) IsInstallUninstallStatmentContext() {}

func NewInstallUninstallStatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstallUninstallStatmentContext {
	var p = new(InstallUninstallStatmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_installUninstallStatment

	return p
}

func (s *InstallUninstallStatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *InstallUninstallStatmentContext) GetAction_() antlr.Token { return s.action_ }

func (s *InstallUninstallStatmentContext) GetType_() antlr.Token { return s.type_ }

func (s *InstallUninstallStatmentContext) SetAction_(v antlr.Token) { s.action_ = v }

func (s *InstallUninstallStatmentContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *InstallUninstallStatmentContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InstallUninstallStatmentContext) SONAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSONAME_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *InstallUninstallStatmentContext) INSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSTALL_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) PLUGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUGIN_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) TextStringLiteralList() ITextStringLiteralListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralListContext)
}

func (s *InstallUninstallStatmentContext) COMPONENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPONENT_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) PluginRef() IPluginRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluginRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluginRefContext)
}

func (s *InstallUninstallStatmentContext) UNINSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNINSTALL_SYMBOL, 0)
}

func (s *InstallUninstallStatmentContext) AllComponentRef() []IComponentRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IComponentRefContext); ok {
			len++
		}
	}

	tst := make([]IComponentRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IComponentRefContext); ok {
			tst[i] = t.(IComponentRefContext)
			i++
		}
	}

	return tst
}

func (s *InstallUninstallStatmentContext) ComponentRef(i int) IComponentRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IComponentRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IComponentRefContext)
}

func (s *InstallUninstallStatmentContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *InstallUninstallStatmentContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *InstallUninstallStatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstallUninstallStatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InstallUninstallStatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterInstallUninstallStatment(s)
	}
}

func (s *InstallUninstallStatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitInstallUninstallStatment(s)
	}
}

func (s *InstallUninstallStatmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitInstallUninstallStatment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) InstallUninstallStatment() (localctx IInstallUninstallStatmentContext) {
	localctx = NewInstallUninstallStatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 322, TiDBParserRULE_installUninstallStatment)
	var _la int

	p.SetState(2761)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 315, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2739)

			var _m = p.Match(TiDBParserINSTALL_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).action_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2740)

			var _m = p.Match(TiDBParserPLUGIN_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2741)
			p.Identifier()
		}
		{
			p.SetState(2742)
			p.Match(TiDBParserSONAME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2743)
			p.TextStringLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2745)

			var _m = p.Match(TiDBParserINSTALL_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).action_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2746)

			var _m = p.Match(TiDBParserCOMPONENT_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2747)
			p.TextStringLiteralList()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2748)

			var _m = p.Match(TiDBParserUNINSTALL_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).action_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2749)

			var _m = p.Match(TiDBParserPLUGIN_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2750)
			p.PluginRef()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2751)

			var _m = p.Match(TiDBParserUNINSTALL_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).action_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2752)

			var _m = p.Match(TiDBParserCOMPONENT_SYMBOL)

			localctx.(*InstallUninstallStatmentContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2753)
			p.ComponentRef()
		}
		p.SetState(2758)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(2754)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2755)
				p.ComponentRef()
			}

			p.SetState(2760)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetStatementContext is an interface to support dynamic dispatch.
type ISetStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SYMBOL() antlr.TerminalNode
	StartOptionValueList() IStartOptionValueListContext

	// IsSetStatementContext differentiates from other interfaces.
	IsSetStatementContext()
}

type SetStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetStatementContext() *SetStatementContext {
	var p = new(SetStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setStatement
	return p
}

func InitEmptySetStatementContext(p *SetStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setStatement
}

func (*SetStatementContext) IsSetStatementContext() {}

func NewSetStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetStatementContext {
	var p = new(SetStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_setStatement

	return p
}

func (s *SetStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *SetStatementContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSET_SYMBOL, 0)
}

func (s *SetStatementContext) StartOptionValueList() IStartOptionValueListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartOptionValueListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartOptionValueListContext)
}

func (s *SetStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSetStatement(s)
	}
}

func (s *SetStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSetStatement(s)
	}
}

func (s *SetStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSetStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SetStatement() (localctx ISetStatementContext) {
	localctx = NewSetStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 324, TiDBParserRULE_setStatement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2763)
		p.Match(TiDBParserSET_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2764)
		p.StartOptionValueList()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartOptionValueListContext is an interface to support dynamic dispatch.
type IStartOptionValueListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OptionValueNoOptionType() IOptionValueNoOptionTypeContext
	OptionValueListContinued() IOptionValueListContinuedContext
	TRANSACTION_SYMBOL() antlr.TerminalNode
	TransactionCharacteristics() ITransactionCharacteristicsContext
	OptionType() IOptionTypeContext
	StartOptionValueListFollowingOptionType() IStartOptionValueListFollowingOptionTypeContext
	AllPASSWORD_SYMBOL() []antlr.TerminalNode
	PASSWORD_SYMBOL(i int) antlr.TerminalNode
	Equal() IEqualContext
	TextString() ITextStringContext
	OLD_PASSWORD_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode
	User() IUserContext
	ReplacePassword() IReplacePasswordContext
	RetainCurrentPassword() IRetainCurrentPasswordContext
	TO_SYMBOL() antlr.TerminalNode
	RANDOM_SYMBOL() antlr.TerminalNode

	// IsStartOptionValueListContext differentiates from other interfaces.
	IsStartOptionValueListContext()
}

type StartOptionValueListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartOptionValueListContext() *StartOptionValueListContext {
	var p = new(StartOptionValueListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_startOptionValueList
	return p
}

func InitEmptyStartOptionValueListContext(p *StartOptionValueListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_startOptionValueList
}

func (*StartOptionValueListContext) IsStartOptionValueListContext() {}

func NewStartOptionValueListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartOptionValueListContext {
	var p = new(StartOptionValueListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_startOptionValueList

	return p
}

func (s *StartOptionValueListContext) GetParser() antlr.Parser { return s.parser }

func (s *StartOptionValueListContext) OptionValueNoOptionType() IOptionValueNoOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueNoOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueNoOptionTypeContext)
}

func (s *StartOptionValueListContext) OptionValueListContinued() IOptionValueListContinuedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueListContinuedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueListContinuedContext)
}

func (s *StartOptionValueListContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRANSACTION_SYMBOL, 0)
}

func (s *StartOptionValueListContext) TransactionCharacteristics() ITransactionCharacteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionCharacteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionCharacteristicsContext)
}

func (s *StartOptionValueListContext) OptionType() IOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionTypeContext)
}

func (s *StartOptionValueListContext) StartOptionValueListFollowingOptionType() IStartOptionValueListFollowingOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartOptionValueListFollowingOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartOptionValueListFollowingOptionTypeContext)
}

func (s *StartOptionValueListContext) AllPASSWORD_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserPASSWORD_SYMBOL)
}

func (s *StartOptionValueListContext) PASSWORD_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, i)
}

func (s *StartOptionValueListContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *StartOptionValueListContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *StartOptionValueListContext) OLD_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOLD_PASSWORD_SYMBOL, 0)
}

func (s *StartOptionValueListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *StartOptionValueListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *StartOptionValueListContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *StartOptionValueListContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *StartOptionValueListContext) ReplacePassword() IReplacePasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReplacePasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReplacePasswordContext)
}

func (s *StartOptionValueListContext) RetainCurrentPassword() IRetainCurrentPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainCurrentPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainCurrentPasswordContext)
}

func (s *StartOptionValueListContext) TO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTO_SYMBOL, 0)
}

func (s *StartOptionValueListContext) RANDOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRANDOM_SYMBOL, 0)
}

func (s *StartOptionValueListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartOptionValueListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartOptionValueListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterStartOptionValueList(s)
	}
}

func (s *StartOptionValueListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitStartOptionValueList(s)
	}
}

func (s *StartOptionValueListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitStartOptionValueList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) StartOptionValueList() (localctx IStartOptionValueListContext) {
	localctx = NewStartOptionValueListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 326, TiDBParserRULE_startOptionValueList)
	var _la int

	p.SetState(2819)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 325, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2766)
			p.OptionValueNoOptionType()
		}
		{
			p.SetState(2767)
			p.OptionValueListContinued()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2769)
			p.Match(TiDBParserTRANSACTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2770)
			p.TransactionCharacteristics()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2771)
			p.OptionType()
		}
		{
			p.SetState(2772)
			p.StartOptionValueListFollowingOptionType()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2774)
			p.Match(TiDBParserPASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2777)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(2775)
				p.Match(TiDBParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2776)
				p.User()
			}

		}
		{
			p.SetState(2779)
			p.Equal()
		}
		p.SetState(2804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 321, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2780)
				p.TextString()
			}
			p.SetState(2782)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserREPLACE_SYMBOL {
				{
					p.SetState(2781)
					p.ReplacePassword()
				}

			}
			p.SetState(2785)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserRETAIN_SYMBOL {
				{
					p.SetState(2784)
					p.RetainCurrentPassword()
				}

			}

		case 2:
			{
				p.SetState(2787)
				p.TextString()
			}
			p.SetState(2789)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserREPLACE_SYMBOL {
				{
					p.SetState(2788)
					p.ReplacePassword()
				}

			}
			p.SetState(2792)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserRETAIN_SYMBOL {
				{
					p.SetState(2791)
					p.RetainCurrentPassword()
				}

			}

		case 3:
			{
				p.SetState(2794)
				p.Match(TiDBParserOLD_PASSWORD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2795)
				p.Match(TiDBParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2796)
				p.TextString()
			}
			{
				p.SetState(2797)
				p.Match(TiDBParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(2799)
				p.Match(TiDBParserPASSWORD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2800)
				p.Match(TiDBParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2801)
				p.TextString()
			}
			{
				p.SetState(2802)
				p.Match(TiDBParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2806)
			p.Match(TiDBParserPASSWORD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2809)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(2807)
				p.Match(TiDBParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2808)
				p.User()
			}

		}
		{
			p.SetState(2811)
			p.Match(TiDBParserTO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2812)
			p.Match(TiDBParserRANDOM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2814)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserREPLACE_SYMBOL {
			{
				p.SetState(2813)
				p.ReplacePassword()
			}

		}
		p.SetState(2817)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserRETAIN_SYMBOL {
			{
				p.SetState(2816)
				p.RetainCurrentPassword()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionCharacteristicsContext is an interface to support dynamic dispatch.
type ITransactionCharacteristicsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TransactionAccessMode() ITransactionAccessModeContext
	IsolationLevel() IIsolationLevelContext
	COMMA_SYMBOL() antlr.TerminalNode

	// IsTransactionCharacteristicsContext differentiates from other interfaces.
	IsTransactionCharacteristicsContext()
}

type TransactionCharacteristicsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionCharacteristicsContext() *TransactionCharacteristicsContext {
	var p = new(TransactionCharacteristicsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionCharacteristics
	return p
}

func InitEmptyTransactionCharacteristicsContext(p *TransactionCharacteristicsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionCharacteristics
}

func (*TransactionCharacteristicsContext) IsTransactionCharacteristicsContext() {}

func NewTransactionCharacteristicsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionCharacteristicsContext {
	var p = new(TransactionCharacteristicsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_transactionCharacteristics

	return p
}

func (s *TransactionCharacteristicsContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionCharacteristicsContext) TransactionAccessMode() ITransactionAccessModeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionAccessModeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionAccessModeContext)
}

func (s *TransactionCharacteristicsContext) IsolationLevel() IIsolationLevelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIsolationLevelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIsolationLevelContext)
}

func (s *TransactionCharacteristicsContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *TransactionCharacteristicsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionCharacteristicsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionCharacteristicsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTransactionCharacteristics(s)
	}
}

func (s *TransactionCharacteristicsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTransactionCharacteristics(s)
	}
}

func (s *TransactionCharacteristicsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTransactionCharacteristics(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TransactionCharacteristics() (localctx ITransactionCharacteristicsContext) {
	localctx = NewTransactionCharacteristicsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 328, TiDBParserRULE_transactionCharacteristics)
	var _la int

	p.SetState(2830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserREAD_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2821)
			p.TransactionAccessMode()
		}
		p.SetState(2823)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserISOLATION_SYMBOL {
			{
				p.SetState(2822)
				p.IsolationLevel()
			}

		}

	case TiDBParserISOLATION_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2825)
			p.IsolationLevel()
		}
		p.SetState(2828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(2826)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2827)
				p.TransactionAccessMode()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITransactionAccessModeContext is an interface to support dynamic dispatch.
type ITransactionAccessModeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	READ_SYMBOL() antlr.TerminalNode
	WRITE_SYMBOL() antlr.TerminalNode
	ONLY_SYMBOL() antlr.TerminalNode

	// IsTransactionAccessModeContext differentiates from other interfaces.
	IsTransactionAccessModeContext()
}

type TransactionAccessModeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTransactionAccessModeContext() *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionAccessMode
	return p
}

func InitEmptyTransactionAccessModeContext(p *TransactionAccessModeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_transactionAccessMode
}

func (*TransactionAccessModeContext) IsTransactionAccessModeContext() {}

func NewTransactionAccessModeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TransactionAccessModeContext {
	var p = new(TransactionAccessModeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_transactionAccessMode

	return p
}

func (s *TransactionAccessModeContext) GetParser() antlr.Parser { return s.parser }

func (s *TransactionAccessModeContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREAD_SYMBOL, 0)
}

func (s *TransactionAccessModeContext) WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWRITE_SYMBOL, 0)
}

func (s *TransactionAccessModeContext) ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserONLY_SYMBOL, 0)
}

func (s *TransactionAccessModeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TransactionAccessModeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TransactionAccessModeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTransactionAccessMode(s)
	}
}

func (s *TransactionAccessModeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTransactionAccessMode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TransactionAccessMode() (localctx ITransactionAccessModeContext) {
	localctx = NewTransactionAccessModeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 330, TiDBParserRULE_transactionAccessMode)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2832)
		p.Match(TiDBParserREAD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2833)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserONLY_SYMBOL || _la == TiDBParserWRITE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIsolationLevelContext is an interface to support dynamic dispatch.
type IIsolationLevelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ISOLATION_SYMBOL() antlr.TerminalNode
	LEVEL_SYMBOL() antlr.TerminalNode
	REPEATABLE_SYMBOL() antlr.TerminalNode
	READ_SYMBOL() antlr.TerminalNode
	SERIALIZABLE_SYMBOL() antlr.TerminalNode
	COMMITTED_SYMBOL() antlr.TerminalNode
	UNCOMMITTED_SYMBOL() antlr.TerminalNode

	// IsIsolationLevelContext differentiates from other interfaces.
	IsIsolationLevelContext()
}

type IsolationLevelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIsolationLevelContext() *IsolationLevelContext {
	var p = new(IsolationLevelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_isolationLevel
	return p
}

func InitEmptyIsolationLevelContext(p *IsolationLevelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_isolationLevel
}

func (*IsolationLevelContext) IsIsolationLevelContext() {}

func NewIsolationLevelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IsolationLevelContext {
	var p = new(IsolationLevelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_isolationLevel

	return p
}

func (s *IsolationLevelContext) GetParser() antlr.Parser { return s.parser }

func (s *IsolationLevelContext) ISOLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserISOLATION_SYMBOL, 0)
}

func (s *IsolationLevelContext) LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEVEL_SYMBOL, 0)
}

func (s *IsolationLevelContext) REPEATABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPEATABLE_SYMBOL, 0)
}

func (s *IsolationLevelContext) READ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREAD_SYMBOL, 0)
}

func (s *IsolationLevelContext) SERIALIZABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSERIALIZABLE_SYMBOL, 0)
}

func (s *IsolationLevelContext) COMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMITTED_SYMBOL, 0)
}

func (s *IsolationLevelContext) UNCOMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNCOMMITTED_SYMBOL, 0)
}

func (s *IsolationLevelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IsolationLevelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IsolationLevelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIsolationLevel(s)
	}
}

func (s *IsolationLevelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIsolationLevel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IsolationLevel() (localctx IIsolationLevelContext) {
	localctx = NewIsolationLevelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 332, TiDBParserRULE_isolationLevel)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2835)
		p.Match(TiDBParserISOLATION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(2836)
		p.Match(TiDBParserLEVEL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2842)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserREPEATABLE_SYMBOL:
		{
			p.SetState(2837)
			p.Match(TiDBParserREPEATABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2838)
			p.Match(TiDBParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREAD_SYMBOL:
		{
			p.SetState(2839)
			p.Match(TiDBParserREAD_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2840)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserCOMMITTED_SYMBOL || _la == TiDBParserUNCOMMITTED_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case TiDBParserSERIALIZABLE_SYMBOL:
		{
			p.SetState(2841)
			p.Match(TiDBParserSERIALIZABLE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionValueListContinuedContext is an interface to support dynamic dispatch.
type IOptionValueListContinuedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	AllOptionValue() []IOptionValueContext
	OptionValue(i int) IOptionValueContext

	// IsOptionValueListContinuedContext differentiates from other interfaces.
	IsOptionValueListContinuedContext()
}

type OptionValueListContinuedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionValueListContinuedContext() *OptionValueListContinuedContext {
	var p = new(OptionValueListContinuedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionValueListContinued
	return p
}

func InitEmptyOptionValueListContinuedContext(p *OptionValueListContinuedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionValueListContinued
}

func (*OptionValueListContinuedContext) IsOptionValueListContinuedContext() {}

func NewOptionValueListContinuedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionValueListContinuedContext {
	var p = new(OptionValueListContinuedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_optionValueListContinued

	return p
}

func (s *OptionValueListContinuedContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionValueListContinuedContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *OptionValueListContinuedContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *OptionValueListContinuedContext) AllOptionValue() []IOptionValueContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOptionValueContext); ok {
			len++
		}
	}

	tst := make([]IOptionValueContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOptionValueContext); ok {
			tst[i] = t.(IOptionValueContext)
			i++
		}
	}

	return tst
}

func (s *OptionValueListContinuedContext) OptionValue(i int) IOptionValueContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueContext)
}

func (s *OptionValueListContinuedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionValueListContinuedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionValueListContinuedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOptionValueListContinued(s)
	}
}

func (s *OptionValueListContinuedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOptionValueListContinued(s)
	}
}

func (s *OptionValueListContinuedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOptionValueListContinued(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OptionValueListContinued() (localctx IOptionValueListContinuedContext) {
	localctx = NewOptionValueListContinuedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 334, TiDBParserRULE_optionValueListContinued)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(2848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(2844)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2845)
			p.OptionValue()
		}

		p.SetState(2850)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionValueNoOptionTypeContext is an interface to support dynamic dispatch.
type IOptionValueNoOptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InternalVariableName() IInternalVariableNameContext
	Equal() IEqualContext
	SetExprOrDefault() ISetExprOrDefaultContext
	CharsetClause() ICharsetClauseContext
	UserVariable() IUserVariableContext
	Expr() IExprContext
	SetSystemVariable() ISetSystemVariableContext
	NAMES_SYMBOL() antlr.TerminalNode
	CharsetName() ICharsetNameContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	Collate() ICollateContext

	// IsOptionValueNoOptionTypeContext differentiates from other interfaces.
	IsOptionValueNoOptionTypeContext()
}

type OptionValueNoOptionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionValueNoOptionTypeContext() *OptionValueNoOptionTypeContext {
	var p = new(OptionValueNoOptionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionValueNoOptionType
	return p
}

func InitEmptyOptionValueNoOptionTypeContext(p *OptionValueNoOptionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionValueNoOptionType
}

func (*OptionValueNoOptionTypeContext) IsOptionValueNoOptionTypeContext() {}

func NewOptionValueNoOptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionValueNoOptionTypeContext {
	var p = new(OptionValueNoOptionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_optionValueNoOptionType

	return p
}

func (s *OptionValueNoOptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionValueNoOptionTypeContext) InternalVariableName() IInternalVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInternalVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInternalVariableNameContext)
}

func (s *OptionValueNoOptionTypeContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *OptionValueNoOptionTypeContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *OptionValueNoOptionTypeContext) CharsetClause() ICharsetClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetClauseContext)
}

func (s *OptionValueNoOptionTypeContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *OptionValueNoOptionTypeContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *OptionValueNoOptionTypeContext) SetSystemVariable() ISetSystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetSystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetSystemVariableContext)
}

func (s *OptionValueNoOptionTypeContext) NAMES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNAMES_SYMBOL, 0)
}

func (s *OptionValueNoOptionTypeContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *OptionValueNoOptionTypeContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *OptionValueNoOptionTypeContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *OptionValueNoOptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionValueNoOptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionValueNoOptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOptionValueNoOptionType(s)
	}
}

func (s *OptionValueNoOptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOptionValueNoOptionType(s)
	}
}

func (s *OptionValueNoOptionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOptionValueNoOptionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OptionValueNoOptionType() (localctx IOptionValueNoOptionTypeContext) {
	localctx = NewOptionValueNoOptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 336, TiDBParserRULE_optionValueNoOptionType)
	var _la int

	p.SetState(2875)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 333, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2851)
			p.InternalVariableName()
		}
		{
			p.SetState(2852)
			p.Equal()
		}
		{
			p.SetState(2853)
			p.SetExprOrDefault()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2855)
			p.CharsetClause()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2856)
			p.UserVariable()
		}
		{
			p.SetState(2857)
			p.Equal()
		}
		{
			p.SetState(2858)
			p.expr(0)
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(2860)
			p.SetSystemVariable()
		}
		{
			p.SetState(2861)
			p.Equal()
		}
		{
			p.SetState(2862)
			p.SetExprOrDefault()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(2864)
			p.Match(TiDBParserNAMES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 332, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(2865)
				p.Equal()
			}
			{
				p.SetState(2866)
				p.expr(0)
			}

		case 2:
			{
				p.SetState(2868)
				p.CharsetName()
			}
			p.SetState(2870)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserCOLLATE_SYMBOL {
				{
					p.SetState(2869)
					p.Collate()
				}

			}

		case 3:
			{
				p.SetState(2872)
				p.Match(TiDBParserDEFAULT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionValueContext is an interface to support dynamic dispatch.
type IOptionValueContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OptionType() IOptionTypeContext
	InternalVariableName() IInternalVariableNameContext
	Equal() IEqualContext
	SetExprOrDefault() ISetExprOrDefaultContext
	OptionValueNoOptionType() IOptionValueNoOptionTypeContext

	// IsOptionValueContext differentiates from other interfaces.
	IsOptionValueContext()
}

type OptionValueContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionValueContext() *OptionValueContext {
	var p = new(OptionValueContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionValue
	return p
}

func InitEmptyOptionValueContext(p *OptionValueContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionValue
}

func (*OptionValueContext) IsOptionValueContext() {}

func NewOptionValueContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionValueContext {
	var p = new(OptionValueContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_optionValue

	return p
}

func (s *OptionValueContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionValueContext) OptionType() IOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionTypeContext)
}

func (s *OptionValueContext) InternalVariableName() IInternalVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInternalVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInternalVariableNameContext)
}

func (s *OptionValueContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *OptionValueContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *OptionValueContext) OptionValueNoOptionType() IOptionValueNoOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueNoOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueNoOptionTypeContext)
}

func (s *OptionValueContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionValueContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionValueContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOptionValue(s)
	}
}

func (s *OptionValueContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOptionValue(s)
	}
}

func (s *OptionValueContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOptionValue(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OptionValue() (localctx IOptionValueContext) {
	localctx = NewOptionValueContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 338, TiDBParserRULE_optionValue)
	p.SetState(2883)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 334, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2877)
			p.OptionType()
		}
		{
			p.SetState(2878)
			p.InternalVariableName()
		}
		{
			p.SetState(2879)
			p.Equal()
		}
		{
			p.SetState(2880)
			p.SetExprOrDefault()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2882)
			p.OptionValueNoOptionType()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetSystemVariableContext is an interface to support dynamic dispatch.
type ISetSystemVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_AT_SIGN_SYMBOL() antlr.TerminalNode
	InternalVariableName() IInternalVariableNameContext
	SetVarIdentType() ISetVarIdentTypeContext

	// IsSetSystemVariableContext differentiates from other interfaces.
	IsSetSystemVariableContext()
}

type SetSystemVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetSystemVariableContext() *SetSystemVariableContext {
	var p = new(SetSystemVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setSystemVariable
	return p
}

func InitEmptySetSystemVariableContext(p *SetSystemVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setSystemVariable
}

func (*SetSystemVariableContext) IsSetSystemVariableContext() {}

func NewSetSystemVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetSystemVariableContext {
	var p = new(SetSystemVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_setSystemVariable

	return p
}

func (s *SetSystemVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SetSystemVariableContext) AT_AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_AT_SIGN_SYMBOL, 0)
}

func (s *SetSystemVariableContext) InternalVariableName() IInternalVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInternalVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInternalVariableNameContext)
}

func (s *SetSystemVariableContext) SetVarIdentType() ISetVarIdentTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetVarIdentTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetVarIdentTypeContext)
}

func (s *SetSystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetSystemVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetSystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSetSystemVariable(s)
	}
}

func (s *SetSystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSetSystemVariable(s)
	}
}

func (s *SetSystemVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSetSystemVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SetSystemVariable() (localctx ISetSystemVariableContext) {
	localctx = NewSetSystemVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 340, TiDBParserRULE_setSystemVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2885)
		p.Match(TiDBParserAT_AT_SIGN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(2887)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 335, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(2886)
			p.SetVarIdentType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(2889)
		p.InternalVariableName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStartOptionValueListFollowingOptionTypeContext is an interface to support dynamic dispatch.
type IStartOptionValueListFollowingOptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OptionValueFollowingOptionType() IOptionValueFollowingOptionTypeContext
	OptionValueListContinued() IOptionValueListContinuedContext
	TRANSACTION_SYMBOL() antlr.TerminalNode
	TransactionCharacteristics() ITransactionCharacteristicsContext

	// IsStartOptionValueListFollowingOptionTypeContext differentiates from other interfaces.
	IsStartOptionValueListFollowingOptionTypeContext()
}

type StartOptionValueListFollowingOptionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartOptionValueListFollowingOptionTypeContext() *StartOptionValueListFollowingOptionTypeContext {
	var p = new(StartOptionValueListFollowingOptionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_startOptionValueListFollowingOptionType
	return p
}

func InitEmptyStartOptionValueListFollowingOptionTypeContext(p *StartOptionValueListFollowingOptionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_startOptionValueListFollowingOptionType
}

func (*StartOptionValueListFollowingOptionTypeContext) IsStartOptionValueListFollowingOptionTypeContext() {
}

func NewStartOptionValueListFollowingOptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartOptionValueListFollowingOptionTypeContext {
	var p = new(StartOptionValueListFollowingOptionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_startOptionValueListFollowingOptionType

	return p
}

func (s *StartOptionValueListFollowingOptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *StartOptionValueListFollowingOptionTypeContext) OptionValueFollowingOptionType() IOptionValueFollowingOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueFollowingOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueFollowingOptionTypeContext)
}

func (s *StartOptionValueListFollowingOptionTypeContext) OptionValueListContinued() IOptionValueListContinuedContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionValueListContinuedContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionValueListContinuedContext)
}

func (s *StartOptionValueListFollowingOptionTypeContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRANSACTION_SYMBOL, 0)
}

func (s *StartOptionValueListFollowingOptionTypeContext) TransactionCharacteristics() ITransactionCharacteristicsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITransactionCharacteristicsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITransactionCharacteristicsContext)
}

func (s *StartOptionValueListFollowingOptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartOptionValueListFollowingOptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StartOptionValueListFollowingOptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterStartOptionValueListFollowingOptionType(s)
	}
}

func (s *StartOptionValueListFollowingOptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitStartOptionValueListFollowingOptionType(s)
	}
}

func (s *StartOptionValueListFollowingOptionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitStartOptionValueListFollowingOptionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) StartOptionValueListFollowingOptionType() (localctx IStartOptionValueListFollowingOptionTypeContext) {
	localctx = NewStartOptionValueListFollowingOptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 342, TiDBParserRULE_startOptionValueListFollowingOptionType)
	p.SetState(2896)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 336, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2891)
			p.OptionValueFollowingOptionType()
		}
		{
			p.SetState(2892)
			p.OptionValueListContinued()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2894)
			p.Match(TiDBParserTRANSACTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2895)
			p.TransactionCharacteristics()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionValueFollowingOptionTypeContext is an interface to support dynamic dispatch.
type IOptionValueFollowingOptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	InternalVariableName() IInternalVariableNameContext
	Equal() IEqualContext
	SetExprOrDefault() ISetExprOrDefaultContext

	// IsOptionValueFollowingOptionTypeContext differentiates from other interfaces.
	IsOptionValueFollowingOptionTypeContext()
}

type OptionValueFollowingOptionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionValueFollowingOptionTypeContext() *OptionValueFollowingOptionTypeContext {
	var p = new(OptionValueFollowingOptionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionValueFollowingOptionType
	return p
}

func InitEmptyOptionValueFollowingOptionTypeContext(p *OptionValueFollowingOptionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionValueFollowingOptionType
}

func (*OptionValueFollowingOptionTypeContext) IsOptionValueFollowingOptionTypeContext() {}

func NewOptionValueFollowingOptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionValueFollowingOptionTypeContext {
	var p = new(OptionValueFollowingOptionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_optionValueFollowingOptionType

	return p
}

func (s *OptionValueFollowingOptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionValueFollowingOptionTypeContext) InternalVariableName() IInternalVariableNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInternalVariableNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInternalVariableNameContext)
}

func (s *OptionValueFollowingOptionTypeContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *OptionValueFollowingOptionTypeContext) SetExprOrDefault() ISetExprOrDefaultContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetExprOrDefaultContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetExprOrDefaultContext)
}

func (s *OptionValueFollowingOptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionValueFollowingOptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionValueFollowingOptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOptionValueFollowingOptionType(s)
	}
}

func (s *OptionValueFollowingOptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOptionValueFollowingOptionType(s)
	}
}

func (s *OptionValueFollowingOptionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOptionValueFollowingOptionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OptionValueFollowingOptionType() (localctx IOptionValueFollowingOptionTypeContext) {
	localctx = NewOptionValueFollowingOptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 344, TiDBParserRULE_optionValueFollowingOptionType)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2898)
		p.InternalVariableName()
	}
	{
		p.SetState(2899)
		p.Equal()
	}
	{
		p.SetState(2900)
		p.SetExprOrDefault()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetExprOrDefaultContext is an interface to support dynamic dispatch.
type ISetExprOrDefaultContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	ON_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode
	SYSTEM_SYMBOL() antlr.TerminalNode

	// IsSetExprOrDefaultContext differentiates from other interfaces.
	IsSetExprOrDefaultContext()
}

type SetExprOrDefaultContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetExprOrDefaultContext() *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setExprOrDefault
	return p
}

func InitEmptySetExprOrDefaultContext(p *SetExprOrDefaultContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setExprOrDefault
}

func (*SetExprOrDefaultContext) IsSetExprOrDefaultContext() {}

func NewSetExprOrDefaultContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetExprOrDefaultContext {
	var p = new(SetExprOrDefaultContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_setExprOrDefault

	return p
}

func (s *SetExprOrDefaultContext) GetParser() antlr.Parser { return s.parser }

func (s *SetExprOrDefaultContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SetExprOrDefaultContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) SYSTEM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSYSTEM_SYMBOL, 0)
}

func (s *SetExprOrDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetExprOrDefaultContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetExprOrDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSetExprOrDefault(s)
	}
}

func (s *SetExprOrDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSetExprOrDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SetExprOrDefault() (localctx ISetExprOrDefaultContext) {
	localctx = NewSetExprOrDefaultContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 346, TiDBParserRULE_setExprOrDefault)
	var _la int

	p.SetState(2905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 337, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(2902)
			p.expr(0)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(2903)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserALL_SYMBOL || _la == TiDBParserBINARY_SYMBOL || _la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserON_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(2904)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserROW_SYMBOL || _la == TiDBParserSYSTEM_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowStatementContext is an interface to support dynamic dispatch.
type IShowStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value token.
	GetValue() antlr.Token

	// GetObject returns the object token.
	GetObject() antlr.Token

	// SetValue sets the value token.
	SetValue(antlr.Token)

	// SetObject sets the object token.
	SetObject(antlr.Token)

	// Getter signatures
	SHOW_SYMBOL() antlr.TerminalNode
	STATUS_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	EVENTS_SYMBOL() antlr.TerminalNode
	FromOrIn() IFromOrInContext
	COUNT_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	MULT_OPERATOR() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	Charset() ICharsetContext
	FOR_SYMBOL() antlr.TerminalNode
	User() IUserContext
	USING_SYMBOL() antlr.TerminalNode
	UserList() IUserListContext
	CODE_SYMBOL() antlr.TerminalNode
	ProcedureRef() IProcedureRefContext
	FunctionRef() IFunctionRefContext
	AUTHORS_SYMBOL() antlr.TerminalNode
	DATABASES_SYMBOL() antlr.TerminalNode
	TRIGGERS_SYMBOL() antlr.TerminalNode
	TABLE_SYMBOL() antlr.TerminalNode
	OPEN_SYMBOL() antlr.TerminalNode
	PLUGINS_SYMBOL() antlr.TerminalNode
	ENGINE_SYMBOL() antlr.TerminalNode
	MUTEX_SYMBOL() antlr.TerminalNode
	LOGS_SYMBOL() antlr.TerminalNode
	COLUMNS_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	ENGINES_SYMBOL() antlr.TerminalNode
	WARNINGS_SYMBOL() antlr.TerminalNode
	ERRORS_SYMBOL() antlr.TerminalNode
	PROFILES_SYMBOL() antlr.TerminalNode
	PROFILE_SYMBOL() antlr.TerminalNode
	PROCESSLIST_SYMBOL() antlr.TerminalNode
	COLLATION_SYMBOL() antlr.TerminalNode
	CONTRIBUTORS_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	GRANTS_SYMBOL() antlr.TerminalNode
	CREATE_SYMBOL() antlr.TerminalNode
	PROCEDURE_SYMBOL() antlr.TerminalNode
	FUNCTION_SYMBOL() antlr.TerminalNode
	EngineRef() IEngineRefContext
	ALL_SYMBOL() antlr.TerminalNode
	HOSTS_SYMBOL() antlr.TerminalNode
	NonBlocking() INonBlockingContext
	BINLOG_SYMBOL() antlr.TerminalNode
	RELAYLOG_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	INDEXES_SYMBOL() antlr.TerminalNode
	KEYS_SYMBOL() antlr.TerminalNode
	VARIABLES_SYMBOL() antlr.TerminalNode
	SchemaRef() ISchemaRefContext
	EventRef() IEventRefContext
	TriggerRef() ITriggerRefContext
	ViewRef() IViewRefContext
	LikeOrWhere() ILikeOrWhereContext
	ShowCommandType() IShowCommandTypeContext
	InDb() IInDbContext
	FULL_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	Ulonglong_number() IUlonglong_numberContext
	LimitClause() ILimitClauseContext
	Channel() IChannelContext
	EXTENDED_SYMBOL() antlr.TerminalNode
	WhereClause() IWhereClauseContext
	STORAGE_SYMBOL() antlr.TerminalNode
	AllProfileType() []IProfileTypeContext
	ProfileType(i int) IProfileTypeContext
	QUERY_SYMBOL() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	OptionType() IOptionTypeContext
	DATABASE_SYMBOL() antlr.TerminalNode
	EVENT_SYMBOL() antlr.TerminalNode
	TRIGGER_SYMBOL() antlr.TerminalNode
	VIEW_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	IfNotExists() IIfNotExistsContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsShowStatementContext differentiates from other interfaces.
	IsShowStatementContext()
}

type ShowStatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.Token
	object antlr.Token
}

func NewEmptyShowStatementContext() *ShowStatementContext {
	var p = new(ShowStatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_showStatement
	return p
}

func InitEmptyShowStatementContext(p *ShowStatementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_showStatement
}

func (*ShowStatementContext) IsShowStatementContext() {}

func NewShowStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowStatementContext {
	var p = new(ShowStatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_showStatement

	return p
}

func (s *ShowStatementContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowStatementContext) GetValue() antlr.Token { return s.value }

func (s *ShowStatementContext) GetObject() antlr.Token { return s.object }

func (s *ShowStatementContext) SetValue(v antlr.Token) { s.value = v }

func (s *ShowStatementContext) SetObject(v antlr.Token) { s.object = v }

func (s *ShowStatementContext) SHOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHOW_SYMBOL, 0)
}

func (s *ShowStatementContext) STATUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATUS_SYMBOL, 0)
}

func (s *ShowStatementContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLES_SYMBOL, 0)
}

func (s *ShowStatementContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *ShowStatementContext) EVENTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEVENTS_SYMBOL, 0)
}

func (s *ShowStatementContext) FromOrIn() IFromOrInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromOrInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromOrInContext)
}

func (s *ShowStatementContext) COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOUNT_SYMBOL, 0)
}

func (s *ShowStatementContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *ShowStatementContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULT_OPERATOR, 0)
}

func (s *ShowStatementContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ShowStatementContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *ShowStatementContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *ShowStatementContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *ShowStatementContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSING_SYMBOL, 0)
}

func (s *ShowStatementContext) UserList() IUserListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserListContext)
}

func (s *ShowStatementContext) CODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCODE_SYMBOL, 0)
}

func (s *ShowStatementContext) ProcedureRef() IProcedureRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProcedureRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProcedureRefContext)
}

func (s *ShowStatementContext) FunctionRef() IFunctionRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionRefContext)
}

func (s *ShowStatementContext) AUTHORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAUTHORS_SYMBOL, 0)
}

func (s *ShowStatementContext) DATABASES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATABASES_SYMBOL, 0)
}

func (s *ShowStatementContext) TRIGGERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRIGGERS_SYMBOL, 0)
}

func (s *ShowStatementContext) TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_SYMBOL, 0)
}

func (s *ShowStatementContext) OPEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_SYMBOL, 0)
}

func (s *ShowStatementContext) PLUGINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUGINS_SYMBOL, 0)
}

func (s *ShowStatementContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENGINE_SYMBOL, 0)
}

func (s *ShowStatementContext) MUTEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMUTEX_SYMBOL, 0)
}

func (s *ShowStatementContext) LOGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOGS_SYMBOL, 0)
}

func (s *ShowStatementContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMNS_SYMBOL, 0)
}

func (s *ShowStatementContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *ShowStatementContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIN_SYMBOL, 0)
}

func (s *ShowStatementContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *ShowStatementContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SYMBOL, 0)
}

func (s *ShowStatementContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSLAVE_SYMBOL, 0)
}

func (s *ShowStatementContext) ENGINES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENGINES_SYMBOL, 0)
}

func (s *ShowStatementContext) WARNINGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWARNINGS_SYMBOL, 0)
}

func (s *ShowStatementContext) ERRORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserERRORS_SYMBOL, 0)
}

func (s *ShowStatementContext) PROFILES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROFILES_SYMBOL, 0)
}

func (s *ShowStatementContext) PROFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROFILE_SYMBOL, 0)
}

func (s *ShowStatementContext) PROCESSLIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROCESSLIST_SYMBOL, 0)
}

func (s *ShowStatementContext) COLLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLLATION_SYMBOL, 0)
}

func (s *ShowStatementContext) CONTRIBUTORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONTRIBUTORS_SYMBOL, 0)
}

func (s *ShowStatementContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIVILEGES_SYMBOL, 0)
}

func (s *ShowStatementContext) GRANTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGRANTS_SYMBOL, 0)
}

func (s *ShowStatementContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCREATE_SYMBOL, 0)
}

func (s *ShowStatementContext) PROCEDURE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROCEDURE_SYMBOL, 0)
}

func (s *ShowStatementContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFUNCTION_SYMBOL, 0)
}

func (s *ShowStatementContext) EngineRef() IEngineRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineRefContext)
}

func (s *ShowStatementContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *ShowStatementContext) HOSTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOSTS_SYMBOL, 0)
}

func (s *ShowStatementContext) NonBlocking() INonBlockingContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INonBlockingContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INonBlockingContext)
}

func (s *ShowStatementContext) BINLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINLOG_SYMBOL, 0)
}

func (s *ShowStatementContext) RELAYLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAYLOG_SYMBOL, 0)
}

func (s *ShowStatementContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINDEX_SYMBOL, 0)
}

func (s *ShowStatementContext) INDEXES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINDEXES_SYMBOL, 0)
}

func (s *ShowStatementContext) KEYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEYS_SYMBOL, 0)
}

func (s *ShowStatementContext) VARIABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVARIABLES_SYMBOL, 0)
}

func (s *ShowStatementContext) SchemaRef() ISchemaRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *ShowStatementContext) EventRef() IEventRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEventRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEventRefContext)
}

func (s *ShowStatementContext) TriggerRef() ITriggerRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITriggerRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITriggerRefContext)
}

func (s *ShowStatementContext) ViewRef() IViewRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewRefContext)
}

func (s *ShowStatementContext) LikeOrWhere() ILikeOrWhereContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeOrWhereContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeOrWhereContext)
}

func (s *ShowStatementContext) ShowCommandType() IShowCommandTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IShowCommandTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IShowCommandTypeContext)
}

func (s *ShowStatementContext) InDb() IInDbContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInDbContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInDbContext)
}

func (s *ShowStatementContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFULL_SYMBOL, 0)
}

func (s *ShowStatementContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *ShowStatementContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *ShowStatementContext) LimitClause() ILimitClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILimitClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILimitClauseContext)
}

func (s *ShowStatementContext) Channel() IChannelContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChannelContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChannelContext)
}

func (s *ShowStatementContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTENDED_SYMBOL, 0)
}

func (s *ShowStatementContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *ShowStatementContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTORAGE_SYMBOL, 0)
}

func (s *ShowStatementContext) AllProfileType() []IProfileTypeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IProfileTypeContext); ok {
			len++
		}
	}

	tst := make([]IProfileTypeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IProfileTypeContext); ok {
			tst[i] = t.(IProfileTypeContext)
			i++
		}
	}

	return tst
}

func (s *ShowStatementContext) ProfileType(i int) IProfileTypeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IProfileTypeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IProfileTypeContext)
}

func (s *ShowStatementContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUERY_SYMBOL, 0)
}

func (s *ShowStatementContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *ShowStatementContext) OptionType() IOptionTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOptionTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOptionTypeContext)
}

func (s *ShowStatementContext) DATABASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATABASE_SYMBOL, 0)
}

func (s *ShowStatementContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEVENT_SYMBOL, 0)
}

func (s *ShowStatementContext) TRIGGER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRIGGER_SYMBOL, 0)
}

func (s *ShowStatementContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVIEW_SYMBOL, 0)
}

func (s *ShowStatementContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *ShowStatementContext) IfNotExists() IIfNotExistsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIfNotExistsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIfNotExistsContext)
}

func (s *ShowStatementContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ShowStatementContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ShowStatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowStatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowStatementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterShowStatement(s)
	}
}

func (s *ShowStatementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitShowStatement(s)
	}
}

func (s *ShowStatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitShowStatement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ShowStatement() (localctx IShowStatementContext) {
	localctx = NewShowStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 348, TiDBParserRULE_showStatement)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(2907)
		p.Match(TiDBParserSHOW_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3123)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 381, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(2908)

			var _m = p.Match(TiDBParserAUTHORS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		{
			p.SetState(2909)

			var _m = p.Match(TiDBParserDATABASES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2911)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(2910)
				p.LikeOrWhere()
			}

		}

	case 3:
		p.SetState(2914)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEXTENDED_SYMBOL || _la == TiDBParserFULL_SYMBOL {
			{
				p.SetState(2913)
				p.ShowCommandType()
			}

		}
		{
			p.SetState(2916)

			var _m = p.Match(TiDBParserTABLES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2918)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL || _la == TiDBParserIN_SYMBOL {
			{
				p.SetState(2917)
				p.InDb()
			}

		}
		p.SetState(2921)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(2920)
				p.LikeOrWhere()
			}

		}

	case 4:
		p.SetState(2924)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFULL_SYMBOL {
			{
				p.SetState(2923)
				p.Match(TiDBParserFULL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(2926)

			var _m = p.Match(TiDBParserTRIGGERS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2928)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL || _la == TiDBParserIN_SYMBOL {
			{
				p.SetState(2927)
				p.InDb()
			}

		}
		p.SetState(2931)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(2930)
				p.LikeOrWhere()
			}

		}

	case 5:
		{
			p.SetState(2933)

			var _m = p.Match(TiDBParserEVENTS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL || _la == TiDBParserIN_SYMBOL {
			{
				p.SetState(2934)
				p.InDb()
			}

		}
		p.SetState(2938)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(2937)
				p.LikeOrWhere()
			}

		}

	case 6:
		{
			p.SetState(2940)

			var _m = p.Match(TiDBParserTABLE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2941)
			p.Match(TiDBParserSTATUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2943)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL || _la == TiDBParserIN_SYMBOL {
			{
				p.SetState(2942)
				p.InDb()
			}

		}
		p.SetState(2946)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(2945)
				p.LikeOrWhere()
			}

		}

	case 7:
		{
			p.SetState(2948)

			var _m = p.Match(TiDBParserOPEN_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2949)
			p.Match(TiDBParserTABLES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2951)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL || _la == TiDBParserIN_SYMBOL {
			{
				p.SetState(2950)
				p.InDb()
			}

		}
		p.SetState(2954)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(2953)
				p.LikeOrWhere()
			}

		}

	case 8:
		{
			p.SetState(2956)

			var _m = p.Match(TiDBParserPLUGINS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 9:
		{
			p.SetState(2957)

			var _m = p.Match(TiDBParserENGINE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2960)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
			{
				p.SetState(2958)
				p.EngineRef()
			}

		case TiDBParserALL_SYMBOL:
			{
				p.SetState(2959)
				p.Match(TiDBParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(2962)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserLOGS_SYMBOL || _la == TiDBParserMUTEX_SYMBOL || _la == TiDBParserSTATUS_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		p.SetState(2964)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEXTENDED_SYMBOL || _la == TiDBParserFULL_SYMBOL {
			{
				p.SetState(2963)
				p.ShowCommandType()
			}

		}
		{
			p.SetState(2966)

			var _m = p.Match(TiDBParserCOLUMNS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(2967)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserFROM_SYMBOL || _la == TiDBParserIN_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2968)
			p.TableRef()
		}
		p.SetState(2970)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL || _la == TiDBParserIN_SYMBOL {
			{
				p.SetState(2969)
				p.InDb()
			}

		}
		p.SetState(2973)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(2972)
				p.LikeOrWhere()
			}

		}

	case 11:
		{
			p.SetState(2975)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserBINARY_SYMBOL || _la == TiDBParserMASTER_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2976)

			var _m = p.Match(TiDBParserLOGS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 12:
		{
			p.SetState(2977)

			var _m = p.Match(TiDBParserSLAVE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2984)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserHOSTS_SYMBOL:
			{
				p.SetState(2978)
				p.Match(TiDBParserHOSTS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TiDBParserSTATUS_SYMBOL:
			{
				p.SetState(2979)
				p.Match(TiDBParserSTATUS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2980)
				p.NonBlocking()
			}
			p.SetState(2982)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserFOR_SYMBOL {
				{
					p.SetState(2981)
					p.Channel()
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 13:
		{
			p.SetState(2986)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowStatementContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserBINLOG_SYMBOL || _la == TiDBParserRELAYLOG_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowStatementContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(2987)
			p.Match(TiDBParserEVENTS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(2990)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserIN_SYMBOL {
			{
				p.SetState(2988)
				p.Match(TiDBParserIN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2989)
				p.TextString()
			}

		}
		p.SetState(2994)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL {
			{
				p.SetState(2992)
				p.Match(TiDBParserFROM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(2993)
				p.Ulonglong_number()
			}

		}
		p.SetState(2997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIMIT_SYMBOL {
			{
				p.SetState(2996)
				p.LimitClause()
			}

		}
		p.SetState(3000)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(2999)
				p.Channel()
			}

		}

	case 14:
		p.SetState(3003)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEXTENDED_SYMBOL {
			{
				p.SetState(3002)
				p.Match(TiDBParserEXTENDED_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3005)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowStatementContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-235)) & ^0x3f) == 0 && ((int64(1)<<(_la-235))&268435459) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowStatementContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3006)
			p.FromOrIn()
		}
		{
			p.SetState(3007)
			p.TableRef()
		}
		p.SetState(3009)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL || _la == TiDBParserIN_SYMBOL {
			{
				p.SetState(3008)
				p.InDb()
			}

		}
		p.SetState(3012)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(3011)
				p.WhereClause()
			}

		}

	case 15:
		p.SetState(3015)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSTORAGE_SYMBOL {
			{
				p.SetState(3014)
				p.Match(TiDBParserSTORAGE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3017)

			var _m = p.Match(TiDBParserENGINES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		{
			p.SetState(3018)
			p.Match(TiDBParserCOUNT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3019)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3020)
			p.Match(TiDBParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3021)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3022)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowStatementContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserERRORS_SYMBOL || _la == TiDBParserWARNINGS_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowStatementContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 17:
		{
			p.SetState(3023)

			var _m = p.Match(TiDBParserWARNINGS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3025)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIMIT_SYMBOL {
			{
				p.SetState(3024)
				p.LimitClause()
			}

		}

	case 18:
		{
			p.SetState(3027)

			var _m = p.Match(TiDBParserERRORS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3029)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIMIT_SYMBOL {
			{
				p.SetState(3028)
				p.LimitClause()
			}

		}

	case 19:
		{
			p.SetState(3031)

			var _m = p.Match(TiDBParserPROFILES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		{
			p.SetState(3032)

			var _m = p.Match(TiDBParserPROFILE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3041)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserALL_SYMBOL || _la == TiDBParserBLOCK_SYMBOL || _la == TiDBParserCONTEXT_SYMBOL || _la == TiDBParserCPU_SYMBOL || _la == TiDBParserIPC_SYMBOL || _la == TiDBParserMEMORY_SYMBOL || _la == TiDBParserPAGE_SYMBOL || _la == TiDBParserSOURCE_SYMBOL || _la == TiDBParserSWAPS_SYMBOL {
			{
				p.SetState(3033)
				p.ProfileType()
			}
			p.SetState(3038)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			for _la == TiDBParserCOMMA_SYMBOL {
				{
					p.SetState(3034)
					p.Match(TiDBParserCOMMA_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3035)
					p.ProfileType()
				}

				p.SetState(3040)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(3046)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(3043)
				p.Match(TiDBParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3044)
				p.Match(TiDBParserQUERY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3045)
				p.Match(TiDBParserINT_NUMBER)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		p.SetState(3049)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIMIT_SYMBOL {
			{
				p.SetState(3048)
				p.LimitClause()
			}

		}

	case 21:
		p.SetState(3052)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserGLOBAL_SYMBOL || _la == TiDBParserLOCAL_SYMBOL || _la == TiDBParserSESSION_SYMBOL || _la == TiDBParserPERSIST_SYMBOL || _la == TiDBParserPERSIST_ONLY_SYMBOL {
			{
				p.SetState(3051)
				p.OptionType()
			}

		}
		{
			p.SetState(3054)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ShowStatementContext).value = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserSTATUS_SYMBOL || _la == TiDBParserVARIABLES_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ShowStatementContext).value = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(3056)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(3055)
				p.LikeOrWhere()
			}

		}

	case 22:
		p.SetState(3059)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFULL_SYMBOL {
			{
				p.SetState(3058)
				p.Match(TiDBParserFULL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3061)

			var _m = p.Match(TiDBParserPROCESSLIST_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		{
			p.SetState(3062)
			p.Charset()
		}
		p.SetState(3064)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(3063)
				p.LikeOrWhere()
			}

		}

	case 24:
		{
			p.SetState(3066)

			var _m = p.Match(TiDBParserCOLLATION_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3068)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(3067)
				p.LikeOrWhere()
			}

		}

	case 25:
		{
			p.SetState(3070)

			var _m = p.Match(TiDBParserCONTRIBUTORS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 26:
		{
			p.SetState(3071)

			var _m = p.Match(TiDBParserPRIVILEGES_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 27:
		{
			p.SetState(3072)

			var _m = p.Match(TiDBParserGRANTS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3075)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(3073)
				p.Match(TiDBParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3074)
				p.User()
			}

		}

	case 28:
		{
			p.SetState(3077)

			var _m = p.Match(TiDBParserGRANTS_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3078)
			p.Match(TiDBParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3079)
			p.User()
		}
		{
			p.SetState(3080)
			p.Match(TiDBParserUSING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3081)
			p.UserList()
		}

	case 29:
		{
			p.SetState(3083)

			var _m = p.Match(TiDBParserMASTER_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3084)
			p.Match(TiDBParserSTATUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		{
			p.SetState(3085)

			var _m = p.Match(TiDBParserCREATE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3105)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserDATABASE_SYMBOL:
			{
				p.SetState(3086)

				var _m = p.Match(TiDBParserDATABASE_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3088)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserIF_SYMBOL {
				{
					p.SetState(3087)
					p.IfNotExists()
				}

			}
			{
				p.SetState(3090)
				p.SchemaRef()
			}

		case TiDBParserEVENT_SYMBOL:
			{
				p.SetState(3091)

				var _m = p.Match(TiDBParserEVENT_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3092)
				p.EventRef()
			}

		case TiDBParserFUNCTION_SYMBOL:
			{
				p.SetState(3093)

				var _m = p.Match(TiDBParserFUNCTION_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3094)
				p.FunctionRef()
			}

		case TiDBParserPROCEDURE_SYMBOL:
			{
				p.SetState(3095)

				var _m = p.Match(TiDBParserPROCEDURE_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3096)
				p.ProcedureRef()
			}

		case TiDBParserTABLE_SYMBOL:
			{
				p.SetState(3097)

				var _m = p.Match(TiDBParserTABLE_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3098)
				p.TableRef()
			}

		case TiDBParserTRIGGER_SYMBOL:
			{
				p.SetState(3099)

				var _m = p.Match(TiDBParserTRIGGER_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3100)
				p.TriggerRef()
			}

		case TiDBParserVIEW_SYMBOL:
			{
				p.SetState(3101)

				var _m = p.Match(TiDBParserVIEW_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3102)
				p.ViewRef()
			}

		case TiDBParserUSER_SYMBOL:
			{
				p.SetState(3103)

				var _m = p.Match(TiDBParserUSER_SYMBOL)

				localctx.(*ShowStatementContext).object = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3104)
				p.User()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 31:
		{
			p.SetState(3107)

			var _m = p.Match(TiDBParserPROCEDURE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3108)
			p.Match(TiDBParserSTATUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3110)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(3109)
				p.LikeOrWhere()
			}

		}

	case 32:
		{
			p.SetState(3112)

			var _m = p.Match(TiDBParserFUNCTION_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3113)
			p.Match(TiDBParserSTATUS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLIKE_SYMBOL || _la == TiDBParserWHERE_SYMBOL {
			{
				p.SetState(3114)
				p.LikeOrWhere()
			}

		}

	case 33:
		{
			p.SetState(3117)

			var _m = p.Match(TiDBParserPROCEDURE_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3118)
			p.Match(TiDBParserCODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3119)
			p.ProcedureRef()
		}

	case 34:
		{
			p.SetState(3120)

			var _m = p.Match(TiDBParserFUNCTION_SYMBOL)

			localctx.(*ShowStatementContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3121)
			p.Match(TiDBParserCODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3122)
			p.FunctionRef()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IShowCommandTypeContext is an interface to support dynamic dispatch.
type IShowCommandTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FULL_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode

	// IsShowCommandTypeContext differentiates from other interfaces.
	IsShowCommandTypeContext()
}

type ShowCommandTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyShowCommandTypeContext() *ShowCommandTypeContext {
	var p = new(ShowCommandTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_showCommandType
	return p
}

func InitEmptyShowCommandTypeContext(p *ShowCommandTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_showCommandType
}

func (*ShowCommandTypeContext) IsShowCommandTypeContext() {}

func NewShowCommandTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ShowCommandTypeContext {
	var p = new(ShowCommandTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_showCommandType

	return p
}

func (s *ShowCommandTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ShowCommandTypeContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFULL_SYMBOL, 0)
}

func (s *ShowCommandTypeContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTENDED_SYMBOL, 0)
}

func (s *ShowCommandTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ShowCommandTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ShowCommandTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterShowCommandType(s)
	}
}

func (s *ShowCommandTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitShowCommandType(s)
	}
}

func (s *ShowCommandTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitShowCommandType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ShowCommandType() (localctx IShowCommandTypeContext) {
	localctx = NewShowCommandTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 350, TiDBParserRULE_showCommandType)
	var _la int

	p.SetState(3130)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserFULL_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3125)
			p.Match(TiDBParserFULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserEXTENDED_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3126)
			p.Match(TiDBParserEXTENDED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3128)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFULL_SYMBOL {
			{
				p.SetState(3127)
				p.Match(TiDBParserFULL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INonBlockingContext is an interface to support dynamic dispatch.
type INonBlockingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NONBLOCKING_SYMBOL() antlr.TerminalNode

	// IsNonBlockingContext differentiates from other interfaces.
	IsNonBlockingContext()
}

type NonBlockingContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNonBlockingContext() *NonBlockingContext {
	var p = new(NonBlockingContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_nonBlocking
	return p
}

func InitEmptyNonBlockingContext(p *NonBlockingContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_nonBlocking
}

func (*NonBlockingContext) IsNonBlockingContext() {}

func NewNonBlockingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NonBlockingContext {
	var p = new(NonBlockingContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_nonBlocking

	return p
}

func (s *NonBlockingContext) GetParser() antlr.Parser { return s.parser }

func (s *NonBlockingContext) NONBLOCKING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNONBLOCKING_SYMBOL, 0)
}

func (s *NonBlockingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NonBlockingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NonBlockingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterNonBlocking(s)
	}
}

func (s *NonBlockingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitNonBlocking(s)
	}
}

func (s *NonBlockingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitNonBlocking(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) NonBlocking() (localctx INonBlockingContext) {
	localctx = NewNonBlockingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 352, TiDBParserRULE_nonBlocking)
	var _la int

	p.SetState(3136)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 385, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(3133)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserNONBLOCKING_SYMBOL {
			{
				p.SetState(3132)
				p.Match(TiDBParserNONBLOCKING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFromOrInContext is an interface to support dynamic dispatch.
type IFromOrInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FROM_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode

	// IsFromOrInContext differentiates from other interfaces.
	IsFromOrInContext()
}

type FromOrInContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFromOrInContext() *FromOrInContext {
	var p = new(FromOrInContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fromOrIn
	return p
}

func InitEmptyFromOrInContext(p *FromOrInContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fromOrIn
}

func (*FromOrInContext) IsFromOrInContext() {}

func NewFromOrInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FromOrInContext {
	var p = new(FromOrInContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fromOrIn

	return p
}

func (s *FromOrInContext) GetParser() antlr.Parser { return s.parser }

func (s *FromOrInContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *FromOrInContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIN_SYMBOL, 0)
}

func (s *FromOrInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FromOrInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FromOrInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFromOrIn(s)
	}
}

func (s *FromOrInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFromOrIn(s)
	}
}

func (s *FromOrInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFromOrIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FromOrIn() (localctx IFromOrInContext) {
	localctx = NewFromOrInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 354, TiDBParserRULE_fromOrIn)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3138)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserFROM_SYMBOL || _la == TiDBParserIN_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInDbContext is an interface to support dynamic dispatch.
type IInDbContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FromOrIn() IFromOrInContext
	Identifier() IIdentifierContext

	// IsInDbContext differentiates from other interfaces.
	IsInDbContext()
}

type InDbContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInDbContext() *InDbContext {
	var p = new(InDbContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_inDb
	return p
}

func InitEmptyInDbContext(p *InDbContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_inDb
}

func (*InDbContext) IsInDbContext() {}

func NewInDbContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InDbContext {
	var p = new(InDbContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_inDb

	return p
}

func (s *InDbContext) GetParser() antlr.Parser { return s.parser }

func (s *InDbContext) FromOrIn() IFromOrInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFromOrInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFromOrInContext)
}

func (s *InDbContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InDbContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InDbContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InDbContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterInDb(s)
	}
}

func (s *InDbContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitInDb(s)
	}
}

func (s *InDbContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitInDb(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) InDb() (localctx IInDbContext) {
	localctx = NewInDbContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 356, TiDBParserRULE_inDb)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3140)
		p.FromOrIn()
	}
	{
		p.SetState(3141)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProfileTypeContext is an interface to support dynamic dispatch.
type IProfileTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BLOCK_SYMBOL() antlr.TerminalNode
	IO_SYMBOL() antlr.TerminalNode
	CONTEXT_SYMBOL() antlr.TerminalNode
	SWITCHES_SYMBOL() antlr.TerminalNode
	PAGE_SYMBOL() antlr.TerminalNode
	FAULTS_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	CPU_SYMBOL() antlr.TerminalNode
	IPC_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	SOURCE_SYMBOL() antlr.TerminalNode
	SWAPS_SYMBOL() antlr.TerminalNode

	// IsProfileTypeContext differentiates from other interfaces.
	IsProfileTypeContext()
}

type ProfileTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProfileTypeContext() *ProfileTypeContext {
	var p = new(ProfileTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_profileType
	return p
}

func InitEmptyProfileTypeContext(p *ProfileTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_profileType
}

func (*ProfileTypeContext) IsProfileTypeContext() {}

func NewProfileTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProfileTypeContext {
	var p = new(ProfileTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_profileType

	return p
}

func (s *ProfileTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *ProfileTypeContext) BLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBLOCK_SYMBOL, 0)
}

func (s *ProfileTypeContext) IO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIO_SYMBOL, 0)
}

func (s *ProfileTypeContext) CONTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONTEXT_SYMBOL, 0)
}

func (s *ProfileTypeContext) SWITCHES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSWITCHES_SYMBOL, 0)
}

func (s *ProfileTypeContext) PAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPAGE_SYMBOL, 0)
}

func (s *ProfileTypeContext) FAULTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFAULTS_SYMBOL, 0)
}

func (s *ProfileTypeContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *ProfileTypeContext) CPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCPU_SYMBOL, 0)
}

func (s *ProfileTypeContext) IPC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIPC_SYMBOL, 0)
}

func (s *ProfileTypeContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEMORY_SYMBOL, 0)
}

func (s *ProfileTypeContext) SOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSOURCE_SYMBOL, 0)
}

func (s *ProfileTypeContext) SWAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSWAPS_SYMBOL, 0)
}

func (s *ProfileTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProfileTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProfileTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterProfileType(s)
	}
}

func (s *ProfileTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitProfileType(s)
	}
}

func (s *ProfileTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitProfileType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ProfileType() (localctx IProfileTypeContext) {
	localctx = NewProfileTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 358, TiDBParserRULE_profileType)
	var _la int

	p.SetState(3150)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserBLOCK_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3143)
			p.Match(TiDBParserBLOCK_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3144)
			p.Match(TiDBParserIO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserCONTEXT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3145)
			p.Match(TiDBParserCONTEXT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3146)
			p.Match(TiDBParserSWITCHES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserPAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3147)
			p.Match(TiDBParserPAGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3148)
			p.Match(TiDBParserFAULTS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserALL_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSWAPS_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3149)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserALL_SYMBOL || _la == TiDBParserCPU_SYMBOL || _la == TiDBParserIPC_SYMBOL || _la == TiDBParserMEMORY_SYMBOL || _la == TiDBParserSOURCE_SYMBOL || _la == TiDBParserSWAPS_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupManagementContext is an interface to support dynamic dispatch.
type IResourceGroupManagementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CreateResourceGroup() ICreateResourceGroupContext
	AlterResourceGroup() IAlterResourceGroupContext
	SetResourceGroup() ISetResourceGroupContext
	DropResourceGroup() IDropResourceGroupContext

	// IsResourceGroupManagementContext differentiates from other interfaces.
	IsResourceGroupManagementContext()
}

type ResourceGroupManagementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupManagementContext() *ResourceGroupManagementContext {
	var p = new(ResourceGroupManagementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupManagement
	return p
}

func InitEmptyResourceGroupManagementContext(p *ResourceGroupManagementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupManagement
}

func (*ResourceGroupManagementContext) IsResourceGroupManagementContext() {}

func NewResourceGroupManagementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupManagementContext {
	var p = new(ResourceGroupManagementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_resourceGroupManagement

	return p
}

func (s *ResourceGroupManagementContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupManagementContext) CreateResourceGroup() ICreateResourceGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateResourceGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateResourceGroupContext)
}

func (s *ResourceGroupManagementContext) AlterResourceGroup() IAlterResourceGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterResourceGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterResourceGroupContext)
}

func (s *ResourceGroupManagementContext) SetResourceGroup() ISetResourceGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISetResourceGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISetResourceGroupContext)
}

func (s *ResourceGroupManagementContext) DropResourceGroup() IDropResourceGroupContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDropResourceGroupContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDropResourceGroupContext)
}

func (s *ResourceGroupManagementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupManagementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupManagementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterResourceGroupManagement(s)
	}
}

func (s *ResourceGroupManagementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitResourceGroupManagement(s)
	}
}

func (s *ResourceGroupManagementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitResourceGroupManagement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ResourceGroupManagement() (localctx IResourceGroupManagementContext) {
	localctx = NewResourceGroupManagementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 360, TiDBParserRULE_resourceGroupManagement)
	p.SetState(3156)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCREATE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3152)
			p.CreateResourceGroup()
		}

	case TiDBParserALTER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3153)
			p.AlterResourceGroup()
		}

	case TiDBParserSET_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3154)
			p.SetResourceGroup()
		}

	case TiDBParserDROP_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3155)
			p.DropResourceGroup()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateResourceGroupContext is an interface to support dynamic dispatch.
type ICreateResourceGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CREATE_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	TYPE_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	SYSTEM_SYMBOL() antlr.TerminalNode
	Equal() IEqualContext
	ResourceGroupVcpuList() IResourceGroupVcpuListContext
	ResourceGroupPriority() IResourceGroupPriorityContext
	ResourceGroupEnableDisable() IResourceGroupEnableDisableContext

	// IsCreateResourceGroupContext differentiates from other interfaces.
	IsCreateResourceGroupContext()
}

type CreateResourceGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateResourceGroupContext() *CreateResourceGroupContext {
	var p = new(CreateResourceGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createResourceGroup
	return p
}

func InitEmptyCreateResourceGroupContext(p *CreateResourceGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createResourceGroup
}

func (*CreateResourceGroupContext) IsCreateResourceGroupContext() {}

func NewCreateResourceGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateResourceGroupContext {
	var p = new(CreateResourceGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_createResourceGroup

	return p
}

func (s *CreateResourceGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateResourceGroupContext) CREATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCREATE_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESOURCE_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateResourceGroupContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTYPE_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) SYSTEM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSYSTEM_SYMBOL, 0)
}

func (s *CreateResourceGroupContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *CreateResourceGroupContext) ResourceGroupVcpuList() IResourceGroupVcpuListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupVcpuListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupVcpuListContext)
}

func (s *CreateResourceGroupContext) ResourceGroupPriority() IResourceGroupPriorityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupPriorityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupPriorityContext)
}

func (s *CreateResourceGroupContext) ResourceGroupEnableDisable() IResourceGroupEnableDisableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupEnableDisableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupEnableDisableContext)
}

func (s *CreateResourceGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateResourceGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateResourceGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCreateResourceGroup(s)
	}
}

func (s *CreateResourceGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCreateResourceGroup(s)
	}
}

func (s *CreateResourceGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCreateResourceGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CreateResourceGroup() (localctx ICreateResourceGroupContext) {
	localctx = NewCreateResourceGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 362, TiDBParserRULE_createResourceGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3158)
		p.Match(TiDBParserCREATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3159)
		p.Match(TiDBParserRESOURCE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3160)
		p.Match(TiDBParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3161)
		p.Identifier()
	}
	{
		p.SetState(3162)
		p.Match(TiDBParserTYPE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3164)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserEQUAL_OPERATOR || _la == TiDBParserASSIGN_OPERATOR {
		{
			p.SetState(3163)
			p.Equal()
		}

	}
	{
		p.SetState(3166)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserUSER_SYMBOL || _la == TiDBParserSYSTEM_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	p.SetState(3168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserVCPU_SYMBOL {
		{
			p.SetState(3167)
			p.ResourceGroupVcpuList()
		}

	}
	p.SetState(3171)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserTHREAD_PRIORITY_SYMBOL {
		{
			p.SetState(3170)
			p.ResourceGroupPriority()
		}

	}
	p.SetState(3174)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserDISABLE_SYMBOL || _la == TiDBParserENABLE_SYMBOL {
		{
			p.SetState(3173)
			p.ResourceGroupEnableDisable()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupVcpuListContext is an interface to support dynamic dispatch.
type IResourceGroupVcpuListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VCPU_SYMBOL() antlr.TerminalNode
	AllVcpuNumOrRange() []IVcpuNumOrRangeContext
	VcpuNumOrRange(i int) IVcpuNumOrRangeContext
	Equal() IEqualContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsResourceGroupVcpuListContext differentiates from other interfaces.
	IsResourceGroupVcpuListContext()
}

type ResourceGroupVcpuListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupVcpuListContext() *ResourceGroupVcpuListContext {
	var p = new(ResourceGroupVcpuListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupVcpuList
	return p
}

func InitEmptyResourceGroupVcpuListContext(p *ResourceGroupVcpuListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupVcpuList
}

func (*ResourceGroupVcpuListContext) IsResourceGroupVcpuListContext() {}

func NewResourceGroupVcpuListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupVcpuListContext {
	var p = new(ResourceGroupVcpuListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_resourceGroupVcpuList

	return p
}

func (s *ResourceGroupVcpuListContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupVcpuListContext) VCPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVCPU_SYMBOL, 0)
}

func (s *ResourceGroupVcpuListContext) AllVcpuNumOrRange() []IVcpuNumOrRangeContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IVcpuNumOrRangeContext); ok {
			len++
		}
	}

	tst := make([]IVcpuNumOrRangeContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IVcpuNumOrRangeContext); ok {
			tst[i] = t.(IVcpuNumOrRangeContext)
			i++
		}
	}

	return tst
}

func (s *ResourceGroupVcpuListContext) VcpuNumOrRange(i int) IVcpuNumOrRangeContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVcpuNumOrRangeContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVcpuNumOrRangeContext)
}

func (s *ResourceGroupVcpuListContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *ResourceGroupVcpuListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ResourceGroupVcpuListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ResourceGroupVcpuListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupVcpuListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupVcpuListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterResourceGroupVcpuList(s)
	}
}

func (s *ResourceGroupVcpuListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitResourceGroupVcpuList(s)
	}
}

func (s *ResourceGroupVcpuListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitResourceGroupVcpuList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ResourceGroupVcpuList() (localctx IResourceGroupVcpuListContext) {
	localctx = NewResourceGroupVcpuListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 364, TiDBParserRULE_resourceGroupVcpuList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3176)
		p.Match(TiDBParserVCPU_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3178)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserEQUAL_OPERATOR || _la == TiDBParserASSIGN_OPERATOR {
		{
			p.SetState(3177)
			p.Equal()
		}

	}
	{
		p.SetState(3180)
		p.VcpuNumOrRange()
	}
	p.SetState(3187)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserINT_NUMBER || _la == TiDBParserCOMMA_SYMBOL {
		p.SetState(3182)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(3181)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3184)
			p.VcpuNumOrRange()
		}

		p.SetState(3189)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVcpuNumOrRangeContext is an interface to support dynamic dispatch.
type IVcpuNumOrRangeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllINT_NUMBER() []antlr.TerminalNode
	INT_NUMBER(i int) antlr.TerminalNode
	MINUS_OPERATOR() antlr.TerminalNode

	// IsVcpuNumOrRangeContext differentiates from other interfaces.
	IsVcpuNumOrRangeContext()
}

type VcpuNumOrRangeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVcpuNumOrRangeContext() *VcpuNumOrRangeContext {
	var p = new(VcpuNumOrRangeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_vcpuNumOrRange
	return p
}

func InitEmptyVcpuNumOrRangeContext(p *VcpuNumOrRangeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_vcpuNumOrRange
}

func (*VcpuNumOrRangeContext) IsVcpuNumOrRangeContext() {}

func NewVcpuNumOrRangeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VcpuNumOrRangeContext {
	var p = new(VcpuNumOrRangeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_vcpuNumOrRange

	return p
}

func (s *VcpuNumOrRangeContext) GetParser() antlr.Parser { return s.parser }

func (s *VcpuNumOrRangeContext) AllINT_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserINT_NUMBER)
}

func (s *VcpuNumOrRangeContext) INT_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, i)
}

func (s *VcpuNumOrRangeContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUS_OPERATOR, 0)
}

func (s *VcpuNumOrRangeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VcpuNumOrRangeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VcpuNumOrRangeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterVcpuNumOrRange(s)
	}
}

func (s *VcpuNumOrRangeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitVcpuNumOrRange(s)
	}
}

func (s *VcpuNumOrRangeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitVcpuNumOrRange(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) VcpuNumOrRange() (localctx IVcpuNumOrRangeContext) {
	localctx = NewVcpuNumOrRangeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 366, TiDBParserRULE_vcpuNumOrRange)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3190)
		p.Match(TiDBParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserMINUS_OPERATOR {
		{
			p.SetState(3191)
			p.Match(TiDBParserMINUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3192)
			p.Match(TiDBParserINT_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupPriorityContext is an interface to support dynamic dispatch.
type IResourceGroupPriorityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THREAD_PRIORITY_SYMBOL() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	Equal() IEqualContext

	// IsResourceGroupPriorityContext differentiates from other interfaces.
	IsResourceGroupPriorityContext()
}

type ResourceGroupPriorityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupPriorityContext() *ResourceGroupPriorityContext {
	var p = new(ResourceGroupPriorityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupPriority
	return p
}

func InitEmptyResourceGroupPriorityContext(p *ResourceGroupPriorityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupPriority
}

func (*ResourceGroupPriorityContext) IsResourceGroupPriorityContext() {}

func NewResourceGroupPriorityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupPriorityContext {
	var p = new(ResourceGroupPriorityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_resourceGroupPriority

	return p
}

func (s *ResourceGroupPriorityContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupPriorityContext) THREAD_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTHREAD_PRIORITY_SYMBOL, 0)
}

func (s *ResourceGroupPriorityContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *ResourceGroupPriorityContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *ResourceGroupPriorityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupPriorityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupPriorityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterResourceGroupPriority(s)
	}
}

func (s *ResourceGroupPriorityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitResourceGroupPriority(s)
	}
}

func (s *ResourceGroupPriorityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitResourceGroupPriority(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ResourceGroupPriority() (localctx IResourceGroupPriorityContext) {
	localctx = NewResourceGroupPriorityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 368, TiDBParserRULE_resourceGroupPriority)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3195)
		p.Match(TiDBParserTHREAD_PRIORITY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3197)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserEQUAL_OPERATOR || _la == TiDBParserASSIGN_OPERATOR {
		{
			p.SetState(3196)
			p.Equal()
		}

	}
	{
		p.SetState(3199)
		p.Match(TiDBParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupEnableDisableContext is an interface to support dynamic dispatch.
type IResourceGroupEnableDisableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENABLE_SYMBOL() antlr.TerminalNode
	DISABLE_SYMBOL() antlr.TerminalNode

	// IsResourceGroupEnableDisableContext differentiates from other interfaces.
	IsResourceGroupEnableDisableContext()
}

type ResourceGroupEnableDisableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupEnableDisableContext() *ResourceGroupEnableDisableContext {
	var p = new(ResourceGroupEnableDisableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupEnableDisable
	return p
}

func InitEmptyResourceGroupEnableDisableContext(p *ResourceGroupEnableDisableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupEnableDisable
}

func (*ResourceGroupEnableDisableContext) IsResourceGroupEnableDisableContext() {}

func NewResourceGroupEnableDisableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupEnableDisableContext {
	var p = new(ResourceGroupEnableDisableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_resourceGroupEnableDisable

	return p
}

func (s *ResourceGroupEnableDisableContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupEnableDisableContext) ENABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENABLE_SYMBOL, 0)
}

func (s *ResourceGroupEnableDisableContext) DISABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISABLE_SYMBOL, 0)
}

func (s *ResourceGroupEnableDisableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupEnableDisableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupEnableDisableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterResourceGroupEnableDisable(s)
	}
}

func (s *ResourceGroupEnableDisableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitResourceGroupEnableDisable(s)
	}
}

func (s *ResourceGroupEnableDisableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitResourceGroupEnableDisable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ResourceGroupEnableDisable() (localctx IResourceGroupEnableDisableContext) {
	localctx = NewResourceGroupEnableDisableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 370, TiDBParserRULE_resourceGroupEnableDisable)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3201)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserDISABLE_SYMBOL || _la == TiDBParserENABLE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterResourceGroupContext is an interface to support dynamic dispatch.
type IAlterResourceGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALTER_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	ResourceGroupRef() IResourceGroupRefContext
	ResourceGroupVcpuList() IResourceGroupVcpuListContext
	ResourceGroupPriority() IResourceGroupPriorityContext
	ResourceGroupEnableDisable() IResourceGroupEnableDisableContext
	FORCE_SYMBOL() antlr.TerminalNode

	// IsAlterResourceGroupContext differentiates from other interfaces.
	IsAlterResourceGroupContext()
}

type AlterResourceGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterResourceGroupContext() *AlterResourceGroupContext {
	var p = new(AlterResourceGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterResourceGroup
	return p
}

func InitEmptyAlterResourceGroupContext(p *AlterResourceGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterResourceGroup
}

func (*AlterResourceGroupContext) IsAlterResourceGroupContext() {}

func NewAlterResourceGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterResourceGroupContext {
	var p = new(AlterResourceGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_alterResourceGroup

	return p
}

func (s *AlterResourceGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterResourceGroupContext) ALTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALTER_SYMBOL, 0)
}

func (s *AlterResourceGroupContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESOURCE_SYMBOL, 0)
}

func (s *AlterResourceGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_SYMBOL, 0)
}

func (s *AlterResourceGroupContext) ResourceGroupRef() IResourceGroupRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupRefContext)
}

func (s *AlterResourceGroupContext) ResourceGroupVcpuList() IResourceGroupVcpuListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupVcpuListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupVcpuListContext)
}

func (s *AlterResourceGroupContext) ResourceGroupPriority() IResourceGroupPriorityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupPriorityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupPriorityContext)
}

func (s *AlterResourceGroupContext) ResourceGroupEnableDisable() IResourceGroupEnableDisableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupEnableDisableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupEnableDisableContext)
}

func (s *AlterResourceGroupContext) FORCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFORCE_SYMBOL, 0)
}

func (s *AlterResourceGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterResourceGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterResourceGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterAlterResourceGroup(s)
	}
}

func (s *AlterResourceGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitAlterResourceGroup(s)
	}
}

func (s *AlterResourceGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitAlterResourceGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) AlterResourceGroup() (localctx IAlterResourceGroupContext) {
	localctx = NewAlterResourceGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 372, TiDBParserRULE_alterResourceGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3203)
		p.Match(TiDBParserALTER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3204)
		p.Match(TiDBParserRESOURCE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3205)
		p.Match(TiDBParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3206)
		p.ResourceGroupRef()
	}
	p.SetState(3208)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserVCPU_SYMBOL {
		{
			p.SetState(3207)
			p.ResourceGroupVcpuList()
		}

	}
	p.SetState(3211)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserTHREAD_PRIORITY_SYMBOL {
		{
			p.SetState(3210)
			p.ResourceGroupPriority()
		}

	}
	p.SetState(3214)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserDISABLE_SYMBOL || _la == TiDBParserENABLE_SYMBOL {
		{
			p.SetState(3213)
			p.ResourceGroupEnableDisable()
		}

	}
	p.SetState(3217)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserFORCE_SYMBOL {
		{
			p.SetState(3216)
			p.Match(TiDBParserFORCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetResourceGroupContext is an interface to support dynamic dispatch.
type ISetResourceGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SET_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	FOR_SYMBOL() antlr.TerminalNode
	ThreadIdList() IThreadIdListContext

	// IsSetResourceGroupContext differentiates from other interfaces.
	IsSetResourceGroupContext()
}

type SetResourceGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetResourceGroupContext() *SetResourceGroupContext {
	var p = new(SetResourceGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setResourceGroup
	return p
}

func InitEmptySetResourceGroupContext(p *SetResourceGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setResourceGroup
}

func (*SetResourceGroupContext) IsSetResourceGroupContext() {}

func NewSetResourceGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetResourceGroupContext {
	var p = new(SetResourceGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_setResourceGroup

	return p
}

func (s *SetResourceGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *SetResourceGroupContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSET_SYMBOL, 0)
}

func (s *SetResourceGroupContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESOURCE_SYMBOL, 0)
}

func (s *SetResourceGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_SYMBOL, 0)
}

func (s *SetResourceGroupContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SetResourceGroupContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *SetResourceGroupContext) ThreadIdList() IThreadIdListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThreadIdListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThreadIdListContext)
}

func (s *SetResourceGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetResourceGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetResourceGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSetResourceGroup(s)
	}
}

func (s *SetResourceGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSetResourceGroup(s)
	}
}

func (s *SetResourceGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSetResourceGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SetResourceGroup() (localctx ISetResourceGroupContext) {
	localctx = NewSetResourceGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 374, TiDBParserRULE_setResourceGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3219)
		p.Match(TiDBParserSET_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3220)
		p.Match(TiDBParserRESOURCE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3221)
		p.Match(TiDBParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3222)
		p.Identifier()
	}
	p.SetState(3225)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserFOR_SYMBOL {
		{
			p.SetState(3223)
			p.Match(TiDBParserFOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3224)
			p.ThreadIdList()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThreadIdListContext is an interface to support dynamic dispatch.
type IThreadIdListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllReal_ulong_number() []IReal_ulong_numberContext
	Real_ulong_number(i int) IReal_ulong_numberContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsThreadIdListContext differentiates from other interfaces.
	IsThreadIdListContext()
}

type ThreadIdListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThreadIdListContext() *ThreadIdListContext {
	var p = new(ThreadIdListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_threadIdList
	return p
}

func InitEmptyThreadIdListContext(p *ThreadIdListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_threadIdList
}

func (*ThreadIdListContext) IsThreadIdListContext() {}

func NewThreadIdListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThreadIdListContext {
	var p = new(ThreadIdListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_threadIdList

	return p
}

func (s *ThreadIdListContext) GetParser() antlr.Parser { return s.parser }

func (s *ThreadIdListContext) AllReal_ulong_number() []IReal_ulong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			len++
		}
	}

	tst := make([]IReal_ulong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReal_ulong_numberContext); ok {
			tst[i] = t.(IReal_ulong_numberContext)
			i++
		}
	}

	return tst
}

func (s *ThreadIdListContext) Real_ulong_number(i int) IReal_ulong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *ThreadIdListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ThreadIdListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ThreadIdListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThreadIdListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThreadIdListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterThreadIdList(s)
	}
}

func (s *ThreadIdListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitThreadIdList(s)
	}
}

func (s *ThreadIdListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitThreadIdList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ThreadIdList() (localctx IThreadIdListContext) {
	localctx = NewThreadIdListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 376, TiDBParserRULE_threadIdList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3227)
		p.Real_ulong_number()
	}
	p.SetState(3234)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for (int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&2199090364423) != 0 {
		p.SetState(3229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(3228)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3231)
			p.Real_ulong_number()
		}

		p.SetState(3236)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDropResourceGroupContext is an interface to support dynamic dispatch.
type IDropResourceGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DROP_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	GROUP_SYMBOL() antlr.TerminalNode
	ResourceGroupRef() IResourceGroupRefContext
	FORCE_SYMBOL() antlr.TerminalNode

	// IsDropResourceGroupContext differentiates from other interfaces.
	IsDropResourceGroupContext()
}

type DropResourceGroupContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDropResourceGroupContext() *DropResourceGroupContext {
	var p = new(DropResourceGroupContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dropResourceGroup
	return p
}

func InitEmptyDropResourceGroupContext(p *DropResourceGroupContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dropResourceGroup
}

func (*DropResourceGroupContext) IsDropResourceGroupContext() {}

func NewDropResourceGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DropResourceGroupContext {
	var p = new(DropResourceGroupContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_dropResourceGroup

	return p
}

func (s *DropResourceGroupContext) GetParser() antlr.Parser { return s.parser }

func (s *DropResourceGroupContext) DROP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDROP_SYMBOL, 0)
}

func (s *DropResourceGroupContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESOURCE_SYMBOL, 0)
}

func (s *DropResourceGroupContext) GROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_SYMBOL, 0)
}

func (s *DropResourceGroupContext) ResourceGroupRef() IResourceGroupRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IResourceGroupRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IResourceGroupRefContext)
}

func (s *DropResourceGroupContext) FORCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFORCE_SYMBOL, 0)
}

func (s *DropResourceGroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DropResourceGroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DropResourceGroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDropResourceGroup(s)
	}
}

func (s *DropResourceGroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDropResourceGroup(s)
	}
}

func (s *DropResourceGroupContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDropResourceGroup(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DropResourceGroup() (localctx IDropResourceGroupContext) {
	localctx = NewDropResourceGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 378, TiDBParserRULE_dropResourceGroup)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3237)
		p.Match(TiDBParserDROP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3238)
		p.Match(TiDBParserRESOURCE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3239)
		p.Match(TiDBParserGROUP_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3240)
		p.ResourceGroupRef()
	}
	p.SetState(3242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserFORCE_SYMBOL {
		{
			p.SetState(3241)
			p.Match(TiDBParserFORCE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprContext is an interface to support dynamic dispatch.
type IExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExprContext differentiates from other interfaces.
	IsExprContext()
}

type ExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprContext() *ExprContext {
	var p = new(ExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_expr
	return p
}

func InitEmptyExprContext(p *ExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_expr
}

func (*ExprContext) IsExprContext() {}

func NewExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprContext {
	var p = new(ExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_expr

	return p
}

func (s *ExprContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprContext) CopyAll(ctx *ExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type ExprOrContext struct {
	ExprContext
	op antlr.Token
}

func NewExprOrContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprOrContext {
	var p = new(ExprOrContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprOrContext) GetOp() antlr.Token { return s.op }

func (s *ExprOrContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprOrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprOrContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprOrContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprOrContext) OR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOR_SYMBOL, 0)
}

func (s *ExprOrContext) LOGICAL_OR_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOGICAL_OR_OPERATOR, 0)
}

func (s *ExprOrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExprOr(s)
	}
}

func (s *ExprOrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExprOr(s)
	}
}

func (s *ExprOrContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExprOr(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprNotContext struct {
	ExprContext
}

func NewExprNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprNotContext {
	var p = new(ExprNotContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprNotContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOT_SYMBOL, 0)
}

func (s *ExprNotContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExprNot(s)
	}
}

func (s *ExprNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExprNot(s)
	}
}

func (s *ExprNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExprNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprIsContext struct {
	ExprContext
	type_ antlr.Token
}

func NewExprIsContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprIsContext {
	var p = new(ExprIsContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprIsContext) GetType_() antlr.Token { return s.type_ }

func (s *ExprIsContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *ExprIsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprIsContext) BoolPri() IBoolPriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolPriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolPriContext)
}

func (s *ExprIsContext) IS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIS_SYMBOL, 0)
}

func (s *ExprIsContext) TRUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRUE_SYMBOL, 0)
}

func (s *ExprIsContext) FALSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFALSE_SYMBOL, 0)
}

func (s *ExprIsContext) UNKNOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNKNOWN_SYMBOL, 0)
}

func (s *ExprIsContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *ExprIsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExprIs(s)
	}
}

func (s *ExprIsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExprIs(s)
	}
}

func (s *ExprIsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExprIs(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprAndContext struct {
	ExprContext
	op antlr.Token
}

func NewExprAndContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprAndContext {
	var p = new(ExprAndContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprAndContext) GetOp() antlr.Token { return s.op }

func (s *ExprAndContext) SetOp(v antlr.Token) { s.op = v }

func (s *ExprAndContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprAndContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprAndContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprAndContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAND_SYMBOL, 0)
}

func (s *ExprAndContext) LOGICAL_AND_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOGICAL_AND_OPERATOR, 0)
}

func (s *ExprAndContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExprAnd(s)
	}
}

func (s *ExprAndContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExprAnd(s)
	}
}

func (s *ExprAndContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExprAnd(s)

	default:
		return t.VisitChildren(s)
	}
}

type ExprXorContext struct {
	ExprContext
}

func NewExprXorContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExprXorContext {
	var p = new(ExprXorContext)

	InitEmptyExprContext(&p.ExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExprContext))

	return p
}

func (s *ExprXorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprXorContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprXorContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprXorContext) XOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserXOR_SYMBOL, 0)
}

func (s *ExprXorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExprXor(s)
	}
}

func (s *ExprXorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExprXor(s)
	}
}

func (s *ExprXorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExprXor(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Expr() (localctx IExprContext) {
	return p.expr(0)
}

func (p *TiDBParser) expr(_p int) (localctx IExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 380
	p.EnterRecursionRule(localctx, 380, TiDBParserRULE_expr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3255)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINARY_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_AND_SYMBOL, TiDBParserBIT_OR_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBIT_XOR_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCASE_SYMBOL, TiDBParserCAST_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHAR_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCONVERT_SYMBOL, TiDBParserCOUNT_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURDATE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURRENT_USER_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserCURTIME_SYMBOL, TiDBParserDATABASE_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_ADD_SYMBOL, TiDBParserDATE_SUB_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXISTS_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserEXTRACT_SYMBOL, TiDBParserFALSE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserGROUP_CONCAT_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIF_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINTERVAL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLEFT_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMATCH_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMIN_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMOD_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNOW_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNULL_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPOSITION_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPEAT_SYMBOL, TiDBParserREPLACE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserRIGHT_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTDDEV_SAMP_SYMBOL, TiDBParserSTD_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUBSTRING_SYMBOL, TiDBParserSUM_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserSYSDATE_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRIM_SYMBOL, TiDBParserTRUE_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserUTC_DATE_SYMBOL, TiDBParserUTC_TIMESTAMP_SYMBOL, TiDBParserUTC_TIME_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUES_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVARIANCE_SYMBOL, TiDBParserVAR_SAMP_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserJSON_OBJECTAGG_SYMBOL, TiDBParserJSON_ARRAYAGG_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserGROUPING_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserCUME_DIST_SYMBOL, TiDBParserDENSE_RANK_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFIRST_VALUE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserLAG_SYMBOL, TiDBParserLAST_VALUE_SYMBOL, TiDBParserLEAD_SYMBOL, TiDBParserNTH_VALUE_SYMBOL, TiDBParserNTILE_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPERCENT_RANK_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRANK_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserROW_NUMBER_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserNOT2_SYMBOL, TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserPLUS_OPERATOR, TiDBParserMINUS_OPERATOR, TiDBParserLOGICAL_NOT_OPERATOR, TiDBParserBITWISE_NOT_OPERATOR, TiDBParserDOT_SYMBOL, TiDBParserOPEN_PAR_SYMBOL, TiDBParserOPEN_CURLY_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserAT_SIGN_SYMBOL, TiDBParserAT_TEXT_SUFFIX, TiDBParserAT_AT_SIGN_SYMBOL, TiDBParserNULL2_SYMBOL, TiDBParserPARAM_MARKER, TiDBParserHEX_NUMBER, TiDBParserBIN_NUMBER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserUNDERSCORE_CHARSET, TiDBParserIDENTIFIER, TiDBParserNCHAR_TEXT, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		localctx = NewExprIsContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(3245)
			p.boolPri(0)
		}
		p.SetState(3251)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 406, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3246)
				p.Match(TiDBParserIS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(3248)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserNOT_SYMBOL || _la == TiDBParserNOT2_SYMBOL {
				{
					p.SetState(3247)
					p.NotRule()
				}

			}
			{
				p.SetState(3250)

				var _lt = p.GetTokenStream().LT(1)

				localctx.(*ExprIsContext).type_ = _lt

				_la = p.GetTokenStream().LA(1)

				if !(_la == TiDBParserFALSE_SYMBOL || _la == TiDBParserTRUE_SYMBOL || _la == TiDBParserUNKNOWN_SYMBOL) {
					var _ri = p.GetErrorHandler().RecoverInline(p)

					localctx.(*ExprIsContext).type_ = _ri
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserNOT_SYMBOL:
		localctx = NewExprNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3253)
			p.Match(TiDBParserNOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3254)
			p.expr(4)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 409, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3266)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 408, p.GetParserRuleContext()) {
			case 1:
				localctx = NewExprAndContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_expr)
				p.SetState(3257)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(3258)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprAndContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == TiDBParserAND_SYMBOL || _la == TiDBParserLOGICAL_AND_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprAndContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3259)
					p.expr(4)
				}

			case 2:
				localctx = NewExprXorContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_expr)
				p.SetState(3260)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(3261)
					p.Match(TiDBParserXOR_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3262)
					p.expr(3)
				}

			case 3:
				localctx = NewExprOrContext(p, NewExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_expr)
				p.SetState(3263)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3264)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*ExprOrContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == TiDBParserOR_SYMBOL || _la == TiDBParserLOGICAL_OR_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*ExprOrContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3265)
					p.expr(2)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3270)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 409, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoolPriContext is an interface to support dynamic dispatch.
type IBoolPriContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsBoolPriContext differentiates from other interfaces.
	IsBoolPriContext()
}

type BoolPriContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolPriContext() *BoolPriContext {
	var p = new(BoolPriContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_boolPri
	return p
}

func InitEmptyBoolPriContext(p *BoolPriContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_boolPri
}

func (*BoolPriContext) IsBoolPriContext() {}

func NewBoolPriContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolPriContext {
	var p = new(BoolPriContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_boolPri

	return p
}

func (s *BoolPriContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolPriContext) CopyAll(ctx *BoolPriContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *BoolPriContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolPriContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PrimaryExprPredicateContext struct {
	BoolPriContext
}

func NewPrimaryExprPredicateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExprPredicateContext {
	var p = new(PrimaryExprPredicateContext)

	InitEmptyBoolPriContext(&p.BoolPriContext)
	p.parser = parser
	p.CopyAll(ctx.(*BoolPriContext))

	return p
}

func (s *PrimaryExprPredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprPredicateContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PrimaryExprPredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPrimaryExprPredicate(s)
	}
}

func (s *PrimaryExprPredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPrimaryExprPredicate(s)
	}
}

func (s *PrimaryExprPredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPrimaryExprPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryExprCompareContext struct {
	BoolPriContext
}

func NewPrimaryExprCompareContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExprCompareContext {
	var p = new(PrimaryExprCompareContext)

	InitEmptyBoolPriContext(&p.BoolPriContext)
	p.parser = parser
	p.CopyAll(ctx.(*BoolPriContext))

	return p
}

func (s *PrimaryExprCompareContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprCompareContext) BoolPri() IBoolPriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolPriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolPriContext)
}

func (s *PrimaryExprCompareContext) CompOp() ICompOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompOpContext)
}

func (s *PrimaryExprCompareContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PrimaryExprCompareContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPrimaryExprCompare(s)
	}
}

func (s *PrimaryExprCompareContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPrimaryExprCompare(s)
	}
}

func (s *PrimaryExprCompareContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPrimaryExprCompare(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryExprAllAnyContext struct {
	BoolPriContext
}

func NewPrimaryExprAllAnyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExprAllAnyContext {
	var p = new(PrimaryExprAllAnyContext)

	InitEmptyBoolPriContext(&p.BoolPriContext)
	p.parser = parser
	p.CopyAll(ctx.(*BoolPriContext))

	return p
}

func (s *PrimaryExprAllAnyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprAllAnyContext) BoolPri() IBoolPriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolPriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolPriContext)
}

func (s *PrimaryExprAllAnyContext) CompOp() ICompOpContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICompOpContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICompOpContext)
}

func (s *PrimaryExprAllAnyContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *PrimaryExprAllAnyContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *PrimaryExprAllAnyContext) ANY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserANY_SYMBOL, 0)
}

func (s *PrimaryExprAllAnyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPrimaryExprAllAny(s)
	}
}

func (s *PrimaryExprAllAnyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPrimaryExprAllAny(s)
	}
}

func (s *PrimaryExprAllAnyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPrimaryExprAllAny(s)

	default:
		return t.VisitChildren(s)
	}
}

type PrimaryExprIsNullContext struct {
	BoolPriContext
}

func NewPrimaryExprIsNullContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PrimaryExprIsNullContext {
	var p = new(PrimaryExprIsNullContext)

	InitEmptyBoolPriContext(&p.BoolPriContext)
	p.parser = parser
	p.CopyAll(ctx.(*BoolPriContext))

	return p
}

func (s *PrimaryExprIsNullContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrimaryExprIsNullContext) BoolPri() IBoolPriContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolPriContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolPriContext)
}

func (s *PrimaryExprIsNullContext) IS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIS_SYMBOL, 0)
}

func (s *PrimaryExprIsNullContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL_SYMBOL, 0)
}

func (s *PrimaryExprIsNullContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *PrimaryExprIsNullContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPrimaryExprIsNull(s)
	}
}

func (s *PrimaryExprIsNullContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPrimaryExprIsNull(s)
	}
}

func (s *PrimaryExprIsNullContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPrimaryExprIsNull(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) BoolPri() (localctx IBoolPriContext) {
	return p.boolPri(0)
}

func (p *TiDBParser) boolPri(_p int) (localctx IBoolPriContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBoolPriContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBoolPriContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 382
	p.EnterRecursionRule(localctx, 382, TiDBParserRULE_boolPri, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewPrimaryExprPredicateContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(3272)
		p.Predicate()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 412, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3289)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 411, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPrimaryExprIsNullContext(p, NewBoolPriContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_boolPri)
				p.SetState(3274)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(3275)
					p.Match(TiDBParserIS_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				p.SetState(3277)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == TiDBParserNOT_SYMBOL || _la == TiDBParserNOT2_SYMBOL {
					{
						p.SetState(3276)
						p.NotRule()
					}

				}
				{
					p.SetState(3279)
					p.Match(TiDBParserNULL_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			case 2:
				localctx = NewPrimaryExprCompareContext(p, NewBoolPriContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_boolPri)
				p.SetState(3280)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(3281)
					p.CompOp()
				}
				{
					p.SetState(3282)
					p.Predicate()
				}

			case 3:
				localctx = NewPrimaryExprAllAnyContext(p, NewBoolPriContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_boolPri)
				p.SetState(3284)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3285)
					p.CompOp()
				}
				{
					p.SetState(3286)
					_la = p.GetTokenStream().LA(1)

					if !(_la == TiDBParserALL_SYMBOL || _la == TiDBParserANY_SYMBOL) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3287)
					p.Subquery()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3293)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 412, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICompOpContext is an interface to support dynamic dispatch.
type ICompOpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_OPERATOR() antlr.TerminalNode
	NULL_SAFE_EQUAL_OPERATOR() antlr.TerminalNode
	GREATER_OR_EQUAL_OPERATOR() antlr.TerminalNode
	GREATER_THAN_OPERATOR() antlr.TerminalNode
	LESS_OR_EQUAL_OPERATOR() antlr.TerminalNode
	LESS_THAN_OPERATOR() antlr.TerminalNode
	NOT_EQUAL_OPERATOR() antlr.TerminalNode

	// IsCompOpContext differentiates from other interfaces.
	IsCompOpContext()
}

type CompOpContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCompOpContext() *CompOpContext {
	var p = new(CompOpContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_compOp
	return p
}

func InitEmptyCompOpContext(p *CompOpContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_compOp
}

func (*CompOpContext) IsCompOpContext() {}

func NewCompOpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CompOpContext {
	var p = new(CompOpContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_compOp

	return p
}

func (s *CompOpContext) GetParser() antlr.Parser { return s.parser }

func (s *CompOpContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *CompOpContext) NULL_SAFE_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL_SAFE_EQUAL_OPERATOR, 0)
}

func (s *CompOpContext) GREATER_OR_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserGREATER_OR_EQUAL_OPERATOR, 0)
}

func (s *CompOpContext) GREATER_THAN_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserGREATER_THAN_OPERATOR, 0)
}

func (s *CompOpContext) LESS_OR_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserLESS_OR_EQUAL_OPERATOR, 0)
}

func (s *CompOpContext) LESS_THAN_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserLESS_THAN_OPERATOR, 0)
}

func (s *CompOpContext) NOT_EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOT_EQUAL_OPERATOR, 0)
}

func (s *CompOpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CompOpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CompOpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCompOp(s)
	}
}

func (s *CompOpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCompOp(s)
	}
}

func (s *CompOpContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCompOp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CompOp() (localctx ICompOpContext) {
	localctx = NewCompOpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 384, TiDBParserRULE_compOp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3294)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-750)) & ^0x3f) == 0 && ((int64(1)<<(_la-750))&253) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateContext is an interface to support dynamic dispatch.
type IPredicateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllBitExpr() []IBitExprContext
	BitExpr(i int) IBitExprContext
	PredicateOperations() IPredicateOperationsContext
	MEMBER_SYMBOL() antlr.TerminalNode
	SimpleExprWithParentheses() ISimpleExprWithParenthesesContext
	SOUNDS_SYMBOL() antlr.TerminalNode
	LIKE_SYMBOL() antlr.TerminalNode
	NotRule() INotRuleContext
	OF_SYMBOL() antlr.TerminalNode

	// IsPredicateContext differentiates from other interfaces.
	IsPredicateContext()
}

type PredicateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateContext() *PredicateContext {
	var p = new(PredicateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_predicate
	return p
}

func InitEmptyPredicateContext(p *PredicateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_predicate
}

func (*PredicateContext) IsPredicateContext() {}

func NewPredicateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateContext {
	var p = new(PredicateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_predicate

	return p
}

func (s *PredicateContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateContext) AllBitExpr() []IBitExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitExprContext); ok {
			len++
		}
	}

	tst := make([]IBitExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitExprContext); ok {
			tst[i] = t.(IBitExprContext)
			i++
		}
	}

	return tst
}

func (s *PredicateContext) BitExpr(i int) IBitExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PredicateContext) PredicateOperations() IPredicateOperationsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateOperationsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateOperationsContext)
}

func (s *PredicateContext) MEMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEMBER_SYMBOL, 0)
}

func (s *PredicateContext) SimpleExprWithParentheses() ISimpleExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprWithParenthesesContext)
}

func (s *PredicateContext) SOUNDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSOUNDS_SYMBOL, 0)
}

func (s *PredicateContext) LIKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLIKE_SYMBOL, 0)
}

func (s *PredicateContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *PredicateContext) OF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOF_SYMBOL, 0)
}

func (s *PredicateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PredicateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPredicate(s)
	}
}

func (s *PredicateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPredicate(s)
	}
}

func (s *PredicateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPredicate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Predicate() (localctx IPredicateContext) {
	localctx = NewPredicateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 386, TiDBParserRULE_predicate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3296)
		p.bitExpr(0)
	}
	p.SetState(3309)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext()) == 1 {
		p.SetState(3298)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserNOT_SYMBOL || _la == TiDBParserNOT2_SYMBOL {
			{
				p.SetState(3297)
				p.NotRule()
			}

		}
		{
			p.SetState(3300)
			p.PredicateOperations()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(3301)
			p.Match(TiDBParserMEMBER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3303)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOF_SYMBOL {
			{
				p.SetState(3302)
				p.Match(TiDBParserOF_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3305)
			p.SimpleExprWithParentheses()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 415, p.GetParserRuleContext()) == 3 {
		{
			p.SetState(3306)
			p.Match(TiDBParserSOUNDS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3307)
			p.Match(TiDBParserLIKE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3308)
			p.bitExpr(0)
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPredicateOperationsContext is an interface to support dynamic dispatch.
type IPredicateOperationsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPredicateOperationsContext differentiates from other interfaces.
	IsPredicateOperationsContext()
}

type PredicateOperationsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPredicateOperationsContext() *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_predicateOperations
	return p
}

func InitEmptyPredicateOperationsContext(p *PredicateOperationsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_predicateOperations
}

func (*PredicateOperationsContext) IsPredicateOperationsContext() {}

func NewPredicateOperationsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PredicateOperationsContext {
	var p = new(PredicateOperationsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_predicateOperations

	return p
}

func (s *PredicateOperationsContext) GetParser() antlr.Parser { return s.parser }

func (s *PredicateOperationsContext) CopyAll(ctx *PredicateOperationsContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PredicateOperationsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateOperationsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PredicateExprRegexContext struct {
	PredicateOperationsContext
}

func NewPredicateExprRegexContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExprRegexContext {
	var p = new(PredicateExprRegexContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *PredicateExprRegexContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExprRegexContext) REGEXP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREGEXP_SYMBOL, 0)
}

func (s *PredicateExprRegexContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PredicateExprRegexContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPredicateExprRegex(s)
	}
}

func (s *PredicateExprRegexContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPredicateExprRegex(s)
	}
}

func (s *PredicateExprRegexContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPredicateExprRegex(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExprBetweenContext struct {
	PredicateOperationsContext
}

func NewPredicateExprBetweenContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExprBetweenContext {
	var p = new(PredicateExprBetweenContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *PredicateExprBetweenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExprBetweenContext) BETWEEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBETWEEN_SYMBOL, 0)
}

func (s *PredicateExprBetweenContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PredicateExprBetweenContext) AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAND_SYMBOL, 0)
}

func (s *PredicateExprBetweenContext) Predicate() IPredicateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPredicateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPredicateContext)
}

func (s *PredicateExprBetweenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPredicateExprBetween(s)
	}
}

func (s *PredicateExprBetweenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPredicateExprBetween(s)
	}
}

func (s *PredicateExprBetweenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPredicateExprBetween(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExprInContext struct {
	PredicateOperationsContext
}

func NewPredicateExprInContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExprInContext {
	var p = new(PredicateExprInContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *PredicateExprInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExprInContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIN_SYMBOL, 0)
}

func (s *PredicateExprInContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *PredicateExprInContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *PredicateExprInContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *PredicateExprInContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PredicateExprInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPredicateExprIn(s)
	}
}

func (s *PredicateExprInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPredicateExprIn(s)
	}
}

func (s *PredicateExprInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPredicateExprIn(s)

	default:
		return t.VisitChildren(s)
	}
}

type PredicateExprLikeContext struct {
	PredicateOperationsContext
}

func NewPredicateExprLikeContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredicateExprLikeContext {
	var p = new(PredicateExprLikeContext)

	InitEmptyPredicateOperationsContext(&p.PredicateOperationsContext)
	p.parser = parser
	p.CopyAll(ctx.(*PredicateOperationsContext))

	return p
}

func (s *PredicateExprLikeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredicateExprLikeContext) LIKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLIKE_SYMBOL, 0)
}

func (s *PredicateExprLikeContext) AllSimpleExpr() []ISimpleExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleExprContext); ok {
			len++
		}
	}

	tst := make([]ISimpleExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleExprContext); ok {
			tst[i] = t.(ISimpleExprContext)
			i++
		}
	}

	return tst
}

func (s *PredicateExprLikeContext) SimpleExpr(i int) ISimpleExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *PredicateExprLikeContext) ESCAPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserESCAPE_SYMBOL, 0)
}

func (s *PredicateExprLikeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPredicateExprLike(s)
	}
}

func (s *PredicateExprLikeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPredicateExprLike(s)
	}
}

func (s *PredicateExprLikeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPredicateExprLike(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PredicateOperations() (localctx IPredicateOperationsContext) {
	localctx = NewPredicateOperationsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 388, TiDBParserRULE_predicateOperations)
	p.SetState(3332)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserIN_SYMBOL:
		localctx = NewPredicateExprInContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3311)
			p.Match(TiDBParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3317)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 416, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3312)
				p.Subquery()
			}

		case 2:
			{
				p.SetState(3313)
				p.Match(TiDBParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3314)
				p.ExprList()
			}
			{
				p.SetState(3315)
				p.Match(TiDBParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case TiDBParserBETWEEN_SYMBOL:
		localctx = NewPredicateExprBetweenContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3319)
			p.Match(TiDBParserBETWEEN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3320)
			p.bitExpr(0)
		}
		{
			p.SetState(3321)
			p.Match(TiDBParserAND_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3322)
			p.Predicate()
		}

	case TiDBParserLIKE_SYMBOL:
		localctx = NewPredicateExprLikeContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3324)
			p.Match(TiDBParserLIKE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3325)
			p.simpleExpr(0)
		}
		p.SetState(3328)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 417, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3326)
				p.Match(TiDBParserESCAPE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3327)
				p.simpleExpr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserREGEXP_SYMBOL:
		localctx = NewPredicateExprRegexContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3330)
			p.Match(TiDBParserREGEXP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3331)
			p.bitExpr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBitExprContext is an interface to support dynamic dispatch.
type IBitExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOp returns the op token.
	GetOp() antlr.Token

	// SetOp sets the op token.
	SetOp(antlr.Token)

	// Getter signatures
	SimpleExpr() ISimpleExprContext
	AllBitExpr() []IBitExprContext
	BitExpr(i int) IBitExprContext
	BITWISE_XOR_OPERATOR() antlr.TerminalNode
	MULT_OPERATOR() antlr.TerminalNode
	DIV_OPERATOR() antlr.TerminalNode
	MOD_OPERATOR() antlr.TerminalNode
	DIV_SYMBOL() antlr.TerminalNode
	MOD_SYMBOL() antlr.TerminalNode
	PLUS_OPERATOR() antlr.TerminalNode
	MINUS_OPERATOR() antlr.TerminalNode
	SHIFT_LEFT_OPERATOR() antlr.TerminalNode
	SHIFT_RIGHT_OPERATOR() antlr.TerminalNode
	BITWISE_AND_OPERATOR() antlr.TerminalNode
	BITWISE_OR_OPERATOR() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	Interval() IIntervalContext

	// IsBitExprContext differentiates from other interfaces.
	IsBitExprContext()
}

type BitExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	op     antlr.Token
}

func NewEmptyBitExprContext() *BitExprContext {
	var p = new(BitExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_bitExpr
	return p
}

func InitEmptyBitExprContext(p *BitExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_bitExpr
}

func (*BitExprContext) IsBitExprContext() {}

func NewBitExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitExprContext {
	var p = new(BitExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_bitExpr

	return p
}

func (s *BitExprContext) GetParser() antlr.Parser { return s.parser }

func (s *BitExprContext) GetOp() antlr.Token { return s.op }

func (s *BitExprContext) SetOp(v antlr.Token) { s.op = v }

func (s *BitExprContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *BitExprContext) AllBitExpr() []IBitExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IBitExprContext); ok {
			len++
		}
	}

	tst := make([]IBitExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IBitExprContext); ok {
			tst[i] = t.(IBitExprContext)
			i++
		}
	}

	return tst
}

func (s *BitExprContext) BitExpr(i int) IBitExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *BitExprContext) BITWISE_XOR_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserBITWISE_XOR_OPERATOR, 0)
}

func (s *BitExprContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULT_OPERATOR, 0)
}

func (s *BitExprContext) DIV_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIV_OPERATOR, 0)
}

func (s *BitExprContext) MOD_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMOD_OPERATOR, 0)
}

func (s *BitExprContext) DIV_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIV_SYMBOL, 0)
}

func (s *BitExprContext) MOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMOD_SYMBOL, 0)
}

func (s *BitExprContext) PLUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUS_OPERATOR, 0)
}

func (s *BitExprContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUS_OPERATOR, 0)
}

func (s *BitExprContext) SHIFT_LEFT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHIFT_LEFT_OPERATOR, 0)
}

func (s *BitExprContext) SHIFT_RIGHT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHIFT_RIGHT_OPERATOR, 0)
}

func (s *BitExprContext) BITWISE_AND_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserBITWISE_AND_OPERATOR, 0)
}

func (s *BitExprContext) BITWISE_OR_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserBITWISE_OR_OPERATOR, 0)
}

func (s *BitExprContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTERVAL_SYMBOL, 0)
}

func (s *BitExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *BitExprContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *BitExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterBitExpr(s)
	}
}

func (s *BitExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitBitExpr(s)
	}
}

func (s *BitExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitBitExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) BitExpr() (localctx IBitExprContext) {
	return p.bitExpr(0)
}

func (p *TiDBParser) bitExpr(_p int) (localctx IBitExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewBitExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IBitExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 390
	p.EnterRecursionRule(localctx, 390, TiDBParserRULE_bitExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3335)
		p.simpleExpr(0)
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3363)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3361)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 419, p.GetParserRuleContext()) {
			case 1:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_bitExpr)
				p.SetState(3337)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(3338)

					var _m = p.Match(TiDBParserBITWISE_XOR_OPERATOR)

					localctx.(*BitExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3339)
					p.bitExpr(8)
				}

			case 2:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_bitExpr)
				p.SetState(3340)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(3341)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*BitExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == TiDBParserDIV_SYMBOL || _la == TiDBParserMOD_SYMBOL || ((int64((_la-760)) & ^0x3f) == 0 && ((int64(1)<<(_la-760))&7) != 0)) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*BitExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3342)
					p.bitExpr(7)
				}

			case 3:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_bitExpr)
				p.SetState(3343)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(3344)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*BitExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == TiDBParserPLUS_OPERATOR || _la == TiDBParserMINUS_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*BitExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3345)
					p.bitExpr(6)
				}

			case 4:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_bitExpr)
				p.SetState(3346)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(3347)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*BitExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == TiDBParserSHIFT_LEFT_OPERATOR || _la == TiDBParserSHIFT_RIGHT_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*BitExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3348)
					p.bitExpr(4)
				}

			case 5:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_bitExpr)
				p.SetState(3349)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(3350)

					var _m = p.Match(TiDBParserBITWISE_AND_OPERATOR)

					localctx.(*BitExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3351)
					p.bitExpr(3)
				}

			case 6:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_bitExpr)
				p.SetState(3352)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(3353)

					var _m = p.Match(TiDBParserBITWISE_OR_OPERATOR)

					localctx.(*BitExprContext).op = _m
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3354)
					p.bitExpr(2)
				}

			case 7:
				localctx = NewBitExprContext(p, _parentctx, _parentState)
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_bitExpr)
				p.SetState(3355)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(3356)

					var _lt = p.GetTokenStream().LT(1)

					localctx.(*BitExprContext).op = _lt

					_la = p.GetTokenStream().LA(1)

					if !(_la == TiDBParserPLUS_OPERATOR || _la == TiDBParserMINUS_OPERATOR) {
						var _ri = p.GetErrorHandler().RecoverInline(p)

						localctx.(*BitExprContext).op = _ri
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(3357)
					p.Match(TiDBParserINTERVAL_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3358)
					p.expr(0)
				}
				{
					p.SetState(3359)
					p.Interval()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3365)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 420, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExprContext is an interface to support dynamic dispatch.
type ISimpleExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSimpleExprContext differentiates from other interfaces.
	IsSimpleExprContext()
}

type SimpleExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExprContext() *SimpleExprContext {
	var p = new(SimpleExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_simpleExpr
	return p
}

func InitEmptySimpleExprContext(p *SimpleExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_simpleExpr
}

func (*SimpleExprContext) IsSimpleExprContext() {}

func NewSimpleExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExprContext {
	var p = new(SimpleExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_simpleExpr

	return p
}

func (s *SimpleExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExprContext) CopyAll(ctx *SimpleExprContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SimpleExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type SimpleExprConvertContext struct {
	SimpleExprContext
}

func NewSimpleExprConvertContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprConvertContext {
	var p = new(SimpleExprConvertContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprConvertContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprConvertContext) CONVERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONVERT_SYMBOL, 0)
}

func (s *SimpleExprConvertContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprConvertContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprConvertContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *SimpleExprConvertContext) CastType() ICastTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastTypeContext)
}

func (s *SimpleExprConvertContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprConvertContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprConvert(s)
	}
}

func (s *SimpleExprConvertContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprConvert(s)
	}
}

func (s *SimpleExprConvertContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprConvert(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprSearchJsonContext struct {
	SimpleExprContext
}

func NewSimpleExprSearchJsonContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprSearchJsonContext {
	var p = new(SimpleExprSearchJsonContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprSearchJsonContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprSearchJsonContext) SearchJsonFunction() ISearchJsonFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISearchJsonFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISearchJsonFunctionContext)
}

func (s *SimpleExprSearchJsonContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprSearchJson(s)
	}
}

func (s *SimpleExprSearchJsonContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprSearchJson(s)
	}
}

func (s *SimpleExprSearchJsonContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprSearchJson(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprVariableContext struct {
	SimpleExprContext
}

func NewSimpleExprVariableContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprVariableContext {
	var p = new(SimpleExprVariableContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprVariableContext) Variable() IVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVariableContext)
}

func (s *SimpleExprVariableContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *SimpleExprVariableContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprVariable(s)
	}
}

func (s *SimpleExprVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprVariable(s)
	}
}

func (s *SimpleExprVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprCastContext struct {
	SimpleExprContext
}

func NewSimpleExprCastContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprCastContext {
	var p = new(SimpleExprCastContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprCastContext) CAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCAST_SYMBOL, 0)
}

func (s *SimpleExprCastContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprCastContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprCastContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *SimpleExprCastContext) CastType() ICastTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastTypeContext)
}

func (s *SimpleExprCastContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprCastContext) ArrayCast() IArrayCastContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IArrayCastContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IArrayCastContext)
}

func (s *SimpleExprCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprCast(s)
	}
}

func (s *SimpleExprCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprCast(s)
	}
}

func (s *SimpleExprCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprCast(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprUnaryContext struct {
	SimpleExprContext
	op antlr.Token
}

func NewSimpleExprUnaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprUnaryContext {
	var p = new(SimpleExprUnaryContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprUnaryContext) GetOp() antlr.Token { return s.op }

func (s *SimpleExprUnaryContext) SetOp(v antlr.Token) { s.op = v }

func (s *SimpleExprUnaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprUnaryContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprUnaryContext) PLUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUS_OPERATOR, 0)
}

func (s *SimpleExprUnaryContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUS_OPERATOR, 0)
}

func (s *SimpleExprUnaryContext) BITWISE_NOT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserBITWISE_NOT_OPERATOR, 0)
}

func (s *SimpleExprUnaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprUnary(s)
	}
}

func (s *SimpleExprUnaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprUnary(s)
	}
}

func (s *SimpleExprUnaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprUnary(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprOdbcContext struct {
	SimpleExprContext
}

func NewSimpleExprOdbcContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprOdbcContext {
	var p = new(SimpleExprOdbcContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprOdbcContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprOdbcContext) OPEN_CURLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_CURLY_SYMBOL, 0)
}

func (s *SimpleExprOdbcContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleExprOdbcContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprOdbcContext) CLOSE_CURLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_CURLY_SYMBOL, 0)
}

func (s *SimpleExprOdbcContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprOdbc(s)
	}
}

func (s *SimpleExprOdbcContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprOdbc(s)
	}
}

func (s *SimpleExprOdbcContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprOdbc(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprRuntimeFunctionContext struct {
	SimpleExprContext
}

func NewSimpleExprRuntimeFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprRuntimeFunctionContext {
	var p = new(SimpleExprRuntimeFunctionContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprRuntimeFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprRuntimeFunctionContext) RuntimeFunctionCall() IRuntimeFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRuntimeFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRuntimeFunctionCallContext)
}

func (s *SimpleExprRuntimeFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprRuntimeFunction(s)
	}
}

func (s *SimpleExprRuntimeFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprRuntimeFunction(s)
	}
}

func (s *SimpleExprRuntimeFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprRuntimeFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprFunctionContext struct {
	SimpleExprContext
}

func NewSimpleExprFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprFunctionContext {
	var p = new(SimpleExprFunctionContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprFunctionContext) FunctionCall() IFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionCallContext)
}

func (s *SimpleExprFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprFunction(s)
	}
}

func (s *SimpleExprFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprFunction(s)
	}
}

func (s *SimpleExprFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprCollateContext struct {
	SimpleExprContext
}

func NewSimpleExprCollateContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprCollateContext {
	var p = new(SimpleExprCollateContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprCollateContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprCollateContext) COLLATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLLATE_SYMBOL, 0)
}

func (s *SimpleExprCollateContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *SimpleExprCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprCollate(s)
	}
}

func (s *SimpleExprCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprCollate(s)
	}
}

func (s *SimpleExprCollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprMatchContext struct {
	SimpleExprContext
}

func NewSimpleExprMatchContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprMatchContext {
	var p = new(SimpleExprMatchContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprMatchContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprMatchContext) MATCH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMATCH_SYMBOL, 0)
}

func (s *SimpleExprMatchContext) IdentListArg() IIdentListArgContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentListArgContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentListArgContext)
}

func (s *SimpleExprMatchContext) AGAINST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAGAINST_SYMBOL, 0)
}

func (s *SimpleExprMatchContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprMatchContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *SimpleExprMatchContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprMatchContext) FulltextOptions() IFulltextOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFulltextOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFulltextOptionsContext)
}

func (s *SimpleExprMatchContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprMatch(s)
	}
}

func (s *SimpleExprMatchContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprMatch(s)
	}
}

func (s *SimpleExprMatchContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprMatch(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprWindowingFunctionContext struct {
	SimpleExprContext
}

func NewSimpleExprWindowingFunctionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprWindowingFunctionContext {
	var p = new(SimpleExprWindowingFunctionContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprWindowingFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprWindowingFunctionContext) WindowFunctionCall() IWindowFunctionCallContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowFunctionCallContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowFunctionCallContext)
}

func (s *SimpleExprWindowingFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprWindowingFunction(s)
	}
}

func (s *SimpleExprWindowingFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprWindowingFunction(s)
	}
}

func (s *SimpleExprWindowingFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprWindowingFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprBinaryContext struct {
	SimpleExprContext
}

func NewSimpleExprBinaryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprBinaryContext {
	var p = new(SimpleExprBinaryContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprBinaryContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *SimpleExprBinaryContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprBinary(s)
	}
}

func (s *SimpleExprBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprBinary(s)
	}
}

func (s *SimpleExprBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprColumnRefContext struct {
	SimpleExprContext
}

func NewSimpleExprColumnRefContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprColumnRefContext {
	var p = new(SimpleExprColumnRefContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprColumnRefContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *SimpleExprColumnRefContext) JsonOperator() IJsonOperatorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonOperatorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonOperatorContext)
}

func (s *SimpleExprColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprColumnRef(s)
	}
}

func (s *SimpleExprColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprColumnRef(s)
	}
}

func (s *SimpleExprColumnRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprColumnRef(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprParamMarkerContext struct {
	SimpleExprContext
}

func NewSimpleExprParamMarkerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprParamMarkerContext {
	var p = new(SimpleExprParamMarkerContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprParamMarkerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprParamMarkerContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARAM_MARKER, 0)
}

func (s *SimpleExprParamMarkerContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprParamMarker(s)
	}
}

func (s *SimpleExprParamMarkerContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprParamMarker(s)
	}
}

func (s *SimpleExprParamMarkerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprParamMarker(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprSumContext struct {
	SimpleExprContext
}

func NewSimpleExprSumContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprSumContext {
	var p = new(SimpleExprSumContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprSumContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprSumContext) SumExpr() ISumExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISumExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISumExprContext)
}

func (s *SimpleExprSumContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprSum(s)
	}
}

func (s *SimpleExprSumContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprSum(s)
	}
}

func (s *SimpleExprSumContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprSum(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprConvertUsingContext struct {
	SimpleExprContext
}

func NewSimpleExprConvertUsingContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprConvertUsingContext {
	var p = new(SimpleExprConvertUsingContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprConvertUsingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprConvertUsingContext) CONVERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONVERT_SYMBOL, 0)
}

func (s *SimpleExprConvertUsingContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprConvertUsingContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprConvertUsingContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSING_SYMBOL, 0)
}

func (s *SimpleExprConvertUsingContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *SimpleExprConvertUsingContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprConvertUsingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprConvertUsing(s)
	}
}

func (s *SimpleExprConvertUsingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprConvertUsing(s)
	}
}

func (s *SimpleExprConvertUsingContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprConvertUsing(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprSubQueryContext struct {
	SimpleExprContext
}

func NewSimpleExprSubQueryContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprSubQueryContext {
	var p = new(SimpleExprSubQueryContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprSubQueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprSubQueryContext) Subquery() ISubqueryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubqueryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubqueryContext)
}

func (s *SimpleExprSubQueryContext) EXISTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXISTS_SYMBOL, 0)
}

func (s *SimpleExprSubQueryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprSubQuery(s)
	}
}

func (s *SimpleExprSubQueryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprSubQuery(s)
	}
}

func (s *SimpleExprSubQueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprSubQuery(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprGroupingOperationContext struct {
	SimpleExprContext
}

func NewSimpleExprGroupingOperationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprGroupingOperationContext {
	var p = new(SimpleExprGroupingOperationContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprGroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprGroupingOperationContext) GroupingOperation() IGroupingOperationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingOperationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingOperationContext)
}

func (s *SimpleExprGroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprGroupingOperation(s)
	}
}

func (s *SimpleExprGroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprGroupingOperation(s)
	}
}

func (s *SimpleExprGroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprNotContext struct {
	SimpleExprContext
}

func NewSimpleExprNotContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprNotContext {
	var p = new(SimpleExprNotContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprNotContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprNotContext) Not2Rule() INot2RuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INot2RuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INot2RuleContext)
}

func (s *SimpleExprNotContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprNotContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprNot(s)
	}
}

func (s *SimpleExprNotContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprNot(s)
	}
}

func (s *SimpleExprNotContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprNot(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprValuesContext struct {
	SimpleExprContext
}

func NewSimpleExprValuesContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprValuesContext {
	var p = new(SimpleExprValuesContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprValuesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprValuesContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVALUES_SYMBOL, 0)
}

func (s *SimpleExprValuesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprValuesContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SimpleExprValuesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprValuesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprValues(s)
	}
}

func (s *SimpleExprValuesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprValues(s)
	}
}

func (s *SimpleExprValuesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprValues(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprDefaultContext struct {
	SimpleExprContext
}

func NewSimpleExprDefaultContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprDefaultContext {
	var p = new(SimpleExprDefaultContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprDefaultContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprDefaultContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *SimpleExprDefaultContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprDefaultContext) SimpleIdentifier() ISimpleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *SimpleExprDefaultContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprDefaultContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprDefault(s)
	}
}

func (s *SimpleExprDefaultContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprDefault(s)
	}
}

func (s *SimpleExprDefaultContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprDefault(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprListContext struct {
	SimpleExprContext
}

func NewSimpleExprListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprListContext {
	var p = new(SimpleExprListContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprListContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *SimpleExprListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprListContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_SYMBOL, 0)
}

func (s *SimpleExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprList(s)
	}
}

func (s *SimpleExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprList(s)
	}
}

func (s *SimpleExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprIntervalContext struct {
	SimpleExprContext
}

func NewSimpleExprIntervalContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprIntervalContext {
	var p = new(SimpleExprIntervalContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprIntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprIntervalContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTERVAL_SYMBOL, 0)
}

func (s *SimpleExprIntervalContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExprIntervalContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprIntervalContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *SimpleExprIntervalContext) PLUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUS_OPERATOR, 0)
}

func (s *SimpleExprIntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprInterval(s)
	}
}

func (s *SimpleExprIntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprInterval(s)
	}
}

func (s *SimpleExprIntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprCaseContext struct {
	SimpleExprContext
}

func NewSimpleExprCaseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprCaseContext {
	var p = new(SimpleExprCaseContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprCaseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprCaseContext) CASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCASE_SYMBOL, 0)
}

func (s *SimpleExprCaseContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEND_SYMBOL, 0)
}

func (s *SimpleExprCaseContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SimpleExprCaseContext) AllWhenExpression() []IWhenExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			len++
		}
	}

	tst := make([]IWhenExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWhenExpressionContext); ok {
			tst[i] = t.(IWhenExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExprCaseContext) WhenExpression(i int) IWhenExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhenExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhenExpressionContext)
}

func (s *SimpleExprCaseContext) AllThenExpression() []IThenExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IThenExpressionContext); ok {
			len++
		}
	}

	tst := make([]IThenExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IThenExpressionContext); ok {
			tst[i] = t.(IThenExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExprCaseContext) ThenExpression(i int) IThenExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IThenExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IThenExpressionContext)
}

func (s *SimpleExprCaseContext) ElseExpression() IElseExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IElseExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IElseExpressionContext)
}

func (s *SimpleExprCaseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprCase(s)
	}
}

func (s *SimpleExprCaseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprCase(s)
	}
}

func (s *SimpleExprCaseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprCase(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprConcatContext struct {
	SimpleExprContext
}

func NewSimpleExprConcatContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprConcatContext {
	var p = new(SimpleExprConcatContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprConcatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprConcatContext) AllSimpleExpr() []ISimpleExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleExprContext); ok {
			len++
		}
	}

	tst := make([]ISimpleExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleExprContext); ok {
			tst[i] = t.(ISimpleExprContext)
			i++
		}
	}

	return tst
}

func (s *SimpleExprConcatContext) SimpleExpr(i int) ISimpleExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprConcatContext) CONCAT_PIPES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONCAT_PIPES_SYMBOL, 0)
}

func (s *SimpleExprConcatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprConcat(s)
	}
}

func (s *SimpleExprConcatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprConcat(s)
	}
}

func (s *SimpleExprConcatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprConcat(s)

	default:
		return t.VisitChildren(s)
	}
}

type SimpleExprLiteralContext struct {
	SimpleExprContext
}

func NewSimpleExprLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleExprLiteralContext {
	var p = new(SimpleExprLiteralContext)

	InitEmptySimpleExprContext(&p.SimpleExprContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleExprContext))

	return p
}

func (s *SimpleExprLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SimpleExprLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprLiteral(s)
	}
}

func (s *SimpleExprLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprLiteral(s)
	}
}

func (s *SimpleExprLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SimpleExpr() (localctx ISimpleExprContext) {
	return p.simpleExpr(0)
}

func (p *TiDBParser) simpleExpr(_p int) (localctx ISimpleExprContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSimpleExprContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimpleExprContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 392
	p.EnterRecursionRule(localctx, 392, TiDBParserRULE_simpleExpr, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 430, p.GetParserRuleContext()) {
	case 1:
		localctx = NewSimpleExprVariableContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(3367)
			p.Variable()
		}
		p.SetState(3371)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 421, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3368)
				p.Equal()
			}
			{
				p.SetState(3369)
				p.expr(0)
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		localctx = NewSimpleExprColumnRefContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3373)
			p.ColumnRef()
		}
		p.SetState(3375)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 422, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3374)
				p.JsonOperator()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		localctx = NewSimpleExprRuntimeFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3377)
			p.RuntimeFunctionCall()
		}

	case 4:
		localctx = NewSimpleExprFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3378)
			p.FunctionCall()
		}

	case 5:
		localctx = NewSimpleExprLiteralContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3379)
			p.Literal()
		}

	case 6:
		localctx = NewSimpleExprParamMarkerContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3380)
			p.Match(TiDBParserPARAM_MARKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 7:
		localctx = NewSimpleExprSumContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3381)
			p.SumExpr()
		}

	case 8:
		localctx = NewSimpleExprGroupingOperationContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3382)
			p.GroupingOperation()
		}

	case 9:
		localctx = NewSimpleExprWindowingFunctionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3383)
			p.WindowFunctionCall()
		}

	case 10:
		localctx = NewSimpleExprUnaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3384)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SimpleExprUnaryContext).op = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-758)) & ^0x3f) == 0 && ((int64(1)<<(_la-758))&67) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SimpleExprUnaryContext).op = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3385)
			p.simpleExpr(15)
		}

	case 11:
		localctx = NewSimpleExprNotContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3386)
			p.Not2Rule()
		}
		{
			p.SetState(3387)
			p.simpleExpr(14)
		}

	case 12:
		localctx = NewSimpleExprListContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(3390)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserROW_SYMBOL {
			{
				p.SetState(3389)
				p.Match(TiDBParserROW_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3392)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3393)
			p.ExprList()
		}
		{
			p.SetState(3394)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 13:
		localctx = NewSimpleExprSubQueryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(3397)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEXISTS_SYMBOL {
			{
				p.SetState(3396)
				p.Match(TiDBParserEXISTS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3399)
			p.Subquery()
		}

	case 14:
		localctx = NewSimpleExprOdbcContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3400)
			p.Match(TiDBParserOPEN_CURLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3401)
			p.Identifier()
		}
		{
			p.SetState(3402)
			p.expr(0)
		}
		{
			p.SetState(3403)
			p.Match(TiDBParserCLOSE_CURLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 15:
		localctx = NewSimpleExprMatchContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3405)
			p.Match(TiDBParserMATCH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3406)
			p.IdentListArg()
		}
		{
			p.SetState(3407)
			p.Match(TiDBParserAGAINST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3408)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3409)
			p.bitExpr(0)
		}
		p.SetState(3411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserIN_SYMBOL || _la == TiDBParserWITH_SYMBOL {
			{
				p.SetState(3410)
				p.FulltextOptions()
			}

		}
		{
			p.SetState(3413)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 16:
		localctx = NewSimpleExprBinaryContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3415)
			p.Match(TiDBParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3416)
			p.simpleExpr(9)
		}

	case 17:
		localctx = NewSimpleExprCastContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3417)
			p.Match(TiDBParserCAST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3418)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3419)
			p.expr(0)
		}
		{
			p.SetState(3420)
			p.Match(TiDBParserAS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3421)
			p.CastType()
		}
		p.SetState(3423)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserARRAY_SYMBOL {
			{
				p.SetState(3422)
				p.ArrayCast()
			}

		}
		{
			p.SetState(3425)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		localctx = NewSimpleExprCaseContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3427)
			p.Match(TiDBParserCASE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3429)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5225064543571856404) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&873621610730880735) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-865958324971471593) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-8882137626648422863) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-576464036585580211) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&7745041819529110015) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&-1746007220614610867) != 0) || ((int64((_la-448)) & ^0x3f) == 0 && ((int64(1)<<(_la-448))&5832610115359342555) != 0) || ((int64((_la-512)) & ^0x3f) == 0 && ((int64(1)<<(_la-512))&-7206898910882232401) != 0) || ((int64((_la-576)) & ^0x3f) == 0 && ((int64(1)<<(_la-576))&-2769768038281836617) != 0) || ((int64((_la-640)) & ^0x3f) == 0 && ((int64(1)<<(_la-640))&-4037485862341231165) != 0) || ((int64((_la-704)) & ^0x3f) == 0 && ((int64(1)<<(_la-704))&1783491423132188607) != 0) || ((int64((_la-772)) & ^0x3f) == 0 && ((int64(1)<<(_la-772))&68712134993) != 0) {
			{
				p.SetState(3428)
				p.expr(0)
			}

		}
		p.SetState(3434)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TiDBParserWHEN_SYMBOL {
			{
				p.SetState(3431)
				p.WhenExpression()
			}
			{
				p.SetState(3432)
				p.ThenExpression()
			}

			p.SetState(3436)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		p.SetState(3439)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserELSE_SYMBOL {
			{
				p.SetState(3438)
				p.ElseExpression()
			}

		}
		{
			p.SetState(3441)
			p.Match(TiDBParserEND_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 19:
		localctx = NewSimpleExprConvertContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3443)
			p.Match(TiDBParserCONVERT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3444)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3445)
			p.expr(0)
		}
		{
			p.SetState(3446)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3447)
			p.CastType()
		}
		{
			p.SetState(3448)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 20:
		localctx = NewSimpleExprConvertUsingContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3450)
			p.Match(TiDBParserCONVERT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3451)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3452)
			p.expr(0)
		}
		{
			p.SetState(3453)
			p.Match(TiDBParserUSING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3454)
			p.CharsetName()
		}
		{
			p.SetState(3455)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		localctx = NewSimpleExprDefaultContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3457)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3458)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3459)
			p.SimpleIdentifier()
		}
		{
			p.SetState(3460)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 22:
		localctx = NewSimpleExprValuesContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3462)
			p.Match(TiDBParserVALUES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3463)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3464)
			p.SimpleIdentifier()
		}
		{
			p.SetState(3465)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 23:
		localctx = NewSimpleExprIntervalContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3467)
			p.Match(TiDBParserINTERVAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3468)
			p.expr(0)
		}
		{
			p.SetState(3469)
			p.Interval()
		}
		{
			p.SetState(3470)
			p.Match(TiDBParserPLUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3471)
			p.expr(0)
		}

	case 24:
		localctx = NewSimpleExprSearchJsonContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(3473)
			p.SearchJsonFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(3484)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(3482)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 431, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSimpleExprConcatContext(p, NewSimpleExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_simpleExpr)
				p.SetState(3476)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(3477)
					p.Match(TiDBParserCONCAT_PIPES_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3478)
					p.simpleExpr(17)
				}

			case 2:
				localctx = NewSimpleExprCollateContext(p, NewSimpleExprContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, TiDBParserRULE_simpleExpr)
				p.SetState(3479)

				if !(p.Precpred(p.GetParserRuleContext(), 22)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 22)", ""))
					goto errorExit
				}
				{
					p.SetState(3480)
					p.Match(TiDBParserCOLLATE_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3481)
					p.TextOrIdentifier()
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(3486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 432, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IArrayCastContext is an interface to support dynamic dispatch.
type IArrayCastContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ARRAY_SYMBOL() antlr.TerminalNode

	// IsArrayCastContext differentiates from other interfaces.
	IsArrayCastContext()
}

type ArrayCastContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyArrayCastContext() *ArrayCastContext {
	var p = new(ArrayCastContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_arrayCast
	return p
}

func InitEmptyArrayCastContext(p *ArrayCastContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_arrayCast
}

func (*ArrayCastContext) IsArrayCastContext() {}

func NewArrayCastContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ArrayCastContext {
	var p = new(ArrayCastContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_arrayCast

	return p
}

func (s *ArrayCastContext) GetParser() antlr.Parser { return s.parser }

func (s *ArrayCastContext) ARRAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserARRAY_SYMBOL, 0)
}

func (s *ArrayCastContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ArrayCastContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ArrayCastContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterArrayCast(s)
	}
}

func (s *ArrayCastContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitArrayCast(s)
	}
}

func (s *ArrayCastContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitArrayCast(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ArrayCast() (localctx IArrayCastContext) {
	localctx = NewArrayCastContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 394, TiDBParserRULE_arrayCast)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3487)
		p.Match(TiDBParserARRAY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonOperatorContext is an interface to support dynamic dispatch.
type IJsonOperatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_SEPARATOR_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	JSON_UNQUOTED_SEPARATOR_SYMBOL() antlr.TerminalNode

	// IsJsonOperatorContext differentiates from other interfaces.
	IsJsonOperatorContext()
}

type JsonOperatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonOperatorContext() *JsonOperatorContext {
	var p = new(JsonOperatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonOperator
	return p
}

func InitEmptyJsonOperatorContext(p *JsonOperatorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonOperator
}

func (*JsonOperatorContext) IsJsonOperatorContext() {}

func NewJsonOperatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonOperatorContext {
	var p = new(JsonOperatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_jsonOperator

	return p
}

func (s *JsonOperatorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonOperatorContext) JSON_SEPARATOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_SEPARATOR_SYMBOL, 0)
}

func (s *JsonOperatorContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *JsonOperatorContext) JSON_UNQUOTED_SEPARATOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_UNQUOTED_SEPARATOR_SYMBOL, 0)
}

func (s *JsonOperatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonOperatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonOperatorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterJsonOperator(s)
	}
}

func (s *JsonOperatorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitJsonOperator(s)
	}
}

func (s *JsonOperatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitJsonOperator(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) JsonOperator() (localctx IJsonOperatorContext) {
	localctx = NewJsonOperatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 396, TiDBParserRULE_jsonOperator)
	p.SetState(3493)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserJSON_SEPARATOR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3489)
			p.Match(TiDBParserJSON_SEPARATOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3490)
			p.TextStringLiteral()
		}

	case TiDBParserJSON_UNQUOTED_SEPARATOR_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3491)
			p.Match(TiDBParserJSON_UNQUOTED_SEPARATOR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3492)
			p.TextStringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISumExprContext is an interface to support dynamic dispatch.
type ISumExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	InSumExpr() IInSumExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AVG_SYMBOL() antlr.TerminalNode
	DISTINCT_SYMBOL() antlr.TerminalNode
	WindowingClause() IWindowingClauseContext
	BIT_AND_SYMBOL() antlr.TerminalNode
	BIT_OR_SYMBOL() antlr.TerminalNode
	BIT_XOR_SYMBOL() antlr.TerminalNode
	JsonFunction() IJsonFunctionContext
	MULT_OPERATOR() antlr.TerminalNode
	COUNT_SYMBOL() antlr.TerminalNode
	ALL_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	MIN_SYMBOL() antlr.TerminalNode
	MAX_SYMBOL() antlr.TerminalNode
	STD_SYMBOL() antlr.TerminalNode
	VARIANCE_SYMBOL() antlr.TerminalNode
	STDDEV_SAMP_SYMBOL() antlr.TerminalNode
	VAR_SAMP_SYMBOL() antlr.TerminalNode
	SUM_SYMBOL() antlr.TerminalNode
	GROUP_CONCAT_SYMBOL() antlr.TerminalNode
	OrderClause() IOrderClauseContext
	SEPARATOR_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext

	// IsSumExprContext differentiates from other interfaces.
	IsSumExprContext()
}

type SumExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptySumExprContext() *SumExprContext {
	var p = new(SumExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_sumExpr
	return p
}

func InitEmptySumExprContext(p *SumExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_sumExpr
}

func (*SumExprContext) IsSumExprContext() {}

func NewSumExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SumExprContext {
	var p = new(SumExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_sumExpr

	return p
}

func (s *SumExprContext) GetParser() antlr.Parser { return s.parser }

func (s *SumExprContext) GetName() antlr.Token { return s.name }

func (s *SumExprContext) SetName(v antlr.Token) { s.name = v }

func (s *SumExprContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SumExprContext) InSumExpr() IInSumExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInSumExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInSumExprContext)
}

func (s *SumExprContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SumExprContext) AVG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAVG_SYMBOL, 0)
}

func (s *SumExprContext) DISTINCT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISTINCT_SYMBOL, 0)
}

func (s *SumExprContext) WindowingClause() IWindowingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowingClauseContext)
}

func (s *SumExprContext) BIT_AND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBIT_AND_SYMBOL, 0)
}

func (s *SumExprContext) BIT_OR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBIT_OR_SYMBOL, 0)
}

func (s *SumExprContext) BIT_XOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBIT_XOR_SYMBOL, 0)
}

func (s *SumExprContext) JsonFunction() IJsonFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonFunctionContext)
}

func (s *SumExprContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULT_OPERATOR, 0)
}

func (s *SumExprContext) COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOUNT_SYMBOL, 0)
}

func (s *SumExprContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *SumExprContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *SumExprContext) MIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMIN_SYMBOL, 0)
}

func (s *SumExprContext) MAX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_SYMBOL, 0)
}

func (s *SumExprContext) STD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTD_SYMBOL, 0)
}

func (s *SumExprContext) VARIANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVARIANCE_SYMBOL, 0)
}

func (s *SumExprContext) STDDEV_SAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTDDEV_SAMP_SYMBOL, 0)
}

func (s *SumExprContext) VAR_SAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVAR_SAMP_SYMBOL, 0)
}

func (s *SumExprContext) SUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUM_SYMBOL, 0)
}

func (s *SumExprContext) GROUP_CONCAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_CONCAT_SYMBOL, 0)
}

func (s *SumExprContext) OrderClause() IOrderClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderClauseContext)
}

func (s *SumExprContext) SEPARATOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSEPARATOR_SYMBOL, 0)
}

func (s *SumExprContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *SumExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SumExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SumExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSumExpr(s)
	}
}

func (s *SumExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSumExpr(s)
	}
}

func (s *SumExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSumExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SumExpr() (localctx ISumExprContext) {
	localctx = NewSumExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 398, TiDBParserRULE_sumExpr)
	var _la int

	p.SetState(3613)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 456, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3495)

			var _m = p.Match(TiDBParserAVG_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3496)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3498)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDISTINCT_SYMBOL {
			{
				p.SetState(3497)
				p.Match(TiDBParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3500)
			p.InSumExpr()
		}
		{
			p.SetState(3501)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3503)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 435, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3502)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3505)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*SumExprContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&377957122048) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*SumExprContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3506)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3507)
			p.InSumExpr()
		}
		{
			p.SetState(3508)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3510)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 436, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3509)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3512)
			p.JsonFunction()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3513)

			var _m = p.Match(TiDBParserCOUNT_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3514)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserALL_SYMBOL {
			{
				p.SetState(3515)
				p.Match(TiDBParserALL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3518)
			p.Match(TiDBParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3519)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3521)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 438, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3520)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3523)

			var _m = p.Match(TiDBParserCOUNT_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3524)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 440, p.GetParserRuleContext()) {
		case 1:
			p.SetState(3526)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserALL_SYMBOL {
				{
					p.SetState(3525)
					p.Match(TiDBParserALL_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(3528)
				p.Match(TiDBParserMULT_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(3529)
				p.InSumExpr()
			}

		case 3:
			{
				p.SetState(3530)
				p.Match(TiDBParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3531)
				p.ExprList()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3534)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3536)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 441, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3535)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3538)

			var _m = p.Match(TiDBParserMIN_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3539)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDISTINCT_SYMBOL {
			{
				p.SetState(3540)
				p.Match(TiDBParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3543)
			p.InSumExpr()
		}
		{
			p.SetState(3544)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3546)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 443, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3545)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3548)

			var _m = p.Match(TiDBParserMAX_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3549)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3551)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDISTINCT_SYMBOL {
			{
				p.SetState(3550)
				p.Match(TiDBParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3553)
			p.InSumExpr()
		}
		{
			p.SetState(3554)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3556)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 445, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3555)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3558)

			var _m = p.Match(TiDBParserSTD_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3559)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3560)
			p.InSumExpr()
		}
		{
			p.SetState(3561)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3563)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 446, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3562)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3565)

			var _m = p.Match(TiDBParserVARIANCE_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3566)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3567)
			p.InSumExpr()
		}
		{
			p.SetState(3568)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3570)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 447, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3569)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3572)

			var _m = p.Match(TiDBParserSTDDEV_SAMP_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3573)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3574)
			p.InSumExpr()
		}
		{
			p.SetState(3575)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3577)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 448, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3576)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3579)

			var _m = p.Match(TiDBParserVAR_SAMP_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3580)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3581)
			p.InSumExpr()
		}
		{
			p.SetState(3582)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3584)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 449, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3583)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3586)

			var _m = p.Match(TiDBParserSUM_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3587)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDISTINCT_SYMBOL {
			{
				p.SetState(3588)
				p.Match(TiDBParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3591)
			p.InSumExpr()
		}
		{
			p.SetState(3592)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3594)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 451, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3593)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3596)

			var _m = p.Match(TiDBParserGROUP_CONCAT_SYMBOL)

			localctx.(*SumExprContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3597)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3599)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDISTINCT_SYMBOL {
			{
				p.SetState(3598)
				p.Match(TiDBParserDISTINCT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(3601)
			p.ExprList()
		}
		p.SetState(3603)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserORDER_SYMBOL {
			{
				p.SetState(3602)
				p.OrderClause()
			}

		}
		p.SetState(3607)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSEPARATOR_SYMBOL {
			{
				p.SetState(3605)
				p.Match(TiDBParserSEPARATOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3606)
				p.TextString()
			}

		}
		{
			p.SetState(3609)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3611)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 455, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3610)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingOperationContext is an interface to support dynamic dispatch.
type IGroupingOperationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GROUPING_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsGroupingOperationContext differentiates from other interfaces.
	IsGroupingOperationContext()
}

type GroupingOperationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingOperationContext() *GroupingOperationContext {
	var p = new(GroupingOperationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupingOperation
	return p
}

func InitEmptyGroupingOperationContext(p *GroupingOperationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupingOperation
}

func (*GroupingOperationContext) IsGroupingOperationContext() {}

func NewGroupingOperationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingOperationContext {
	var p = new(GroupingOperationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_groupingOperation

	return p
}

func (s *GroupingOperationContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingOperationContext) GROUPING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUPING_SYMBOL, 0)
}

func (s *GroupingOperationContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *GroupingOperationContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *GroupingOperationContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *GroupingOperationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingOperationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingOperationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGroupingOperation(s)
	}
}

func (s *GroupingOperationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGroupingOperation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GroupingOperation() (localctx IGroupingOperationContext) {
	localctx = NewGroupingOperationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 400, TiDBParserRULE_groupingOperation)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3615)
		p.Match(TiDBParserGROUPING_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3616)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(3617)
		p.ExprList()
	}
	{
		p.SetState(3618)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowFunctionCallContext is an interface to support dynamic dispatch.
type IWindowFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Parentheses() IParenthesesContext
	WindowingClause() IWindowingClauseContext
	ROW_NUMBER_SYMBOL() antlr.TerminalNode
	RANK_SYMBOL() antlr.TerminalNode
	DENSE_RANK_SYMBOL() antlr.TerminalNode
	CUME_DIST_SYMBOL() antlr.TerminalNode
	PERCENT_RANK_SYMBOL() antlr.TerminalNode
	NTILE_SYMBOL() antlr.TerminalNode
	SimpleExprWithParentheses() ISimpleExprWithParenthesesContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	LEAD_SYMBOL() antlr.TerminalNode
	LAG_SYMBOL() antlr.TerminalNode
	LeadLagInfo() ILeadLagInfoContext
	NullTreatment() INullTreatmentContext
	ExprWithParentheses() IExprWithParenthesesContext
	FIRST_VALUE_SYMBOL() antlr.TerminalNode
	LAST_VALUE_SYMBOL() antlr.TerminalNode
	NTH_VALUE_SYMBOL() antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode
	SimpleExpr() ISimpleExprContext
	FROM_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode

	// IsWindowFunctionCallContext differentiates from other interfaces.
	IsWindowFunctionCallContext()
}

type WindowFunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowFunctionCallContext() *WindowFunctionCallContext {
	var p = new(WindowFunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFunctionCall
	return p
}

func InitEmptyWindowFunctionCallContext(p *WindowFunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowFunctionCall
}

func (*WindowFunctionCallContext) IsWindowFunctionCallContext() {}

func NewWindowFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowFunctionCallContext {
	var p = new(WindowFunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowFunctionCall

	return p
}

func (s *WindowFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowFunctionCallContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *WindowFunctionCallContext) WindowingClause() IWindowingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowingClauseContext)
}

func (s *WindowFunctionCallContext) ROW_NUMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_NUMBER_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) RANK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRANK_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) DENSE_RANK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDENSE_RANK_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) CUME_DIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCUME_DIST_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) PERCENT_RANK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPERCENT_RANK_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) NTILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNTILE_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) SimpleExprWithParentheses() ISimpleExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprWithParenthesesContext)
}

func (s *WindowFunctionCallContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WindowFunctionCallContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LEAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEAD_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LAG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLAG_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LeadLagInfo() ILeadLagInfoContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILeadLagInfoContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILeadLagInfoContext)
}

func (s *WindowFunctionCallContext) NullTreatment() INullTreatmentContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullTreatmentContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullTreatmentContext)
}

func (s *WindowFunctionCallContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *WindowFunctionCallContext) FIRST_VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIRST_VALUE_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LAST_VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLAST_VALUE_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) NTH_VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNTH_VALUE_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *WindowFunctionCallContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIRST_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLAST_SYMBOL, 0)
}

func (s *WindowFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowFunctionCall(s)
	}
}

func (s *WindowFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowFunctionCall() (localctx IWindowFunctionCallContext) {
	localctx = NewWindowFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 402, TiDBParserRULE_windowFunctionCall)
	var _la int

	p.SetState(3662)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCUME_DIST_SYMBOL, TiDBParserDENSE_RANK_SYMBOL, TiDBParserPERCENT_RANK_SYMBOL, TiDBParserRANK_SYMBOL, TiDBParserROW_NUMBER_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3620)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-678)) & ^0x3f) == 0 && ((int64(1)<<(_la-678))&344067) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3621)
			p.Parentheses()
		}
		{
			p.SetState(3622)
			p.WindowingClause()
		}

	case TiDBParserNTILE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3624)
			p.Match(TiDBParserNTILE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3625)
			p.SimpleExprWithParentheses()
		}
		{
			p.SetState(3626)
			p.WindowingClause()
		}

	case TiDBParserLAG_SYMBOL, TiDBParserLEAD_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3628)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserLAG_SYMBOL || _la == TiDBParserLEAD_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3629)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3630)
			p.expr(0)
		}
		p.SetState(3632)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(3631)
				p.LeadLagInfo()
			}

		}
		{
			p.SetState(3634)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3636)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserIGNORE_SYMBOL || _la == TiDBParserRESPECT_SYMBOL {
			{
				p.SetState(3635)
				p.NullTreatment()
			}

		}
		{
			p.SetState(3638)
			p.WindowingClause()
		}

	case TiDBParserFIRST_VALUE_SYMBOL, TiDBParserLAST_VALUE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3640)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserFIRST_VALUE_SYMBOL || _la == TiDBParserLAST_VALUE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3641)
			p.ExprWithParentheses()
		}
		p.SetState(3643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserIGNORE_SYMBOL || _la == TiDBParserRESPECT_SYMBOL {
			{
				p.SetState(3642)
				p.NullTreatment()
			}

		}
		{
			p.SetState(3645)
			p.WindowingClause()
		}

	case TiDBParserNTH_VALUE_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3647)
			p.Match(TiDBParserNTH_VALUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3648)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3649)
			p.expr(0)
		}
		{
			p.SetState(3650)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3651)
			p.simpleExpr(0)
		}
		{
			p.SetState(3652)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3655)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL {
			{
				p.SetState(3653)
				p.Match(TiDBParserFROM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3654)
				_la = p.GetTokenStream().LA(1)

				if !(_la == TiDBParserFIRST_SYMBOL || _la == TiDBParserLAST_SYMBOL) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(3658)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserIGNORE_SYMBOL || _la == TiDBParserRESPECT_SYMBOL {
			{
				p.SetState(3657)
				p.NullTreatment()
			}

		}
		{
			p.SetState(3660)
			p.WindowingClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowingClauseContext is an interface to support dynamic dispatch.
type IWindowingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OVER_SYMBOL() antlr.TerminalNode
	WindowName() IWindowNameContext
	WindowSpec() IWindowSpecContext

	// IsWindowingClauseContext differentiates from other interfaces.
	IsWindowingClauseContext()
}

type WindowingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowingClauseContext() *WindowingClauseContext {
	var p = new(WindowingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowingClause
	return p
}

func InitEmptyWindowingClauseContext(p *WindowingClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowingClause
}

func (*WindowingClauseContext) IsWindowingClauseContext() {}

func NewWindowingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowingClauseContext {
	var p = new(WindowingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowingClause

	return p
}

func (s *WindowingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowingClauseContext) OVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOVER_SYMBOL, 0)
}

func (s *WindowingClauseContext) WindowName() IWindowNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowNameContext)
}

func (s *WindowingClauseContext) WindowSpec() IWindowSpecContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowSpecContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowSpecContext)
}

func (s *WindowingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowingClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowingClause(s)
	}
}

func (s *WindowingClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowingClause(s)
	}
}

func (s *WindowingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowingClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowingClause() (localctx IWindowingClauseContext) {
	localctx = NewWindowingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 404, TiDBParserRULE_windowingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3664)
		p.Match(TiDBParserOVER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3667)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		{
			p.SetState(3665)
			p.WindowName()
		}

	case TiDBParserOPEN_PAR_SYMBOL:
		{
			p.SetState(3666)
			p.WindowSpec()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILeadLagInfoContext is an interface to support dynamic dispatch.
type ILeadLagInfoContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	Ulonglong_number() IUlonglong_numberContext
	PARAM_MARKER() antlr.TerminalNode
	Expr() IExprContext

	// IsLeadLagInfoContext differentiates from other interfaces.
	IsLeadLagInfoContext()
}

type LeadLagInfoContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLeadLagInfoContext() *LeadLagInfoContext {
	var p = new(LeadLagInfoContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_leadLagInfo
	return p
}

func InitEmptyLeadLagInfoContext(p *LeadLagInfoContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_leadLagInfo
}

func (*LeadLagInfoContext) IsLeadLagInfoContext() {}

func NewLeadLagInfoContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LeadLagInfoContext {
	var p = new(LeadLagInfoContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_leadLagInfo

	return p
}

func (s *LeadLagInfoContext) GetParser() antlr.Parser { return s.parser }

func (s *LeadLagInfoContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *LeadLagInfoContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *LeadLagInfoContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *LeadLagInfoContext) PARAM_MARKER() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARAM_MARKER, 0)
}

func (s *LeadLagInfoContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *LeadLagInfoContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LeadLagInfoContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LeadLagInfoContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLeadLagInfo(s)
	}
}

func (s *LeadLagInfoContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLeadLagInfo(s)
	}
}

func (s *LeadLagInfoContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLeadLagInfo(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LeadLagInfo() (localctx ILeadLagInfoContext) {
	localctx = NewLeadLagInfoContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 406, TiDBParserRULE_leadLagInfo)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3669)
		p.Match(TiDBParserCOMMA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(3672)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER:
		{
			p.SetState(3670)
			p.Ulonglong_number()
		}

	case TiDBParserPARAM_MARKER:
		{
			p.SetState(3671)
			p.Match(TiDBParserPARAM_MARKER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(3676)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(3674)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3675)
			p.expr(0)
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullTreatmentContext is an interface to support dynamic dispatch.
type INullTreatmentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULLS_SYMBOL() antlr.TerminalNode
	RESPECT_SYMBOL() antlr.TerminalNode
	IGNORE_SYMBOL() antlr.TerminalNode

	// IsNullTreatmentContext differentiates from other interfaces.
	IsNullTreatmentContext()
}

type NullTreatmentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullTreatmentContext() *NullTreatmentContext {
	var p = new(NullTreatmentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_nullTreatment
	return p
}

func InitEmptyNullTreatmentContext(p *NullTreatmentContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_nullTreatment
}

func (*NullTreatmentContext) IsNullTreatmentContext() {}

func NewNullTreatmentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullTreatmentContext {
	var p = new(NullTreatmentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_nullTreatment

	return p
}

func (s *NullTreatmentContext) GetParser() antlr.Parser { return s.parser }

func (s *NullTreatmentContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULLS_SYMBOL, 0)
}

func (s *NullTreatmentContext) RESPECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESPECT_SYMBOL, 0)
}

func (s *NullTreatmentContext) IGNORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIGNORE_SYMBOL, 0)
}

func (s *NullTreatmentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullTreatmentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullTreatmentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterNullTreatment(s)
	}
}

func (s *NullTreatmentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitNullTreatment(s)
	}
}

func (s *NullTreatmentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitNullTreatment(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) NullTreatment() (localctx INullTreatmentContext) {
	localctx = NewNullTreatmentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 408, TiDBParserRULE_nullTreatment)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3678)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserIGNORE_SYMBOL || _la == TiDBParserRESPECT_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(3679)
		p.Match(TiDBParserNULLS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonFunctionContext is an interface to support dynamic dispatch.
type IJsonFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_ARRAYAGG_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllInSumExpr() []IInSumExprContext
	InSumExpr(i int) IInSumExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	WindowingClause() IWindowingClauseContext
	JSON_OBJECTAGG_SYMBOL() antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode

	// IsJsonFunctionContext differentiates from other interfaces.
	IsJsonFunctionContext()
}

type JsonFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonFunctionContext() *JsonFunctionContext {
	var p = new(JsonFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonFunction
	return p
}

func InitEmptyJsonFunctionContext(p *JsonFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonFunction
}

func (*JsonFunctionContext) IsJsonFunctionContext() {}

func NewJsonFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonFunctionContext {
	var p = new(JsonFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_jsonFunction

	return p
}

func (s *JsonFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonFunctionContext) JSON_ARRAYAGG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_ARRAYAGG_SYMBOL, 0)
}

func (s *JsonFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *JsonFunctionContext) AllInSumExpr() []IInSumExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInSumExprContext); ok {
			len++
		}
	}

	tst := make([]IInSumExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInSumExprContext); ok {
			tst[i] = t.(IInSumExprContext)
			i++
		}
	}

	return tst
}

func (s *JsonFunctionContext) InSumExpr(i int) IInSumExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInSumExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInSumExprContext)
}

func (s *JsonFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *JsonFunctionContext) WindowingClause() IWindowingClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWindowingClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWindowingClauseContext)
}

func (s *JsonFunctionContext) JSON_OBJECTAGG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_OBJECTAGG_SYMBOL, 0)
}

func (s *JsonFunctionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *JsonFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterJsonFunction(s)
	}
}

func (s *JsonFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitJsonFunction(s)
	}
}

func (s *JsonFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitJsonFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) JsonFunction() (localctx IJsonFunctionContext) {
	localctx = NewJsonFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 410, TiDBParserRULE_jsonFunction)
	p.SetState(3697)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserJSON_ARRAYAGG_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3681)
			p.Match(TiDBParserJSON_ARRAYAGG_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3682)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3683)
			p.InSumExpr()
		}
		{
			p.SetState(3684)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3686)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 466, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3685)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserJSON_OBJECTAGG_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3688)
			p.Match(TiDBParserJSON_OBJECTAGG_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3689)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3690)
			p.InSumExpr()
		}
		{
			p.SetState(3691)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3692)
			p.InSumExpr()
		}
		{
			p.SetState(3693)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3695)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 467, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3694)
				p.WindowingClause()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInSumExprContext is an interface to support dynamic dispatch.
type IInSumExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	ALL_SYMBOL() antlr.TerminalNode

	// IsInSumExprContext differentiates from other interfaces.
	IsInSumExprContext()
}

type InSumExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInSumExprContext() *InSumExprContext {
	var p = new(InSumExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_inSumExpr
	return p
}

func InitEmptyInSumExprContext(p *InSumExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_inSumExpr
}

func (*InSumExprContext) IsInSumExprContext() {}

func NewInSumExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InSumExprContext {
	var p = new(InSumExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_inSumExpr

	return p
}

func (s *InSumExprContext) GetParser() antlr.Parser { return s.parser }

func (s *InSumExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *InSumExprContext) ALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALL_SYMBOL, 0)
}

func (s *InSumExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InSumExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InSumExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterInSumExpr(s)
	}
}

func (s *InSumExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitInSumExpr(s)
	}
}

func (s *InSumExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitInSumExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) InSumExpr() (localctx IInSumExprContext) {
	localctx = NewInSumExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 412, TiDBParserRULE_inSumExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(3700)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserALL_SYMBOL {
		{
			p.SetState(3699)
			p.Match(TiDBParserALL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(3702)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentListArgContext is an interface to support dynamic dispatch.
type IIdentListArgContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentList() IIdentListContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsIdentListArgContext differentiates from other interfaces.
	IsIdentListArgContext()
}

type IdentListArgContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentListArgContext() *IdentListArgContext {
	var p = new(IdentListArgContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identListArg
	return p
}

func InitEmptyIdentListArgContext(p *IdentListArgContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identListArg
}

func (*IdentListArgContext) IsIdentListArgContext() {}

func NewIdentListArgContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentListArgContext {
	var p = new(IdentListArgContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identListArg

	return p
}

func (s *IdentListArgContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentListArgContext) IdentList() IIdentListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentListContext)
}

func (s *IdentListArgContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *IdentListArgContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *IdentListArgContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentListArgContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentListArgContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentListArg(s)
	}
}

func (s *IdentListArgContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentListArg(s)
	}
}

func (s *IdentListArgContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentListArg(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentListArg() (localctx IIdentListArgContext) {
	localctx = NewIdentListArgContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 414, TiDBParserRULE_identListArg)
	p.SetState(3709)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserDOT_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3704)
			p.IdentList()
		}

	case TiDBParserOPEN_PAR_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3705)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3706)
			p.IdentList()
		}
		{
			p.SetState(3707)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentListContext is an interface to support dynamic dispatch.
type IIdentListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSimpleIdentifier() []ISimpleIdentifierContext
	SimpleIdentifier(i int) ISimpleIdentifierContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIdentListContext differentiates from other interfaces.
	IsIdentListContext()
}

type IdentListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentListContext() *IdentListContext {
	var p = new(IdentListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identList
	return p
}

func InitEmptyIdentListContext(p *IdentListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identList
}

func (*IdentListContext) IsIdentListContext() {}

func NewIdentListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentListContext {
	var p = new(IdentListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identList

	return p
}

func (s *IdentListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentListContext) AllSimpleIdentifier() []ISimpleIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ISimpleIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISimpleIdentifierContext); ok {
			tst[i] = t.(ISimpleIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentListContext) SimpleIdentifier(i int) ISimpleIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleIdentifierContext)
}

func (s *IdentListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *IdentListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *IdentListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentList(s)
	}
}

func (s *IdentListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentList(s)
	}
}

func (s *IdentListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentList() (localctx IIdentListContext) {
	localctx = NewIdentListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 416, TiDBParserRULE_identList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(3711)
		p.SimpleIdentifier()
	}
	p.SetState(3716)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(3712)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3713)
			p.SimpleIdentifier()
		}

		p.SetState(3718)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFulltextOptionsContext is an interface to support dynamic dispatch.
type IFulltextOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IN_SYMBOL() antlr.TerminalNode
	BOOLEAN_SYMBOL() antlr.TerminalNode
	MODE_SYMBOL() antlr.TerminalNode
	NATURAL_SYMBOL() antlr.TerminalNode
	LANGUAGE_SYMBOL() antlr.TerminalNode
	WITH_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	EXPANSION_SYMBOL() antlr.TerminalNode

	// IsFulltextOptionsContext differentiates from other interfaces.
	IsFulltextOptionsContext()
}

type FulltextOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFulltextOptionsContext() *FulltextOptionsContext {
	var p = new(FulltextOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fulltextOptions
	return p
}

func InitEmptyFulltextOptionsContext(p *FulltextOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fulltextOptions
}

func (*FulltextOptionsContext) IsFulltextOptionsContext() {}

func NewFulltextOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FulltextOptionsContext {
	var p = new(FulltextOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fulltextOptions

	return p
}

func (s *FulltextOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *FulltextOptionsContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIN_SYMBOL, 0)
}

func (s *FulltextOptionsContext) BOOLEAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBOOLEAN_SYMBOL, 0)
}

func (s *FulltextOptionsContext) MODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMODE_SYMBOL, 0)
}

func (s *FulltextOptionsContext) NATURAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNATURAL_SYMBOL, 0)
}

func (s *FulltextOptionsContext) LANGUAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLANGUAGE_SYMBOL, 0)
}

func (s *FulltextOptionsContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *FulltextOptionsContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUERY_SYMBOL, 0)
}

func (s *FulltextOptionsContext) EXPANSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXPANSION_SYMBOL, 0)
}

func (s *FulltextOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FulltextOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FulltextOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFulltextOptions(s)
	}
}

func (s *FulltextOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFulltextOptions(s)
	}
}

func (s *FulltextOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFulltextOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FulltextOptions() (localctx IFulltextOptionsContext) {
	localctx = NewFulltextOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 418, TiDBParserRULE_fulltextOptions)
	var _la int

	p.SetState(3734)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 473, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3719)
			p.Match(TiDBParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3720)
			p.Match(TiDBParserBOOLEAN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3721)
			p.Match(TiDBParserMODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3722)
			p.Match(TiDBParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3723)
			p.Match(TiDBParserNATURAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3724)
			p.Match(TiDBParserLANGUAGE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3725)
			p.Match(TiDBParserMODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3729)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserWITH_SYMBOL {
			{
				p.SetState(3726)
				p.Match(TiDBParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3727)
				p.Match(TiDBParserQUERY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3728)
				p.Match(TiDBParserEXPANSION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3731)
			p.Match(TiDBParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3732)
			p.Match(TiDBParserQUERY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3733)
			p.Match(TiDBParserEXPANSION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRuntimeFunctionCallContext is an interface to support dynamic dispatch.
type IRuntimeFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	CHAR_SYMBOL() antlr.TerminalNode
	USING_SYMBOL() antlr.TerminalNode
	CharsetName() ICharsetNameContext
	CURRENT_USER_SYMBOL() antlr.TerminalNode
	Parentheses() IParenthesesContext
	ExprWithParentheses() IExprWithParenthesesContext
	DATE_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	HOUR_SYMBOL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	INSERT_SYMBOL() antlr.TerminalNode
	INTERVAL_SYMBOL() antlr.TerminalNode
	LEFT_SYMBOL() antlr.TerminalNode
	MINUTE_SYMBOL() antlr.TerminalNode
	MONTH_SYMBOL() antlr.TerminalNode
	RIGHT_SYMBOL() antlr.TerminalNode
	SECOND_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode
	TrimFunction() ITrimFunctionContext
	USER_SYMBOL() antlr.TerminalNode
	VALUES_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode
	ADDDATE_SYMBOL() antlr.TerminalNode
	SUBDATE_SYMBOL() antlr.TerminalNode
	Interval() IIntervalContext
	CURDATE_SYMBOL() antlr.TerminalNode
	CURTIME_SYMBOL() antlr.TerminalNode
	TimeFunctionParameters() ITimeFunctionParametersContext
	DATE_ADD_SYMBOL() antlr.TerminalNode
	DATE_SUB_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	EXTRACT_SYMBOL() antlr.TerminalNode
	DateTimeTtype() IDateTimeTtypeContext
	GET_FORMAT_SYMBOL() antlr.TerminalNode
	NOW_SYMBOL() antlr.TerminalNode
	BitExpr() IBitExprContext
	IN_SYMBOL() antlr.TerminalNode
	POSITION_SYMBOL() antlr.TerminalNode
	SubstringFunction() ISubstringFunctionContext
	SYSDATE_SYMBOL() antlr.TerminalNode
	IntervalTimeStamp() IIntervalTimeStampContext
	TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode
	TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode
	UTC_DATE_SYMBOL() antlr.TerminalNode
	UTC_TIME_SYMBOL() antlr.TerminalNode
	UTC_TIMESTAMP_SYMBOL() antlr.TerminalNode
	ASCII_SYMBOL() antlr.TerminalNode
	CHARSET_SYMBOL() antlr.TerminalNode
	ExprListWithParentheses() IExprListWithParenthesesContext
	COALESCE_SYMBOL() antlr.TerminalNode
	COLLATION_SYMBOL() antlr.TerminalNode
	DATABASE_SYMBOL() antlr.TerminalNode
	IF_SYMBOL() antlr.TerminalNode
	FORMAT_SYMBOL() antlr.TerminalNode
	MICROSECOND_SYMBOL() antlr.TerminalNode
	MOD_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	OLD_PASSWORD_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	QUARTER_SYMBOL() antlr.TerminalNode
	REPEAT_SYMBOL() antlr.TerminalNode
	REPLACE_SYMBOL() antlr.TerminalNode
	REVERSE_SYMBOL() antlr.TerminalNode
	ROW_COUNT_SYMBOL() antlr.TerminalNode
	TRUNCATE_SYMBOL() antlr.TerminalNode
	WEEK_SYMBOL() antlr.TerminalNode
	WEIGHT_STRING_SYMBOL() antlr.TerminalNode
	AS_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode
	WsNumCodepoints() IWsNumCodepointsContext
	AllUlong_number() []IUlong_numberContext
	Ulong_number(i int) IUlong_numberContext
	WeightStringLevels() IWeightStringLevelsContext
	GeometryFunction() IGeometryFunctionContext

	// IsRuntimeFunctionCallContext differentiates from other interfaces.
	IsRuntimeFunctionCallContext()
}

type RuntimeFunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyRuntimeFunctionCallContext() *RuntimeFunctionCallContext {
	var p = new(RuntimeFunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_runtimeFunctionCall
	return p
}

func InitEmptyRuntimeFunctionCallContext(p *RuntimeFunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_runtimeFunctionCall
}

func (*RuntimeFunctionCallContext) IsRuntimeFunctionCallContext() {}

func NewRuntimeFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RuntimeFunctionCallContext {
	var p = new(RuntimeFunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_runtimeFunctionCall

	return p
}

func (s *RuntimeFunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *RuntimeFunctionCallContext) GetName() antlr.Token { return s.name }

func (s *RuntimeFunctionCallContext) SetName(v antlr.Token) { s.name = v }

func (s *RuntimeFunctionCallContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *RuntimeFunctionCallContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHAR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSING_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *RuntimeFunctionCallContext) CURRENT_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURRENT_USER_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *RuntimeFunctionCallContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *RuntimeFunctionCallContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDAY_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOUR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *RuntimeFunctionCallContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *RuntimeFunctionCallContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *RuntimeFunctionCallContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *RuntimeFunctionCallContext) INSERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSERT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) INTERVAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTERVAL_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) LEFT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEFT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUTE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMONTH_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) RIGHT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRIGHT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECOND_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIME_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TrimFunction() ITrimFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITrimFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITrimFunctionContext)
}

func (s *RuntimeFunctionCallContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVALUES_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserYEAR_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ADDDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserADDDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) SUBDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) Interval() IIntervalContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalContext)
}

func (s *RuntimeFunctionCallContext) CURDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) CURTIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURTIME_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TimeFunctionParameters() ITimeFunctionParametersContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITimeFunctionParametersContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITimeFunctionParametersContext)
}

func (s *RuntimeFunctionCallContext) DATE_ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATE_ADD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) DATE_SUB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATE_SUB_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) EXTRACT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTRACT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) DateTimeTtype() IDateTimeTtypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimeTtypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimeTtypeContext)
}

func (s *RuntimeFunctionCallContext) GET_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGET_FORMAT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) NOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOW_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *RuntimeFunctionCallContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIN_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) POSITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPOSITION_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) SubstringFunction() ISubstringFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubstringFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubstringFunctionContext)
}

func (s *RuntimeFunctionCallContext) SYSDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSYSDATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) IntervalTimeStamp() IIntervalTimeStampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTimeStampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTimeStampContext)
}

func (s *RuntimeFunctionCallContext) TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_ADD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_DIFF_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) UTC_DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUTC_DATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) UTC_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUTC_TIME_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) UTC_TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUTC_TIMESTAMP_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ASCII_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserASCII_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) CHARSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHARSET_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ExprListWithParentheses() IExprListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListWithParenthesesContext)
}

func (s *RuntimeFunctionCallContext) COALESCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOALESCE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) COLLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLLATION_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) DATABASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATABASE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) IF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIF_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFORMAT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMICROSECOND_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) MOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMOD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *RuntimeFunctionCallContext) OLD_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOLD_PASSWORD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) QUARTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUARTER_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) REPEAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPEAT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLACE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) REVERSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREVERSE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) ROW_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_COUNT_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) TRUNCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRUNCATE_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) WEEK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWEEK_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) WEIGHT_STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWEIGHT_STRING_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *RuntimeFunctionCallContext) WsNumCodepoints() IWsNumCodepointsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWsNumCodepointsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWsNumCodepointsContext)
}

func (s *RuntimeFunctionCallContext) AllUlong_number() []IUlong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUlong_numberContext); ok {
			len++
		}
	}

	tst := make([]IUlong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUlong_numberContext); ok {
			tst[i] = t.(IUlong_numberContext)
			i++
		}
	}

	return tst
}

func (s *RuntimeFunctionCallContext) Ulong_number(i int) IUlong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *RuntimeFunctionCallContext) WeightStringLevels() IWeightStringLevelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWeightStringLevelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWeightStringLevelsContext)
}

func (s *RuntimeFunctionCallContext) GeometryFunction() IGeometryFunctionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGeometryFunctionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGeometryFunctionContext)
}

func (s *RuntimeFunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RuntimeFunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RuntimeFunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRuntimeFunctionCall(s)
	}
}

func (s *RuntimeFunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRuntimeFunctionCall(s)
	}
}

func (s *RuntimeFunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRuntimeFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RuntimeFunctionCall() (localctx IRuntimeFunctionCallContext) {
	localctx = NewRuntimeFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 420, TiDBParserRULE_runtimeFunctionCall)
	var _la int

	p.SetState(4006)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCHAR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(3736)

			var _m = p.Match(TiDBParserCHAR_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3737)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3738)
			p.ExprList()
		}
		p.SetState(3741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserUSING_SYMBOL {
			{
				p.SetState(3739)
				p.Match(TiDBParserUSING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3740)
				p.CharsetName()
			}

		}
		{
			p.SetState(3743)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserCURRENT_USER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(3745)

			var _m = p.Match(TiDBParserCURRENT_USER_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3747)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 475, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3746)
				p.Parentheses()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserDATE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(3749)

			var _m = p.Match(TiDBParserDATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3750)
			p.ExprWithParentheses()
		}

	case TiDBParserDAY_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(3751)

			var _m = p.Match(TiDBParserDAY_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3752)
			p.ExprWithParentheses()
		}

	case TiDBParserHOUR_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(3753)

			var _m = p.Match(TiDBParserHOUR_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3754)
			p.ExprWithParentheses()
		}

	case TiDBParserINSERT_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(3755)

			var _m = p.Match(TiDBParserINSERT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3756)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3757)
			p.expr(0)
		}
		{
			p.SetState(3758)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3759)
			p.expr(0)
		}
		{
			p.SetState(3760)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3761)
			p.expr(0)
		}
		{
			p.SetState(3762)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3763)
			p.expr(0)
		}
		{
			p.SetState(3764)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserINTERVAL_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(3766)

			var _m = p.Match(TiDBParserINTERVAL_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3767)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3768)
			p.expr(0)
		}
		p.SetState(3771)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(3769)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3770)
				p.expr(0)
			}

			p.SetState(3773)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(3775)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserLEFT_SYMBOL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(3777)

			var _m = p.Match(TiDBParserLEFT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3778)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3779)
			p.expr(0)
		}
		{
			p.SetState(3780)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3781)
			p.expr(0)
		}
		{
			p.SetState(3782)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserMINUTE_SYMBOL:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(3784)

			var _m = p.Match(TiDBParserMINUTE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3785)
			p.ExprWithParentheses()
		}

	case TiDBParserMONTH_SYMBOL:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(3786)

			var _m = p.Match(TiDBParserMONTH_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3787)
			p.ExprWithParentheses()
		}

	case TiDBParserRIGHT_SYMBOL:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(3788)

			var _m = p.Match(TiDBParserRIGHT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3789)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3790)
			p.expr(0)
		}
		{
			p.SetState(3791)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3792)
			p.expr(0)
		}
		{
			p.SetState(3793)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserSECOND_SYMBOL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(3795)

			var _m = p.Match(TiDBParserSECOND_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3796)
			p.ExprWithParentheses()
		}

	case TiDBParserTIME_SYMBOL:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(3797)

			var _m = p.Match(TiDBParserTIME_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3798)
			p.ExprWithParentheses()
		}

	case TiDBParserTIMESTAMP_SYMBOL:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(3799)

			var _m = p.Match(TiDBParserTIMESTAMP_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3800)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3801)
			p.expr(0)
		}
		p.SetState(3804)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(3802)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3803)
				p.expr(0)
			}

		}
		{
			p.SetState(3806)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserTRIM_SYMBOL:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(3808)
			p.TrimFunction()
		}

	case TiDBParserUSER_SYMBOL:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(3809)

			var _m = p.Match(TiDBParserUSER_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3810)
			p.Parentheses()
		}

	case TiDBParserVALUES_SYMBOL:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(3811)

			var _m = p.Match(TiDBParserVALUES_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3812)
			p.ExprWithParentheses()
		}

	case TiDBParserYEAR_SYMBOL:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(3813)

			var _m = p.Match(TiDBParserYEAR_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3814)
			p.ExprWithParentheses()
		}

	case TiDBParserADDDATE_SYMBOL, TiDBParserSUBDATE_SYMBOL:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(3815)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RuntimeFunctionCallContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserADDDATE_SYMBOL || _la == TiDBParserSUBDATE_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RuntimeFunctionCallContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3816)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3817)
			p.expr(0)
		}
		{
			p.SetState(3818)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3824)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 478, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(3819)
				p.expr(0)
			}

		case 2:
			{
				p.SetState(3820)
				p.Match(TiDBParserINTERVAL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3821)
				p.expr(0)
			}
			{
				p.SetState(3822)
				p.Interval()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(3826)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserCURDATE_SYMBOL:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(3828)

			var _m = p.Match(TiDBParserCURDATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3830)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 479, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3829)
				p.Parentheses()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserCURTIME_SYMBOL:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(3832)

			var _m = p.Match(TiDBParserCURTIME_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3834)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 480, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3833)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserDATE_ADD_SYMBOL, TiDBParserDATE_SUB_SYMBOL:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(3836)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RuntimeFunctionCallContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserDATE_ADD_SYMBOL || _la == TiDBParserDATE_SUB_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RuntimeFunctionCallContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3837)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3838)
			p.expr(0)
		}
		{
			p.SetState(3839)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3840)
			p.Match(TiDBParserINTERVAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3841)
			p.expr(0)
		}
		{
			p.SetState(3842)
			p.Interval()
		}
		{
			p.SetState(3843)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserEXTRACT_SYMBOL:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(3845)

			var _m = p.Match(TiDBParserEXTRACT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3846)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3847)
			p.Interval()
		}
		{
			p.SetState(3848)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3849)
			p.expr(0)
		}
		{
			p.SetState(3850)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserGET_FORMAT_SYMBOL:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(3852)

			var _m = p.Match(TiDBParserGET_FORMAT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3853)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3854)
			p.DateTimeTtype()
		}
		{
			p.SetState(3855)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3856)
			p.expr(0)
		}
		{
			p.SetState(3857)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserNOW_SYMBOL:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(3859)

			var _m = p.Match(TiDBParserNOW_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3861)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 481, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3860)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserPOSITION_SYMBOL:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(3863)

			var _m = p.Match(TiDBParserPOSITION_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3864)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3865)
			p.bitExpr(0)
		}
		{
			p.SetState(3866)
			p.Match(TiDBParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3867)
			p.expr(0)
		}
		{
			p.SetState(3868)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserSUBSTRING_SYMBOL:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(3870)
			p.SubstringFunction()
		}

	case TiDBParserSYSDATE_SYMBOL:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(3871)

			var _m = p.Match(TiDBParserSYSDATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3873)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 482, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3872)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(3875)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*RuntimeFunctionCallContext).name = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserTIMESTAMP_ADD_SYMBOL || _la == TiDBParserTIMESTAMP_DIFF_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*RuntimeFunctionCallContext).name = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(3876)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3877)
			p.IntervalTimeStamp()
		}
		{
			p.SetState(3878)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3879)
			p.expr(0)
		}
		{
			p.SetState(3880)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3881)
			p.expr(0)
		}
		{
			p.SetState(3882)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserUTC_DATE_SYMBOL:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(3884)

			var _m = p.Match(TiDBParserUTC_DATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3886)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 483, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3885)
				p.Parentheses()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserUTC_TIME_SYMBOL:
		p.EnterOuterAlt(localctx, 31)
		{
			p.SetState(3888)

			var _m = p.Match(TiDBParserUTC_TIME_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3890)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 484, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3889)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserUTC_TIMESTAMP_SYMBOL:
		p.EnterOuterAlt(localctx, 32)
		{
			p.SetState(3892)

			var _m = p.Match(TiDBParserUTC_TIMESTAMP_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(3894)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 485, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(3893)
				p.TimeFunctionParameters()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserASCII_SYMBOL:
		p.EnterOuterAlt(localctx, 33)
		{
			p.SetState(3896)

			var _m = p.Match(TiDBParserASCII_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3897)
			p.ExprWithParentheses()
		}

	case TiDBParserCHARSET_SYMBOL:
		p.EnterOuterAlt(localctx, 34)
		{
			p.SetState(3898)

			var _m = p.Match(TiDBParserCHARSET_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3899)
			p.ExprWithParentheses()
		}

	case TiDBParserCOALESCE_SYMBOL:
		p.EnterOuterAlt(localctx, 35)
		{
			p.SetState(3900)

			var _m = p.Match(TiDBParserCOALESCE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3901)
			p.ExprListWithParentheses()
		}

	case TiDBParserCOLLATION_SYMBOL:
		p.EnterOuterAlt(localctx, 36)
		{
			p.SetState(3902)

			var _m = p.Match(TiDBParserCOLLATION_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3903)
			p.ExprWithParentheses()
		}

	case TiDBParserDATABASE_SYMBOL:
		p.EnterOuterAlt(localctx, 37)
		{
			p.SetState(3904)

			var _m = p.Match(TiDBParserDATABASE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3905)
			p.Parentheses()
		}

	case TiDBParserIF_SYMBOL:
		p.EnterOuterAlt(localctx, 38)
		{
			p.SetState(3906)

			var _m = p.Match(TiDBParserIF_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3907)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3908)
			p.expr(0)
		}
		{
			p.SetState(3909)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3910)
			p.expr(0)
		}
		{
			p.SetState(3911)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3912)
			p.expr(0)
		}
		{
			p.SetState(3913)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserFORMAT_SYMBOL:
		p.EnterOuterAlt(localctx, 39)
		{
			p.SetState(3915)

			var _m = p.Match(TiDBParserFORMAT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3916)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3917)
			p.expr(0)
		}
		{
			p.SetState(3918)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3919)
			p.expr(0)
		}
		p.SetState(3922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(3920)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3921)
				p.expr(0)
			}

		}
		{
			p.SetState(3924)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserMICROSECOND_SYMBOL:
		p.EnterOuterAlt(localctx, 40)
		{
			p.SetState(3926)

			var _m = p.Match(TiDBParserMICROSECOND_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3927)
			p.ExprWithParentheses()
		}

	case TiDBParserMOD_SYMBOL:
		p.EnterOuterAlt(localctx, 41)
		{
			p.SetState(3928)

			var _m = p.Match(TiDBParserMOD_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3929)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3930)
			p.expr(0)
		}
		{
			p.SetState(3931)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3932)
			p.expr(0)
		}
		{
			p.SetState(3933)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserOLD_PASSWORD_SYMBOL:
		p.EnterOuterAlt(localctx, 42)
		{
			p.SetState(3935)

			var _m = p.Match(TiDBParserOLD_PASSWORD_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3936)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3937)
			p.TextLiteral()
		}
		{
			p.SetState(3938)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserPASSWORD_SYMBOL:
		p.EnterOuterAlt(localctx, 43)
		{
			p.SetState(3940)

			var _m = p.Match(TiDBParserPASSWORD_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3941)
			p.ExprWithParentheses()
		}

	case TiDBParserQUARTER_SYMBOL:
		p.EnterOuterAlt(localctx, 44)
		{
			p.SetState(3942)

			var _m = p.Match(TiDBParserQUARTER_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3943)
			p.ExprWithParentheses()
		}

	case TiDBParserREPEAT_SYMBOL:
		p.EnterOuterAlt(localctx, 45)
		{
			p.SetState(3944)

			var _m = p.Match(TiDBParserREPEAT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3945)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3946)
			p.expr(0)
		}
		{
			p.SetState(3947)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3948)
			p.expr(0)
		}
		{
			p.SetState(3949)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREPLACE_SYMBOL:
		p.EnterOuterAlt(localctx, 46)
		{
			p.SetState(3951)

			var _m = p.Match(TiDBParserREPLACE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3952)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3953)
			p.expr(0)
		}
		{
			p.SetState(3954)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3955)
			p.expr(0)
		}
		{
			p.SetState(3956)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3957)
			p.expr(0)
		}
		{
			p.SetState(3958)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserREVERSE_SYMBOL:
		p.EnterOuterAlt(localctx, 47)
		{
			p.SetState(3960)

			var _m = p.Match(TiDBParserREVERSE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3961)
			p.ExprWithParentheses()
		}

	case TiDBParserROW_COUNT_SYMBOL:
		p.EnterOuterAlt(localctx, 48)
		{
			p.SetState(3962)

			var _m = p.Match(TiDBParserROW_COUNT_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3963)
			p.Parentheses()
		}

	case TiDBParserTRUNCATE_SYMBOL:
		p.EnterOuterAlt(localctx, 49)
		{
			p.SetState(3964)

			var _m = p.Match(TiDBParserTRUNCATE_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3965)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3966)
			p.expr(0)
		}
		{
			p.SetState(3967)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3968)
			p.expr(0)
		}
		{
			p.SetState(3969)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserWEEK_SYMBOL:
		p.EnterOuterAlt(localctx, 50)
		{
			p.SetState(3971)

			var _m = p.Match(TiDBParserWEEK_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3972)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3973)
			p.expr(0)
		}
		p.SetState(3976)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(3974)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3975)
				p.expr(0)
			}

		}
		{
			p.SetState(3978)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserWEIGHT_STRING_SYMBOL:
		p.EnterOuterAlt(localctx, 51)
		{
			p.SetState(3980)

			var _m = p.Match(TiDBParserWEIGHT_STRING_SYMBOL)

			localctx.(*RuntimeFunctionCallContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3981)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(3982)
			p.expr(0)
		}
		p.SetState(4001)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 490, p.GetParserRuleContext()) {
		case 1:
			p.SetState(3986)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserAS_SYMBOL {
				{
					p.SetState(3983)
					p.Match(TiDBParserAS_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3984)
					p.Match(TiDBParserCHAR_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(3985)
					p.WsNumCodepoints()
				}

			}
			p.SetState(3989)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserLEVEL_SYMBOL {
				{
					p.SetState(3988)
					p.WeightStringLevels()
				}

			}

		case 2:
			{
				p.SetState(3991)
				p.Match(TiDBParserAS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3992)
				p.Match(TiDBParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3993)
				p.WsNumCodepoints()
			}

		case 3:
			{
				p.SetState(3994)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3995)
				p.Ulong_number()
			}
			{
				p.SetState(3996)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3997)
				p.Ulong_number()
			}
			{
				p.SetState(3998)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(3999)
				p.Ulong_number()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4003)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserCONTAINS_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL:
		p.EnterOuterAlt(localctx, 52)
		{
			p.SetState(4005)
			p.GeometryFunction()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGeometryFunctionContext is an interface to support dynamic dispatch.
type IGeometryFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetName returns the name token.
	GetName() antlr.Token

	// SetName sets the name token.
	SetName(antlr.Token)

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	COMMA_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	CONTAINS_SYMBOL() antlr.TerminalNode
	GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	ExprListWithParentheses() IExprListWithParenthesesContext
	LINESTRING_SYMBOL() antlr.TerminalNode
	MULTILINESTRING_SYMBOL() antlr.TerminalNode
	MULTIPOINT_SYMBOL() antlr.TerminalNode
	MULTIPOLYGON_SYMBOL() antlr.TerminalNode
	POINT_SYMBOL() antlr.TerminalNode
	POLYGON_SYMBOL() antlr.TerminalNode

	// IsGeometryFunctionContext differentiates from other interfaces.
	IsGeometryFunctionContext()
}

type GeometryFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	name   antlr.Token
}

func NewEmptyGeometryFunctionContext() *GeometryFunctionContext {
	var p = new(GeometryFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_geometryFunction
	return p
}

func InitEmptyGeometryFunctionContext(p *GeometryFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_geometryFunction
}

func (*GeometryFunctionContext) IsGeometryFunctionContext() {}

func NewGeometryFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GeometryFunctionContext {
	var p = new(GeometryFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_geometryFunction

	return p
}

func (s *GeometryFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *GeometryFunctionContext) GetName() antlr.Token { return s.name }

func (s *GeometryFunctionContext) SetName(v antlr.Token) { s.name = v }

func (s *GeometryFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *GeometryFunctionContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *GeometryFunctionContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *GeometryFunctionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *GeometryFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *GeometryFunctionContext) CONTAINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONTAINS_SYMBOL, 0)
}

func (s *GeometryFunctionContext) GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGEOMETRYCOLLECTION_SYMBOL, 0)
}

func (s *GeometryFunctionContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *GeometryFunctionContext) ExprListWithParentheses() IExprListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListWithParenthesesContext)
}

func (s *GeometryFunctionContext) LINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLINESTRING_SYMBOL, 0)
}

func (s *GeometryFunctionContext) MULTILINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTILINESTRING_SYMBOL, 0)
}

func (s *GeometryFunctionContext) MULTIPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTIPOINT_SYMBOL, 0)
}

func (s *GeometryFunctionContext) MULTIPOLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTIPOLYGON_SYMBOL, 0)
}

func (s *GeometryFunctionContext) POINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPOINT_SYMBOL, 0)
}

func (s *GeometryFunctionContext) POLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPOLYGON_SYMBOL, 0)
}

func (s *GeometryFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GeometryFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GeometryFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGeometryFunction(s)
	}
}

func (s *GeometryFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGeometryFunction(s)
	}
}

func (s *GeometryFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGeometryFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GeometryFunction() (localctx IGeometryFunctionContext) {
	localctx = NewGeometryFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 422, TiDBParserRULE_geometryFunction)
	var _la int

	p.SetState(4038)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCONTAINS_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4008)

			var _m = p.Match(TiDBParserCONTAINS_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4009)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4010)
			p.expr(0)
		}
		{
			p.SetState(4011)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4012)
			p.expr(0)
		}
		{
			p.SetState(4013)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserGEOMETRYCOLLECTION_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4015)

			var _m = p.Match(TiDBParserGEOMETRYCOLLECTION_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4016)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5225064543571856404) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&873621610730880735) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-865958324971471593) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-8882137626648422863) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-576464036585580211) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&7745041819529110015) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&-1746007220614610867) != 0) || ((int64((_la-448)) & ^0x3f) == 0 && ((int64(1)<<(_la-448))&5832610115359342555) != 0) || ((int64((_la-512)) & ^0x3f) == 0 && ((int64(1)<<(_la-512))&-7206898910882232401) != 0) || ((int64((_la-576)) & ^0x3f) == 0 && ((int64(1)<<(_la-576))&-2769768038281836617) != 0) || ((int64((_la-640)) & ^0x3f) == 0 && ((int64(1)<<(_la-640))&-4037485862341231165) != 0) || ((int64((_la-704)) & ^0x3f) == 0 && ((int64(1)<<(_la-704))&1783491423132188607) != 0) || ((int64((_la-772)) & ^0x3f) == 0 && ((int64(1)<<(_la-772))&68712134993) != 0) {
			{
				p.SetState(4017)
				p.ExprList()
			}

		}
		{
			p.SetState(4020)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserLINESTRING_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4021)

			var _m = p.Match(TiDBParserLINESTRING_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4022)
			p.ExprListWithParentheses()
		}

	case TiDBParserMULTILINESTRING_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4023)

			var _m = p.Match(TiDBParserMULTILINESTRING_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4024)
			p.ExprListWithParentheses()
		}

	case TiDBParserMULTIPOINT_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4025)

			var _m = p.Match(TiDBParserMULTIPOINT_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4026)
			p.ExprListWithParentheses()
		}

	case TiDBParserMULTIPOLYGON_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4027)

			var _m = p.Match(TiDBParserMULTIPOLYGON_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4028)
			p.ExprListWithParentheses()
		}

	case TiDBParserPOINT_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4029)

			var _m = p.Match(TiDBParserPOINT_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4030)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4031)
			p.expr(0)
		}
		{
			p.SetState(4032)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4033)
			p.expr(0)
		}
		{
			p.SetState(4034)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserPOLYGON_SYMBOL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4036)

			var _m = p.Match(TiDBParserPOLYGON_SYMBOL)

			localctx.(*GeometryFunctionContext).name = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4037)
			p.ExprListWithParentheses()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITimeFunctionParametersContext is an interface to support dynamic dispatch.
type ITimeFunctionParametersContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	FractionalPrecision() IFractionalPrecisionContext

	// IsTimeFunctionParametersContext differentiates from other interfaces.
	IsTimeFunctionParametersContext()
}

type TimeFunctionParametersContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeFunctionParametersContext() *TimeFunctionParametersContext {
	var p = new(TimeFunctionParametersContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_timeFunctionParameters
	return p
}

func InitEmptyTimeFunctionParametersContext(p *TimeFunctionParametersContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_timeFunctionParameters
}

func (*TimeFunctionParametersContext) IsTimeFunctionParametersContext() {}

func NewTimeFunctionParametersContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeFunctionParametersContext {
	var p = new(TimeFunctionParametersContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_timeFunctionParameters

	return p
}

func (s *TimeFunctionParametersContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeFunctionParametersContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *TimeFunctionParametersContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TimeFunctionParametersContext) FractionalPrecision() IFractionalPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFractionalPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFractionalPrecisionContext)
}

func (s *TimeFunctionParametersContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeFunctionParametersContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeFunctionParametersContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTimeFunctionParameters(s)
	}
}

func (s *TimeFunctionParametersContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTimeFunctionParameters(s)
	}
}

func (s *TimeFunctionParametersContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTimeFunctionParameters(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TimeFunctionParameters() (localctx ITimeFunctionParametersContext) {
	localctx = NewTimeFunctionParametersContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 424, TiDBParserRULE_timeFunctionParameters)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4040)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4042)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserINT_NUMBER {
		{
			p.SetState(4041)
			p.FractionalPrecision()
		}

	}
	{
		p.SetState(4044)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFractionalPrecisionContext is an interface to support dynamic dispatch.
type IFractionalPrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode

	// IsFractionalPrecisionContext differentiates from other interfaces.
	IsFractionalPrecisionContext()
}

type FractionalPrecisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFractionalPrecisionContext() *FractionalPrecisionContext {
	var p = new(FractionalPrecisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fractionalPrecision
	return p
}

func InitEmptyFractionalPrecisionContext(p *FractionalPrecisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fractionalPrecision
}

func (*FractionalPrecisionContext) IsFractionalPrecisionContext() {}

func NewFractionalPrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FractionalPrecisionContext {
	var p = new(FractionalPrecisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fractionalPrecision

	return p
}

func (s *FractionalPrecisionContext) GetParser() antlr.Parser { return s.parser }

func (s *FractionalPrecisionContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *FractionalPrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FractionalPrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FractionalPrecisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFractionalPrecision(s)
	}
}

func (s *FractionalPrecisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFractionalPrecision(s)
	}
}

func (s *FractionalPrecisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFractionalPrecision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FractionalPrecision() (localctx IFractionalPrecisionContext) {
	localctx = NewFractionalPrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 426, TiDBParserRULE_fractionalPrecision)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4046)
		p.Match(TiDBParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWeightStringLevelsContext is an interface to support dynamic dispatch.
type IWeightStringLevelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LEVEL_SYMBOL() antlr.TerminalNode
	AllReal_ulong_number() []IReal_ulong_numberContext
	Real_ulong_number(i int) IReal_ulong_numberContext
	MINUS_OPERATOR() antlr.TerminalNode
	AllWeightStringLevelListItem() []IWeightStringLevelListItemContext
	WeightStringLevelListItem(i int) IWeightStringLevelListItemContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsWeightStringLevelsContext differentiates from other interfaces.
	IsWeightStringLevelsContext()
}

type WeightStringLevelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWeightStringLevelsContext() *WeightStringLevelsContext {
	var p = new(WeightStringLevelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_weightStringLevels
	return p
}

func InitEmptyWeightStringLevelsContext(p *WeightStringLevelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_weightStringLevels
}

func (*WeightStringLevelsContext) IsWeightStringLevelsContext() {}

func NewWeightStringLevelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WeightStringLevelsContext {
	var p = new(WeightStringLevelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_weightStringLevels

	return p
}

func (s *WeightStringLevelsContext) GetParser() antlr.Parser { return s.parser }

func (s *WeightStringLevelsContext) LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEVEL_SYMBOL, 0)
}

func (s *WeightStringLevelsContext) AllReal_ulong_number() []IReal_ulong_numberContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			len++
		}
	}

	tst := make([]IReal_ulong_numberContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IReal_ulong_numberContext); ok {
			tst[i] = t.(IReal_ulong_numberContext)
			i++
		}
	}

	return tst
}

func (s *WeightStringLevelsContext) Real_ulong_number(i int) IReal_ulong_numberContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *WeightStringLevelsContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUS_OPERATOR, 0)
}

func (s *WeightStringLevelsContext) AllWeightStringLevelListItem() []IWeightStringLevelListItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IWeightStringLevelListItemContext); ok {
			len++
		}
	}

	tst := make([]IWeightStringLevelListItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IWeightStringLevelListItemContext); ok {
			tst[i] = t.(IWeightStringLevelListItemContext)
			i++
		}
	}

	return tst
}

func (s *WeightStringLevelsContext) WeightStringLevelListItem(i int) IWeightStringLevelListItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWeightStringLevelListItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWeightStringLevelListItemContext)
}

func (s *WeightStringLevelsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *WeightStringLevelsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *WeightStringLevelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WeightStringLevelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WeightStringLevelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWeightStringLevels(s)
	}
}

func (s *WeightStringLevelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWeightStringLevels(s)
	}
}

func (s *WeightStringLevelsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWeightStringLevels(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WeightStringLevels() (localctx IWeightStringLevelsContext) {
	localctx = NewWeightStringLevelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 428, TiDBParserRULE_weightStringLevels)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4048)
		p.Match(TiDBParserLEVEL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4061)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 496, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(4049)
			p.Real_ulong_number()
		}
		{
			p.SetState(4050)
			p.Match(TiDBParserMINUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4051)
			p.Real_ulong_number()
		}

	case 2:
		{
			p.SetState(4053)
			p.WeightStringLevelListItem()
		}
		p.SetState(4058)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(4054)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4055)
				p.WeightStringLevelListItem()
			}

			p.SetState(4060)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWeightStringLevelListItemContext is an interface to support dynamic dispatch.
type IWeightStringLevelListItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Real_ulong_number() IReal_ulong_numberContext
	REVERSE_SYMBOL() antlr.TerminalNode
	ASC_SYMBOL() antlr.TerminalNode
	DESC_SYMBOL() antlr.TerminalNode

	// IsWeightStringLevelListItemContext differentiates from other interfaces.
	IsWeightStringLevelListItemContext()
}

type WeightStringLevelListItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWeightStringLevelListItemContext() *WeightStringLevelListItemContext {
	var p = new(WeightStringLevelListItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_weightStringLevelListItem
	return p
}

func InitEmptyWeightStringLevelListItemContext(p *WeightStringLevelListItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_weightStringLevelListItem
}

func (*WeightStringLevelListItemContext) IsWeightStringLevelListItemContext() {}

func NewWeightStringLevelListItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WeightStringLevelListItemContext {
	var p = new(WeightStringLevelListItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_weightStringLevelListItem

	return p
}

func (s *WeightStringLevelListItemContext) GetParser() antlr.Parser { return s.parser }

func (s *WeightStringLevelListItemContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *WeightStringLevelListItemContext) REVERSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREVERSE_SYMBOL, 0)
}

func (s *WeightStringLevelListItemContext) ASC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserASC_SYMBOL, 0)
}

func (s *WeightStringLevelListItemContext) DESC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDESC_SYMBOL, 0)
}

func (s *WeightStringLevelListItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WeightStringLevelListItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WeightStringLevelListItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWeightStringLevelListItem(s)
	}
}

func (s *WeightStringLevelListItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWeightStringLevelListItem(s)
	}
}

func (s *WeightStringLevelListItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWeightStringLevelListItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WeightStringLevelListItem() (localctx IWeightStringLevelListItemContext) {
	localctx = NewWeightStringLevelListItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 430, TiDBParserRULE_weightStringLevelListItem)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4063)
		p.Real_ulong_number()
	}
	p.SetState(4069)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case TiDBParserASC_SYMBOL, TiDBParserDESC_SYMBOL:
		{
			p.SetState(4064)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserASC_SYMBOL || _la == TiDBParserDESC_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4066)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserREVERSE_SYMBOL {
			{
				p.SetState(4065)
				p.Match(TiDBParserREVERSE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserREVERSE_SYMBOL:
		{
			p.SetState(4068)
			p.Match(TiDBParserREVERSE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserCOMMA_SYMBOL, TiDBParserCLOSE_PAR_SYMBOL:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDateTimeTtypeContext is an interface to support dynamic dispatch.
type IDateTimeTtypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode

	// IsDateTimeTtypeContext differentiates from other interfaces.
	IsDateTimeTtypeContext()
}

type DateTimeTtypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimeTtypeContext() *DateTimeTtypeContext {
	var p = new(DateTimeTtypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dateTimeTtype
	return p
}

func InitEmptyDateTimeTtypeContext(p *DateTimeTtypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dateTimeTtype
}

func (*DateTimeTtypeContext) IsDateTimeTtypeContext() {}

func NewDateTimeTtypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimeTtypeContext {
	var p = new(DateTimeTtypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_dateTimeTtype

	return p
}

func (s *DateTimeTtypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimeTtypeContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATE_SYMBOL, 0)
}

func (s *DateTimeTtypeContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIME_SYMBOL, 0)
}

func (s *DateTimeTtypeContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATETIME_SYMBOL, 0)
}

func (s *DateTimeTtypeContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_SYMBOL, 0)
}

func (s *DateTimeTtypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeTtypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateTimeTtypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDateTimeTtype(s)
	}
}

func (s *DateTimeTtypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDateTimeTtype(s)
	}
}

func (s *DateTimeTtypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDateTimeTtype(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DateTimeTtype() (localctx IDateTimeTtypeContext) {
	localctx = NewDateTimeTtypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 432, TiDBParserRULE_dateTimeTtype)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4071)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserDATETIME_SYMBOL || _la == TiDBParserDATE_SYMBOL || _la == TiDBParserTIMESTAMP_SYMBOL || _la == TiDBParserTIME_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITrimFunctionContext is an interface to support dynamic dispatch.
type ITrimFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRIM_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	LEADING_SYMBOL() antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	TRAILING_SYMBOL() antlr.TerminalNode
	BOTH_SYMBOL() antlr.TerminalNode

	// IsTrimFunctionContext differentiates from other interfaces.
	IsTrimFunctionContext()
}

type TrimFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTrimFunctionContext() *TrimFunctionContext {
	var p = new(TrimFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_trimFunction
	return p
}

func InitEmptyTrimFunctionContext(p *TrimFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_trimFunction
}

func (*TrimFunctionContext) IsTrimFunctionContext() {}

func NewTrimFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TrimFunctionContext {
	var p = new(TrimFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_trimFunction

	return p
}

func (s *TrimFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *TrimFunctionContext) TRIM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRIM_SYMBOL, 0)
}

func (s *TrimFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *TrimFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TrimFunctionContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *TrimFunctionContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *TrimFunctionContext) LEADING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEADING_SYMBOL, 0)
}

func (s *TrimFunctionContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *TrimFunctionContext) TRAILING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRAILING_SYMBOL, 0)
}

func (s *TrimFunctionContext) BOTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBOTH_SYMBOL, 0)
}

func (s *TrimFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TrimFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TrimFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTrimFunction(s)
	}
}

func (s *TrimFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTrimFunction(s)
	}
}

func (s *TrimFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTrimFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TrimFunction() (localctx ITrimFunctionContext) {
	localctx = NewTrimFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 434, TiDBParserRULE_trimFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4073)
		p.Match(TiDBParserTRIM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4074)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINARY_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_AND_SYMBOL, TiDBParserBIT_OR_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBIT_XOR_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCASE_SYMBOL, TiDBParserCAST_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHAR_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCONVERT_SYMBOL, TiDBParserCOUNT_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURDATE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURRENT_USER_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserCURTIME_SYMBOL, TiDBParserDATABASE_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_ADD_SYMBOL, TiDBParserDATE_SUB_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXISTS_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserEXTRACT_SYMBOL, TiDBParserFALSE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserGROUP_CONCAT_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIF_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINTERVAL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLEFT_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMATCH_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMIN_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMOD_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNOT_SYMBOL, TiDBParserNOW_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNULL_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPOSITION_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPEAT_SYMBOL, TiDBParserREPLACE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserRIGHT_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTDDEV_SAMP_SYMBOL, TiDBParserSTD_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUBSTRING_SYMBOL, TiDBParserSUM_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserSYSDATE_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRIM_SYMBOL, TiDBParserTRUE_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserUTC_DATE_SYMBOL, TiDBParserUTC_TIMESTAMP_SYMBOL, TiDBParserUTC_TIME_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUES_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVARIANCE_SYMBOL, TiDBParserVAR_SAMP_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserJSON_OBJECTAGG_SYMBOL, TiDBParserJSON_ARRAYAGG_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserGROUPING_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserCUME_DIST_SYMBOL, TiDBParserDENSE_RANK_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFIRST_VALUE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserLAG_SYMBOL, TiDBParserLAST_VALUE_SYMBOL, TiDBParserLEAD_SYMBOL, TiDBParserNTH_VALUE_SYMBOL, TiDBParserNTILE_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPERCENT_RANK_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRANK_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserROW_NUMBER_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserNOT2_SYMBOL, TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserPLUS_OPERATOR, TiDBParserMINUS_OPERATOR, TiDBParserLOGICAL_NOT_OPERATOR, TiDBParserBITWISE_NOT_OPERATOR, TiDBParserDOT_SYMBOL, TiDBParserOPEN_PAR_SYMBOL, TiDBParserOPEN_CURLY_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserAT_SIGN_SYMBOL, TiDBParserAT_TEXT_SUFFIX, TiDBParserAT_AT_SIGN_SYMBOL, TiDBParserNULL2_SYMBOL, TiDBParserPARAM_MARKER, TiDBParserHEX_NUMBER, TiDBParserBIN_NUMBER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserUNDERSCORE_CHARSET, TiDBParserIDENTIFIER, TiDBParserNCHAR_TEXT, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		{
			p.SetState(4075)
			p.expr(0)
		}
		p.SetState(4078)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFROM_SYMBOL {
			{
				p.SetState(4076)
				p.Match(TiDBParserFROM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4077)
				p.expr(0)
			}

		}

	case TiDBParserLEADING_SYMBOL:
		{
			p.SetState(4080)
			p.Match(TiDBParserLEADING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5225064543571856404) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&873621610730880735) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-865958324971471593) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-8882137626648422863) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-576464036585580211) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&7745041819529110015) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&-1746007220614610867) != 0) || ((int64((_la-448)) & ^0x3f) == 0 && ((int64(1)<<(_la-448))&5832610115359342555) != 0) || ((int64((_la-512)) & ^0x3f) == 0 && ((int64(1)<<(_la-512))&-7206898910882232401) != 0) || ((int64((_la-576)) & ^0x3f) == 0 && ((int64(1)<<(_la-576))&-2769768038281836617) != 0) || ((int64((_la-640)) & ^0x3f) == 0 && ((int64(1)<<(_la-640))&-4037485862341231165) != 0) || ((int64((_la-704)) & ^0x3f) == 0 && ((int64(1)<<(_la-704))&1783491423132188607) != 0) || ((int64((_la-772)) & ^0x3f) == 0 && ((int64(1)<<(_la-772))&68712134993) != 0) {
			{
				p.SetState(4081)
				p.expr(0)
			}

		}
		{
			p.SetState(4084)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4085)
			p.expr(0)
		}

	case TiDBParserTRAILING_SYMBOL:
		{
			p.SetState(4086)
			p.Match(TiDBParserTRAILING_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4088)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5225064543571856404) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&873621610730880735) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-865958324971471593) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-8882137626648422863) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-576464036585580211) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&7745041819529110015) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&-1746007220614610867) != 0) || ((int64((_la-448)) & ^0x3f) == 0 && ((int64(1)<<(_la-448))&5832610115359342555) != 0) || ((int64((_la-512)) & ^0x3f) == 0 && ((int64(1)<<(_la-512))&-7206898910882232401) != 0) || ((int64((_la-576)) & ^0x3f) == 0 && ((int64(1)<<(_la-576))&-2769768038281836617) != 0) || ((int64((_la-640)) & ^0x3f) == 0 && ((int64(1)<<(_la-640))&-4037485862341231165) != 0) || ((int64((_la-704)) & ^0x3f) == 0 && ((int64(1)<<(_la-704))&1783491423132188607) != 0) || ((int64((_la-772)) & ^0x3f) == 0 && ((int64(1)<<(_la-772))&68712134993) != 0) {
			{
				p.SetState(4087)
				p.expr(0)
			}

		}
		{
			p.SetState(4090)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4091)
			p.expr(0)
		}

	case TiDBParserBOTH_SYMBOL:
		{
			p.SetState(4092)
			p.Match(TiDBParserBOTH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4094)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5225064543571856404) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&873621610730880735) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-865958324971471593) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-8882137626648422863) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-576464036585580211) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&7745041819529110015) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&-1746007220614610867) != 0) || ((int64((_la-448)) & ^0x3f) == 0 && ((int64(1)<<(_la-448))&5832610115359342555) != 0) || ((int64((_la-512)) & ^0x3f) == 0 && ((int64(1)<<(_la-512))&-7206898910882232401) != 0) || ((int64((_la-576)) & ^0x3f) == 0 && ((int64(1)<<(_la-576))&-2769768038281836617) != 0) || ((int64((_la-640)) & ^0x3f) == 0 && ((int64(1)<<(_la-640))&-4037485862341231165) != 0) || ((int64((_la-704)) & ^0x3f) == 0 && ((int64(1)<<(_la-704))&1783491423132188607) != 0) || ((int64((_la-772)) & ^0x3f) == 0 && ((int64(1)<<(_la-772))&68712134993) != 0) {
			{
				p.SetState(4093)
				p.expr(0)
			}

		}
		{
			p.SetState(4096)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4097)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4100)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubstringFunctionContext is an interface to support dynamic dispatch.
type ISubstringFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBSTRING_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode
	FROM_SYMBOL() antlr.TerminalNode
	FOR_SYMBOL() antlr.TerminalNode

	// IsSubstringFunctionContext differentiates from other interfaces.
	IsSubstringFunctionContext()
}

type SubstringFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubstringFunctionContext() *SubstringFunctionContext {
	var p = new(SubstringFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_substringFunction
	return p
}

func InitEmptySubstringFunctionContext(p *SubstringFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_substringFunction
}

func (*SubstringFunctionContext) IsSubstringFunctionContext() {}

func NewSubstringFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubstringFunctionContext {
	var p = new(SubstringFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_substringFunction

	return p
}

func (s *SubstringFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubstringFunctionContext) SUBSTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBSTRING_SYMBOL, 0)
}

func (s *SubstringFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SubstringFunctionContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *SubstringFunctionContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SubstringFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SubstringFunctionContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *SubstringFunctionContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *SubstringFunctionContext) FROM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFROM_SYMBOL, 0)
}

func (s *SubstringFunctionContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *SubstringFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubstringFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubstringFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSubstringFunction(s)
	}
}

func (s *SubstringFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSubstringFunction(s)
	}
}

func (s *SubstringFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSubstringFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SubstringFunction() (localctx ISubstringFunctionContext) {
	localctx = NewSubstringFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 436, TiDBParserRULE_substringFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4102)
		p.Match(TiDBParserSUBSTRING_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4103)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4104)
		p.expr(0)
	}
	p.SetState(4117)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCOMMA_SYMBOL:
		{
			p.SetState(4105)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4106)
			p.expr(0)
		}
		p.SetState(4109)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(4107)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4108)
				p.expr(0)
			}

		}

	case TiDBParserFROM_SYMBOL:
		{
			p.SetState(4111)
			p.Match(TiDBParserFROM_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4112)
			p.expr(0)
		}
		p.SetState(4115)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserFOR_SYMBOL {
			{
				p.SetState(4113)
				p.Match(TiDBParserFOR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4114)
				p.expr(0)
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4119)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionCallContext is an interface to support dynamic dispatch.
type IFunctionCallContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	UdfExprList() IUdfExprListContext
	QualifiedIdentifier() IQualifiedIdentifierContext
	ExprList() IExprListContext

	// IsFunctionCallContext differentiates from other interfaces.
	IsFunctionCallContext()
}

type FunctionCallContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionCallContext() *FunctionCallContext {
	var p = new(FunctionCallContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_functionCall
	return p
}

func InitEmptyFunctionCallContext(p *FunctionCallContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_functionCall
}

func (*FunctionCallContext) IsFunctionCallContext() {}

func NewFunctionCallContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionCallContext {
	var p = new(FunctionCallContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_functionCall

	return p
}

func (s *FunctionCallContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionCallContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *FunctionCallContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *FunctionCallContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *FunctionCallContext) UdfExprList() IUdfExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUdfExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUdfExprListContext)
}

func (s *FunctionCallContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *FunctionCallContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *FunctionCallContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionCallContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionCallContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFunctionCall(s)
	}
}

func (s *FunctionCallContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFunctionCall(s)
	}
}

func (s *FunctionCallContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFunctionCall(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FunctionCall() (localctx IFunctionCallContext) {
	localctx = NewFunctionCallContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 438, TiDBParserRULE_functionCall)
	var _la int

	p.SetState(4135)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 509, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4121)
			p.PureIdentifier()
		}
		{
			p.SetState(4122)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4124)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5225064543571856404) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&873621610730880735) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-865958324971471593) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-8882137626648422863) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-576464036585580211) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&7745041819529110015) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&-1746007220614610867) != 0) || ((int64((_la-448)) & ^0x3f) == 0 && ((int64(1)<<(_la-448))&5832610115359342555) != 0) || ((int64((_la-512)) & ^0x3f) == 0 && ((int64(1)<<(_la-512))&-7206898910882232401) != 0) || ((int64((_la-576)) & ^0x3f) == 0 && ((int64(1)<<(_la-576))&-2769768038281836617) != 0) || ((int64((_la-640)) & ^0x3f) == 0 && ((int64(1)<<(_la-640))&-4037485862341231165) != 0) || ((int64((_la-704)) & ^0x3f) == 0 && ((int64(1)<<(_la-704))&1783491423132188607) != 0) || ((int64((_la-772)) & ^0x3f) == 0 && ((int64(1)<<(_la-772))&68712134993) != 0) {
			{
				p.SetState(4123)
				p.UdfExprList()
			}

		}
		{
			p.SetState(4126)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4128)
			p.QualifiedIdentifier()
		}
		{
			p.SetState(4129)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4131)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-5225064543571856404) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&873621610730880735) != 0) || ((int64((_la-128)) & ^0x3f) == 0 && ((int64(1)<<(_la-128))&-865958324971471593) != 0) || ((int64((_la-192)) & ^0x3f) == 0 && ((int64(1)<<(_la-192))&-8882137626648422863) != 0) || ((int64((_la-256)) & ^0x3f) == 0 && ((int64(1)<<(_la-256))&-576464036585580211) != 0) || ((int64((_la-320)) & ^0x3f) == 0 && ((int64(1)<<(_la-320))&7745041819529110015) != 0) || ((int64((_la-384)) & ^0x3f) == 0 && ((int64(1)<<(_la-384))&-1746007220614610867) != 0) || ((int64((_la-448)) & ^0x3f) == 0 && ((int64(1)<<(_la-448))&5832610115359342555) != 0) || ((int64((_la-512)) & ^0x3f) == 0 && ((int64(1)<<(_la-512))&-7206898910882232401) != 0) || ((int64((_la-576)) & ^0x3f) == 0 && ((int64(1)<<(_la-576))&-2769768038281836617) != 0) || ((int64((_la-640)) & ^0x3f) == 0 && ((int64(1)<<(_la-640))&-4037485862341231165) != 0) || ((int64((_la-704)) & ^0x3f) == 0 && ((int64(1)<<(_la-704))&1783491423132188607) != 0) || ((int64((_la-772)) & ^0x3f) == 0 && ((int64(1)<<(_la-772))&68712134993) != 0) {
			{
				p.SetState(4130)
				p.ExprList()
			}

		}
		{
			p.SetState(4133)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISearchJsonFunctionContext is an interface to support dynamic dispatch.
type ISearchJsonFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	JSON_VALUE_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	COMMA_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	JsonValueReturning() IJsonValueReturningContext
	JsonValueOnEmpty() IJsonValueOnEmptyContext
	JsonValueOnError() IJsonValueOnErrorContext

	// IsSearchJsonFunctionContext differentiates from other interfaces.
	IsSearchJsonFunctionContext()
}

type SearchJsonFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySearchJsonFunctionContext() *SearchJsonFunctionContext {
	var p = new(SearchJsonFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_searchJsonFunction
	return p
}

func InitEmptySearchJsonFunctionContext(p *SearchJsonFunctionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_searchJsonFunction
}

func (*SearchJsonFunctionContext) IsSearchJsonFunctionContext() {}

func NewSearchJsonFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SearchJsonFunctionContext {
	var p = new(SearchJsonFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_searchJsonFunction

	return p
}

func (s *SearchJsonFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *SearchJsonFunctionContext) JSON_VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_VALUE_SYMBOL, 0)
}

func (s *SearchJsonFunctionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SearchJsonFunctionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SearchJsonFunctionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *SearchJsonFunctionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *SearchJsonFunctionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *SearchJsonFunctionContext) JsonValueReturning() IJsonValueReturningContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonValueReturningContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonValueReturningContext)
}

func (s *SearchJsonFunctionContext) JsonValueOnEmpty() IJsonValueOnEmptyContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonValueOnEmptyContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonValueOnEmptyContext)
}

func (s *SearchJsonFunctionContext) JsonValueOnError() IJsonValueOnErrorContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IJsonValueOnErrorContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IJsonValueOnErrorContext)
}

func (s *SearchJsonFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SearchJsonFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SearchJsonFunctionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSearchJsonFunction(s)
	}
}

func (s *SearchJsonFunctionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSearchJsonFunction(s)
	}
}

func (s *SearchJsonFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSearchJsonFunction(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SearchJsonFunction() (localctx ISearchJsonFunctionContext) {
	localctx = NewSearchJsonFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 440, TiDBParserRULE_searchJsonFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4137)
		p.Match(TiDBParserJSON_VALUE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4138)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

	{
		p.SetState(4139)
		p.expr(0)
	}
	{
		p.SetState(4140)
		p.Match(TiDBParserCOMMA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4141)
		p.TextLiteral()
	}
	p.SetState(4143)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserRETURNING_SYMBOL {
		{
			p.SetState(4142)
			p.JsonValueReturning()
		}

	}
	p.SetState(4146)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 511, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4145)
			p.JsonValueOnEmpty()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4149)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserERROR_SYMBOL || _la == TiDBParserNULL_SYMBOL || _la == TiDBParserNULL2_SYMBOL {
		{
			p.SetState(4148)
			p.JsonValueOnError()
		}

	}

	{
		p.SetState(4151)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonValueReturningContext is an interface to support dynamic dispatch.
type IJsonValueReturningContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETURNING_SYMBOL() antlr.TerminalNode
	CastType() ICastTypeContext

	// IsJsonValueReturningContext differentiates from other interfaces.
	IsJsonValueReturningContext()
}

type JsonValueReturningContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonValueReturningContext() *JsonValueReturningContext {
	var p = new(JsonValueReturningContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonValueReturning
	return p
}

func InitEmptyJsonValueReturningContext(p *JsonValueReturningContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonValueReturning
}

func (*JsonValueReturningContext) IsJsonValueReturningContext() {}

func NewJsonValueReturningContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonValueReturningContext {
	var p = new(JsonValueReturningContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_jsonValueReturning

	return p
}

func (s *JsonValueReturningContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonValueReturningContext) RETURNING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRETURNING_SYMBOL, 0)
}

func (s *JsonValueReturningContext) CastType() ICastTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICastTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICastTypeContext)
}

func (s *JsonValueReturningContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueReturningContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonValueReturningContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterJsonValueReturning(s)
	}
}

func (s *JsonValueReturningContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitJsonValueReturning(s)
	}
}

func (s *JsonValueReturningContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitJsonValueReturning(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) JsonValueReturning() (localctx IJsonValueReturningContext) {
	localctx = NewJsonValueReturningContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 442, TiDBParserRULE_jsonValueReturning)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4153)
		p.Match(TiDBParserRETURNING_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4154)
		p.CastType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonValueOnEmptyContext is an interface to support dynamic dispatch.
type IJsonValueOnEmptyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON_SYMBOL() antlr.TerminalNode
	EMPTY_SYMBOL() antlr.TerminalNode
	NullLiteral() INullLiteralContext
	ERROR_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsJsonValueOnEmptyContext differentiates from other interfaces.
	IsJsonValueOnEmptyContext()
}

type JsonValueOnEmptyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonValueOnEmptyContext() *JsonValueOnEmptyContext {
	var p = new(JsonValueOnEmptyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonValueOnEmpty
	return p
}

func InitEmptyJsonValueOnEmptyContext(p *JsonValueOnEmptyContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonValueOnEmpty
}

func (*JsonValueOnEmptyContext) IsJsonValueOnEmptyContext() {}

func NewJsonValueOnEmptyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonValueOnEmptyContext {
	var p = new(JsonValueOnEmptyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_jsonValueOnEmpty

	return p
}

func (s *JsonValueOnEmptyContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonValueOnEmptyContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *JsonValueOnEmptyContext) EMPTY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEMPTY_SYMBOL, 0)
}

func (s *JsonValueOnEmptyContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *JsonValueOnEmptyContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserERROR_SYMBOL, 0)
}

func (s *JsonValueOnEmptyContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *JsonValueOnEmptyContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *JsonValueOnEmptyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueOnEmptyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonValueOnEmptyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterJsonValueOnEmpty(s)
	}
}

func (s *JsonValueOnEmptyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitJsonValueOnEmpty(s)
	}
}

func (s *JsonValueOnEmptyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitJsonValueOnEmpty(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) JsonValueOnEmpty() (localctx IJsonValueOnEmptyContext) {
	localctx = NewJsonValueOnEmptyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 444, TiDBParserRULE_jsonValueOnEmpty)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4160)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserNULL_SYMBOL, TiDBParserNULL2_SYMBOL:
		{
			p.SetState(4156)
			p.NullLiteral()
		}

	case TiDBParserERROR_SYMBOL:
		{
			p.SetState(4157)
			p.Match(TiDBParserERROR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserDEFAULT_SYMBOL:
		{
			p.SetState(4158)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4159)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4162)
		p.Match(TiDBParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4163)
		p.Match(TiDBParserEMPTY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IJsonValueOnErrorContext is an interface to support dynamic dispatch.
type IJsonValueOnErrorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ON_SYMBOL() antlr.TerminalNode
	AllERROR_SYMBOL() []antlr.TerminalNode
	ERROR_SYMBOL(i int) antlr.TerminalNode
	NullLiteral() INullLiteralContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsJsonValueOnErrorContext differentiates from other interfaces.
	IsJsonValueOnErrorContext()
}

type JsonValueOnErrorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyJsonValueOnErrorContext() *JsonValueOnErrorContext {
	var p = new(JsonValueOnErrorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonValueOnError
	return p
}

func InitEmptyJsonValueOnErrorContext(p *JsonValueOnErrorContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_jsonValueOnError
}

func (*JsonValueOnErrorContext) IsJsonValueOnErrorContext() {}

func NewJsonValueOnErrorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *JsonValueOnErrorContext {
	var p = new(JsonValueOnErrorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_jsonValueOnError

	return p
}

func (s *JsonValueOnErrorContext) GetParser() antlr.Parser { return s.parser }

func (s *JsonValueOnErrorContext) ON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, 0)
}

func (s *JsonValueOnErrorContext) AllERROR_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserERROR_SYMBOL)
}

func (s *JsonValueOnErrorContext) ERROR_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserERROR_SYMBOL, i)
}

func (s *JsonValueOnErrorContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *JsonValueOnErrorContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *JsonValueOnErrorContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *JsonValueOnErrorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *JsonValueOnErrorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *JsonValueOnErrorContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterJsonValueOnError(s)
	}
}

func (s *JsonValueOnErrorContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitJsonValueOnError(s)
	}
}

func (s *JsonValueOnErrorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitJsonValueOnError(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) JsonValueOnError() (localctx IJsonValueOnErrorContext) {
	localctx = NewJsonValueOnErrorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 446, TiDBParserRULE_jsonValueOnError)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(4169)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserNULL_SYMBOL, TiDBParserNULL2_SYMBOL:
		{
			p.SetState(4165)
			p.NullLiteral()
		}

	case TiDBParserERROR_SYMBOL:
		{
			p.SetState(4166)
			p.Match(TiDBParserERROR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserDEFAULT_SYMBOL:
		{
			p.SetState(4167)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4168)
			p.expr(0)
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4171)
		p.Match(TiDBParserON_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4172)
		p.Match(TiDBParserERROR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUdfExprListContext is an interface to support dynamic dispatch.
type IUdfExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUdfExpr() []IUdfExprContext
	UdfExpr(i int) IUdfExprContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsUdfExprListContext differentiates from other interfaces.
	IsUdfExprListContext()
}

type UdfExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdfExprListContext() *UdfExprListContext {
	var p = new(UdfExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_udfExprList
	return p
}

func InitEmptyUdfExprListContext(p *UdfExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_udfExprList
}

func (*UdfExprListContext) IsUdfExprListContext() {}

func NewUdfExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UdfExprListContext {
	var p = new(UdfExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_udfExprList

	return p
}

func (s *UdfExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *UdfExprListContext) AllUdfExpr() []IUdfExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUdfExprContext); ok {
			len++
		}
	}

	tst := make([]IUdfExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUdfExprContext); ok {
			tst[i] = t.(IUdfExprContext)
			i++
		}
	}

	return tst
}

func (s *UdfExprListContext) UdfExpr(i int) IUdfExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUdfExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUdfExprContext)
}

func (s *UdfExprListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *UdfExprListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *UdfExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UdfExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUdfExprList(s)
	}
}

func (s *UdfExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUdfExprList(s)
	}
}

func (s *UdfExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUdfExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UdfExprList() (localctx IUdfExprListContext) {
	localctx = NewUdfExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 448, TiDBParserRULE_udfExprList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4174)
		p.UdfExpr()
	}
	p.SetState(4179)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(4175)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4176)
			p.UdfExpr()
		}

		p.SetState(4181)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUdfExprContext is an interface to support dynamic dispatch.
type IUdfExprContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	SelectAlias() ISelectAliasContext

	// IsUdfExprContext differentiates from other interfaces.
	IsUdfExprContext()
}

type UdfExprContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdfExprContext() *UdfExprContext {
	var p = new(UdfExprContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_udfExpr
	return p
}

func InitEmptyUdfExprContext(p *UdfExprContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_udfExpr
}

func (*UdfExprContext) IsUdfExprContext() {}

func NewUdfExprContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UdfExprContext {
	var p = new(UdfExprContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_udfExpr

	return p
}

func (s *UdfExprContext) GetParser() antlr.Parser { return s.parser }

func (s *UdfExprContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UdfExprContext) SelectAlias() ISelectAliasContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISelectAliasContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISelectAliasContext)
}

func (s *UdfExprContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfExprContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UdfExprContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUdfExpr(s)
	}
}

func (s *UdfExprContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUdfExpr(s)
	}
}

func (s *UdfExprContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUdfExpr(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UdfExpr() (localctx IUdfExprContext) {
	localctx = NewUdfExprContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 450, TiDBParserRULE_udfExpr)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4182)
		p.expr(0)
	}
	p.SetState(4184)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871717396) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&7551) != 0) {
		{
			p.SetState(4183)
			p.SelectAlias()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVariableContext is an interface to support dynamic dispatch.
type IVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserVariable() IUserVariableContext
	SystemVariable() ISystemVariableContext

	// IsVariableContext differentiates from other interfaces.
	IsVariableContext()
}

type VariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVariableContext() *VariableContext {
	var p = new(VariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_variable
	return p
}

func InitEmptyVariableContext(p *VariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_variable
}

func (*VariableContext) IsVariableContext() {}

func NewVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VariableContext {
	var p = new(VariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_variable

	return p
}

func (s *VariableContext) GetParser() antlr.Parser { return s.parser }

func (s *VariableContext) UserVariable() IUserVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserVariableContext)
}

func (s *VariableContext) SystemVariable() ISystemVariableContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISystemVariableContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISystemVariableContext)
}

func (s *VariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterVariable(s)
	}
}

func (s *VariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitVariable(s)
	}
}

func (s *VariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Variable() (localctx IVariableContext) {
	localctx = NewVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 452, TiDBParserRULE_variable)
	p.SetState(4188)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserAT_SIGN_SYMBOL, TiDBParserAT_TEXT_SUFFIX:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4186)
			p.UserVariable()
		}

	case TiDBParserAT_AT_SIGN_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4187)
			p.SystemVariable()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserVariableContext is an interface to support dynamic dispatch.
type IUserVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_SIGN_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	AT_TEXT_SUFFIX() antlr.TerminalNode

	// IsUserVariableContext differentiates from other interfaces.
	IsUserVariableContext()
}

type UserVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserVariableContext() *UserVariableContext {
	var p = new(UserVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_userVariable
	return p
}

func InitEmptyUserVariableContext(p *UserVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_userVariable
}

func (*UserVariableContext) IsUserVariableContext() {}

func NewUserVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserVariableContext {
	var p = new(UserVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_userVariable

	return p
}

func (s *UserVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *UserVariableContext) AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_SIGN_SYMBOL, 0)
}

func (s *UserVariableContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *UserVariableContext) AT_TEXT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_TEXT_SUFFIX, 0)
}

func (s *UserVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUserVariable(s)
	}
}

func (s *UserVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUserVariable(s)
	}
}

func (s *UserVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUserVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UserVariable() (localctx IUserVariableContext) {
	localctx = NewUserVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 454, TiDBParserRULE_userVariable)
	p.SetState(4193)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserAT_SIGN_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4190)
			p.Match(TiDBParserAT_SIGN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4191)
			p.TextOrIdentifier()
		}

	case TiDBParserAT_TEXT_SUFFIX:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4192)
			p.Match(TiDBParserAT_TEXT_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISystemVariableContext is an interface to support dynamic dispatch.
type ISystemVariableContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AT_AT_SIGN_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	VarIdentType() IVarIdentTypeContext
	DotIdentifier() IDotIdentifierContext

	// IsSystemVariableContext differentiates from other interfaces.
	IsSystemVariableContext()
}

type SystemVariableContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySystemVariableContext() *SystemVariableContext {
	var p = new(SystemVariableContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_systemVariable
	return p
}

func InitEmptySystemVariableContext(p *SystemVariableContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_systemVariable
}

func (*SystemVariableContext) IsSystemVariableContext() {}

func NewSystemVariableContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SystemVariableContext {
	var p = new(SystemVariableContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_systemVariable

	return p
}

func (s *SystemVariableContext) GetParser() antlr.Parser { return s.parser }

func (s *SystemVariableContext) AT_AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_AT_SIGN_SYMBOL, 0)
}

func (s *SystemVariableContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *SystemVariableContext) VarIdentType() IVarIdentTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVarIdentTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVarIdentTypeContext)
}

func (s *SystemVariableContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *SystemVariableContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SystemVariableContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SystemVariableContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSystemVariable(s)
	}
}

func (s *SystemVariableContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSystemVariable(s)
	}
}

func (s *SystemVariableContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSystemVariable(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SystemVariable() (localctx ISystemVariableContext) {
	localctx = NewSystemVariableContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 456, TiDBParserRULE_systemVariable)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4195)
		p.Match(TiDBParserAT_AT_SIGN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4197)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 519, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4196)
			p.VarIdentType()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	{
		p.SetState(4199)
		p.TextOrIdentifier()
	}
	p.SetState(4201)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 520, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4200)
			p.DotIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInternalVariableNameContext is an interface to support dynamic dispatch.
type IInternalVariableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LValueIdentifier() ILValueIdentifierContext
	DotIdentifier() IDotIdentifierContext
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsInternalVariableNameContext differentiates from other interfaces.
	IsInternalVariableNameContext()
}

type InternalVariableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInternalVariableNameContext() *InternalVariableNameContext {
	var p = new(InternalVariableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_internalVariableName
	return p
}

func InitEmptyInternalVariableNameContext(p *InternalVariableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_internalVariableName
}

func (*InternalVariableNameContext) IsInternalVariableNameContext() {}

func NewInternalVariableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InternalVariableNameContext {
	var p = new(InternalVariableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_internalVariableName

	return p
}

func (s *InternalVariableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *InternalVariableNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *InternalVariableNameContext) LValueIdentifier() ILValueIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILValueIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILValueIdentifierContext)
}

func (s *InternalVariableNameContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *InternalVariableNameContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *InternalVariableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InternalVariableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InternalVariableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterInternalVariableName(s)
	}
}

func (s *InternalVariableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitInternalVariableName(s)
	}
}

func (s *InternalVariableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitInternalVariableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) InternalVariableName() (localctx IInternalVariableNameContext) {
	localctx = NewInternalVariableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 458, TiDBParserRULE_internalVariableName)
	var _la int

	p.SetState(4215)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4211)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 523, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4203)
				p.Identifier()
			}
			p.SetState(4205)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserDOT_SYMBOL {
				{
					p.SetState(4204)
					p.DotIdentifier()
				}

			}

		case 2:
			{
				p.SetState(4207)
				p.LValueIdentifier()
			}
			p.SetState(4209)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserDOT_SYMBOL {
				{
					p.SetState(4208)
					p.DotIdentifier()
				}

			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case TiDBParserDEFAULT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4213)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4214)
			p.DotIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWhenExpressionContext is an interface to support dynamic dispatch.
type IWhenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WHEN_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsWhenExpressionContext differentiates from other interfaces.
	IsWhenExpressionContext()
}

type WhenExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhenExpressionContext() *WhenExpressionContext {
	var p = new(WhenExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_whenExpression
	return p
}

func InitEmptyWhenExpressionContext(p *WhenExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_whenExpression
}

func (*WhenExpressionContext) IsWhenExpressionContext() {}

func NewWhenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhenExpressionContext {
	var p = new(WhenExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_whenExpression

	return p
}

func (s *WhenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *WhenExpressionContext) WHEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWHEN_SYMBOL, 0)
}

func (s *WhenExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *WhenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WhenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWhenExpression(s)
	}
}

func (s *WhenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWhenExpression(s)
	}
}

func (s *WhenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWhenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WhenExpression() (localctx IWhenExpressionContext) {
	localctx = NewWhenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 460, TiDBParserRULE_whenExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4217)
		p.Match(TiDBParserWHEN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4218)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IThenExpressionContext is an interface to support dynamic dispatch.
type IThenExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	THEN_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsThenExpressionContext differentiates from other interfaces.
	IsThenExpressionContext()
}

type ThenExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyThenExpressionContext() *ThenExpressionContext {
	var p = new(ThenExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_thenExpression
	return p
}

func InitEmptyThenExpressionContext(p *ThenExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_thenExpression
}

func (*ThenExpressionContext) IsThenExpressionContext() {}

func NewThenExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ThenExpressionContext {
	var p = new(ThenExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_thenExpression

	return p
}

func (s *ThenExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ThenExpressionContext) THEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTHEN_SYMBOL, 0)
}

func (s *ThenExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ThenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThenExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ThenExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterThenExpression(s)
	}
}

func (s *ThenExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitThenExpression(s)
	}
}

func (s *ThenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitThenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ThenExpression() (localctx IThenExpressionContext) {
	localctx = NewThenExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 462, TiDBParserRULE_thenExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4220)
		p.Match(TiDBParserTHEN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4221)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IElseExpressionContext is an interface to support dynamic dispatch.
type IElseExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ELSE_SYMBOL() antlr.TerminalNode
	Expr() IExprContext

	// IsElseExpressionContext differentiates from other interfaces.
	IsElseExpressionContext()
}

type ElseExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyElseExpressionContext() *ElseExpressionContext {
	var p = new(ElseExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_elseExpression
	return p
}

func InitEmptyElseExpressionContext(p *ElseExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_elseExpression
}

func (*ElseExpressionContext) IsElseExpressionContext() {}

func NewElseExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ElseExpressionContext {
	var p = new(ElseExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_elseExpression

	return p
}

func (s *ElseExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ElseExpressionContext) ELSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserELSE_SYMBOL, 0)
}

func (s *ElseExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ElseExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElseExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ElseExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterElseExpression(s)
	}
}

func (s *ElseExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitElseExpression(s)
	}
}

func (s *ElseExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitElseExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ElseExpression() (localctx IElseExpressionContext) {
	localctx = NewElseExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 464, TiDBParserRULE_elseExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4223)
		p.Match(TiDBParserELSE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4224)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICastTypeContext is an interface to support dynamic dispatch.
type ICastTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BINARY_SYMBOL() antlr.TerminalNode
	FieldLength() IFieldLengthContext
	CHAR_SYMBOL() antlr.TerminalNode
	CharsetWithOptBinary() ICharsetWithOptBinaryContext
	Nchar() INcharContext
	SIGNED_SYMBOL() antlr.TerminalNode
	INT_SYMBOL() antlr.TerminalNode
	UNSIGNED_SYMBOL() antlr.TerminalNode
	DATE_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TypeDatetimePrecision() ITypeDatetimePrecisionContext
	DATETIME_SYMBOL() antlr.TerminalNode
	DECIMAL_SYMBOL() antlr.TerminalNode
	FloatOptions() IFloatOptionsContext
	JSON_SYMBOL() antlr.TerminalNode
	RealType() IRealTypeContext
	FLOAT_SYMBOL() antlr.TerminalNode
	StandardFloatOptions() IStandardFloatOptionsContext

	// IsCastTypeContext differentiates from other interfaces.
	IsCastTypeContext()
}

type CastTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCastTypeContext() *CastTypeContext {
	var p = new(CastTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_castType
	return p
}

func InitEmptyCastTypeContext(p *CastTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_castType
}

func (*CastTypeContext) IsCastTypeContext() {}

func NewCastTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CastTypeContext {
	var p = new(CastTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_castType

	return p
}

func (s *CastTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *CastTypeContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *CastTypeContext) FieldLength() IFieldLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *CastTypeContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHAR_SYMBOL, 0)
}

func (s *CastTypeContext) CharsetWithOptBinary() ICharsetWithOptBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetWithOptBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetWithOptBinaryContext)
}

func (s *CastTypeContext) Nchar() INcharContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INcharContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INcharContext)
}

func (s *CastTypeContext) SIGNED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSIGNED_SYMBOL, 0)
}

func (s *CastTypeContext) INT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_SYMBOL, 0)
}

func (s *CastTypeContext) UNSIGNED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNSIGNED_SYMBOL, 0)
}

func (s *CastTypeContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATE_SYMBOL, 0)
}

func (s *CastTypeContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIME_SYMBOL, 0)
}

func (s *CastTypeContext) TypeDatetimePrecision() ITypeDatetimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDatetimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDatetimePrecisionContext)
}

func (s *CastTypeContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATETIME_SYMBOL, 0)
}

func (s *CastTypeContext) DECIMAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDECIMAL_SYMBOL, 0)
}

func (s *CastTypeContext) FloatOptions() IFloatOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatOptionsContext)
}

func (s *CastTypeContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_SYMBOL, 0)
}

func (s *CastTypeContext) RealType() IRealTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRealTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRealTypeContext)
}

func (s *CastTypeContext) FLOAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFLOAT_SYMBOL, 0)
}

func (s *CastTypeContext) StandardFloatOptions() IStandardFloatOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStandardFloatOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStandardFloatOptionsContext)
}

func (s *CastTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CastTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCastType(s)
	}
}

func (s *CastTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCastType(s)
	}
}

func (s *CastTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCastType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CastType() (localctx ICastTypeContext) {
	localctx = NewCastTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 466, TiDBParserRULE_castType)
	var _la int

	p.SetState(4268)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserBINARY_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4226)
			p.Match(TiDBParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4228)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4227)
				p.FieldLength()
			}

		}

	case TiDBParserCHAR_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4230)
			p.Match(TiDBParserCHAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4232)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4231)
				p.FieldLength()
			}

		}
		p.SetState(4235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4234)
				p.CharsetWithOptBinary()
			}

		}

	case TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4237)
			p.Nchar()
		}
		p.SetState(4239)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4238)
				p.FieldLength()
			}

		}

	case TiDBParserSIGNED_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4241)
			p.Match(TiDBParserSIGNED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4243)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserINT_SYMBOL {
			{
				p.SetState(4242)
				p.Match(TiDBParserINT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserUNSIGNED_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4245)
			p.Match(TiDBParserUNSIGNED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4247)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserINT_SYMBOL {
			{
				p.SetState(4246)
				p.Match(TiDBParserINT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserDATE_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4249)
			p.Match(TiDBParserDATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserTIME_SYMBOL:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4250)
			p.Match(TiDBParserTIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4252)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4251)
				p.TypeDatetimePrecision()
			}

		}

	case TiDBParserDATETIME_SYMBOL:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4254)
			p.Match(TiDBParserDATETIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4256)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4255)
				p.TypeDatetimePrecision()
			}

		}

	case TiDBParserDECIMAL_SYMBOL:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4258)
			p.Match(TiDBParserDECIMAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4260)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4259)
				p.FloatOptions()
			}

		}

	case TiDBParserJSON_SYMBOL:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4262)
			p.Match(TiDBParserJSON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserDOUBLE_SYMBOL, TiDBParserREAL_SYMBOL:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4263)
			p.RealType()
		}

	case TiDBParserFLOAT_SYMBOL:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4264)
			p.Match(TiDBParserFLOAT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4266)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4265)
				p.StandardFloatOptions()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListContext is an interface to support dynamic dispatch.
type IExprListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpr() []IExprContext
	Expr(i int) IExprContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsExprListContext differentiates from other interfaces.
	IsExprListContext()
}

type ExprListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListContext() *ExprListContext {
	var p = new(ExprListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_exprList
	return p
}

func InitEmptyExprListContext(p *ExprListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_exprList
}

func (*ExprListContext) IsExprListContext() {}

func NewExprListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListContext {
	var p = new(ExprListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_exprList

	return p
}

func (s *ExprListContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListContext) AllExpr() []IExprContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExprContext); ok {
			len++
		}
	}

	tst := make([]IExprContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExprContext); ok {
			tst[i] = t.(IExprContext)
			i++
		}
	}

	return tst
}

func (s *ExprListContext) Expr(i int) IExprContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ExprListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ExprListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExprList(s)
	}
}

func (s *ExprListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExprList(s)
	}
}

func (s *ExprListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExprList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ExprList() (localctx IExprListContext) {
	localctx = NewExprListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 468, TiDBParserRULE_exprList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4270)
		p.expr(0)
	}
	p.SetState(4275)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(4271)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4272)
			p.expr(0)
		}

		p.SetState(4277)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetContext is an interface to support dynamic dispatch.
type ICharsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CHAR_SYMBOL() antlr.TerminalNode
	SET_SYMBOL() antlr.TerminalNode
	CHARSET_SYMBOL() antlr.TerminalNode

	// IsCharsetContext differentiates from other interfaces.
	IsCharsetContext()
}

type CharsetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetContext() *CharsetContext {
	var p = new(CharsetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_charset
	return p
}

func InitEmptyCharsetContext(p *CharsetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_charset
}

func (*CharsetContext) IsCharsetContext() {}

func NewCharsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetContext {
	var p = new(CharsetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_charset

	return p
}

func (s *CharsetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHAR_SYMBOL, 0)
}

func (s *CharsetContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSET_SYMBOL, 0)
}

func (s *CharsetContext) CHARSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHARSET_SYMBOL, 0)
}

func (s *CharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCharset(s)
	}
}

func (s *CharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCharset(s)
	}
}

func (s *CharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Charset() (localctx ICharsetContext) {
	localctx = NewCharsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 470, TiDBParserRULE_charset)
	p.SetState(4281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCHAR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4278)
			p.Match(TiDBParserCHAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4279)
			p.Match(TiDBParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserCHARSET_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4280)
			p.Match(TiDBParserCHARSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INotRuleContext is an interface to support dynamic dispatch.
type INotRuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NOT_SYMBOL() antlr.TerminalNode
	NOT2_SYMBOL() antlr.TerminalNode

	// IsNotRuleContext differentiates from other interfaces.
	IsNotRuleContext()
}

type NotRuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNotRuleContext() *NotRuleContext {
	var p = new(NotRuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_notRule
	return p
}

func InitEmptyNotRuleContext(p *NotRuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_notRule
}

func (*NotRuleContext) IsNotRuleContext() {}

func NewNotRuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NotRuleContext {
	var p = new(NotRuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_notRule

	return p
}

func (s *NotRuleContext) GetParser() antlr.Parser { return s.parser }

func (s *NotRuleContext) NOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOT_SYMBOL, 0)
}

func (s *NotRuleContext) NOT2_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOT2_SYMBOL, 0)
}

func (s *NotRuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotRuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NotRuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterNotRule(s)
	}
}

func (s *NotRuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitNotRule(s)
	}
}

func (s *NotRuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitNotRule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) NotRule() (localctx INotRuleContext) {
	localctx = NewNotRuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 472, TiDBParserRULE_notRule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4283)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserNOT_SYMBOL || _la == TiDBParserNOT2_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INot2RuleContext is an interface to support dynamic dispatch.
type INot2RuleContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOGICAL_NOT_OPERATOR() antlr.TerminalNode
	NOT2_SYMBOL() antlr.TerminalNode

	// IsNot2RuleContext differentiates from other interfaces.
	IsNot2RuleContext()
}

type Not2RuleContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNot2RuleContext() *Not2RuleContext {
	var p = new(Not2RuleContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_not2Rule
	return p
}

func InitEmptyNot2RuleContext(p *Not2RuleContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_not2Rule
}

func (*Not2RuleContext) IsNot2RuleContext() {}

func NewNot2RuleContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Not2RuleContext {
	var p = new(Not2RuleContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_not2Rule

	return p
}

func (s *Not2RuleContext) GetParser() antlr.Parser { return s.parser }

func (s *Not2RuleContext) LOGICAL_NOT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOGICAL_NOT_OPERATOR, 0)
}

func (s *Not2RuleContext) NOT2_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOT2_SYMBOL, 0)
}

func (s *Not2RuleContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Not2RuleContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Not2RuleContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterNot2Rule(s)
	}
}

func (s *Not2RuleContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitNot2Rule(s)
	}
}

func (s *Not2RuleContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitNot2Rule(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Not2Rule() (localctx INot2RuleContext) {
	localctx = NewNot2RuleContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 474, TiDBParserRULE_not2Rule)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4285)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserNOT2_SYMBOL || _la == TiDBParserLOGICAL_NOT_OPERATOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalContext is an interface to support dynamic dispatch.
type IIntervalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IntervalTimeStamp() IIntervalTimeStampContext
	SECOND_MICROSECOND_SYMBOL() antlr.TerminalNode
	MINUTE_MICROSECOND_SYMBOL() antlr.TerminalNode
	MINUTE_SECOND_SYMBOL() antlr.TerminalNode
	HOUR_MICROSECOND_SYMBOL() antlr.TerminalNode
	HOUR_SECOND_SYMBOL() antlr.TerminalNode
	HOUR_MINUTE_SYMBOL() antlr.TerminalNode
	DAY_MICROSECOND_SYMBOL() antlr.TerminalNode
	DAY_SECOND_SYMBOL() antlr.TerminalNode
	DAY_MINUTE_SYMBOL() antlr.TerminalNode
	DAY_HOUR_SYMBOL() antlr.TerminalNode
	YEAR_MONTH_SYMBOL() antlr.TerminalNode

	// IsIntervalContext differentiates from other interfaces.
	IsIntervalContext()
}

type IntervalContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalContext() *IntervalContext {
	var p = new(IntervalContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_interval
	return p
}

func InitEmptyIntervalContext(p *IntervalContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_interval
}

func (*IntervalContext) IsIntervalContext() {}

func NewIntervalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalContext {
	var p = new(IntervalContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_interval

	return p
}

func (s *IntervalContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalContext) IntervalTimeStamp() IIntervalTimeStampContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTimeStampContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTimeStampContext)
}

func (s *IntervalContext) SECOND_MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECOND_MICROSECOND_SYMBOL, 0)
}

func (s *IntervalContext) MINUTE_MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUTE_MICROSECOND_SYMBOL, 0)
}

func (s *IntervalContext) MINUTE_SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUTE_SECOND_SYMBOL, 0)
}

func (s *IntervalContext) HOUR_MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOUR_MICROSECOND_SYMBOL, 0)
}

func (s *IntervalContext) HOUR_SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOUR_SECOND_SYMBOL, 0)
}

func (s *IntervalContext) HOUR_MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOUR_MINUTE_SYMBOL, 0)
}

func (s *IntervalContext) DAY_MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDAY_MICROSECOND_SYMBOL, 0)
}

func (s *IntervalContext) DAY_SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDAY_SECOND_SYMBOL, 0)
}

func (s *IntervalContext) DAY_MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDAY_MINUTE_SYMBOL, 0)
}

func (s *IntervalContext) DAY_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDAY_HOUR_SYMBOL, 0)
}

func (s *IntervalContext) YEAR_MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserYEAR_MONTH_SYMBOL, 0)
}

func (s *IntervalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterInterval(s)
	}
}

func (s *IntervalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitInterval(s)
	}
}

func (s *IntervalContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitInterval(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Interval() (localctx IIntervalContext) {
	localctx = NewIntervalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 476, TiDBParserRULE_interval)
	var _la int

	p.SetState(4289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserDAY_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserYEAR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4287)
			p.IntervalTimeStamp()
		}

	case TiDBParserDAY_HOUR_SYMBOL, TiDBParserDAY_MICROSECOND_SYMBOL, TiDBParserDAY_MINUTE_SYMBOL, TiDBParserDAY_SECOND_SYMBOL, TiDBParserHOUR_MICROSECOND_SYMBOL, TiDBParserHOUR_MINUTE_SYMBOL, TiDBParserHOUR_SECOND_SYMBOL, TiDBParserMINUTE_MICROSECOND_SYMBOL, TiDBParserMINUTE_SECOND_SYMBOL, TiDBParserSECOND_MICROSECOND_SYMBOL, TiDBParserYEAR_MONTH_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4288)
			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-118)) & ^0x3f) == 0 && ((int64(1)<<(_la-118))&15) != 0) || ((int64((_la-226)) & ^0x3f) == 0 && ((int64(1)<<(_la-226))&7) != 0) || _la == TiDBParserMINUTE_MICROSECOND_SYMBOL || _la == TiDBParserMINUTE_SECOND_SYMBOL || _la == TiDBParserSECOND_MICROSECOND_SYMBOL || _la == TiDBParserYEAR_MONTH_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIntervalTimeStampContext is an interface to support dynamic dispatch.
type IIntervalTimeStampContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	MICROSECOND_SYMBOL() antlr.TerminalNode
	SECOND_SYMBOL() antlr.TerminalNode
	MINUTE_SYMBOL() antlr.TerminalNode
	HOUR_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	WEEK_SYMBOL() antlr.TerminalNode
	MONTH_SYMBOL() antlr.TerminalNode
	QUARTER_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode

	// IsIntervalTimeStampContext differentiates from other interfaces.
	IsIntervalTimeStampContext()
}

type IntervalTimeStampContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTimeStampContext() *IntervalTimeStampContext {
	var p = new(IntervalTimeStampContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_intervalTimeStamp
	return p
}

func InitEmptyIntervalTimeStampContext(p *IntervalTimeStampContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_intervalTimeStamp
}

func (*IntervalTimeStampContext) IsIntervalTimeStampContext() {}

func NewIntervalTimeStampContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTimeStampContext {
	var p = new(IntervalTimeStampContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_intervalTimeStamp

	return p
}

func (s *IntervalTimeStampContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTimeStampContext) MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMICROSECOND_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECOND_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUTE_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOUR_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDAY_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) WEEK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWEEK_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMONTH_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) QUARTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUARTER_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserYEAR_SYMBOL, 0)
}

func (s *IntervalTimeStampContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTimeStampContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IntervalTimeStampContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIntervalTimeStamp(s)
	}
}

func (s *IntervalTimeStampContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIntervalTimeStamp(s)
	}
}

func (s *IntervalTimeStampContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIntervalTimeStamp(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IntervalTimeStamp() (localctx IIntervalTimeStampContext) {
	localctx = NewIntervalTimeStampContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 478, TiDBParserRULE_intervalTimeStamp)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4291)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserDAY_SYMBOL || _la == TiDBParserHOUR_SYMBOL || ((int64((_la-337)) & ^0x3f) == 0 && ((int64(1)<<(_la-337))&8257) != 0) || _la == TiDBParserQUARTER_SYMBOL || _la == TiDBParserSECOND_SYMBOL || _la == TiDBParserWEEK_SYMBOL || _la == TiDBParserYEAR_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprListWithParenthesesContext is an interface to support dynamic dispatch.
type IExprListWithParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	ExprList() IExprListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsExprListWithParenthesesContext differentiates from other interfaces.
	IsExprListWithParenthesesContext()
}

type ExprListWithParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprListWithParenthesesContext() *ExprListWithParenthesesContext {
	var p = new(ExprListWithParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_exprListWithParentheses
	return p
}

func InitEmptyExprListWithParenthesesContext(p *ExprListWithParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_exprListWithParentheses
}

func (*ExprListWithParenthesesContext) IsExprListWithParenthesesContext() {}

func NewExprListWithParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprListWithParenthesesContext {
	var p = new(ExprListWithParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_exprListWithParentheses

	return p
}

func (s *ExprListWithParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprListWithParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *ExprListWithParenthesesContext) ExprList() IExprListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprListContext)
}

func (s *ExprListWithParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ExprListWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprListWithParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprListWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExprListWithParentheses(s)
	}
}

func (s *ExprListWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExprListWithParentheses(s)
	}
}

func (s *ExprListWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExprListWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ExprListWithParentheses() (localctx IExprListWithParenthesesContext) {
	localctx = NewExprListWithParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 480, TiDBParserRULE_exprListWithParentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4293)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4294)
		p.ExprList()
	}
	{
		p.SetState(4295)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IExprWithParenthesesContext is an interface to support dynamic dispatch.
type IExprWithParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Expr() IExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsExprWithParenthesesContext differentiates from other interfaces.
	IsExprWithParenthesesContext()
}

type ExprWithParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExprWithParenthesesContext() *ExprWithParenthesesContext {
	var p = new(ExprWithParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_exprWithParentheses
	return p
}

func InitEmptyExprWithParenthesesContext(p *ExprWithParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_exprWithParentheses
}

func (*ExprWithParenthesesContext) IsExprWithParenthesesContext() {}

func NewExprWithParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExprWithParenthesesContext {
	var p = new(ExprWithParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_exprWithParentheses

	return p
}

func (s *ExprWithParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *ExprWithParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *ExprWithParenthesesContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *ExprWithParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ExprWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExprWithParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ExprWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterExprWithParentheses(s)
	}
}

func (s *ExprWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitExprWithParentheses(s)
	}
}

func (s *ExprWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitExprWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ExprWithParentheses() (localctx IExprWithParenthesesContext) {
	localctx = NewExprWithParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 482, TiDBParserRULE_exprWithParentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4297)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4298)
		p.expr(0)
	}
	{
		p.SetState(4299)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleExprWithParenthesesContext is an interface to support dynamic dispatch.
type ISimpleExprWithParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	SimpleExpr() ISimpleExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsSimpleExprWithParenthesesContext differentiates from other interfaces.
	IsSimpleExprWithParenthesesContext()
}

type SimpleExprWithParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleExprWithParenthesesContext() *SimpleExprWithParenthesesContext {
	var p = new(SimpleExprWithParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_simpleExprWithParentheses
	return p
}

func InitEmptySimpleExprWithParenthesesContext(p *SimpleExprWithParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_simpleExprWithParentheses
}

func (*SimpleExprWithParenthesesContext) IsSimpleExprWithParenthesesContext() {}

func NewSimpleExprWithParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleExprWithParenthesesContext {
	var p = new(SimpleExprWithParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_simpleExprWithParentheses

	return p
}

func (s *SimpleExprWithParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleExprWithParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SimpleExprWithParenthesesContext) SimpleExpr() ISimpleExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleExprContext)
}

func (s *SimpleExprWithParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SimpleExprWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleExprWithParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleExprWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleExprWithParentheses(s)
	}
}

func (s *SimpleExprWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleExprWithParentheses(s)
	}
}

func (s *SimpleExprWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleExprWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SimpleExprWithParentheses() (localctx ISimpleExprWithParenthesesContext) {
	localctx = NewSimpleExprWithParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 484, TiDBParserRULE_simpleExprWithParentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4301)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4302)
		p.simpleExpr(0)
	}
	{
		p.SetState(4303)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderListContext is an interface to support dynamic dispatch.
type IOrderListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllOrderExpression() []IOrderExpressionContext
	OrderExpression(i int) IOrderExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsOrderListContext differentiates from other interfaces.
	IsOrderListContext()
}

type OrderListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderListContext() *OrderListContext {
	var p = new(OrderListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_orderList
	return p
}

func InitEmptyOrderListContext(p *OrderListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_orderList
}

func (*OrderListContext) IsOrderListContext() {}

func NewOrderListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderListContext {
	var p = new(OrderListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_orderList

	return p
}

func (s *OrderListContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderListContext) AllOrderExpression() []IOrderExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOrderExpressionContext); ok {
			len++
		}
	}

	tst := make([]IOrderExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOrderExpressionContext); ok {
			tst[i] = t.(IOrderExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrderListContext) OrderExpression(i int) IOrderExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOrderExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOrderExpressionContext)
}

func (s *OrderListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *OrderListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *OrderListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOrderList(s)
	}
}

func (s *OrderListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOrderList(s)
	}
}

func (s *OrderListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOrderList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OrderList() (localctx IOrderListContext) {
	localctx = NewOrderListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 486, TiDBParserRULE_orderList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4305)
		p.OrderExpression()
	}
	p.SetState(4310)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(4306)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4307)
			p.OrderExpression()
		}

		p.SetState(4312)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOrderExpressionContext is an interface to support dynamic dispatch.
type IOrderExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext
	Direction() IDirectionContext

	// IsOrderExpressionContext differentiates from other interfaces.
	IsOrderExpressionContext()
}

type OrderExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOrderExpressionContext() *OrderExpressionContext {
	var p = new(OrderExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_orderExpression
	return p
}

func InitEmptyOrderExpressionContext(p *OrderExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_orderExpression
}

func (*OrderExpressionContext) IsOrderExpressionContext() {}

func NewOrderExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OrderExpressionContext {
	var p = new(OrderExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_orderExpression

	return p
}

func (s *OrderExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *OrderExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *OrderExpressionContext) Direction() IDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionContext)
}

func (s *OrderExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrderExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OrderExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOrderExpression(s)
	}
}

func (s *OrderExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOrderExpression(s)
	}
}

func (s *OrderExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOrderExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OrderExpression() (localctx IOrderExpressionContext) {
	localctx = NewOrderExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 488, TiDBParserRULE_orderExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4313)
		p.expr(0)
	}
	p.SetState(4315)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserASC_SYMBOL || _la == TiDBParserDESC_SYMBOL {
		{
			p.SetState(4314)
			p.Direction()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupListContext is an interface to support dynamic dispatch.
type IGroupListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllGroupingExpression() []IGroupingExpressionContext
	GroupingExpression(i int) IGroupingExpressionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsGroupListContext differentiates from other interfaces.
	IsGroupListContext()
}

type GroupListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupListContext() *GroupListContext {
	var p = new(GroupListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupList
	return p
}

func InitEmptyGroupListContext(p *GroupListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupList
}

func (*GroupListContext) IsGroupListContext() {}

func NewGroupListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupListContext {
	var p = new(GroupListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_groupList

	return p
}

func (s *GroupListContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupListContext) AllGroupingExpression() []IGroupingExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IGroupingExpressionContext); ok {
			len++
		}
	}

	tst := make([]IGroupingExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IGroupingExpressionContext); ok {
			tst[i] = t.(IGroupingExpressionContext)
			i++
		}
	}

	return tst
}

func (s *GroupListContext) GroupingExpression(i int) IGroupingExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IGroupingExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IGroupingExpressionContext)
}

func (s *GroupListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *GroupListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *GroupListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGroupList(s)
	}
}

func (s *GroupListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGroupList(s)
	}
}

func (s *GroupListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGroupList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GroupList() (localctx IGroupListContext) {
	localctx = NewGroupListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 490, TiDBParserRULE_groupList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4317)
		p.GroupingExpression()
	}
	p.SetState(4322)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(4318)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4319)
			p.GroupingExpression()
		}

		p.SetState(4324)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGroupingExpressionContext is an interface to support dynamic dispatch.
type IGroupingExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expr() IExprContext

	// IsGroupingExpressionContext differentiates from other interfaces.
	IsGroupingExpressionContext()
}

type GroupingExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupingExpressionContext() *GroupingExpressionContext {
	var p = new(GroupingExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupingExpression
	return p
}

func InitEmptyGroupingExpressionContext(p *GroupingExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_groupingExpression
}

func (*GroupingExpressionContext) IsGroupingExpressionContext() {}

func NewGroupingExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupingExpressionContext {
	var p = new(GroupingExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_groupingExpression

	return p
}

func (s *GroupingExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupingExpressionContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *GroupingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupingExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupingExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGroupingExpression(s)
	}
}

func (s *GroupingExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGroupingExpression(s)
	}
}

func (s *GroupingExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGroupingExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GroupingExpression() (localctx IGroupingExpressionContext) {
	localctx = NewGroupingExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 492, TiDBParserRULE_groupingExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4325)
		p.expr(0)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IChannelContext is an interface to support dynamic dispatch.
type IChannelContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FOR_SYMBOL() antlr.TerminalNode
	CHANNEL_SYMBOL() antlr.TerminalNode
	TextStringNoLinebreak() ITextStringNoLinebreakContext

	// IsChannelContext differentiates from other interfaces.
	IsChannelContext()
}

type ChannelContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChannelContext() *ChannelContext {
	var p = new(ChannelContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_channel
	return p
}

func InitEmptyChannelContext(p *ChannelContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_channel
}

func (*ChannelContext) IsChannelContext() {}

func NewChannelContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChannelContext {
	var p = new(ChannelContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_channel

	return p
}

func (s *ChannelContext) GetParser() antlr.Parser { return s.parser }

func (s *ChannelContext) FOR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOR_SYMBOL, 0)
}

func (s *ChannelContext) CHANNEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHANNEL_SYMBOL, 0)
}

func (s *ChannelContext) TextStringNoLinebreak() ITextStringNoLinebreakContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringNoLinebreakContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringNoLinebreakContext)
}

func (s *ChannelContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChannelContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ChannelContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterChannel(s)
	}
}

func (s *ChannelContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitChannel(s)
	}
}

func (s *ChannelContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitChannel(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Channel() (localctx IChannelContext) {
	localctx = NewChannelContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 494, TiDBParserRULE_channel)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4327)
		p.Match(TiDBParserFOR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4328)
		p.Match(TiDBParserCHANNEL_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4329)
		p.TextStringNoLinebreak()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnFormatContext is an interface to support dynamic dispatch.
type IColumnFormatContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FIXED_SYMBOL() antlr.TerminalNode
	DYNAMIC_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsColumnFormatContext differentiates from other interfaces.
	IsColumnFormatContext()
}

type ColumnFormatContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnFormatContext() *ColumnFormatContext {
	var p = new(ColumnFormatContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnFormat
	return p
}

func InitEmptyColumnFormatContext(p *ColumnFormatContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnFormat
}

func (*ColumnFormatContext) IsColumnFormatContext() {}

func NewColumnFormatContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnFormatContext {
	var p = new(ColumnFormatContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_columnFormat

	return p
}

func (s *ColumnFormatContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnFormatContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIXED_SYMBOL, 0)
}

func (s *ColumnFormatContext) DYNAMIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDYNAMIC_SYMBOL, 0)
}

func (s *ColumnFormatContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *ColumnFormatContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnFormatContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnFormatContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterColumnFormat(s)
	}
}

func (s *ColumnFormatContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitColumnFormat(s)
	}
}

func (s *ColumnFormatContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitColumnFormat(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ColumnFormat() (localctx IColumnFormatContext) {
	localctx = NewColumnFormatContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 496, TiDBParserRULE_columnFormat)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4331)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserDYNAMIC_SYMBOL || _la == TiDBParserFIXED_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStorageMediaContext is an interface to support dynamic dispatch.
type IStorageMediaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISK_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsStorageMediaContext differentiates from other interfaces.
	IsStorageMediaContext()
}

type StorageMediaContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStorageMediaContext() *StorageMediaContext {
	var p = new(StorageMediaContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_storageMedia
	return p
}

func InitEmptyStorageMediaContext(p *StorageMediaContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_storageMedia
}

func (*StorageMediaContext) IsStorageMediaContext() {}

func NewStorageMediaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StorageMediaContext {
	var p = new(StorageMediaContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_storageMedia

	return p
}

func (s *StorageMediaContext) GetParser() antlr.Parser { return s.parser }

func (s *StorageMediaContext) DISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISK_SYMBOL, 0)
}

func (s *StorageMediaContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEMORY_SYMBOL, 0)
}

func (s *StorageMediaContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *StorageMediaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StorageMediaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StorageMediaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterStorageMedia(s)
	}
}

func (s *StorageMediaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitStorageMedia(s)
	}
}

func (s *StorageMediaContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitStorageMedia(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) StorageMedia() (localctx IStorageMediaContext) {
	localctx = NewStorageMediaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 498, TiDBParserRULE_storageMedia)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4333)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserDEFAULT_SYMBOL || _la == TiDBParserDISK_SYMBOL || _la == TiDBParserMEMORY_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IGcolAttributeContext is an interface to support dynamic dispatch.
type IGcolAttributeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNIQUE_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	NULL_SYMBOL() antlr.TerminalNode
	NotRule() INotRuleContext
	PRIMARY_SYMBOL() antlr.TerminalNode

	// IsGcolAttributeContext differentiates from other interfaces.
	IsGcolAttributeContext()
}

type GcolAttributeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGcolAttributeContext() *GcolAttributeContext {
	var p = new(GcolAttributeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_gcolAttribute
	return p
}

func InitEmptyGcolAttributeContext(p *GcolAttributeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_gcolAttribute
}

func (*GcolAttributeContext) IsGcolAttributeContext() {}

func NewGcolAttributeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GcolAttributeContext {
	var p = new(GcolAttributeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_gcolAttribute

	return p
}

func (s *GcolAttributeContext) GetParser() antlr.Parser { return s.parser }

func (s *GcolAttributeContext) UNIQUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNIQUE_SYMBOL, 0)
}

func (s *GcolAttributeContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_SYMBOL, 0)
}

func (s *GcolAttributeContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMENT_SYMBOL, 0)
}

func (s *GcolAttributeContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *GcolAttributeContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL_SYMBOL, 0)
}

func (s *GcolAttributeContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *GcolAttributeContext) PRIMARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIMARY_SYMBOL, 0)
}

func (s *GcolAttributeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GcolAttributeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GcolAttributeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterGcolAttribute(s)
	}
}

func (s *GcolAttributeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitGcolAttribute(s)
	}
}

func (s *GcolAttributeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitGcolAttribute(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) GcolAttribute() (localctx IGcolAttributeContext) {
	localctx = NewGcolAttributeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 500, TiDBParserRULE_gcolAttribute)
	var _la int

	p.SetState(4349)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserUNIQUE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4335)
			p.Match(TiDBParserUNIQUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4337)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserKEY_SYMBOL {
			{
				p.SetState(4336)
				p.Match(TiDBParserKEY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserCOMMENT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4339)
			p.Match(TiDBParserCOMMENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4340)
			p.TextString()
		}

	case TiDBParserNOT_SYMBOL, TiDBParserNULL_SYMBOL, TiDBParserNOT2_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		p.SetState(4342)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserNOT_SYMBOL || _la == TiDBParserNOT2_SYMBOL {
			{
				p.SetState(4341)
				p.NotRule()
			}

		}
		{
			p.SetState(4344)
			p.Match(TiDBParserNULL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserKEY_SYMBOL, TiDBParserPRIMARY_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		p.SetState(4346)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserPRIMARY_SYMBOL {
			{
				p.SetState(4345)
				p.Match(TiDBParserPRIMARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4348)
			p.Match(TiDBParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReferencesContext is an interface to support dynamic dispatch.
type IReferencesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetMatch returns the match token.
	GetMatch() antlr.Token

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetMatch sets the match token.
	SetMatch(antlr.Token)

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	REFERENCES_SYMBOL() antlr.TerminalNode
	TableRef() ITableRefContext
	IdentifierListWithParentheses() IIdentifierListWithParenthesesContext
	MATCH_SYMBOL() antlr.TerminalNode
	AllON_SYMBOL() []antlr.TerminalNode
	ON_SYMBOL(i int) antlr.TerminalNode
	AllDeleteOption() []IDeleteOptionContext
	DeleteOption(i int) IDeleteOptionContext
	UPDATE_SYMBOL() antlr.TerminalNode
	DELETE_SYMBOL() antlr.TerminalNode
	FULL_SYMBOL() antlr.TerminalNode
	PARTIAL_SYMBOL() antlr.TerminalNode
	SIMPLE_SYMBOL() antlr.TerminalNode

	// IsReferencesContext differentiates from other interfaces.
	IsReferencesContext()
}

type ReferencesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	match  antlr.Token
	option antlr.Token
}

func NewEmptyReferencesContext() *ReferencesContext {
	var p = new(ReferencesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_references
	return p
}

func InitEmptyReferencesContext(p *ReferencesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_references
}

func (*ReferencesContext) IsReferencesContext() {}

func NewReferencesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferencesContext {
	var p = new(ReferencesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_references

	return p
}

func (s *ReferencesContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferencesContext) GetMatch() antlr.Token { return s.match }

func (s *ReferencesContext) GetOption() antlr.Token { return s.option }

func (s *ReferencesContext) SetMatch(v antlr.Token) { s.match = v }

func (s *ReferencesContext) SetOption(v antlr.Token) { s.option = v }

func (s *ReferencesContext) REFERENCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREFERENCES_SYMBOL, 0)
}

func (s *ReferencesContext) TableRef() ITableRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *ReferencesContext) IdentifierListWithParentheses() IIdentifierListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListWithParenthesesContext)
}

func (s *ReferencesContext) MATCH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMATCH_SYMBOL, 0)
}

func (s *ReferencesContext) AllON_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserON_SYMBOL)
}

func (s *ReferencesContext) ON_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserON_SYMBOL, i)
}

func (s *ReferencesContext) AllDeleteOption() []IDeleteOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDeleteOptionContext); ok {
			len++
		}
	}

	tst := make([]IDeleteOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDeleteOptionContext); ok {
			tst[i] = t.(IDeleteOptionContext)
			i++
		}
	}

	return tst
}

func (s *ReferencesContext) DeleteOption(i int) IDeleteOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDeleteOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDeleteOptionContext)
}

func (s *ReferencesContext) UPDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUPDATE_SYMBOL, 0)
}

func (s *ReferencesContext) DELETE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDELETE_SYMBOL, 0)
}

func (s *ReferencesContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFULL_SYMBOL, 0)
}

func (s *ReferencesContext) PARTIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTIAL_SYMBOL, 0)
}

func (s *ReferencesContext) SIMPLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSIMPLE_SYMBOL, 0)
}

func (s *ReferencesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferencesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReferencesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterReferences(s)
	}
}

func (s *ReferencesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitReferences(s)
	}
}

func (s *ReferencesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitReferences(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) References() (localctx IReferencesContext) {
	localctx = NewReferencesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 502, TiDBParserRULE_references)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4351)
		p.Match(TiDBParserREFERENCES_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4352)
		p.TableRef()
	}
	p.SetState(4354)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserOPEN_PAR_SYMBOL {
		{
			p.SetState(4353)
			p.IdentifierListWithParentheses()
		}

	}
	p.SetState(4358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserMATCH_SYMBOL {
		{
			p.SetState(4356)
			p.Match(TiDBParserMATCH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4357)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ReferencesContext).match = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserFULL_SYMBOL || _la == TiDBParserPARTIAL_SYMBOL || _la == TiDBParserSIMPLE_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ReferencesContext).match = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	p.SetState(4376)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 550, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4360)
			p.Match(TiDBParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4361)

			var _m = p.Match(TiDBParserUPDATE_SYMBOL)

			localctx.(*ReferencesContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4362)
			p.DeleteOption()
		}
		p.SetState(4366)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 548, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4363)
				p.Match(TiDBParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4364)
				p.Match(TiDBParserDELETE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4365)
				p.DeleteOption()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 550, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4368)
			p.Match(TiDBParserON_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4369)

			var _m = p.Match(TiDBParserDELETE_SYMBOL)

			localctx.(*ReferencesContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4370)
			p.DeleteOption()
		}
		p.SetState(4374)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 549, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4371)
				p.Match(TiDBParserON_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4372)
				p.Match(TiDBParserUPDATE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4373)
				p.DeleteOption()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDeleteOptionContext is an interface to support dynamic dispatch.
type IDeleteOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RESTRICT_SYMBOL() antlr.TerminalNode
	CASCADE_SYMBOL() antlr.TerminalNode
	SET_SYMBOL() antlr.TerminalNode
	NullLiteral() INullLiteralContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	ACTION_SYMBOL() antlr.TerminalNode

	// IsDeleteOptionContext differentiates from other interfaces.
	IsDeleteOptionContext()
}

type DeleteOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDeleteOptionContext() *DeleteOptionContext {
	var p = new(DeleteOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_deleteOption
	return p
}

func InitEmptyDeleteOptionContext(p *DeleteOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_deleteOption
}

func (*DeleteOptionContext) IsDeleteOptionContext() {}

func NewDeleteOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DeleteOptionContext {
	var p = new(DeleteOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_deleteOption

	return p
}

func (s *DeleteOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DeleteOptionContext) RESTRICT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESTRICT_SYMBOL, 0)
}

func (s *DeleteOptionContext) CASCADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCASCADE_SYMBOL, 0)
}

func (s *DeleteOptionContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSET_SYMBOL, 0)
}

func (s *DeleteOptionContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *DeleteOptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *DeleteOptionContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_SYMBOL, 0)
}

func (s *DeleteOptionContext) ACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserACTION_SYMBOL, 0)
}

func (s *DeleteOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DeleteOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DeleteOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDeleteOption(s)
	}
}

func (s *DeleteOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDeleteOption(s)
	}
}

func (s *DeleteOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDeleteOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DeleteOption() (localctx IDeleteOptionContext) {
	localctx = NewDeleteOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 504, TiDBParserRULE_deleteOption)
	var _la int

	p.SetState(4385)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 551, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4378)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserCASCADE_SYMBOL || _la == TiDBParserRESTRICT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4379)
			p.Match(TiDBParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4380)
			p.NullLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4381)
			p.Match(TiDBParserSET_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4382)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4383)
			p.Match(TiDBParserNO_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4384)
			p.Match(TiDBParserACTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyListContext is an interface to support dynamic dispatch.
type IKeyListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllKeyPart() []IKeyPartContext
	KeyPart(i int) IKeyPartContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsKeyListContext differentiates from other interfaces.
	IsKeyListContext()
}

type KeyListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyListContext() *KeyListContext {
	var p = new(KeyListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyList
	return p
}

func InitEmptyKeyListContext(p *KeyListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyList
}

func (*KeyListContext) IsKeyListContext() {}

func NewKeyListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyListContext {
	var p = new(KeyListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_keyList

	return p
}

func (s *KeyListContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *KeyListContext) AllKeyPart() []IKeyPartContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyPartContext); ok {
			len++
		}
	}

	tst := make([]IKeyPartContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyPartContext); ok {
			tst[i] = t.(IKeyPartContext)
			i++
		}
	}

	return tst
}

func (s *KeyListContext) KeyPart(i int) IKeyPartContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartContext)
}

func (s *KeyListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *KeyListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *KeyListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *KeyListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterKeyList(s)
	}
}

func (s *KeyListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitKeyList(s)
	}
}

func (s *KeyListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitKeyList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) KeyList() (localctx IKeyListContext) {
	localctx = NewKeyListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 506, TiDBParserRULE_keyList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4387)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4388)
		p.KeyPart()
	}
	p.SetState(4393)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(4389)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4390)
			p.KeyPart()
		}

		p.SetState(4395)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4396)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartContext is an interface to support dynamic dispatch.
type IKeyPartContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FieldLength() IFieldLengthContext
	Direction() IDirectionContext

	// IsKeyPartContext differentiates from other interfaces.
	IsKeyPartContext()
}

type KeyPartContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartContext() *KeyPartContext {
	var p = new(KeyPartContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyPart
	return p
}

func InitEmptyKeyPartContext(p *KeyPartContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyPart
}

func (*KeyPartContext) IsKeyPartContext() {}

func NewKeyPartContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartContext {
	var p = new(KeyPartContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_keyPart

	return p
}

func (s *KeyPartContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *KeyPartContext) FieldLength() IFieldLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *KeyPartContext) Direction() IDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionContext)
}

func (s *KeyPartContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterKeyPart(s)
	}
}

func (s *KeyPartContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitKeyPart(s)
	}
}

func (s *KeyPartContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitKeyPart(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) KeyPart() (localctx IKeyPartContext) {
	localctx = NewKeyPartContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 508, TiDBParserRULE_keyPart)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4398)
		p.Identifier()
	}
	p.SetState(4400)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserOPEN_PAR_SYMBOL {
		{
			p.SetState(4399)
			p.FieldLength()
		}

	}
	p.SetState(4403)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserASC_SYMBOL || _la == TiDBParserDESC_SYMBOL {
		{
			p.SetState(4402)
			p.Direction()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyListWithExpressionContext is an interface to support dynamic dispatch.
type IKeyListWithExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllKeyPartOrExpression() []IKeyPartOrExpressionContext
	KeyPartOrExpression(i int) IKeyPartOrExpressionContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsKeyListWithExpressionContext differentiates from other interfaces.
	IsKeyListWithExpressionContext()
}

type KeyListWithExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyListWithExpressionContext() *KeyListWithExpressionContext {
	var p = new(KeyListWithExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyListWithExpression
	return p
}

func InitEmptyKeyListWithExpressionContext(p *KeyListWithExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyListWithExpression
}

func (*KeyListWithExpressionContext) IsKeyListWithExpressionContext() {}

func NewKeyListWithExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyListWithExpressionContext {
	var p = new(KeyListWithExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_keyListWithExpression

	return p
}

func (s *KeyListWithExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyListWithExpressionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *KeyListWithExpressionContext) AllKeyPartOrExpression() []IKeyPartOrExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IKeyPartOrExpressionContext); ok {
			len++
		}
	}

	tst := make([]IKeyPartOrExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IKeyPartOrExpressionContext); ok {
			tst[i] = t.(IKeyPartOrExpressionContext)
			i++
		}
	}

	return tst
}

func (s *KeyListWithExpressionContext) KeyPartOrExpression(i int) IKeyPartOrExpressionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartOrExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartOrExpressionContext)
}

func (s *KeyListWithExpressionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *KeyListWithExpressionContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *KeyListWithExpressionContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *KeyListWithExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyListWithExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyListWithExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterKeyListWithExpression(s)
	}
}

func (s *KeyListWithExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitKeyListWithExpression(s)
	}
}

func (s *KeyListWithExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitKeyListWithExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) KeyListWithExpression() (localctx IKeyListWithExpressionContext) {
	localctx = NewKeyListWithExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 510, TiDBParserRULE_keyListWithExpression)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4405)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4406)
		p.KeyPartOrExpression()
	}
	p.SetState(4411)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(4407)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4408)
			p.KeyPartOrExpression()
		}

		p.SetState(4413)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4414)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyPartOrExpressionContext is an interface to support dynamic dispatch.
type IKeyPartOrExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KeyPart() IKeyPartContext
	ExprWithParentheses() IExprWithParenthesesContext
	Direction() IDirectionContext

	// IsKeyPartOrExpressionContext differentiates from other interfaces.
	IsKeyPartOrExpressionContext()
}

type KeyPartOrExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyPartOrExpressionContext() *KeyPartOrExpressionContext {
	var p = new(KeyPartOrExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyPartOrExpression
	return p
}

func InitEmptyKeyPartOrExpressionContext(p *KeyPartOrExpressionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyPartOrExpression
}

func (*KeyPartOrExpressionContext) IsKeyPartOrExpressionContext() {}

func NewKeyPartOrExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyPartOrExpressionContext {
	var p = new(KeyPartOrExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_keyPartOrExpression

	return p
}

func (s *KeyPartOrExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyPartOrExpressionContext) KeyPart() IKeyPartContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyPartContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyPartContext)
}

func (s *KeyPartOrExpressionContext) ExprWithParentheses() IExprWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprWithParenthesesContext)
}

func (s *KeyPartOrExpressionContext) Direction() IDirectionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDirectionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDirectionContext)
}

func (s *KeyPartOrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyPartOrExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyPartOrExpressionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterKeyPartOrExpression(s)
	}
}

func (s *KeyPartOrExpressionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitKeyPartOrExpression(s)
	}
}

func (s *KeyPartOrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitKeyPartOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) KeyPartOrExpression() (localctx IKeyPartOrExpressionContext) {
	localctx = NewKeyPartOrExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 512, TiDBParserRULE_keyPartOrExpression)
	var _la int

	p.SetState(4421)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4416)
			p.KeyPart()
		}

	case TiDBParserOPEN_PAR_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4417)
			p.ExprWithParentheses()
		}
		p.SetState(4419)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserASC_SYMBOL || _la == TiDBParserDESC_SYMBOL {
			{
				p.SetState(4418)
				p.Direction()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IKeyListVariantsContext is an interface to support dynamic dispatch.
type IKeyListVariantsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KeyListWithExpression() IKeyListWithExpressionContext
	KeyList() IKeyListContext

	// IsKeyListVariantsContext differentiates from other interfaces.
	IsKeyListVariantsContext()
}

type KeyListVariantsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeyListVariantsContext() *KeyListVariantsContext {
	var p = new(KeyListVariantsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyListVariants
	return p
}

func InitEmptyKeyListVariantsContext(p *KeyListVariantsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_keyListVariants
}

func (*KeyListVariantsContext) IsKeyListVariantsContext() {}

func NewKeyListVariantsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeyListVariantsContext {
	var p = new(KeyListVariantsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_keyListVariants

	return p
}

func (s *KeyListVariantsContext) GetParser() antlr.Parser { return s.parser }

func (s *KeyListVariantsContext) KeyListWithExpression() IKeyListWithExpressionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyListWithExpressionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyListWithExpressionContext)
}

func (s *KeyListVariantsContext) KeyList() IKeyListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeyListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeyListContext)
}

func (s *KeyListVariantsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeyListVariantsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *KeyListVariantsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterKeyListVariants(s)
	}
}

func (s *KeyListVariantsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitKeyListVariants(s)
	}
}

func (s *KeyListVariantsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitKeyListVariants(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) KeyListVariants() (localctx IKeyListVariantsContext) {
	localctx = NewKeyListVariantsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 514, TiDBParserRULE_keyListVariants)
	p.SetState(4425)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 558, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4423)
			p.KeyListWithExpression()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4424)
			p.KeyList()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeContext is an interface to support dynamic dispatch.
type IIndexTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetAlgorithm returns the algorithm token.
	GetAlgorithm() antlr.Token

	// SetAlgorithm sets the algorithm token.
	SetAlgorithm(antlr.Token)

	// Getter signatures
	BTREE_SYMBOL() antlr.TerminalNode
	RTREE_SYMBOL() antlr.TerminalNode
	HASH_SYMBOL() antlr.TerminalNode

	// IsIndexTypeContext differentiates from other interfaces.
	IsIndexTypeContext()
}

type IndexTypeContext struct {
	antlr.BaseParserRuleContext
	parser    antlr.Parser
	algorithm antlr.Token
}

func NewEmptyIndexTypeContext() *IndexTypeContext {
	var p = new(IndexTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexType
	return p
}

func InitEmptyIndexTypeContext(p *IndexTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexType
}

func (*IndexTypeContext) IsIndexTypeContext() {}

func NewIndexTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeContext {
	var p = new(IndexTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexType

	return p
}

func (s *IndexTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeContext) GetAlgorithm() antlr.Token { return s.algorithm }

func (s *IndexTypeContext) SetAlgorithm(v antlr.Token) { s.algorithm = v }

func (s *IndexTypeContext) BTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBTREE_SYMBOL, 0)
}

func (s *IndexTypeContext) RTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRTREE_SYMBOL, 0)
}

func (s *IndexTypeContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHASH_SYMBOL, 0)
}

func (s *IndexTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexType(s)
	}
}

func (s *IndexTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexType(s)
	}
}

func (s *IndexTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexType() (localctx IIndexTypeContext) {
	localctx = NewIndexTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 516, TiDBParserRULE_indexType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4427)

		var _lt = p.GetTokenStream().LT(1)

		localctx.(*IndexTypeContext).algorithm = _lt

		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserBTREE_SYMBOL || _la == TiDBParserHASH_SYMBOL || _la == TiDBParserRTREE_SYMBOL) {
			var _ri = p.GetErrorHandler().RecoverInline(p)

			localctx.(*IndexTypeContext).algorithm = _ri
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexOptionContext is an interface to support dynamic dispatch.
type IIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommonIndexOption() ICommonIndexOptionContext
	IndexTypeClause() IIndexTypeClauseContext

	// IsIndexOptionContext differentiates from other interfaces.
	IsIndexOptionContext()
}

type IndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexOptionContext() *IndexOptionContext {
	var p = new(IndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexOption
	return p
}

func InitEmptyIndexOptionContext(p *IndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexOption
}

func (*IndexOptionContext) IsIndexOptionContext() {}

func NewIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexOptionContext {
	var p = new(IndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexOption

	return p
}

func (s *IndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexOptionContext) CommonIndexOption() ICommonIndexOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonIndexOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonIndexOptionContext)
}

func (s *IndexOptionContext) IndexTypeClause() IIndexTypeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeClauseContext)
}

func (s *IndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexOption(s)
	}
}

func (s *IndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexOption(s)
	}
}

func (s *IndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexOption() (localctx IIndexOptionContext) {
	localctx = NewIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 518, TiDBParserRULE_indexOption)
	p.SetState(4431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCOMMENT_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4429)
			p.CommonIndexOption()
		}

	case TiDBParserTYPE_SYMBOL, TiDBParserUSING_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4430)
			p.IndexTypeClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICommonIndexOptionContext is an interface to support dynamic dispatch.
type ICommonIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	EQUAL_OPERATOR() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	Visibility() IVisibilityContext

	// IsCommonIndexOptionContext differentiates from other interfaces.
	IsCommonIndexOptionContext()
}

type CommonIndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommonIndexOptionContext() *CommonIndexOptionContext {
	var p = new(CommonIndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_commonIndexOption
	return p
}

func InitEmptyCommonIndexOptionContext(p *CommonIndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_commonIndexOption
}

func (*CommonIndexOptionContext) IsCommonIndexOptionContext() {}

func NewCommonIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommonIndexOptionContext {
	var p = new(CommonIndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_commonIndexOption

	return p
}

func (s *CommonIndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CommonIndexOptionContext) KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_BLOCK_SIZE_SYMBOL, 0)
}

func (s *CommonIndexOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *CommonIndexOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *CommonIndexOptionContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMENT_SYMBOL, 0)
}

func (s *CommonIndexOptionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *CommonIndexOptionContext) Visibility() IVisibilityContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVisibilityContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVisibilityContext)
}

func (s *CommonIndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommonIndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommonIndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCommonIndexOption(s)
	}
}

func (s *CommonIndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCommonIndexOption(s)
	}
}

func (s *CommonIndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCommonIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CommonIndexOption() (localctx ICommonIndexOptionContext) {
	localctx = NewCommonIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 520, TiDBParserRULE_commonIndexOption)
	var _la int

	p.SetState(4441)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserKEY_BLOCK_SIZE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4433)
			p.Match(TiDBParserKEY_BLOCK_SIZE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4435)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4434)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4437)
			p.Ulong_number()
		}

	case TiDBParserCOMMENT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4438)
			p.Match(TiDBParserCOMMENT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4439)
			p.TextLiteral()
		}

	case TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4440)
			p.Visibility()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVisibilityContext is an interface to support dynamic dispatch.
type IVisibilityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	VISIBLE_SYMBOL() antlr.TerminalNode
	INVISIBLE_SYMBOL() antlr.TerminalNode

	// IsVisibilityContext differentiates from other interfaces.
	IsVisibilityContext()
}

type VisibilityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVisibilityContext() *VisibilityContext {
	var p = new(VisibilityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_visibility
	return p
}

func InitEmptyVisibilityContext(p *VisibilityContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_visibility
}

func (*VisibilityContext) IsVisibilityContext() {}

func NewVisibilityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VisibilityContext {
	var p = new(VisibilityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_visibility

	return p
}

func (s *VisibilityContext) GetParser() antlr.Parser { return s.parser }

func (s *VisibilityContext) VISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVISIBLE_SYMBOL, 0)
}

func (s *VisibilityContext) INVISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINVISIBLE_SYMBOL, 0)
}

func (s *VisibilityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VisibilityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VisibilityContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterVisibility(s)
	}
}

func (s *VisibilityContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitVisibility(s)
	}
}

func (s *VisibilityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitVisibility(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Visibility() (localctx IVisibilityContext) {
	localctx = NewVisibilityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 522, TiDBParserRULE_visibility)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4443)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserINVISIBLE_SYMBOL || _la == TiDBParserVISIBLE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexTypeClauseContext is an interface to support dynamic dispatch.
type IIndexTypeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IndexType() IIndexTypeContext
	USING_SYMBOL() antlr.TerminalNode
	TYPE_SYMBOL() antlr.TerminalNode

	// IsIndexTypeClauseContext differentiates from other interfaces.
	IsIndexTypeClauseContext()
}

type IndexTypeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexTypeClauseContext() *IndexTypeClauseContext {
	var p = new(IndexTypeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexTypeClause
	return p
}

func InitEmptyIndexTypeClauseContext(p *IndexTypeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexTypeClause
}

func (*IndexTypeClauseContext) IsIndexTypeClauseContext() {}

func NewIndexTypeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexTypeClauseContext {
	var p = new(IndexTypeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexTypeClause

	return p
}

func (s *IndexTypeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexTypeClauseContext) IndexType() IIndexTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIndexTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIndexTypeContext)
}

func (s *IndexTypeClauseContext) USING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSING_SYMBOL, 0)
}

func (s *IndexTypeClauseContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTYPE_SYMBOL, 0)
}

func (s *IndexTypeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexTypeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexTypeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexTypeClause(s)
	}
}

func (s *IndexTypeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexTypeClause(s)
	}
}

func (s *IndexTypeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexTypeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexTypeClause() (localctx IIndexTypeClauseContext) {
	localctx = NewIndexTypeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 524, TiDBParserRULE_indexTypeClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4445)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserTYPE_SYMBOL || _la == TiDBParserUSING_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(4446)
		p.IndexType()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFulltextIndexOptionContext is an interface to support dynamic dispatch.
type IFulltextIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommonIndexOption() ICommonIndexOptionContext
	WITH_SYMBOL() antlr.TerminalNode
	PARSER_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsFulltextIndexOptionContext differentiates from other interfaces.
	IsFulltextIndexOptionContext()
}

type FulltextIndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFulltextIndexOptionContext() *FulltextIndexOptionContext {
	var p = new(FulltextIndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fulltextIndexOption
	return p
}

func InitEmptyFulltextIndexOptionContext(p *FulltextIndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fulltextIndexOption
}

func (*FulltextIndexOptionContext) IsFulltextIndexOptionContext() {}

func NewFulltextIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FulltextIndexOptionContext {
	var p = new(FulltextIndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fulltextIndexOption

	return p
}

func (s *FulltextIndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *FulltextIndexOptionContext) CommonIndexOption() ICommonIndexOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonIndexOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonIndexOptionContext)
}

func (s *FulltextIndexOptionContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *FulltextIndexOptionContext) PARSER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARSER_SYMBOL, 0)
}

func (s *FulltextIndexOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *FulltextIndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FulltextIndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FulltextIndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFulltextIndexOption(s)
	}
}

func (s *FulltextIndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFulltextIndexOption(s)
	}
}

func (s *FulltextIndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFulltextIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FulltextIndexOption() (localctx IFulltextIndexOptionContext) {
	localctx = NewFulltextIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 526, TiDBParserRULE_fulltextIndexOption)
	p.SetState(4452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserCOMMENT_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4448)
			p.CommonIndexOption()
		}

	case TiDBParserWITH_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4449)
			p.Match(TiDBParserWITH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4450)
			p.Match(TiDBParserPARSER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4451)
			p.Identifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISpatialIndexOptionContext is an interface to support dynamic dispatch.
type ISpatialIndexOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	CommonIndexOption() ICommonIndexOptionContext

	// IsSpatialIndexOptionContext differentiates from other interfaces.
	IsSpatialIndexOptionContext()
}

type SpatialIndexOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpatialIndexOptionContext() *SpatialIndexOptionContext {
	var p = new(SpatialIndexOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_spatialIndexOption
	return p
}

func InitEmptySpatialIndexOptionContext(p *SpatialIndexOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_spatialIndexOption
}

func (*SpatialIndexOptionContext) IsSpatialIndexOptionContext() {}

func NewSpatialIndexOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpatialIndexOptionContext {
	var p = new(SpatialIndexOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_spatialIndexOption

	return p
}

func (s *SpatialIndexOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *SpatialIndexOptionContext) CommonIndexOption() ICommonIndexOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICommonIndexOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICommonIndexOptionContext)
}

func (s *SpatialIndexOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpatialIndexOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpatialIndexOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSpatialIndexOption(s)
	}
}

func (s *SpatialIndexOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSpatialIndexOption(s)
	}
}

func (s *SpatialIndexOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSpatialIndexOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SpatialIndexOption() (localctx ISpatialIndexOptionContext) {
	localctx = NewSpatialIndexOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 528, TiDBParserRULE_spatialIndexOption)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4454)
		p.CommonIndexOption()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeDefinitionContext is an interface to support dynamic dispatch.
type IDataTypeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	EOF() antlr.TerminalNode

	// IsDataTypeDefinitionContext differentiates from other interfaces.
	IsDataTypeDefinitionContext()
}

type DataTypeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDataTypeDefinitionContext() *DataTypeDefinitionContext {
	var p = new(DataTypeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dataTypeDefinition
	return p
}

func InitEmptyDataTypeDefinitionContext(p *DataTypeDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dataTypeDefinition
}

func (*DataTypeDefinitionContext) IsDataTypeDefinitionContext() {}

func NewDataTypeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeDefinitionContext {
	var p = new(DataTypeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_dataTypeDefinition

	return p
}

func (s *DataTypeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeDefinitionContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *DataTypeDefinitionContext) EOF() antlr.TerminalNode {
	return s.GetToken(TiDBParserEOF, 0)
}

func (s *DataTypeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDataTypeDefinition(s)
	}
}

func (s *DataTypeDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDataTypeDefinition(s)
	}
}

func (s *DataTypeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDataTypeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DataTypeDefinition() (localctx IDataTypeDefinitionContext) {
	localctx = NewDataTypeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 530, TiDBParserRULE_dataTypeDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4456)
		p.DataType()
	}
	{
		p.SetState(4457)
		p.Match(TiDBParserEOF)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDataTypeContext is an interface to support dynamic dispatch.
type IDataTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	INT_SYMBOL() antlr.TerminalNode
	TINYINT_SYMBOL() antlr.TerminalNode
	SMALLINT_SYMBOL() antlr.TerminalNode
	MEDIUMINT_SYMBOL() antlr.TerminalNode
	BIGINT_SYMBOL() antlr.TerminalNode
	FieldLength() IFieldLengthContext
	FieldOptions() IFieldOptionsContext
	REAL_SYMBOL() antlr.TerminalNode
	DOUBLE_SYMBOL() antlr.TerminalNode
	Precision() IPrecisionContext
	PRECISION_SYMBOL() antlr.TerminalNode
	FLOAT_SYMBOL() antlr.TerminalNode
	DECIMAL_SYMBOL() antlr.TerminalNode
	NUMERIC_SYMBOL() antlr.TerminalNode
	FIXED_SYMBOL() antlr.TerminalNode
	FloatOptions() IFloatOptionsContext
	BIT_SYMBOL() antlr.TerminalNode
	BOOL_SYMBOL() antlr.TerminalNode
	BOOLEAN_SYMBOL() antlr.TerminalNode
	CHAR_SYMBOL() antlr.TerminalNode
	CharsetWithOptBinary() ICharsetWithOptBinaryContext
	Nchar() INcharContext
	BINARY_SYMBOL() antlr.TerminalNode
	VARYING_SYMBOL() antlr.TerminalNode
	VARCHAR_SYMBOL() antlr.TerminalNode
	NATIONAL_SYMBOL() antlr.TerminalNode
	NVARCHAR_SYMBOL() antlr.TerminalNode
	NCHAR_SYMBOL() antlr.TerminalNode
	VARBINARY_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode
	DATE_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TypeDatetimePrecision() ITypeDatetimePrecisionContext
	TIMESTAMP_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	TINYBLOB_SYMBOL() antlr.TerminalNode
	BLOB_SYMBOL() antlr.TerminalNode
	MEDIUMBLOB_SYMBOL() antlr.TerminalNode
	LONGBLOB_SYMBOL() antlr.TerminalNode
	LONG_SYMBOL() antlr.TerminalNode
	TINYTEXT_SYMBOL() antlr.TerminalNode
	TEXT_SYMBOL() antlr.TerminalNode
	MEDIUMTEXT_SYMBOL() antlr.TerminalNode
	LONGTEXT_SYMBOL() antlr.TerminalNode
	StringList() IStringListContext
	ENUM_SYMBOL() antlr.TerminalNode
	SET_SYMBOL() antlr.TerminalNode
	SERIAL_SYMBOL() antlr.TerminalNode
	JSON_SYMBOL() antlr.TerminalNode
	GEOMETRY_SYMBOL() antlr.TerminalNode
	GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode
	POINT_SYMBOL() antlr.TerminalNode
	MULTIPOINT_SYMBOL() antlr.TerminalNode
	LINESTRING_SYMBOL() antlr.TerminalNode
	MULTILINESTRING_SYMBOL() antlr.TerminalNode
	POLYGON_SYMBOL() antlr.TerminalNode
	MULTIPOLYGON_SYMBOL() antlr.TerminalNode

	// IsDataTypeContext differentiates from other interfaces.
	IsDataTypeContext()
}

type DataTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyDataTypeContext() *DataTypeContext {
	var p = new(DataTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dataType
	return p
}

func InitEmptyDataTypeContext(p *DataTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dataType
}

func (*DataTypeContext) IsDataTypeContext() {}

func NewDataTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DataTypeContext {
	var p = new(DataTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_dataType

	return p
}

func (s *DataTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *DataTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *DataTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *DataTypeContext) INT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_SYMBOL, 0)
}

func (s *DataTypeContext) TINYINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTINYINT_SYMBOL, 0)
}

func (s *DataTypeContext) SMALLINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSMALLINT_SYMBOL, 0)
}

func (s *DataTypeContext) MEDIUMINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEDIUMINT_SYMBOL, 0)
}

func (s *DataTypeContext) BIGINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBIGINT_SYMBOL, 0)
}

func (s *DataTypeContext) FieldLength() IFieldLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *DataTypeContext) FieldOptions() IFieldOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldOptionsContext)
}

func (s *DataTypeContext) REAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREAL_SYMBOL, 0)
}

func (s *DataTypeContext) DOUBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDOUBLE_SYMBOL, 0)
}

func (s *DataTypeContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *DataTypeContext) PRECISION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRECISION_SYMBOL, 0)
}

func (s *DataTypeContext) FLOAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFLOAT_SYMBOL, 0)
}

func (s *DataTypeContext) DECIMAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDECIMAL_SYMBOL, 0)
}

func (s *DataTypeContext) NUMERIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNUMERIC_SYMBOL, 0)
}

func (s *DataTypeContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIXED_SYMBOL, 0)
}

func (s *DataTypeContext) FloatOptions() IFloatOptionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFloatOptionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFloatOptionsContext)
}

func (s *DataTypeContext) BIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBIT_SYMBOL, 0)
}

func (s *DataTypeContext) BOOL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBOOL_SYMBOL, 0)
}

func (s *DataTypeContext) BOOLEAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBOOLEAN_SYMBOL, 0)
}

func (s *DataTypeContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHAR_SYMBOL, 0)
}

func (s *DataTypeContext) CharsetWithOptBinary() ICharsetWithOptBinaryContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetWithOptBinaryContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetWithOptBinaryContext)
}

func (s *DataTypeContext) Nchar() INcharContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INcharContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INcharContext)
}

func (s *DataTypeContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *DataTypeContext) VARYING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVARYING_SYMBOL, 0)
}

func (s *DataTypeContext) VARCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVARCHAR_SYMBOL, 0)
}

func (s *DataTypeContext) NATIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNATIONAL_SYMBOL, 0)
}

func (s *DataTypeContext) NVARCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNVARCHAR_SYMBOL, 0)
}

func (s *DataTypeContext) NCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNCHAR_SYMBOL, 0)
}

func (s *DataTypeContext) VARBINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVARBINARY_SYMBOL, 0)
}

func (s *DataTypeContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserYEAR_SYMBOL, 0)
}

func (s *DataTypeContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATE_SYMBOL, 0)
}

func (s *DataTypeContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIME_SYMBOL, 0)
}

func (s *DataTypeContext) TypeDatetimePrecision() ITypeDatetimePrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeDatetimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeDatetimePrecisionContext)
}

func (s *DataTypeContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_SYMBOL, 0)
}

func (s *DataTypeContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATETIME_SYMBOL, 0)
}

func (s *DataTypeContext) TINYBLOB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTINYBLOB_SYMBOL, 0)
}

func (s *DataTypeContext) BLOB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBLOB_SYMBOL, 0)
}

func (s *DataTypeContext) MEDIUMBLOB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEDIUMBLOB_SYMBOL, 0)
}

func (s *DataTypeContext) LONGBLOB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLONGBLOB_SYMBOL, 0)
}

func (s *DataTypeContext) LONG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLONG_SYMBOL, 0)
}

func (s *DataTypeContext) TINYTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTINYTEXT_SYMBOL, 0)
}

func (s *DataTypeContext) TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTEXT_SYMBOL, 0)
}

func (s *DataTypeContext) MEDIUMTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEDIUMTEXT_SYMBOL, 0)
}

func (s *DataTypeContext) LONGTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLONGTEXT_SYMBOL, 0)
}

func (s *DataTypeContext) StringList() IStringListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStringListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStringListContext)
}

func (s *DataTypeContext) ENUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENUM_SYMBOL, 0)
}

func (s *DataTypeContext) SET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSET_SYMBOL, 0)
}

func (s *DataTypeContext) SERIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSERIAL_SYMBOL, 0)
}

func (s *DataTypeContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_SYMBOL, 0)
}

func (s *DataTypeContext) GEOMETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGEOMETRY_SYMBOL, 0)
}

func (s *DataTypeContext) GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGEOMETRYCOLLECTION_SYMBOL, 0)
}

func (s *DataTypeContext) POINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPOINT_SYMBOL, 0)
}

func (s *DataTypeContext) MULTIPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTIPOINT_SYMBOL, 0)
}

func (s *DataTypeContext) LINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLINESTRING_SYMBOL, 0)
}

func (s *DataTypeContext) MULTILINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTILINESTRING_SYMBOL, 0)
}

func (s *DataTypeContext) POLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPOLYGON_SYMBOL, 0)
}

func (s *DataTypeContext) MULTIPOLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTIPOLYGON_SYMBOL, 0)
}

func (s *DataTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DataTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DataTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDataType(s)
	}
}

func (s *DataTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDataType(s)
	}
}

func (s *DataTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDataType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DataType() (localctx IDataTypeContext) {
	localctx = NewDataTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 532, TiDBParserRULE_dataType)
	var _la int

	p.SetState(4605)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 596, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4459)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserBIGINT_SYMBOL || _la == TiDBParserINT_SYMBOL || _la == TiDBParserMEDIUMINT_SYMBOL || _la == TiDBParserSMALLINT_SYMBOL || _la == TiDBParserTINYINT_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4461)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4460)
				p.FieldLength()
			}

		}
		p.SetState(4464)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSIGNED_SYMBOL || _la == TiDBParserUNSIGNED_SYMBOL || _la == TiDBParserZEROFILL_SYMBOL {
			{
				p.SetState(4463)
				p.FieldOptions()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4471)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserREAL_SYMBOL:
			{
				p.SetState(4466)

				var _m = p.Match(TiDBParserREAL_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TiDBParserDOUBLE_SYMBOL:
			{
				p.SetState(4467)

				var _m = p.Match(TiDBParserDOUBLE_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4469)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserPRECISION_SYMBOL {
				{
					p.SetState(4468)
					p.Match(TiDBParserPRECISION_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(4474)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4473)
				p.Precision()
			}

		}
		p.SetState(4477)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSIGNED_SYMBOL || _la == TiDBParserUNSIGNED_SYMBOL || _la == TiDBParserZEROFILL_SYMBOL {
			{
				p.SetState(4476)
				p.FieldOptions()
			}

		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4479)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserDECIMAL_SYMBOL || _la == TiDBParserFIXED_SYMBOL || _la == TiDBParserFLOAT_SYMBOL || _la == TiDBParserNUMERIC_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4481)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4480)
				p.FloatOptions()
			}

		}
		p.SetState(4484)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSIGNED_SYMBOL || _la == TiDBParserUNSIGNED_SYMBOL || _la == TiDBParserZEROFILL_SYMBOL {
			{
				p.SetState(4483)
				p.FieldOptions()
			}

		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4486)

			var _m = p.Match(TiDBParserBIT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4488)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4487)
				p.FieldLength()
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4490)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserBOOLEAN_SYMBOL || _la == TiDBParserBOOL_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4491)

			var _m = p.Match(TiDBParserCHAR_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4493)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4492)
				p.FieldLength()
			}

		}
		p.SetState(4496)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4495)
				p.CharsetWithOptBinary()
			}

		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4498)
			p.Nchar()
		}
		p.SetState(4500)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4499)
				p.FieldLength()
			}

		}
		p.SetState(4503)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserBINARY_SYMBOL {
			{
				p.SetState(4502)
				p.Match(TiDBParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4505)

			var _m = p.Match(TiDBParserBINARY_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4506)
				p.FieldLength()
			}

		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		p.SetState(4512)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserCHAR_SYMBOL:
			{
				p.SetState(4509)

				var _m = p.Match(TiDBParserCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4510)
				p.Match(TiDBParserVARYING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TiDBParserVARCHAR_SYMBOL:
			{
				p.SetState(4511)

				var _m = p.Match(TiDBParserVARCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		{
			p.SetState(4514)
			p.FieldLength()
		}
		p.SetState(4516)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4515)
				p.CharsetWithOptBinary()
			}

		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		p.SetState(4528)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 579, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(4518)

				var _m = p.Match(TiDBParserNATIONAL_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4519)
				p.Match(TiDBParserVARCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 2:
			{
				p.SetState(4520)

				var _m = p.Match(TiDBParserNVARCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(4521)

				var _m = p.Match(TiDBParserNCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4522)
				p.Match(TiDBParserVARCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(4523)

				var _m = p.Match(TiDBParserNATIONAL_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4524)
				p.Match(TiDBParserCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4525)
				p.Match(TiDBParserVARYING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(4526)

				var _m = p.Match(TiDBParserNCHAR_SYMBOL)

				localctx.(*DataTypeContext).type_ = _m
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4527)
				p.Match(TiDBParserVARYING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4530)
			p.FieldLength()
		}
		p.SetState(4532)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserBINARY_SYMBOL {
			{
				p.SetState(4531)
				p.Match(TiDBParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4534)

			var _m = p.Match(TiDBParserVARBINARY_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4535)
			p.FieldLength()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4536)

			var _m = p.Match(TiDBParserYEAR_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4538)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4537)
				p.FieldLength()
			}

		}
		p.SetState(4541)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSIGNED_SYMBOL || _la == TiDBParserUNSIGNED_SYMBOL || _la == TiDBParserZEROFILL_SYMBOL {
			{
				p.SetState(4540)
				p.FieldOptions()
			}

		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4543)

			var _m = p.Match(TiDBParserDATE_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4544)

			var _m = p.Match(TiDBParserTIME_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4546)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4545)
				p.TypeDatetimePrecision()
			}

		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4548)

			var _m = p.Match(TiDBParserTIMESTAMP_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4550)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4549)
				p.TypeDatetimePrecision()
			}

		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(4552)

			var _m = p.Match(TiDBParserDATETIME_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4554)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4553)
				p.TypeDatetimePrecision()
			}

		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(4556)

			var _m = p.Match(TiDBParserTINYBLOB_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(4557)

			var _m = p.Match(TiDBParserBLOB_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4559)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4558)
				p.FieldLength()
			}

		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(4561)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserLONGBLOB_SYMBOL || _la == TiDBParserMEDIUMBLOB_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(4562)

			var _m = p.Match(TiDBParserLONG_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4563)
			p.Match(TiDBParserVARBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(4564)

			var _m = p.Match(TiDBParserLONG_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4568)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 587, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(4565)
				p.Match(TiDBParserCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4566)
				p.Match(TiDBParserVARYING_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 587, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(4567)
				p.Match(TiDBParserVARCHAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}
		p.SetState(4571)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4570)
				p.CharsetWithOptBinary()
			}

		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(4573)

			var _m = p.Match(TiDBParserTINYTEXT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4575)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4574)
				p.CharsetWithOptBinary()
			}

		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(4577)

			var _m = p.Match(TiDBParserTEXT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4579)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(4578)
				p.FieldLength()
			}

		}
		p.SetState(4582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4581)
				p.CharsetWithOptBinary()
			}

		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(4584)

			var _m = p.Match(TiDBParserMEDIUMTEXT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4586)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4585)
				p.CharsetWithOptBinary()
			}

		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(4588)

			var _m = p.Match(TiDBParserLONGTEXT_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4590)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4589)
				p.CharsetWithOptBinary()
			}

		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(4592)

			var _m = p.Match(TiDBParserENUM_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4593)
			p.StringList()
		}
		p.SetState(4595)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4594)
				p.CharsetWithOptBinary()
			}

		}

	case 27:
		p.EnterOuterAlt(localctx, 27)
		{
			p.SetState(4597)

			var _m = p.Match(TiDBParserSET_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4598)
			p.StringList()
		}
		p.SetState(4600)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&1441222253798227968) != 0) || _la == TiDBParserUNICODE_SYMBOL {
			{
				p.SetState(4599)
				p.CharsetWithOptBinary()
			}

		}

	case 28:
		p.EnterOuterAlt(localctx, 28)
		{
			p.SetState(4602)

			var _m = p.Match(TiDBParserSERIAL_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 29:
		p.EnterOuterAlt(localctx, 29)
		{
			p.SetState(4603)

			var _m = p.Match(TiDBParserJSON_SYMBOL)

			localctx.(*DataTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 30:
		p.EnterOuterAlt(localctx, 30)
		{
			p.SetState(4604)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*DataTypeContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserGEOMETRYCOLLECTION_SYMBOL || _la == TiDBParserGEOMETRY_SYMBOL || _la == TiDBParserLINESTRING_SYMBOL || ((int64((_la-351)) & ^0x3f) == 0 && ((int64(1)<<(_la-351))&3458764513820540935) != 0)) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*DataTypeContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INcharContext is an interface to support dynamic dispatch.
type INcharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	NCHAR_SYMBOL() antlr.TerminalNode
	CHAR_SYMBOL() antlr.TerminalNode
	NATIONAL_SYMBOL() antlr.TerminalNode

	// IsNcharContext differentiates from other interfaces.
	IsNcharContext()
}

type NcharContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyNcharContext() *NcharContext {
	var p = new(NcharContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_nchar
	return p
}

func InitEmptyNcharContext(p *NcharContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_nchar
}

func (*NcharContext) IsNcharContext() {}

func NewNcharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NcharContext {
	var p = new(NcharContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_nchar

	return p
}

func (s *NcharContext) GetParser() antlr.Parser { return s.parser }

func (s *NcharContext) GetType_() antlr.Token { return s.type_ }

func (s *NcharContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *NcharContext) NCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNCHAR_SYMBOL, 0)
}

func (s *NcharContext) CHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHAR_SYMBOL, 0)
}

func (s *NcharContext) NATIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNATIONAL_SYMBOL, 0)
}

func (s *NcharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NcharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NcharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterNchar(s)
	}
}

func (s *NcharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitNchar(s)
	}
}

func (s *NcharContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitNchar(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Nchar() (localctx INcharContext) {
	localctx = NewNcharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 534, TiDBParserRULE_nchar)
	p.SetState(4610)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserNCHAR_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4607)

			var _m = p.Match(TiDBParserNCHAR_SYMBOL)

			localctx.(*NcharContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserNATIONAL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4608)

			var _m = p.Match(TiDBParserNATIONAL_SYMBOL)

			localctx.(*NcharContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4609)
			p.Match(TiDBParserCHAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRealTypeContext is an interface to support dynamic dispatch.
type IRealTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	REAL_SYMBOL() antlr.TerminalNode
	DOUBLE_SYMBOL() antlr.TerminalNode
	PRECISION_SYMBOL() antlr.TerminalNode

	// IsRealTypeContext differentiates from other interfaces.
	IsRealTypeContext()
}

type RealTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyRealTypeContext() *RealTypeContext {
	var p = new(RealTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_realType
	return p
}

func InitEmptyRealTypeContext(p *RealTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_realType
}

func (*RealTypeContext) IsRealTypeContext() {}

func NewRealTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RealTypeContext {
	var p = new(RealTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_realType

	return p
}

func (s *RealTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *RealTypeContext) GetType_() antlr.Token { return s.type_ }

func (s *RealTypeContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *RealTypeContext) REAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREAL_SYMBOL, 0)
}

func (s *RealTypeContext) DOUBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDOUBLE_SYMBOL, 0)
}

func (s *RealTypeContext) PRECISION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRECISION_SYMBOL, 0)
}

func (s *RealTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RealTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RealTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRealType(s)
	}
}

func (s *RealTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRealType(s)
	}
}

func (s *RealTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRealType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RealType() (localctx IRealTypeContext) {
	localctx = NewRealTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 536, TiDBParserRULE_realType)
	var _la int

	p.SetState(4617)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserREAL_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4612)

			var _m = p.Match(TiDBParserREAL_SYMBOL)

			localctx.(*RealTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserDOUBLE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4613)

			var _m = p.Match(TiDBParserDOUBLE_SYMBOL)

			localctx.(*RealTypeContext).type_ = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4615)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserPRECISION_SYMBOL {
			{
				p.SetState(4614)
				p.Match(TiDBParserPRECISION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldLengthContext is an interface to support dynamic dispatch.
type IFieldLengthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	Real_ulonglong_number() IReal_ulonglong_numberContext
	DECIMAL_NUMBER() antlr.TerminalNode

	// IsFieldLengthContext differentiates from other interfaces.
	IsFieldLengthContext()
}

type FieldLengthContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldLengthContext() *FieldLengthContext {
	var p = new(FieldLengthContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldLength
	return p
}

func InitEmptyFieldLengthContext(p *FieldLengthContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldLength
}

func (*FieldLengthContext) IsFieldLengthContext() {}

func NewFieldLengthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldLengthContext {
	var p = new(FieldLengthContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fieldLength

	return p
}

func (s *FieldLengthContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldLengthContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *FieldLengthContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *FieldLengthContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *FieldLengthContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserDECIMAL_NUMBER, 0)
}

func (s *FieldLengthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldLengthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldLengthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFieldLength(s)
	}
}

func (s *FieldLengthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFieldLength(s)
	}
}

func (s *FieldLengthContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFieldLength(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FieldLength() (localctx IFieldLengthContext) {
	localctx = NewFieldLengthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 538, TiDBParserRULE_fieldLength)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4619)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4622)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserHEX_NUMBER:
		{
			p.SetState(4620)
			p.Real_ulonglong_number()
		}

	case TiDBParserDECIMAL_NUMBER:
		{
			p.SetState(4621)
			p.Match(TiDBParserDECIMAL_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(4624)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldOptionsContext is an interface to support dynamic dispatch.
type IFieldOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllSIGNED_SYMBOL() []antlr.TerminalNode
	SIGNED_SYMBOL(i int) antlr.TerminalNode
	AllUNSIGNED_SYMBOL() []antlr.TerminalNode
	UNSIGNED_SYMBOL(i int) antlr.TerminalNode
	AllZEROFILL_SYMBOL() []antlr.TerminalNode
	ZEROFILL_SYMBOL(i int) antlr.TerminalNode

	// IsFieldOptionsContext differentiates from other interfaces.
	IsFieldOptionsContext()
}

type FieldOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldOptionsContext() *FieldOptionsContext {
	var p = new(FieldOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldOptions
	return p
}

func InitEmptyFieldOptionsContext(p *FieldOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldOptions
}

func (*FieldOptionsContext) IsFieldOptionsContext() {}

func NewFieldOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldOptionsContext {
	var p = new(FieldOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fieldOptions

	return p
}

func (s *FieldOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldOptionsContext) AllSIGNED_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserSIGNED_SYMBOL)
}

func (s *FieldOptionsContext) SIGNED_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserSIGNED_SYMBOL, i)
}

func (s *FieldOptionsContext) AllUNSIGNED_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserUNSIGNED_SYMBOL)
}

func (s *FieldOptionsContext) UNSIGNED_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserUNSIGNED_SYMBOL, i)
}

func (s *FieldOptionsContext) AllZEROFILL_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserZEROFILL_SYMBOL)
}

func (s *FieldOptionsContext) ZEROFILL_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserZEROFILL_SYMBOL, i)
}

func (s *FieldOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFieldOptions(s)
	}
}

func (s *FieldOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFieldOptions(s)
	}
}

func (s *FieldOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFieldOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FieldOptions() (localctx IFieldOptionsContext) {
	localctx = NewFieldOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 540, TiDBParserRULE_fieldOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == TiDBParserSIGNED_SYMBOL || _la == TiDBParserUNSIGNED_SYMBOL || _la == TiDBParserZEROFILL_SYMBOL {
		{
			p.SetState(4626)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserSIGNED_SYMBOL || _la == TiDBParserUNSIGNED_SYMBOL || _la == TiDBParserZEROFILL_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		p.SetState(4629)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetWithOptBinaryContext is an interface to support dynamic dispatch.
type ICharsetWithOptBinaryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ascii() IAsciiContext
	Unicode() IUnicodeContext
	BYTE_SYMBOL() antlr.TerminalNode
	Charset() ICharsetContext
	CharsetName() ICharsetNameContext
	BINARY_SYMBOL() antlr.TerminalNode

	// IsCharsetWithOptBinaryContext differentiates from other interfaces.
	IsCharsetWithOptBinaryContext()
}

type CharsetWithOptBinaryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetWithOptBinaryContext() *CharsetWithOptBinaryContext {
	var p = new(CharsetWithOptBinaryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_charsetWithOptBinary
	return p
}

func InitEmptyCharsetWithOptBinaryContext(p *CharsetWithOptBinaryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_charsetWithOptBinary
}

func (*CharsetWithOptBinaryContext) IsCharsetWithOptBinaryContext() {}

func NewCharsetWithOptBinaryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetWithOptBinaryContext {
	var p = new(CharsetWithOptBinaryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_charsetWithOptBinary

	return p
}

func (s *CharsetWithOptBinaryContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetWithOptBinaryContext) Ascii() IAsciiContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAsciiContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAsciiContext)
}

func (s *CharsetWithOptBinaryContext) Unicode() IUnicodeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnicodeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnicodeContext)
}

func (s *CharsetWithOptBinaryContext) BYTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBYTE_SYMBOL, 0)
}

func (s *CharsetWithOptBinaryContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *CharsetWithOptBinaryContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CharsetWithOptBinaryContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *CharsetWithOptBinaryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetWithOptBinaryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetWithOptBinaryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCharsetWithOptBinary(s)
	}
}

func (s *CharsetWithOptBinaryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCharsetWithOptBinary(s)
	}
}

func (s *CharsetWithOptBinaryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCharsetWithOptBinary(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CharsetWithOptBinary() (localctx ICharsetWithOptBinaryContext) {
	localctx = NewCharsetWithOptBinaryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 542, TiDBParserRULE_charsetWithOptBinary)
	var _la int

	p.SetState(4645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 604, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4631)
			p.Ascii()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4632)
			p.Unicode()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4633)
			p.Match(TiDBParserBYTE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4634)
			p.Charset()
		}
		{
			p.SetState(4635)
			p.CharsetName()
		}
		p.SetState(4637)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserBINARY_SYMBOL {
			{
				p.SetState(4636)
				p.Match(TiDBParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4639)
			p.Match(TiDBParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4643)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCHARSET_SYMBOL || _la == TiDBParserCHAR_SYMBOL {
			{
				p.SetState(4640)
				p.Charset()
			}
			{
				p.SetState(4641)
				p.CharsetName()
			}

		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAsciiContext is an interface to support dynamic dispatch.
type IAsciiContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASCII_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode

	// IsAsciiContext differentiates from other interfaces.
	IsAsciiContext()
}

type AsciiContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAsciiContext() *AsciiContext {
	var p = new(AsciiContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ascii
	return p
}

func InitEmptyAsciiContext(p *AsciiContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ascii
}

func (*AsciiContext) IsAsciiContext() {}

func NewAsciiContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AsciiContext {
	var p = new(AsciiContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_ascii

	return p
}

func (s *AsciiContext) GetParser() antlr.Parser { return s.parser }

func (s *AsciiContext) ASCII_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserASCII_SYMBOL, 0)
}

func (s *AsciiContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *AsciiContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AsciiContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AsciiContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterAscii(s)
	}
}

func (s *AsciiContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitAscii(s)
	}
}

func (s *AsciiContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitAscii(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Ascii() (localctx IAsciiContext) {
	localctx = NewAsciiContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 544, TiDBParserRULE_ascii)
	var _la int

	p.SetState(4653)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserASCII_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4647)
			p.Match(TiDBParserASCII_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4649)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserBINARY_SYMBOL {
			{
				p.SetState(4648)
				p.Match(TiDBParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserBINARY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4651)
			p.Match(TiDBParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4652)
			p.Match(TiDBParserASCII_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUnicodeContext is an interface to support dynamic dispatch.
type IUnicodeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UNICODE_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode

	// IsUnicodeContext differentiates from other interfaces.
	IsUnicodeContext()
}

type UnicodeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnicodeContext() *UnicodeContext {
	var p = new(UnicodeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_unicode
	return p
}

func InitEmptyUnicodeContext(p *UnicodeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_unicode
}

func (*UnicodeContext) IsUnicodeContext() {}

func NewUnicodeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnicodeContext {
	var p = new(UnicodeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_unicode

	return p
}

func (s *UnicodeContext) GetParser() antlr.Parser { return s.parser }

func (s *UnicodeContext) UNICODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNICODE_SYMBOL, 0)
}

func (s *UnicodeContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *UnicodeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnicodeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UnicodeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUnicode(s)
	}
}

func (s *UnicodeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUnicode(s)
	}
}

func (s *UnicodeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUnicode(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Unicode() (localctx IUnicodeContext) {
	localctx = NewUnicodeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 546, TiDBParserRULE_unicode)
	var _la int

	p.SetState(4661)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserUNICODE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4655)
			p.Match(TiDBParserUNICODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4657)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserBINARY_SYMBOL {
			{
				p.SetState(4656)
				p.Match(TiDBParserBINARY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	case TiDBParserBINARY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4659)
			p.Match(TiDBParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4660)
			p.Match(TiDBParserUNICODE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWsNumCodepointsContext is an interface to support dynamic dispatch.
type IWsNumCodepointsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsWsNumCodepointsContext differentiates from other interfaces.
	IsWsNumCodepointsContext()
}

type WsNumCodepointsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWsNumCodepointsContext() *WsNumCodepointsContext {
	var p = new(WsNumCodepointsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_wsNumCodepoints
	return p
}

func InitEmptyWsNumCodepointsContext(p *WsNumCodepointsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_wsNumCodepoints
}

func (*WsNumCodepointsContext) IsWsNumCodepointsContext() {}

func NewWsNumCodepointsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WsNumCodepointsContext {
	var p = new(WsNumCodepointsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_wsNumCodepoints

	return p
}

func (s *WsNumCodepointsContext) GetParser() antlr.Parser { return s.parser }

func (s *WsNumCodepointsContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *WsNumCodepointsContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *WsNumCodepointsContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *WsNumCodepointsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WsNumCodepointsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WsNumCodepointsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWsNumCodepoints(s)
	}
}

func (s *WsNumCodepointsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWsNumCodepoints(s)
	}
}

func (s *WsNumCodepointsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWsNumCodepoints(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WsNumCodepoints() (localctx IWsNumCodepointsContext) {
	localctx = NewWsNumCodepointsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 548, TiDBParserRULE_wsNumCodepoints)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4663)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4664)
		p.Real_ulong_number()
	}
	{
		p.SetState(4665)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeDatetimePrecisionContext is an interface to support dynamic dispatch.
type ITypeDatetimePrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	INT_NUMBER() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsTypeDatetimePrecisionContext differentiates from other interfaces.
	IsTypeDatetimePrecisionContext()
}

type TypeDatetimePrecisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeDatetimePrecisionContext() *TypeDatetimePrecisionContext {
	var p = new(TypeDatetimePrecisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_typeDatetimePrecision
	return p
}

func InitEmptyTypeDatetimePrecisionContext(p *TypeDatetimePrecisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_typeDatetimePrecision
}

func (*TypeDatetimePrecisionContext) IsTypeDatetimePrecisionContext() {}

func NewTypeDatetimePrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeDatetimePrecisionContext {
	var p = new(TypeDatetimePrecisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_typeDatetimePrecision

	return p
}

func (s *TypeDatetimePrecisionContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeDatetimePrecisionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *TypeDatetimePrecisionContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *TypeDatetimePrecisionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *TypeDatetimePrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeDatetimePrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeDatetimePrecisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTypeDatetimePrecision(s)
	}
}

func (s *TypeDatetimePrecisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTypeDatetimePrecision(s)
	}
}

func (s *TypeDatetimePrecisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTypeDatetimePrecision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TypeDatetimePrecision() (localctx ITypeDatetimePrecisionContext) {
	localctx = NewTypeDatetimePrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 550, TiDBParserRULE_typeDatetimePrecision)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4667)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4668)
		p.Match(TiDBParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4669)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetNameContext is an interface to support dynamic dispatch.
type ICharsetNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext
	BINARY_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsCharsetNameContext differentiates from other interfaces.
	IsCharsetNameContext()
}

type CharsetNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetNameContext() *CharsetNameContext {
	var p = new(CharsetNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_charsetName
	return p
}

func InitEmptyCharsetNameContext(p *CharsetNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_charsetName
}

func (*CharsetNameContext) IsCharsetNameContext() {}

func NewCharsetNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetNameContext {
	var p = new(CharsetNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_charsetName

	return p
}

func (s *CharsetNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetNameContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *CharsetNameContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *CharsetNameContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *CharsetNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCharsetName(s)
	}
}

func (s *CharsetNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCharsetName(s)
	}
}

func (s *CharsetNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCharsetName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CharsetName() (localctx ICharsetNameContext) {
	localctx = NewCharsetNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 552, TiDBParserRULE_charsetName)
	p.SetState(4674)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4671)
			p.TextOrIdentifier()
		}

	case TiDBParserBINARY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4672)
			p.Match(TiDBParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserDEFAULT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4673)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollationNameContext is an interface to support dynamic dispatch.
type ICollationNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	BINARY_SYMBOL() antlr.TerminalNode

	// IsCollationNameContext differentiates from other interfaces.
	IsCollationNameContext()
}

type CollationNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollationNameContext() *CollationNameContext {
	var p = new(CollationNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_collationName
	return p
}

func InitEmptyCollationNameContext(p *CollationNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_collationName
}

func (*CollationNameContext) IsCollationNameContext() {}

func NewCollationNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollationNameContext {
	var p = new(CollationNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_collationName

	return p
}

func (s *CollationNameContext) GetParser() antlr.Parser { return s.parser }

func (s *CollationNameContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *CollationNameContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *CollationNameContext) BINARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINARY_SYMBOL, 0)
}

func (s *CollationNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollationNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollationNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCollationName(s)
	}
}

func (s *CollationNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCollationName(s)
	}
}

func (s *CollationNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCollationName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CollationName() (localctx ICollationNameContext) {
	localctx = NewCollationNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 554, TiDBParserRULE_collationName)
	p.SetState(4679)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4676)
			p.TextOrIdentifier()
		}

	case TiDBParserDEFAULT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4677)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserBINARY_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4678)
			p.Match(TiDBParserBINARY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableOptionsContext is an interface to support dynamic dispatch.
type ICreateTableOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreateTableOption() []ICreateTableOptionContext
	CreateTableOption(i int) ICreateTableOptionContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsCreateTableOptionsContext differentiates from other interfaces.
	IsCreateTableOptionsContext()
}

type CreateTableOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableOptionsContext() *CreateTableOptionsContext {
	var p = new(CreateTableOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createTableOptions
	return p
}

func InitEmptyCreateTableOptionsContext(p *CreateTableOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createTableOptions
}

func (*CreateTableOptionsContext) IsCreateTableOptionsContext() {}

func NewCreateTableOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableOptionsContext {
	var p = new(CreateTableOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_createTableOptions

	return p
}

func (s *CreateTableOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableOptionsContext) AllCreateTableOption() []ICreateTableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateTableOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateTableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateTableOptionContext); ok {
			tst[i] = t.(ICreateTableOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableOptionsContext) CreateTableOption(i int) ICreateTableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableOptionContext)
}

func (s *CreateTableOptionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *CreateTableOptionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *CreateTableOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCreateTableOptions(s)
	}
}

func (s *CreateTableOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCreateTableOptions(s)
	}
}

func (s *CreateTableOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCreateTableOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CreateTableOptions() (localctx ICreateTableOptionsContext) {
	localctx = NewCreateTableOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 556, TiDBParserRULE_createTableOptions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4681)
		p.CreateTableOption()
	}
	p.SetState(4688)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&1299323900206776323) != 0) || ((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&2322168558977025) != 0) || ((int64((_la-236)) & ^0x3f) == 0 && ((int64(1)<<(_la-236))&268435585) != 0) || _la == TiDBParserMAX_ROWS_SYMBOL || _la == TiDBParserMIN_ROWS_SYMBOL || _la == TiDBParserPACK_KEYS_SYMBOL || _la == TiDBParserPASSWORD_SYMBOL || ((int64((_la-486)) & ^0x3f) == 0 && ((int64(1)<<(_la-486))&2161727821137838081) != 0) || ((int64((_la-553)) & ^0x3f) == 0 && ((int64(1)<<(_la-553))&36028797023682561) != 0) || _la == TiDBParserSECONDARY_ENGINE_SYMBOL || _la == TiDBParserCOMMA_SYMBOL {
		p.SetState(4683)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(4682)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4685)
			p.CreateTableOption()
		}

		p.SetState(4690)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableOptionsSpaceSeparatedContext is an interface to support dynamic dispatch.
type ICreateTableOptionsSpaceSeparatedContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreateTableOption() []ICreateTableOptionContext
	CreateTableOption(i int) ICreateTableOptionContext

	// IsCreateTableOptionsSpaceSeparatedContext differentiates from other interfaces.
	IsCreateTableOptionsSpaceSeparatedContext()
}

type CreateTableOptionsSpaceSeparatedContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateTableOptionsSpaceSeparatedContext() *CreateTableOptionsSpaceSeparatedContext {
	var p = new(CreateTableOptionsSpaceSeparatedContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createTableOptionsSpaceSeparated
	return p
}

func InitEmptyCreateTableOptionsSpaceSeparatedContext(p *CreateTableOptionsSpaceSeparatedContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createTableOptionsSpaceSeparated
}

func (*CreateTableOptionsSpaceSeparatedContext) IsCreateTableOptionsSpaceSeparatedContext() {}

func NewCreateTableOptionsSpaceSeparatedContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableOptionsSpaceSeparatedContext {
	var p = new(CreateTableOptionsSpaceSeparatedContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_createTableOptionsSpaceSeparated

	return p
}

func (s *CreateTableOptionsSpaceSeparatedContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableOptionsSpaceSeparatedContext) AllCreateTableOption() []ICreateTableOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateTableOptionContext); ok {
			len++
		}
	}

	tst := make([]ICreateTableOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateTableOptionContext); ok {
			tst[i] = t.(ICreateTableOptionContext)
			i++
		}
	}

	return tst
}

func (s *CreateTableOptionsSpaceSeparatedContext) CreateTableOption(i int) ICreateTableOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateTableOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateTableOptionContext)
}

func (s *CreateTableOptionsSpaceSeparatedContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableOptionsSpaceSeparatedContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableOptionsSpaceSeparatedContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCreateTableOptionsSpaceSeparated(s)
	}
}

func (s *CreateTableOptionsSpaceSeparatedContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCreateTableOptionsSpaceSeparated(s)
	}
}

func (s *CreateTableOptionsSpaceSeparatedContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCreateTableOptionsSpaceSeparated(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CreateTableOptionsSpaceSeparated() (localctx ICreateTableOptionsSpaceSeparatedContext) {
	localctx = NewCreateTableOptionsSpaceSeparatedContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 558, TiDBParserRULE_createTableOptionsSpaceSeparated)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4692)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = ((int64((_la-24)) & ^0x3f) == 0 && ((int64(1)<<(_la-24))&1299323900206776323) != 0) || ((int64((_la-112)) & ^0x3f) == 0 && ((int64(1)<<(_la-112))&2322168558977025) != 0) || ((int64((_la-236)) & ^0x3f) == 0 && ((int64(1)<<(_la-236))&268435585) != 0) || _la == TiDBParserMAX_ROWS_SYMBOL || _la == TiDBParserMIN_ROWS_SYMBOL || _la == TiDBParserPACK_KEYS_SYMBOL || _la == TiDBParserPASSWORD_SYMBOL || ((int64((_la-486)) & ^0x3f) == 0 && ((int64(1)<<(_la-486))&2161727821137838081) != 0) || ((int64((_la-553)) & ^0x3f) == 0 && ((int64(1)<<(_la-553))&36028797023682561) != 0) || _la == TiDBParserSECONDARY_ENGINE_SYMBOL {
		{
			p.SetState(4691)
			p.CreateTableOption()
		}

		p.SetState(4694)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateTableOptionContext is an interface to support dynamic dispatch.
type ICreateTableOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// GetFormat returns the format token.
	GetFormat() antlr.Token

	// GetMethod returns the method token.
	GetMethod() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// SetFormat sets the format token.
	SetFormat(antlr.Token)

	// SetMethod sets the method token.
	SetMethod(antlr.Token)

	// Getter signatures
	EngineRef() IEngineRefContext
	ENGINE_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode
	NULL_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	Equal() IEqualContext
	Ulonglong_number() IUlonglong_numberContext
	MAX_ROWS_SYMBOL() antlr.TerminalNode
	MIN_ROWS_SYMBOL() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	PASSWORD_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	COMPRESSION_SYMBOL() antlr.TerminalNode
	ENCRYPTION_SYMBOL() antlr.TerminalNode
	AUTO_INCREMENT_SYMBOL() antlr.TerminalNode
	TernaryOption() ITernaryOptionContext
	PACK_KEYS_SYMBOL() antlr.TerminalNode
	STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode
	STATS_PERSISTENT_SYMBOL() antlr.TerminalNode
	STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode
	CHECKSUM_SYMBOL() antlr.TerminalNode
	TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode
	DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode
	ROW_FORMAT_SYMBOL() antlr.TerminalNode
	DEFAULT_SYMBOL() antlr.TerminalNode
	DYNAMIC_SYMBOL() antlr.TerminalNode
	FIXED_SYMBOL() antlr.TerminalNode
	COMPRESSED_SYMBOL() antlr.TerminalNode
	REDUNDANT_SYMBOL() antlr.TerminalNode
	COMPACT_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	TableRefList() ITableRefListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	UNION_SYMBOL() antlr.TerminalNode
	DefaultCharset() IDefaultCharsetContext
	DefaultCollation() IDefaultCollationContext
	INSERT_METHOD_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	TABLESPACE_SYMBOL() antlr.TerminalNode
	STORAGE_SYMBOL() antlr.TerminalNode
	DISK_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	CONNECTION_SYMBOL() antlr.TerminalNode
	KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	TRANSACTION_SYMBOL() antlr.TerminalNode
	START_SYMBOL() antlr.TerminalNode

	// IsCreateTableOptionContext differentiates from other interfaces.
	IsCreateTableOptionContext()
}

type CreateTableOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
	format antlr.Token
	method antlr.Token
}

func NewEmptyCreateTableOptionContext() *CreateTableOptionContext {
	var p = new(CreateTableOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createTableOption
	return p
}

func InitEmptyCreateTableOptionContext(p *CreateTableOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createTableOption
}

func (*CreateTableOptionContext) IsCreateTableOptionContext() {}

func NewCreateTableOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateTableOptionContext {
	var p = new(CreateTableOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_createTableOption

	return p
}

func (s *CreateTableOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateTableOptionContext) GetOption() antlr.Token { return s.option }

func (s *CreateTableOptionContext) GetFormat() antlr.Token { return s.format }

func (s *CreateTableOptionContext) GetMethod() antlr.Token { return s.method }

func (s *CreateTableOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *CreateTableOptionContext) SetFormat(v antlr.Token) { s.format = v }

func (s *CreateTableOptionContext) SetMethod(v antlr.Token) { s.method = v }

func (s *CreateTableOptionContext) EngineRef() IEngineRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineRefContext)
}

func (s *CreateTableOptionContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENGINE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *CreateTableOptionContext) SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECONDARY_ENGINE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *CreateTableOptionContext) Equal() IEqualContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEqualContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEqualContext)
}

func (s *CreateTableOptionContext) Ulonglong_number() IUlonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlonglong_numberContext)
}

func (s *CreateTableOptionContext) MAX_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_ROWS_SYMBOL, 0)
}

func (s *CreateTableOptionContext) MIN_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMIN_ROWS_SYMBOL, 0)
}

func (s *CreateTableOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *CreateTableOptionContext) AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAVG_ROW_LENGTH_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *CreateTableOptionContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *CreateTableOptionContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMENT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *CreateTableOptionContext) COMPRESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPRESSION_SYMBOL, 0)
}

func (s *CreateTableOptionContext) ENCRYPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENCRYPTION_SYMBOL, 0)
}

func (s *CreateTableOptionContext) AUTO_INCREMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAUTO_INCREMENT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TernaryOption() ITernaryOptionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITernaryOptionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITernaryOptionContext)
}

func (s *CreateTableOptionContext) PACK_KEYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPACK_KEYS_SYMBOL, 0)
}

func (s *CreateTableOptionContext) STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATS_AUTO_RECALC_SYMBOL, 0)
}

func (s *CreateTableOptionContext) STATS_PERSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATS_PERSISTENT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, 0)
}

func (s *CreateTableOptionContext) CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHECKSUM_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_CHECKSUM_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDELAY_KEY_WRITE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_FORMAT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DYNAMIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDYNAMIC_SYMBOL, 0)
}

func (s *CreateTableOptionContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIXED_SYMBOL, 0)
}

func (s *CreateTableOptionContext) COMPRESSED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPRESSED_SYMBOL, 0)
}

func (s *CreateTableOptionContext) REDUNDANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREDUNDANT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) COMPACT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPACT_SYMBOL, 0)
}

func (s *CreateTableOptionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TableRefList() ITableRefListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefListContext)
}

func (s *CreateTableOptionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *CreateTableOptionContext) UNION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNION_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DefaultCharset() IDefaultCharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultCharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultCharsetContext)
}

func (s *CreateTableOptionContext) DefaultCollation() IDefaultCollationContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefaultCollationContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefaultCollationContext)
}

func (s *CreateTableOptionContext) INSERT_METHOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSERT_METHOD_SYMBOL, 0)
}

func (s *CreateTableOptionContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_SYMBOL, 0)
}

func (s *CreateTableOptionContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIRST_SYMBOL, 0)
}

func (s *CreateTableOptionContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLAST_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIRECTORY_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATA_SYMBOL, 0)
}

func (s *CreateTableOptionContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINDEX_SYMBOL, 0)
}

func (s *CreateTableOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CreateTableOptionContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLESPACE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTORAGE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) DISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISK_SYMBOL, 0)
}

func (s *CreateTableOptionContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEMORY_SYMBOL, 0)
}

func (s *CreateTableOptionContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONNECTION_SYMBOL, 0)
}

func (s *CreateTableOptionContext) KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_BLOCK_SIZE_SYMBOL, 0)
}

func (s *CreateTableOptionContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRANSACTION_SYMBOL, 0)
}

func (s *CreateTableOptionContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTART_SYMBOL, 0)
}

func (s *CreateTableOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateTableOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateTableOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCreateTableOption(s)
	}
}

func (s *CreateTableOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCreateTableOption(s)
	}
}

func (s *CreateTableOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCreateTableOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CreateTableOption() (localctx ICreateTableOptionContext) {
	localctx = NewCreateTableOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 560, TiDBParserRULE_createTableOption)
	var _la int

	p.SetState(4823)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 638, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4696)

			var _m = p.Match(TiDBParserENGINE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4698)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4697)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4700)
			p.EngineRef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4701)

			var _m = p.Match(TiDBParserSECONDARY_ENGINE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4703)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR || _la == TiDBParserASSIGN_OPERATOR {
			{
				p.SetState(4702)
				p.Equal()
			}

		}
		p.SetState(4707)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserNULL_SYMBOL:
			{
				p.SetState(4705)
				p.Match(TiDBParserNULL_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
			{
				p.SetState(4706)
				p.TextOrIdentifier()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4709)

			var _m = p.Match(TiDBParserMAX_ROWS_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4711)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4710)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4713)
			p.Ulonglong_number()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(4714)

			var _m = p.Match(TiDBParserMIN_ROWS_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4716)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4715)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4718)
			p.Ulonglong_number()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(4719)

			var _m = p.Match(TiDBParserAVG_ROW_LENGTH_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4721)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4720)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4723)
			p.Ulong_number()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(4724)

			var _m = p.Match(TiDBParserPASSWORD_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4726)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4725)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4728)
			p.TextStringLiteral()
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(4729)

			var _m = p.Match(TiDBParserCOMMENT_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4731)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4730)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4733)
			p.TextStringLiteral()
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(4734)

			var _m = p.Match(TiDBParserCOMPRESSION_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4736)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4735)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4738)
			p.TextString()
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(4739)

			var _m = p.Match(TiDBParserENCRYPTION_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4741)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4740)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4743)
			p.TextString()
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(4744)

			var _m = p.Match(TiDBParserAUTO_INCREMENT_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4746)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4745)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4748)
			p.Ulonglong_number()
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(4749)

			var _m = p.Match(TiDBParserPACK_KEYS_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4751)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4750)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4753)
			p.TernaryOption()
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(4754)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTableOptionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-544)) & ^0x3f) == 0 && ((int64(1)<<(_la-544))&7) != 0) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTableOptionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4756)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4755)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4758)
			p.TernaryOption()
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(4759)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTableOptionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserCHECKSUM_SYMBOL || _la == TiDBParserTABLE_CHECKSUM_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTableOptionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4761)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4760)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4763)
			p.Ulong_number()
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(4764)

			var _m = p.Match(TiDBParserDELAY_KEY_WRITE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4766)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4765)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4768)
			p.Ulong_number()
		}

	case 15:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(4769)

			var _m = p.Match(TiDBParserROW_FORMAT_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4771)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4770)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4773)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTableOptionContext).format = _lt

			_la = p.GetTokenStream().LA(1)

			if !(((int64((_la-78)) & ^0x3f) == 0 && ((int64(1)<<(_la-78))&1125899906842629) != 0) || _la == TiDBParserDYNAMIC_SYMBOL || _la == TiDBParserFIXED_SYMBOL || _la == TiDBParserREDUNDANT_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTableOptionContext).format = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 16:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(4774)

			var _m = p.Match(TiDBParserUNION_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4776)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4775)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4778)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4779)
			p.TableRefList()
		}
		{
			p.SetState(4780)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 17:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(4782)
			p.DefaultCharset()
		}

	case 18:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(4783)
			p.DefaultCollation()
		}

	case 19:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(4784)

			var _m = p.Match(TiDBParserINSERT_METHOD_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4786)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4785)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4788)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*CreateTableOptionContext).method = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserFIRST_SYMBOL || _la == TiDBParserLAST_SYMBOL || _la == TiDBParserNO_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*CreateTableOptionContext).method = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 20:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(4789)

			var _m = p.Match(TiDBParserDATA_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4790)
			p.Match(TiDBParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4792)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4791)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4794)
			p.TextString()
		}

	case 21:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(4795)

			var _m = p.Match(TiDBParserINDEX_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4796)
			p.Match(TiDBParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4798)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4797)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4800)
			p.TextString()
		}

	case 22:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(4801)

			var _m = p.Match(TiDBParserTABLESPACE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4806)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 635, p.GetParserRuleContext()) {
		case 1:
			p.SetState(4803)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserEQUAL_OPERATOR {
				{
					p.SetState(4802)
					p.Match(TiDBParserEQUAL_OPERATOR)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}

		case 2:

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}
		{
			p.SetState(4808)
			p.Identifier()
		}

	case 23:
		p.EnterOuterAlt(localctx, 23)
		{
			p.SetState(4809)

			var _m = p.Match(TiDBParserSTORAGE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4810)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserDISK_SYMBOL || _la == TiDBParserMEMORY_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 24:
		p.EnterOuterAlt(localctx, 24)
		{
			p.SetState(4811)

			var _m = p.Match(TiDBParserCONNECTION_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4813)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4812)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4815)
			p.TextString()
		}

	case 25:
		p.EnterOuterAlt(localctx, 25)
		{
			p.SetState(4816)

			var _m = p.Match(TiDBParserKEY_BLOCK_SIZE_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4818)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4817)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4820)
			p.Ulong_number()
		}

	case 26:
		p.EnterOuterAlt(localctx, 26)
		{
			p.SetState(4821)

			var _m = p.Match(TiDBParserSTART_SYMBOL)

			localctx.(*CreateTableOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4822)
			p.Match(TiDBParserTRANSACTION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITernaryOptionContext is an interface to support dynamic dispatch.
type ITernaryOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Ulong_number() IUlong_numberContext
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsTernaryOptionContext differentiates from other interfaces.
	IsTernaryOptionContext()
}

type TernaryOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTernaryOptionContext() *TernaryOptionContext {
	var p = new(TernaryOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ternaryOption
	return p
}

func InitEmptyTernaryOptionContext(p *TernaryOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ternaryOption
}

func (*TernaryOptionContext) IsTernaryOptionContext() {}

func NewTernaryOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TernaryOptionContext {
	var p = new(TernaryOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_ternaryOption

	return p
}

func (s *TernaryOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *TernaryOptionContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *TernaryOptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *TernaryOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TernaryOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TernaryOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTernaryOption(s)
	}
}

func (s *TernaryOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTernaryOption(s)
	}
}

func (s *TernaryOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTernaryOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TernaryOption() (localctx ITernaryOptionContext) {
	localctx = NewTernaryOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 562, TiDBParserRULE_ternaryOption)
	p.SetState(4827)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserHEX_NUMBER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4825)
			p.Ulong_number()
		}

	case TiDBParserDEFAULT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4826)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultCollationContext is an interface to support dynamic dispatch.
type IDefaultCollationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE_SYMBOL() antlr.TerminalNode
	CollationName() ICollationNameContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsDefaultCollationContext differentiates from other interfaces.
	IsDefaultCollationContext()
}

type DefaultCollationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultCollationContext() *DefaultCollationContext {
	var p = new(DefaultCollationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_defaultCollation
	return p
}

func InitEmptyDefaultCollationContext(p *DefaultCollationContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_defaultCollation
}

func (*DefaultCollationContext) IsDefaultCollationContext() {}

func NewDefaultCollationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultCollationContext {
	var p = new(DefaultCollationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_defaultCollation

	return p
}

func (s *DefaultCollationContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultCollationContext) COLLATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLLATE_SYMBOL, 0)
}

func (s *DefaultCollationContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *DefaultCollationContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *DefaultCollationContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *DefaultCollationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultCollationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultCollationContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDefaultCollation(s)
	}
}

func (s *DefaultCollationContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDefaultCollation(s)
	}
}

func (s *DefaultCollationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDefaultCollation(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DefaultCollation() (localctx IDefaultCollationContext) {
	localctx = NewDefaultCollationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 564, TiDBParserRULE_defaultCollation)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4830)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserDEFAULT_SYMBOL {
		{
			p.SetState(4829)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4832)
		p.Match(TiDBParserCOLLATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4834)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserEQUAL_OPERATOR {
		{
			p.SetState(4833)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4836)
		p.CollationName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultEncryptionContext is an interface to support dynamic dispatch.
type IDefaultEncryptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ENCRYPTION_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsDefaultEncryptionContext differentiates from other interfaces.
	IsDefaultEncryptionContext()
}

type DefaultEncryptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultEncryptionContext() *DefaultEncryptionContext {
	var p = new(DefaultEncryptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_defaultEncryption
	return p
}

func InitEmptyDefaultEncryptionContext(p *DefaultEncryptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_defaultEncryption
}

func (*DefaultEncryptionContext) IsDefaultEncryptionContext() {}

func NewDefaultEncryptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultEncryptionContext {
	var p = new(DefaultEncryptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_defaultEncryption

	return p
}

func (s *DefaultEncryptionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultEncryptionContext) ENCRYPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENCRYPTION_SYMBOL, 0)
}

func (s *DefaultEncryptionContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *DefaultEncryptionContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *DefaultEncryptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *DefaultEncryptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultEncryptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultEncryptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDefaultEncryption(s)
	}
}

func (s *DefaultEncryptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDefaultEncryption(s)
	}
}

func (s *DefaultEncryptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDefaultEncryption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DefaultEncryption() (localctx IDefaultEncryptionContext) {
	localctx = NewDefaultEncryptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 566, TiDBParserRULE_defaultEncryption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4839)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserDEFAULT_SYMBOL {
		{
			p.SetState(4838)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4841)
		p.Match(TiDBParserENCRYPTION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4843)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserEQUAL_OPERATOR {
		{
			p.SetState(4842)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4845)
		p.TextStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefaultCharsetContext is an interface to support dynamic dispatch.
type IDefaultCharsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Charset() ICharsetContext
	CharsetName() ICharsetNameContext
	DEFAULT_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode

	// IsDefaultCharsetContext differentiates from other interfaces.
	IsDefaultCharsetContext()
}

type DefaultCharsetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefaultCharsetContext() *DefaultCharsetContext {
	var p = new(DefaultCharsetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_defaultCharset
	return p
}

func InitEmptyDefaultCharsetContext(p *DefaultCharsetContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_defaultCharset
}

func (*DefaultCharsetContext) IsDefaultCharsetContext() {}

func NewDefaultCharsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefaultCharsetContext {
	var p = new(DefaultCharsetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_defaultCharset

	return p
}

func (s *DefaultCharsetContext) GetParser() antlr.Parser { return s.parser }

func (s *DefaultCharsetContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *DefaultCharsetContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *DefaultCharsetContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *DefaultCharsetContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *DefaultCharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefaultCharsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefaultCharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDefaultCharset(s)
	}
}

func (s *DefaultCharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDefaultCharset(s)
	}
}

func (s *DefaultCharsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDefaultCharset(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DefaultCharset() (localctx IDefaultCharsetContext) {
	localctx = NewDefaultCharsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 568, TiDBParserRULE_defaultCharset)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(4848)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserDEFAULT_SYMBOL {
		{
			p.SetState(4847)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4850)
		p.Charset()
	}
	p.SetState(4852)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserEQUAL_OPERATOR {
		{
			p.SetState(4851)
			p.Match(TiDBParserEQUAL_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(4854)
		p.CharsetName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionClauseContext is an interface to support dynamic dispatch.
type IPartitionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	PartitionTypeDef() IPartitionTypeDefContext
	PARTITIONS_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	SubPartitions() ISubPartitionsContext
	PartitionDefinitions() IPartitionDefinitionsContext

	// IsPartitionClauseContext differentiates from other interfaces.
	IsPartitionClauseContext()
}

type PartitionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionClauseContext() *PartitionClauseContext {
	var p = new(PartitionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionClause
	return p
}

func InitEmptyPartitionClauseContext(p *PartitionClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionClause
}

func (*PartitionClauseContext) IsPartitionClauseContext() {}

func NewPartitionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionClauseContext {
	var p = new(PartitionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_partitionClause

	return p
}

func (s *PartitionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionClauseContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITION_SYMBOL, 0)
}

func (s *PartitionClauseContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *PartitionClauseContext) PartitionTypeDef() IPartitionTypeDefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionTypeDefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionTypeDefContext)
}

func (s *PartitionClauseContext) PARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITIONS_SYMBOL, 0)
}

func (s *PartitionClauseContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *PartitionClauseContext) SubPartitions() ISubPartitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubPartitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubPartitionsContext)
}

func (s *PartitionClauseContext) PartitionDefinitions() IPartitionDefinitionsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionsContext)
}

func (s *PartitionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionClause(s)
	}
}

func (s *PartitionClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionClause(s)
	}
}

func (s *PartitionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PartitionClause() (localctx IPartitionClauseContext) {
	localctx = NewPartitionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 570, TiDBParserRULE_partitionClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4856)
		p.Match(TiDBParserPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4857)
		p.Match(TiDBParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4858)
		p.PartitionTypeDef()
	}
	p.SetState(4861)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserPARTITIONS_SYMBOL {
		{
			p.SetState(4859)
			p.Match(TiDBParserPARTITIONS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4860)
			p.Real_ulong_number()
		}

	}
	p.SetState(4864)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserSUBPARTITION_SYMBOL {
		{
			p.SetState(4863)
			p.SubPartitions()
		}

	}
	p.SetState(4867)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserOPEN_PAR_SYMBOL {
		{
			p.SetState(4866)
			p.PartitionDefinitions()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionTypeDefContext is an interface to support dynamic dispatch.
type IPartitionTypeDefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPartitionTypeDefContext differentiates from other interfaces.
	IsPartitionTypeDefContext()
}

type PartitionTypeDefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionTypeDefContext() *PartitionTypeDefContext {
	var p = new(PartitionTypeDefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionTypeDef
	return p
}

func InitEmptyPartitionTypeDefContext(p *PartitionTypeDefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionTypeDef
}

func (*PartitionTypeDefContext) IsPartitionTypeDefContext() {}

func NewPartitionTypeDefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionTypeDefContext {
	var p = new(PartitionTypeDefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_partitionTypeDef

	return p
}

func (s *PartitionTypeDefContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionTypeDefContext) CopyAll(ctx *PartitionTypeDefContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *PartitionTypeDefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionTypeDefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

type PartitionDefRangeListContext struct {
	PartitionTypeDefContext
}

func NewPartitionDefRangeListContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionDefRangeListContext {
	var p = new(PartitionDefRangeListContext)

	InitEmptyPartitionTypeDefContext(&p.PartitionTypeDefContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionTypeDefContext))

	return p
}

func (s *PartitionDefRangeListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefRangeListContext) RANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRANGE_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) LIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLIST_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PartitionDefRangeListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMNS_SYMBOL, 0)
}

func (s *PartitionDefRangeListContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionDefRangeListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionDefRangeList(s)
	}
}

func (s *PartitionDefRangeListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionDefRangeList(s)
	}
}

func (s *PartitionDefRangeListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionDefRangeList(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionDefKeyContext struct {
	PartitionTypeDefContext
}

func NewPartitionDefKeyContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionDefKeyContext {
	var p = new(PartitionDefKeyContext)

	InitEmptyPartitionTypeDefContext(&p.PartitionTypeDefContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionTypeDefContext))

	return p
}

func (s *PartitionDefKeyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefKeyContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_SYMBOL, 0)
}

func (s *PartitionDefKeyContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefKeyContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefKeyContext) LINEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLINEAR_SYMBOL, 0)
}

func (s *PartitionDefKeyContext) PartitionKeyAlgorithm() IPartitionKeyAlgorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyAlgorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyAlgorithmContext)
}

func (s *PartitionDefKeyContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *PartitionDefKeyContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionDefKey(s)
	}
}

func (s *PartitionDefKeyContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionDefKey(s)
	}
}

func (s *PartitionDefKeyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionDefKey(s)

	default:
		return t.VisitChildren(s)
	}
}

type PartitionDefHashContext struct {
	PartitionTypeDefContext
}

func NewPartitionDefHashContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PartitionDefHashContext {
	var p = new(PartitionDefHashContext)

	InitEmptyPartitionTypeDefContext(&p.PartitionTypeDefContext)
	p.parser = parser
	p.CopyAll(ctx.(*PartitionTypeDefContext))

	return p
}

func (s *PartitionDefHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefHashContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHASH_SYMBOL, 0)
}

func (s *PartitionDefHashContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefHashContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PartitionDefHashContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefHashContext) LINEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLINEAR_SYMBOL, 0)
}

func (s *PartitionDefHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionDefHash(s)
	}
}

func (s *PartitionDefHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionDefHash(s)
	}
}

func (s *PartitionDefHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionDefHash(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PartitionTypeDef() (localctx IPartitionTypeDefContext) {
	localctx = NewPartitionTypeDefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 572, TiDBParserRULE_partitionTypeDef)
	var _la int

	p.SetState(4902)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 655, p.GetParserRuleContext()) {
	case 1:
		localctx = NewPartitionDefKeyContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(4870)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLINEAR_SYMBOL {
			{
				p.SetState(4869)
				p.Match(TiDBParserLINEAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4872)
			p.Match(TiDBParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4874)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserALGORITHM_SYMBOL {
			{
				p.SetState(4873)
				p.PartitionKeyAlgorithm()
			}

		}
		{
			p.SetState(4876)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4878)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871848468) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
			{
				p.SetState(4877)
				p.IdentifierList()
			}

		}
		{
			p.SetState(4880)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 2:
		localctx = NewPartitionDefHashContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4882)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserLINEAR_SYMBOL {
			{
				p.SetState(4881)
				p.Match(TiDBParserLINEAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4884)
			p.Match(TiDBParserHASH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4885)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4886)
			p.bitExpr(0)
		}
		{
			p.SetState(4887)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		localctx = NewPartitionDefRangeListContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(4889)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserLIST_SYMBOL || _la == TiDBParserRANGE_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(4900)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserOPEN_PAR_SYMBOL:
			{
				p.SetState(4890)
				p.Match(TiDBParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4891)
				p.bitExpr(0)
			}
			{
				p.SetState(4892)
				p.Match(TiDBParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case TiDBParserCOLUMNS_SYMBOL:
			{
				p.SetState(4894)
				p.Match(TiDBParserCOLUMNS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4895)
				p.Match(TiDBParserOPEN_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(4897)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871848468) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
				{
					p.SetState(4896)
					p.IdentifierList()
				}

			}
			{
				p.SetState(4899)
				p.Match(TiDBParserCLOSE_PAR_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubPartitionsContext is an interface to support dynamic dispatch.
type ISubPartitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	HASH_SYMBOL() antlr.TerminalNode
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	BitExpr() IBitExprContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	KEY_SYMBOL() antlr.TerminalNode
	IdentifierListWithParentheses() IIdentifierListWithParenthesesContext
	LINEAR_SYMBOL() antlr.TerminalNode
	SUBPARTITIONS_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	PartitionKeyAlgorithm() IPartitionKeyAlgorithmContext

	// IsSubPartitionsContext differentiates from other interfaces.
	IsSubPartitionsContext()
}

type SubPartitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubPartitionsContext() *SubPartitionsContext {
	var p = new(SubPartitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_subPartitions
	return p
}

func InitEmptySubPartitionsContext(p *SubPartitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_subPartitions
}

func (*SubPartitionsContext) IsSubPartitionsContext() {}

func NewSubPartitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubPartitionsContext {
	var p = new(SubPartitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_subPartitions

	return p
}

func (s *SubPartitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *SubPartitionsContext) SUBPARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBPARTITION_SYMBOL, 0)
}

func (s *SubPartitionsContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *SubPartitionsContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHASH_SYMBOL, 0)
}

func (s *SubPartitionsContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SubPartitionsContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *SubPartitionsContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SubPartitionsContext) KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_SYMBOL, 0)
}

func (s *SubPartitionsContext) IdentifierListWithParentheses() IIdentifierListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListWithParenthesesContext)
}

func (s *SubPartitionsContext) LINEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLINEAR_SYMBOL, 0)
}

func (s *SubPartitionsContext) SUBPARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBPARTITIONS_SYMBOL, 0)
}

func (s *SubPartitionsContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *SubPartitionsContext) PartitionKeyAlgorithm() IPartitionKeyAlgorithmContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionKeyAlgorithmContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionKeyAlgorithmContext)
}

func (s *SubPartitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubPartitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubPartitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSubPartitions(s)
	}
}

func (s *SubPartitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSubPartitions(s)
	}
}

func (s *SubPartitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSubPartitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SubPartitions() (localctx ISubPartitionsContext) {
	localctx = NewSubPartitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 574, TiDBParserRULE_subPartitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4904)
		p.Match(TiDBParserSUBPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4905)
		p.Match(TiDBParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(4907)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserLINEAR_SYMBOL {
		{
			p.SetState(4906)
			p.Match(TiDBParserLINEAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	p.SetState(4919)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserHASH_SYMBOL:
		{
			p.SetState(4909)
			p.Match(TiDBParserHASH_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4910)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4911)
			p.bitExpr(0)
		}
		{
			p.SetState(4912)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserKEY_SYMBOL:
		{
			p.SetState(4914)
			p.Match(TiDBParserKEY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserALGORITHM_SYMBOL {
			{
				p.SetState(4915)
				p.PartitionKeyAlgorithm()
			}

		}
		{
			p.SetState(4918)
			p.IdentifierListWithParentheses()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(4923)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserSUBPARTITIONS_SYMBOL {
		{
			p.SetState(4921)
			p.Match(TiDBParserSUBPARTITIONS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4922)
			p.Real_ulong_number()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionKeyAlgorithmContext is an interface to support dynamic dispatch.
type IPartitionKeyAlgorithmContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ALGORITHM_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext

	// IsPartitionKeyAlgorithmContext differentiates from other interfaces.
	IsPartitionKeyAlgorithmContext()
}

type PartitionKeyAlgorithmContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionKeyAlgorithmContext() *PartitionKeyAlgorithmContext {
	var p = new(PartitionKeyAlgorithmContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionKeyAlgorithm
	return p
}

func InitEmptyPartitionKeyAlgorithmContext(p *PartitionKeyAlgorithmContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionKeyAlgorithm
}

func (*PartitionKeyAlgorithmContext) IsPartitionKeyAlgorithmContext() {}

func NewPartitionKeyAlgorithmContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionKeyAlgorithmContext {
	var p = new(PartitionKeyAlgorithmContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_partitionKeyAlgorithm

	return p
}

func (s *PartitionKeyAlgorithmContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionKeyAlgorithmContext) ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALGORITHM_SYMBOL, 0)
}

func (s *PartitionKeyAlgorithmContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *PartitionKeyAlgorithmContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *PartitionKeyAlgorithmContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionKeyAlgorithmContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionKeyAlgorithmContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionKeyAlgorithm(s)
	}
}

func (s *PartitionKeyAlgorithmContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionKeyAlgorithm(s)
	}
}

func (s *PartitionKeyAlgorithmContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionKeyAlgorithm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PartitionKeyAlgorithm() (localctx IPartitionKeyAlgorithmContext) {
	localctx = NewPartitionKeyAlgorithmContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 576, TiDBParserRULE_partitionKeyAlgorithm)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4925)
		p.Match(TiDBParserALGORITHM_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4926)
		p.Match(TiDBParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4927)
		p.Real_ulong_number()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionsContext is an interface to support dynamic dispatch.
type IPartitionDefinitionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllPartitionDefinition() []IPartitionDefinitionContext
	PartitionDefinition(i int) IPartitionDefinitionContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartitionDefinitionsContext differentiates from other interfaces.
	IsPartitionDefinitionsContext()
}

type PartitionDefinitionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionsContext() *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionDefinitions
	return p
}

func InitEmptyPartitionDefinitionsContext(p *PartitionDefinitionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionDefinitions
}

func (*PartitionDefinitionsContext) IsPartitionDefinitionsContext() {}

func NewPartitionDefinitionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionsContext {
	var p = new(PartitionDefinitionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_partitionDefinitions

	return p
}

func (s *PartitionDefinitionsContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionsContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefinitionsContext) AllPartitionDefinition() []IPartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionDefinitionContext); ok {
			tst[i] = t.(IPartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionsContext) PartitionDefinition(i int) IPartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionDefinitionContext)
}

func (s *PartitionDefinitionsContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefinitionsContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *PartitionDefinitionsContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *PartitionDefinitionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionDefinitions(s)
	}
}

func (s *PartitionDefinitionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionDefinitions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PartitionDefinitions() (localctx IPartitionDefinitionsContext) {
	localctx = NewPartitionDefinitionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 578, TiDBParserRULE_partitionDefinitions)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4929)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4930)
		p.PartitionDefinition()
	}
	p.SetState(4935)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(4931)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4932)
			p.PartitionDefinition()
		}

		p.SetState(4937)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(4938)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionDefinitionContext is an interface to support dynamic dispatch.
type IPartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext
	VALUES_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	THAN_SYMBOL() antlr.TerminalNode
	IN_SYMBOL() antlr.TerminalNode
	PartitionValuesIn() IPartitionValuesInContext
	AllPartitionOption() []IPartitionOptionContext
	PartitionOption(i int) IPartitionOptionContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllSubpartitionDefinition() []ISubpartitionDefinitionContext
	SubpartitionDefinition(i int) ISubpartitionDefinitionContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	PartitionValueItemListParen() IPartitionValueItemListParenContext
	MAXVALUE_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartitionDefinitionContext differentiates from other interfaces.
	IsPartitionDefinitionContext()
}

type PartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionDefinitionContext() *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionDefinition
	return p
}

func InitEmptyPartitionDefinitionContext(p *PartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionDefinition
}

func (*PartitionDefinitionContext) IsPartitionDefinitionContext() {}

func NewPartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionDefinitionContext {
	var p = new(PartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_partitionDefinition

	return p
}

func (s *PartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionDefinitionContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITION_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionDefinitionContext) VALUES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVALUES_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLESS_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) THAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTHAN_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIN_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) PartitionValuesIn() IPartitionValuesInContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValuesInContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValuesInContext)
}

func (s *PartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *PartitionDefinitionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) AllSubpartitionDefinition() []ISubpartitionDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ISubpartitionDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISubpartitionDefinitionContext); ok {
			tst[i] = t.(ISubpartitionDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *PartitionDefinitionContext) SubpartitionDefinition(i int) ISubpartitionDefinitionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISubpartitionDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISubpartitionDefinitionContext)
}

func (s *PartitionDefinitionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) PartitionValueItemListParen() IPartitionValueItemListParenContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueItemListParenContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueItemListParenContext)
}

func (s *PartitionDefinitionContext) MAXVALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAXVALUE_SYMBOL, 0)
}

func (s *PartitionDefinitionContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *PartitionDefinitionContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *PartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionDefinition(s)
	}
}

func (s *PartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionDefinition(s)
	}
}

func (s *PartitionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PartitionDefinition() (localctx IPartitionDefinitionContext) {
	localctx = NewPartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 580, TiDBParserRULE_partitionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(4940)
		p.Match(TiDBParserPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(4941)
		p.Identifier()
	}
	p.SetState(4952)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 662, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(4942)
			p.Match(TiDBParserVALUES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4943)
			p.Match(TiDBParserLESS_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4944)
			p.Match(TiDBParserTHAN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4947)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserOPEN_PAR_SYMBOL:
			{
				p.SetState(4945)
				p.PartitionValueItemListParen()
			}

		case TiDBParserMAXVALUE_SYMBOL:
			{
				p.SetState(4946)
				p.Match(TiDBParserMAXVALUE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 662, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(4949)
			p.Match(TiDBParserVALUES_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4950)
			p.Match(TiDBParserIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4951)
			p.PartitionValuesIn()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}
	p.SetState(4957)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMENT_SYMBOL || _la == TiDBParserDATA_SYMBOL || _la == TiDBParserENGINE_SYMBOL || _la == TiDBParserINDEX_SYMBOL || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&35184374185985) != 0) || _la == TiDBParserSTORAGE_SYMBOL || _la == TiDBParserTABLESPACE_SYMBOL {
		{
			p.SetState(4954)
			p.PartitionOption()
		}

		p.SetState(4959)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(4971)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserOPEN_PAR_SYMBOL {
		{
			p.SetState(4960)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4961)
			p.SubpartitionDefinition()
		}
		p.SetState(4966)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(4962)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4963)
				p.SubpartitionDefinition()
			}

			p.SetState(4968)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4969)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValuesInContext is an interface to support dynamic dispatch.
type IPartitionValuesInContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllPartitionValueItemListParen() []IPartitionValueItemListParenContext
	PartitionValueItemListParen(i int) IPartitionValueItemListParenContext
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartitionValuesInContext differentiates from other interfaces.
	IsPartitionValuesInContext()
}

type PartitionValuesInContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValuesInContext() *PartitionValuesInContext {
	var p = new(PartitionValuesInContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionValuesIn
	return p
}

func InitEmptyPartitionValuesInContext(p *PartitionValuesInContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionValuesIn
}

func (*PartitionValuesInContext) IsPartitionValuesInContext() {}

func NewPartitionValuesInContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValuesInContext {
	var p = new(PartitionValuesInContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_partitionValuesIn

	return p
}

func (s *PartitionValuesInContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValuesInContext) AllPartitionValueItemListParen() []IPartitionValueItemListParenContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueItemListParenContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueItemListParenContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueItemListParenContext); ok {
			tst[i] = t.(IPartitionValueItemListParenContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValuesInContext) PartitionValueItemListParen(i int) IPartitionValueItemListParenContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueItemListParenContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueItemListParenContext)
}

func (s *PartitionValuesInContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionValuesInContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionValuesInContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *PartitionValuesInContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *PartitionValuesInContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValuesInContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValuesInContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionValuesIn(s)
	}
}

func (s *PartitionValuesInContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionValuesIn(s)
	}
}

func (s *PartitionValuesInContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionValuesIn(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PartitionValuesIn() (localctx IPartitionValuesInContext) {
	localctx = NewPartitionValuesInContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 582, TiDBParserRULE_partitionValuesIn)
	var _la int

	p.SetState(4985)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 667, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4973)
			p.PartitionValueItemListParen()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(4974)
			p.Match(TiDBParserOPEN_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(4975)
			p.PartitionValueItemListParen()
		}
		p.SetState(4980)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		for _la == TiDBParserCOMMA_SYMBOL {
			{
				p.SetState(4976)
				p.Match(TiDBParserCOMMA_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(4977)
				p.PartitionValueItemListParen()
			}

			p.SetState(4982)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(4983)
			p.Match(TiDBParserCLOSE_PAR_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionOptionContext is an interface to support dynamic dispatch.
type IPartitionOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetOption returns the option token.
	GetOption() antlr.Token

	// SetOption sets the option token.
	SetOption(antlr.Token)

	// Getter signatures
	Identifier() IIdentifierContext
	TABLESPACE_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	EngineRef() IEngineRefContext
	ENGINE_SYMBOL() antlr.TerminalNode
	STORAGE_SYMBOL() antlr.TerminalNode
	Real_ulong_number() IReal_ulong_numberContext
	NODEGROUP_SYMBOL() antlr.TerminalNode
	MAX_ROWS_SYMBOL() antlr.TerminalNode
	MIN_ROWS_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	TextLiteral() ITextLiteralContext
	DATA_SYMBOL() antlr.TerminalNode
	INDEX_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode

	// IsPartitionOptionContext differentiates from other interfaces.
	IsPartitionOptionContext()
}

type PartitionOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	option antlr.Token
}

func NewEmptyPartitionOptionContext() *PartitionOptionContext {
	var p = new(PartitionOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionOption
	return p
}

func InitEmptyPartitionOptionContext(p *PartitionOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionOption
}

func (*PartitionOptionContext) IsPartitionOptionContext() {}

func NewPartitionOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionOptionContext {
	var p = new(PartitionOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_partitionOption

	return p
}

func (s *PartitionOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionOptionContext) GetOption() antlr.Token { return s.option }

func (s *PartitionOptionContext) SetOption(v antlr.Token) { s.option = v }

func (s *PartitionOptionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PartitionOptionContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLESPACE_SYMBOL, 0)
}

func (s *PartitionOptionContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *PartitionOptionContext) EngineRef() IEngineRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IEngineRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IEngineRefContext)
}

func (s *PartitionOptionContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENGINE_SYMBOL, 0)
}

func (s *PartitionOptionContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTORAGE_SYMBOL, 0)
}

func (s *PartitionOptionContext) Real_ulong_number() IReal_ulong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulong_numberContext)
}

func (s *PartitionOptionContext) NODEGROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNODEGROUP_SYMBOL, 0)
}

func (s *PartitionOptionContext) MAX_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_ROWS_SYMBOL, 0)
}

func (s *PartitionOptionContext) MIN_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMIN_ROWS_SYMBOL, 0)
}

func (s *PartitionOptionContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIRECTORY_SYMBOL, 0)
}

func (s *PartitionOptionContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *PartitionOptionContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATA_SYMBOL, 0)
}

func (s *PartitionOptionContext) INDEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINDEX_SYMBOL, 0)
}

func (s *PartitionOptionContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMENT_SYMBOL, 0)
}

func (s *PartitionOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionOption(s)
	}
}

func (s *PartitionOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionOption(s)
	}
}

func (s *PartitionOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PartitionOption() (localctx IPartitionOptionContext) {
	localctx = NewPartitionOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 584, TiDBParserRULE_partitionOption)
	var _la int

	p.SetState(5021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserTABLESPACE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(4987)

			var _m = p.Match(TiDBParserTABLESPACE_SYMBOL)

			localctx.(*PartitionOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4989)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4988)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4991)
			p.Identifier()
		}

	case TiDBParserENGINE_SYMBOL, TiDBParserSTORAGE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(4993)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserSTORAGE_SYMBOL {
			{
				p.SetState(4992)
				p.Match(TiDBParserSTORAGE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4995)

			var _m = p.Match(TiDBParserENGINE_SYMBOL)

			localctx.(*PartitionOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(4997)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(4996)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(4999)
			p.EngineRef()
		}

	case TiDBParserNODEGROUP_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5000)

			var _m = p.Match(TiDBParserNODEGROUP_SYMBOL)

			localctx.(*PartitionOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5002)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(5001)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5004)
			p.Real_ulong_number()
		}

	case TiDBParserMAX_ROWS_SYMBOL, TiDBParserMIN_ROWS_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5005)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PartitionOptionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserMAX_ROWS_SYMBOL || _la == TiDBParserMIN_ROWS_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PartitionOptionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(5007)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(5006)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5009)
			p.Real_ulong_number()
		}

	case TiDBParserDATA_SYMBOL, TiDBParserINDEX_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5010)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*PartitionOptionContext).option = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserDATA_SYMBOL || _la == TiDBParserINDEX_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*PartitionOptionContext).option = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(5011)
			p.Match(TiDBParserDIRECTORY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5013)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(5012)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5015)
			p.TextLiteral()
		}

	case TiDBParserCOMMENT_SYMBOL:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(5016)

			var _m = p.Match(TiDBParserCOMMENT_SYMBOL)

			localctx.(*PartitionOptionContext).option = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5018)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserEQUAL_OPERATOR {
			{
				p.SetState(5017)
				p.Match(TiDBParserEQUAL_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5020)
			p.TextLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISubpartitionDefinitionContext is an interface to support dynamic dispatch.
type ISubpartitionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SUBPARTITION_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	AllPartitionOption() []IPartitionOptionContext
	PartitionOption(i int) IPartitionOptionContext

	// IsSubpartitionDefinitionContext differentiates from other interfaces.
	IsSubpartitionDefinitionContext()
}

type SubpartitionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySubpartitionDefinitionContext() *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_subpartitionDefinition
	return p
}

func InitEmptySubpartitionDefinitionContext(p *SubpartitionDefinitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_subpartitionDefinition
}

func (*SubpartitionDefinitionContext) IsSubpartitionDefinitionContext() {}

func NewSubpartitionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SubpartitionDefinitionContext {
	var p = new(SubpartitionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_subpartitionDefinition

	return p
}

func (s *SubpartitionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *SubpartitionDefinitionContext) SUBPARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBPARTITION_SYMBOL, 0)
}

func (s *SubpartitionDefinitionContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *SubpartitionDefinitionContext) AllPartitionOption() []IPartitionOptionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			len++
		}
	}

	tst := make([]IPartitionOptionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionOptionContext); ok {
			tst[i] = t.(IPartitionOptionContext)
			i++
		}
	}

	return tst
}

func (s *SubpartitionDefinitionContext) PartitionOption(i int) IPartitionOptionContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionOptionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionOptionContext)
}

func (s *SubpartitionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SubpartitionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SubpartitionDefinitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSubpartitionDefinition(s)
	}
}

func (s *SubpartitionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSubpartitionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SubpartitionDefinition() (localctx ISubpartitionDefinitionContext) {
	localctx = NewSubpartitionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 586, TiDBParserRULE_subpartitionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5023)
		p.Match(TiDBParserSUBPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5024)
		p.TextOrIdentifier()
	}
	p.SetState(5028)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMENT_SYMBOL || _la == TiDBParserDATA_SYMBOL || _la == TiDBParserENGINE_SYMBOL || _la == TiDBParserINDEX_SYMBOL || ((int64((_la-323)) & ^0x3f) == 0 && ((int64(1)<<(_la-323))&35184374185985) != 0) || _la == TiDBParserSTORAGE_SYMBOL || _la == TiDBParserTABLESPACE_SYMBOL {
		{
			p.SetState(5025)
			p.PartitionOption()
		}

		p.SetState(5030)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueItemListParenContext is an interface to support dynamic dispatch.
type IPartitionValueItemListParenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllPartitionValueItem() []IPartitionValueItemContext
	PartitionValueItem(i int) IPartitionValueItemContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsPartitionValueItemListParenContext differentiates from other interfaces.
	IsPartitionValueItemListParenContext()
}

type PartitionValueItemListParenContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueItemListParenContext() *PartitionValueItemListParenContext {
	var p = new(PartitionValueItemListParenContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionValueItemListParen
	return p
}

func InitEmptyPartitionValueItemListParenContext(p *PartitionValueItemListParenContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionValueItemListParen
}

func (*PartitionValueItemListParenContext) IsPartitionValueItemListParenContext() {}

func NewPartitionValueItemListParenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueItemListParenContext {
	var p = new(PartitionValueItemListParenContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_partitionValueItemListParen

	return p
}

func (s *PartitionValueItemListParenContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueItemListParenContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *PartitionValueItemListParenContext) AllPartitionValueItem() []IPartitionValueItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IPartitionValueItemContext); ok {
			len++
		}
	}

	tst := make([]IPartitionValueItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IPartitionValueItemContext); ok {
			tst[i] = t.(IPartitionValueItemContext)
			i++
		}
	}

	return tst
}

func (s *PartitionValueItemListParenContext) PartitionValueItem(i int) IPartitionValueItemContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPartitionValueItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPartitionValueItemContext)
}

func (s *PartitionValueItemListParenContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PartitionValueItemListParenContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *PartitionValueItemListParenContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *PartitionValueItemListParenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueItemListParenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueItemListParenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionValueItemListParen(s)
	}
}

func (s *PartitionValueItemListParenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionValueItemListParen(s)
	}
}

func (s *PartitionValueItemListParenContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionValueItemListParen(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PartitionValueItemListParen() (localctx IPartitionValueItemListParenContext) {
	localctx = NewPartitionValueItemListParenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 588, TiDBParserRULE_partitionValueItemListParen)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5031)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5032)
		p.PartitionValueItem()
	}
	p.SetState(5037)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5033)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5034)
			p.PartitionValueItem()
		}

		p.SetState(5039)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5040)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPartitionValueItemContext is an interface to support dynamic dispatch.
type IPartitionValueItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BitExpr() IBitExprContext
	MAXVALUE_SYMBOL() antlr.TerminalNode

	// IsPartitionValueItemContext differentiates from other interfaces.
	IsPartitionValueItemContext()
}

type PartitionValueItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPartitionValueItemContext() *PartitionValueItemContext {
	var p = new(PartitionValueItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionValueItem
	return p
}

func InitEmptyPartitionValueItemContext(p *PartitionValueItemContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_partitionValueItem
}

func (*PartitionValueItemContext) IsPartitionValueItemContext() {}

func NewPartitionValueItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PartitionValueItemContext {
	var p = new(PartitionValueItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_partitionValueItem

	return p
}

func (s *PartitionValueItemContext) GetParser() antlr.Parser { return s.parser }

func (s *PartitionValueItemContext) BitExpr() IBitExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBitExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBitExprContext)
}

func (s *PartitionValueItemContext) MAXVALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAXVALUE_SYMBOL, 0)
}

func (s *PartitionValueItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PartitionValueItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PartitionValueItemContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPartitionValueItem(s)
	}
}

func (s *PartitionValueItemContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPartitionValueItem(s)
	}
}

func (s *PartitionValueItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPartitionValueItem(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PartitionValueItem() (localctx IPartitionValueItemContext) {
	localctx = NewPartitionValueItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 590, TiDBParserRULE_partitionValueItem)
	p.SetState(5044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINARY_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_AND_SYMBOL, TiDBParserBIT_OR_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBIT_XOR_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCASE_SYMBOL, TiDBParserCAST_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHAR_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCONVERT_SYMBOL, TiDBParserCOUNT_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURDATE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURRENT_USER_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserCURTIME_SYMBOL, TiDBParserDATABASE_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_ADD_SYMBOL, TiDBParserDATE_SUB_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXISTS_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserEXTRACT_SYMBOL, TiDBParserFALSE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserGROUP_CONCAT_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIF_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINTERVAL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLEFT_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMATCH_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMIN_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMOD_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNOW_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNULL_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPOSITION_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPEAT_SYMBOL, TiDBParserREPLACE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserRIGHT_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTDDEV_SAMP_SYMBOL, TiDBParserSTD_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUBSTRING_SYMBOL, TiDBParserSUM_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserSYSDATE_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRIM_SYMBOL, TiDBParserTRUE_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserUTC_DATE_SYMBOL, TiDBParserUTC_TIMESTAMP_SYMBOL, TiDBParserUTC_TIME_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUES_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVARIANCE_SYMBOL, TiDBParserVAR_SAMP_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserJSON_OBJECTAGG_SYMBOL, TiDBParserJSON_ARRAYAGG_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserGROUPING_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserCUME_DIST_SYMBOL, TiDBParserDENSE_RANK_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFIRST_VALUE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserLAG_SYMBOL, TiDBParserLAST_VALUE_SYMBOL, TiDBParserLEAD_SYMBOL, TiDBParserNTH_VALUE_SYMBOL, TiDBParserNTILE_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPERCENT_RANK_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRANK_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserROW_NUMBER_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserNOT2_SYMBOL, TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserPLUS_OPERATOR, TiDBParserMINUS_OPERATOR, TiDBParserLOGICAL_NOT_OPERATOR, TiDBParserBITWISE_NOT_OPERATOR, TiDBParserDOT_SYMBOL, TiDBParserOPEN_PAR_SYMBOL, TiDBParserOPEN_CURLY_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserAT_SIGN_SYMBOL, TiDBParserAT_TEXT_SUFFIX, TiDBParserAT_AT_SIGN_SYMBOL, TiDBParserNULL2_SYMBOL, TiDBParserPARAM_MARKER, TiDBParserHEX_NUMBER, TiDBParserBIN_NUMBER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserUNDERSCORE_CHARSET, TiDBParserIDENTIFIER, TiDBParserNCHAR_TEXT, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5042)
			p.bitExpr(0)
		}

	case TiDBParserMAXVALUE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5043)
			p.Match(TiDBParserMAXVALUE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDefinerClauseContext is an interface to support dynamic dispatch.
type IDefinerClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DEFINER_SYMBOL() antlr.TerminalNode
	EQUAL_OPERATOR() antlr.TerminalNode
	User() IUserContext

	// IsDefinerClauseContext differentiates from other interfaces.
	IsDefinerClauseContext()
}

type DefinerClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinerClauseContext() *DefinerClauseContext {
	var p = new(DefinerClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_definerClause
	return p
}

func InitEmptyDefinerClauseContext(p *DefinerClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_definerClause
}

func (*DefinerClauseContext) IsDefinerClauseContext() {}

func NewDefinerClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinerClauseContext {
	var p = new(DefinerClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_definerClause

	return p
}

func (s *DefinerClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinerClauseContext) DEFINER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFINER_SYMBOL, 0)
}

func (s *DefinerClauseContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *DefinerClauseContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *DefinerClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinerClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DefinerClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDefinerClause(s)
	}
}

func (s *DefinerClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDefinerClause(s)
	}
}

func (s *DefinerClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDefinerClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DefinerClause() (localctx IDefinerClauseContext) {
	localctx = NewDefinerClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 592, TiDBParserRULE_definerClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5046)
		p.Match(TiDBParserDEFINER_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5047)
		p.Match(TiDBParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5048)
		p.User()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfExistsContext is an interface to support dynamic dispatch.
type IIfExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF_SYMBOL() antlr.TerminalNode
	EXISTS_SYMBOL() antlr.TerminalNode

	// IsIfExistsContext differentiates from other interfaces.
	IsIfExistsContext()
}

type IfExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfExistsContext() *IfExistsContext {
	var p = new(IfExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ifExists
	return p
}

func InitEmptyIfExistsContext(p *IfExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ifExists
}

func (*IfExistsContext) IsIfExistsContext() {}

func NewIfExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfExistsContext {
	var p = new(IfExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_ifExists

	return p
}

func (s *IfExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfExistsContext) IF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIF_SYMBOL, 0)
}

func (s *IfExistsContext) EXISTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXISTS_SYMBOL, 0)
}

func (s *IfExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIfExists(s)
	}
}

func (s *IfExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIfExists(s)
	}
}

func (s *IfExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIfExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IfExists() (localctx IIfExistsContext) {
	localctx = NewIfExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 594, TiDBParserRULE_ifExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5050)
		p.Match(TiDBParserIF_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5051)
		p.Match(TiDBParserEXISTS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIfNotExistsContext is an interface to support dynamic dispatch.
type IIfNotExistsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IF_SYMBOL() antlr.TerminalNode
	NotRule() INotRuleContext
	EXISTS_SYMBOL() antlr.TerminalNode

	// IsIfNotExistsContext differentiates from other interfaces.
	IsIfNotExistsContext()
}

type IfNotExistsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIfNotExistsContext() *IfNotExistsContext {
	var p = new(IfNotExistsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ifNotExists
	return p
}

func InitEmptyIfNotExistsContext(p *IfNotExistsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ifNotExists
}

func (*IfNotExistsContext) IsIfNotExistsContext() {}

func NewIfNotExistsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IfNotExistsContext {
	var p = new(IfNotExistsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_ifNotExists

	return p
}

func (s *IfNotExistsContext) GetParser() antlr.Parser { return s.parser }

func (s *IfNotExistsContext) IF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIF_SYMBOL, 0)
}

func (s *IfNotExistsContext) NotRule() INotRuleContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INotRuleContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INotRuleContext)
}

func (s *IfNotExistsContext) EXISTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXISTS_SYMBOL, 0)
}

func (s *IfNotExistsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfNotExistsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IfNotExistsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIfNotExists(s)
	}
}

func (s *IfNotExistsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIfNotExists(s)
	}
}

func (s *IfNotExistsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIfNotExists(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IfNotExists() (localctx IIfNotExistsContext) {
	localctx = NewIfNotExistsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 596, TiDBParserRULE_ifNotExists)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5053)
		p.Match(TiDBParserIF_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5054)
		p.NotRule()
	}
	{
		p.SetState(5055)
		p.Match(TiDBParserEXISTS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureParameterContext is an interface to support dynamic dispatch.
type IProcedureParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetType_ returns the type_ token.
	GetType_() antlr.Token

	// SetType_ sets the type_ token.
	SetType_(antlr.Token)

	// Getter signatures
	FunctionParameter() IFunctionParameterContext
	IN_SYMBOL() antlr.TerminalNode
	OUT_SYMBOL() antlr.TerminalNode
	INOUT_SYMBOL() antlr.TerminalNode

	// IsProcedureParameterContext differentiates from other interfaces.
	IsProcedureParameterContext()
}

type ProcedureParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	type_  antlr.Token
}

func NewEmptyProcedureParameterContext() *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_procedureParameter
	return p
}

func InitEmptyProcedureParameterContext(p *ProcedureParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_procedureParameter
}

func (*ProcedureParameterContext) IsProcedureParameterContext() {}

func NewProcedureParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureParameterContext {
	var p = new(ProcedureParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_procedureParameter

	return p
}

func (s *ProcedureParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureParameterContext) GetType_() antlr.Token { return s.type_ }

func (s *ProcedureParameterContext) SetType_(v antlr.Token) { s.type_ = v }

func (s *ProcedureParameterContext) FunctionParameter() IFunctionParameterContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionParameterContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionParameterContext)
}

func (s *ProcedureParameterContext) IN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIN_SYMBOL, 0)
}

func (s *ProcedureParameterContext) OUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOUT_SYMBOL, 0)
}

func (s *ProcedureParameterContext) INOUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINOUT_SYMBOL, 0)
}

func (s *ProcedureParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitProcedureParameter(s)
	}
}

func (s *ProcedureParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitProcedureParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ProcedureParameter() (localctx IProcedureParameterContext) {
	localctx = NewProcedureParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 598, TiDBParserRULE_procedureParameter)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5058)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserINOUT_SYMBOL || _la == TiDBParserIN_SYMBOL || _la == TiDBParserOUT_SYMBOL {
		{
			p.SetState(5057)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ProcedureParameterContext).type_ = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserINOUT_SYMBOL || _la == TiDBParserIN_SYMBOL || _la == TiDBParserOUT_SYMBOL) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ProcedureParameterContext).type_ = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(5060)
		p.FunctionParameter()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionParameterContext is an interface to support dynamic dispatch.
type IFunctionParameterContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ParameterName() IParameterNameContext
	TypeWithOptCollate() ITypeWithOptCollateContext

	// IsFunctionParameterContext differentiates from other interfaces.
	IsFunctionParameterContext()
}

type FunctionParameterContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionParameterContext() *FunctionParameterContext {
	var p = new(FunctionParameterContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_functionParameter
	return p
}

func InitEmptyFunctionParameterContext(p *FunctionParameterContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_functionParameter
}

func (*FunctionParameterContext) IsFunctionParameterContext() {}

func NewFunctionParameterContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionParameterContext {
	var p = new(FunctionParameterContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_functionParameter

	return p
}

func (s *FunctionParameterContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionParameterContext) ParameterName() IParameterNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterNameContext)
}

func (s *FunctionParameterContext) TypeWithOptCollate() ITypeWithOptCollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeWithOptCollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeWithOptCollateContext)
}

func (s *FunctionParameterContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionParameterContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionParameterContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFunctionParameter(s)
	}
}

func (s *FunctionParameterContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFunctionParameter(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FunctionParameter() (localctx IFunctionParameterContext) {
	localctx = NewFunctionParameterContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 600, TiDBParserRULE_functionParameter)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5062)
		p.ParameterName()
	}
	{
		p.SetState(5063)
		p.TypeWithOptCollate()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICollateContext is an interface to support dynamic dispatch.
type ICollateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLLATE_SYMBOL() antlr.TerminalNode
	CollationName() ICollationNameContext

	// IsCollateContext differentiates from other interfaces.
	IsCollateContext()
}

type CollateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCollateContext() *CollateContext {
	var p = new(CollateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_collate
	return p
}

func InitEmptyCollateContext(p *CollateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_collate
}

func (*CollateContext) IsCollateContext() {}

func NewCollateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CollateContext {
	var p = new(CollateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_collate

	return p
}

func (s *CollateContext) GetParser() antlr.Parser { return s.parser }

func (s *CollateContext) COLLATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLLATE_SYMBOL, 0)
}

func (s *CollateContext) CollationName() ICollationNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollationNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollationNameContext)
}

func (s *CollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CollateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCollate(s)
	}
}

func (s *CollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCollate(s)
	}
}

func (s *CollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Collate() (localctx ICollateContext) {
	localctx = NewCollateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 602, TiDBParserRULE_collate)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5065)
		p.Match(TiDBParserCOLLATE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5066)
		p.CollationName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITypeWithOptCollateContext is an interface to support dynamic dispatch.
type ITypeWithOptCollateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DataType() IDataTypeContext
	Collate() ICollateContext

	// IsTypeWithOptCollateContext differentiates from other interfaces.
	IsTypeWithOptCollateContext()
}

type TypeWithOptCollateContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeWithOptCollateContext() *TypeWithOptCollateContext {
	var p = new(TypeWithOptCollateContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_typeWithOptCollate
	return p
}

func InitEmptyTypeWithOptCollateContext(p *TypeWithOptCollateContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_typeWithOptCollate
}

func (*TypeWithOptCollateContext) IsTypeWithOptCollateContext() {}

func NewTypeWithOptCollateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeWithOptCollateContext {
	var p = new(TypeWithOptCollateContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_typeWithOptCollate

	return p
}

func (s *TypeWithOptCollateContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeWithOptCollateContext) DataType() IDataTypeContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDataTypeContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDataTypeContext)
}

func (s *TypeWithOptCollateContext) Collate() ICollateContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICollateContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICollateContext)
}

func (s *TypeWithOptCollateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeWithOptCollateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TypeWithOptCollateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTypeWithOptCollate(s)
	}
}

func (s *TypeWithOptCollateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTypeWithOptCollate(s)
	}
}

func (s *TypeWithOptCollateContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTypeWithOptCollate(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TypeWithOptCollate() (localctx ITypeWithOptCollateContext) {
	localctx = NewTypeWithOptCollateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 604, TiDBParserRULE_typeWithOptCollate)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5068)
		p.DataType()
	}
	p.SetState(5070)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserCOLLATE_SYMBOL {
		{
			p.SetState(5069)
			p.Collate()
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaIdentifierPairContext is an interface to support dynamic dispatch.
type ISchemaIdentifierPairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllSchemaRef() []ISchemaRefContext
	SchemaRef(i int) ISchemaRefContext
	COMMA_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsSchemaIdentifierPairContext differentiates from other interfaces.
	IsSchemaIdentifierPairContext()
}

type SchemaIdentifierPairContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaIdentifierPairContext() *SchemaIdentifierPairContext {
	var p = new(SchemaIdentifierPairContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_schemaIdentifierPair
	return p
}

func InitEmptySchemaIdentifierPairContext(p *SchemaIdentifierPairContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_schemaIdentifierPair
}

func (*SchemaIdentifierPairContext) IsSchemaIdentifierPairContext() {}

func NewSchemaIdentifierPairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaIdentifierPairContext {
	var p = new(SchemaIdentifierPairContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_schemaIdentifierPair

	return p
}

func (s *SchemaIdentifierPairContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaIdentifierPairContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *SchemaIdentifierPairContext) AllSchemaRef() []ISchemaRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISchemaRefContext); ok {
			len++
		}
	}

	tst := make([]ISchemaRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISchemaRefContext); ok {
			tst[i] = t.(ISchemaRefContext)
			i++
		}
	}

	return tst
}

func (s *SchemaIdentifierPairContext) SchemaRef(i int) ISchemaRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *SchemaIdentifierPairContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *SchemaIdentifierPairContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *SchemaIdentifierPairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaIdentifierPairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaIdentifierPairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSchemaIdentifierPair(s)
	}
}

func (s *SchemaIdentifierPairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSchemaIdentifierPair(s)
	}
}

func (s *SchemaIdentifierPairContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSchemaIdentifierPair(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SchemaIdentifierPair() (localctx ISchemaIdentifierPairContext) {
	localctx = NewSchemaIdentifierPairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 606, TiDBParserRULE_schemaIdentifierPair)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5072)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5073)
		p.SchemaRef()
	}
	{
		p.SetState(5074)
		p.Match(TiDBParserCOMMA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5075)
		p.SchemaRef()
	}
	{
		p.SetState(5076)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewRefListContext is an interface to support dynamic dispatch.
type IViewRefListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllViewRef() []IViewRefContext
	ViewRef(i int) IViewRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsViewRefListContext differentiates from other interfaces.
	IsViewRefListContext()
}

type ViewRefListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewRefListContext() *ViewRefListContext {
	var p = new(ViewRefListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_viewRefList
	return p
}

func InitEmptyViewRefListContext(p *ViewRefListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_viewRefList
}

func (*ViewRefListContext) IsViewRefListContext() {}

func NewViewRefListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewRefListContext {
	var p = new(ViewRefListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_viewRefList

	return p
}

func (s *ViewRefListContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewRefListContext) AllViewRef() []IViewRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IViewRefContext); ok {
			len++
		}
	}

	tst := make([]IViewRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IViewRefContext); ok {
			tst[i] = t.(IViewRefContext)
			i++
		}
	}

	return tst
}

func (s *ViewRefListContext) ViewRef(i int) IViewRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IViewRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IViewRefContext)
}

func (s *ViewRefListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ViewRefListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ViewRefListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewRefListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewRefListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterViewRefList(s)
	}
}

func (s *ViewRefListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitViewRefList(s)
	}
}

func (s *ViewRefListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitViewRefList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ViewRefList() (localctx IViewRefListContext) {
	localctx = NewViewRefListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 608, TiDBParserRULE_viewRefList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5078)
		p.ViewRef()
	}
	p.SetState(5083)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5079)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5080)
			p.ViewRef()
		}

		p.SetState(5085)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateListContext is an interface to support dynamic dispatch.
type IUpdateListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUpdateElement() []IUpdateElementContext
	UpdateElement(i int) IUpdateElementContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsUpdateListContext differentiates from other interfaces.
	IsUpdateListContext()
}

type UpdateListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateListContext() *UpdateListContext {
	var p = new(UpdateListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_updateList
	return p
}

func InitEmptyUpdateListContext(p *UpdateListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_updateList
}

func (*UpdateListContext) IsUpdateListContext() {}

func NewUpdateListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateListContext {
	var p = new(UpdateListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_updateList

	return p
}

func (s *UpdateListContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateListContext) AllUpdateElement() []IUpdateElementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUpdateElementContext); ok {
			len++
		}
	}

	tst := make([]IUpdateElementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUpdateElementContext); ok {
			tst[i] = t.(IUpdateElementContext)
			i++
		}
	}

	return tst
}

func (s *UpdateListContext) UpdateElement(i int) IUpdateElementContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUpdateElementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUpdateElementContext)
}

func (s *UpdateListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *UpdateListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *UpdateListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUpdateList(s)
	}
}

func (s *UpdateListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUpdateList(s)
	}
}

func (s *UpdateListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUpdateList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UpdateList() (localctx IUpdateListContext) {
	localctx = NewUpdateListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 610, TiDBParserRULE_updateList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5086)
		p.UpdateElement()
	}
	p.SetState(5091)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5087)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5088)
			p.UpdateElement()
		}

		p.SetState(5093)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUpdateElementContext is an interface to support dynamic dispatch.
type IUpdateElementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnRef() IColumnRefContext
	EQUAL_OPERATOR() antlr.TerminalNode
	Expr() IExprContext
	DEFAULT_SYMBOL() antlr.TerminalNode

	// IsUpdateElementContext differentiates from other interfaces.
	IsUpdateElementContext()
}

type UpdateElementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUpdateElementContext() *UpdateElementContext {
	var p = new(UpdateElementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_updateElement
	return p
}

func InitEmptyUpdateElementContext(p *UpdateElementContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_updateElement
}

func (*UpdateElementContext) IsUpdateElementContext() {}

func NewUpdateElementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UpdateElementContext {
	var p = new(UpdateElementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_updateElement

	return p
}

func (s *UpdateElementContext) GetParser() antlr.Parser { return s.parser }

func (s *UpdateElementContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *UpdateElementContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *UpdateElementContext) Expr() IExprContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExprContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExprContext)
}

func (s *UpdateElementContext) DEFAULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_SYMBOL, 0)
}

func (s *UpdateElementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UpdateElementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UpdateElementContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUpdateElement(s)
	}
}

func (s *UpdateElementContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUpdateElement(s)
	}
}

func (s *UpdateElementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUpdateElement(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UpdateElement() (localctx IUpdateElementContext) {
	localctx = NewUpdateElementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 612, TiDBParserRULE_updateElement)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5094)
		p.ColumnRef()
	}
	{
		p.SetState(5095)
		p.Match(TiDBParserEQUAL_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5098)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 683, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(5096)
			p.expr(0)
		}

	case 2:
		{
			p.SetState(5097)
			p.Match(TiDBParserDEFAULT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICharsetClauseContext is an interface to support dynamic dispatch.
type ICharsetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Charset() ICharsetContext
	CharsetName() ICharsetNameContext

	// IsCharsetClauseContext differentiates from other interfaces.
	IsCharsetClauseContext()
}

type CharsetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetClauseContext() *CharsetClauseContext {
	var p = new(CharsetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_charsetClause
	return p
}

func InitEmptyCharsetClauseContext(p *CharsetClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_charsetClause
}

func (*CharsetClauseContext) IsCharsetClauseContext() {}

func NewCharsetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetClauseContext {
	var p = new(CharsetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_charsetClause

	return p
}

func (s *CharsetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetClauseContext) Charset() ICharsetContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *CharsetClauseContext) CharsetName() ICharsetNameContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICharsetNameContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICharsetNameContext)
}

func (s *CharsetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCharsetClause(s)
	}
}

func (s *CharsetClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCharsetClause(s)
	}
}

func (s *CharsetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCharsetClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CharsetClause() (localctx ICharsetClauseContext) {
	localctx = NewCharsetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 614, TiDBParserRULE_charsetClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5100)
		p.Charset()
	}
	{
		p.SetState(5101)
		p.CharsetName()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldsClauseContext is an interface to support dynamic dispatch.
type IFieldsClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	COLUMNS_SYMBOL() antlr.TerminalNode
	AllFieldTerm() []IFieldTermContext
	FieldTerm(i int) IFieldTermContext

	// IsFieldsClauseContext differentiates from other interfaces.
	IsFieldsClauseContext()
}

type FieldsClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldsClauseContext() *FieldsClauseContext {
	var p = new(FieldsClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldsClause
	return p
}

func InitEmptyFieldsClauseContext(p *FieldsClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldsClause
}

func (*FieldsClauseContext) IsFieldsClauseContext() {}

func NewFieldsClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldsClauseContext {
	var p = new(FieldsClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fieldsClause

	return p
}

func (s *FieldsClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldsClauseContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMNS_SYMBOL, 0)
}

func (s *FieldsClauseContext) AllFieldTerm() []IFieldTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IFieldTermContext); ok {
			len++
		}
	}

	tst := make([]IFieldTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IFieldTermContext); ok {
			tst[i] = t.(IFieldTermContext)
			i++
		}
	}

	return tst
}

func (s *FieldsClauseContext) FieldTerm(i int) IFieldTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldTermContext)
}

func (s *FieldsClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldsClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldsClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFieldsClause(s)
	}
}

func (s *FieldsClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFieldsClause(s)
	}
}

func (s *FieldsClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFieldsClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FieldsClause() (localctx IFieldsClauseContext) {
	localctx = NewFieldsClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 616, TiDBParserRULE_fieldsClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5103)
		p.Match(TiDBParserCOLUMNS_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5105)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == TiDBParserENCLOSED_SYMBOL || _la == TiDBParserESCAPED_SYMBOL || _la == TiDBParserOPTIONALLY_SYMBOL || _la == TiDBParserTERMINATED_SYMBOL {
		{
			p.SetState(5104)
			p.FieldTerm()
		}

		p.SetState(5107)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldTermContext is an interface to support dynamic dispatch.
type IFieldTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TERMINATED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	ENCLOSED_SYMBOL() antlr.TerminalNode
	OPTIONALLY_SYMBOL() antlr.TerminalNode
	ESCAPED_SYMBOL() antlr.TerminalNode

	// IsFieldTermContext differentiates from other interfaces.
	IsFieldTermContext()
}

type FieldTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldTermContext() *FieldTermContext {
	var p = new(FieldTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldTerm
	return p
}

func InitEmptyFieldTermContext(p *FieldTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldTerm
}

func (*FieldTermContext) IsFieldTermContext() {}

func NewFieldTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldTermContext {
	var p = new(FieldTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fieldTerm

	return p
}

func (s *FieldTermContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldTermContext) TERMINATED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTERMINATED_SYMBOL, 0)
}

func (s *FieldTermContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *FieldTermContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *FieldTermContext) ENCLOSED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENCLOSED_SYMBOL, 0)
}

func (s *FieldTermContext) OPTIONALLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTIONALLY_SYMBOL, 0)
}

func (s *FieldTermContext) ESCAPED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserESCAPED_SYMBOL, 0)
}

func (s *FieldTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFieldTerm(s)
	}
}

func (s *FieldTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFieldTerm(s)
	}
}

func (s *FieldTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFieldTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FieldTerm() (localctx IFieldTermContext) {
	localctx = NewFieldTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 618, TiDBParserRULE_fieldTerm)
	var _la int

	p.SetState(5121)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserTERMINATED_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5109)
			p.Match(TiDBParserTERMINATED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5110)
			p.Match(TiDBParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5111)
			p.TextString()
		}

	case TiDBParserENCLOSED_SYMBOL, TiDBParserOPTIONALLY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5113)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPTIONALLY_SYMBOL {
			{
				p.SetState(5112)
				p.Match(TiDBParserOPTIONALLY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5115)
			p.Match(TiDBParserENCLOSED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5116)
			p.Match(TiDBParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5117)
			p.TextString()
		}

	case TiDBParserESCAPED_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5118)
			p.Match(TiDBParserESCAPED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5119)
			p.Match(TiDBParserBY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5120)
			p.TextString()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILinesClauseContext is an interface to support dynamic dispatch.
type ILinesClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LINES_SYMBOL() antlr.TerminalNode
	AllLineTerm() []ILineTermContext
	LineTerm(i int) ILineTermContext

	// IsLinesClauseContext differentiates from other interfaces.
	IsLinesClauseContext()
}

type LinesClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLinesClauseContext() *LinesClauseContext {
	var p = new(LinesClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_linesClause
	return p
}

func InitEmptyLinesClauseContext(p *LinesClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_linesClause
}

func (*LinesClauseContext) IsLinesClauseContext() {}

func NewLinesClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LinesClauseContext {
	var p = new(LinesClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_linesClause

	return p
}

func (s *LinesClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LinesClauseContext) LINES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLINES_SYMBOL, 0)
}

func (s *LinesClauseContext) AllLineTerm() []ILineTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILineTermContext); ok {
			len++
		}
	}

	tst := make([]ILineTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILineTermContext); ok {
			tst[i] = t.(ILineTermContext)
			i++
		}
	}

	return tst
}

func (s *LinesClauseContext) LineTerm(i int) ILineTermContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILineTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILineTermContext)
}

func (s *LinesClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LinesClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LinesClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLinesClause(s)
	}
}

func (s *LinesClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLinesClause(s)
	}
}

func (s *LinesClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLinesClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LinesClause() (localctx ILinesClauseContext) {
	localctx = NewLinesClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 620, TiDBParserRULE_linesClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5123)
		p.Match(TiDBParserLINES_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5125)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = _la == TiDBParserSTARTING_SYMBOL || _la == TiDBParserTERMINATED_SYMBOL {
		{
			p.SetState(5124)
			p.LineTerm()
		}

		p.SetState(5127)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILineTermContext is an interface to support dynamic dispatch.
type ILineTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	BY_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	TERMINATED_SYMBOL() antlr.TerminalNode
	STARTING_SYMBOL() antlr.TerminalNode

	// IsLineTermContext differentiates from other interfaces.
	IsLineTermContext()
}

type LineTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLineTermContext() *LineTermContext {
	var p = new(LineTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lineTerm
	return p
}

func InitEmptyLineTermContext(p *LineTermContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lineTerm
}

func (*LineTermContext) IsLineTermContext() {}

func NewLineTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LineTermContext {
	var p = new(LineTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lineTerm

	return p
}

func (s *LineTermContext) GetParser() antlr.Parser { return s.parser }

func (s *LineTermContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *LineTermContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *LineTermContext) TERMINATED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTERMINATED_SYMBOL, 0)
}

func (s *LineTermContext) STARTING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTARTING_SYMBOL, 0)
}

func (s *LineTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LineTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LineTermContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLineTerm(s)
	}
}

func (s *LineTermContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLineTerm(s)
	}
}

func (s *LineTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLineTerm(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LineTerm() (localctx ILineTermContext) {
	localctx = NewLineTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 622, TiDBParserRULE_lineTerm)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5129)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserSTARTING_SYMBOL || _la == TiDBParserTERMINATED_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(5130)
		p.Match(TiDBParserBY_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5131)
		p.TextString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserListContext is an interface to support dynamic dispatch.
type IUserListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllUser() []IUserContext
	User(i int) IUserContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsUserListContext differentiates from other interfaces.
	IsUserListContext()
}

type UserListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserListContext() *UserListContext {
	var p = new(UserListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_userList
	return p
}

func InitEmptyUserListContext(p *UserListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_userList
}

func (*UserListContext) IsUserListContext() {}

func NewUserListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserListContext {
	var p = new(UserListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_userList

	return p
}

func (s *UserListContext) GetParser() antlr.Parser { return s.parser }

func (s *UserListContext) AllUser() []IUserContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IUserContext); ok {
			len++
		}
	}

	tst := make([]IUserContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IUserContext); ok {
			tst[i] = t.(IUserContext)
			i++
		}
	}

	return tst
}

func (s *UserListContext) User(i int) IUserContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *UserListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *UserListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *UserListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUserList(s)
	}
}

func (s *UserListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUserList(s)
	}
}

func (s *UserListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUserList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UserList() (localctx IUserListContext) {
	localctx = NewUserListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 624, TiDBParserRULE_userList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5133)
		p.User()
	}
	p.SetState(5138)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5134)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5135)
			p.User()
		}

		p.SetState(5140)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserListContext is an interface to support dynamic dispatch.
type ICreateUserListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCreateUserEntry() []ICreateUserEntryContext
	CreateUserEntry(i int) ICreateUserEntryContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsCreateUserListContext differentiates from other interfaces.
	IsCreateUserListContext()
}

type CreateUserListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserListContext() *CreateUserListContext {
	var p = new(CreateUserListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createUserList
	return p
}

func InitEmptyCreateUserListContext(p *CreateUserListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createUserList
}

func (*CreateUserListContext) IsCreateUserListContext() {}

func NewCreateUserListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserListContext {
	var p = new(CreateUserListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_createUserList

	return p
}

func (s *CreateUserListContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserListContext) AllCreateUserEntry() []ICreateUserEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICreateUserEntryContext); ok {
			len++
		}
	}

	tst := make([]ICreateUserEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICreateUserEntryContext); ok {
			tst[i] = t.(ICreateUserEntryContext)
			i++
		}
	}

	return tst
}

func (s *CreateUserListContext) CreateUserEntry(i int) ICreateUserEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICreateUserEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICreateUserEntryContext)
}

func (s *CreateUserListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *CreateUserListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *CreateUserListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCreateUserList(s)
	}
}

func (s *CreateUserListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCreateUserList(s)
	}
}

func (s *CreateUserListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCreateUserList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CreateUserList() (localctx ICreateUserListContext) {
	localctx = NewCreateUserListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 626, TiDBParserRULE_createUserList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5141)
		p.CreateUserEntry()
	}
	p.SetState(5146)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5142)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5143)
			p.CreateUserEntry()
		}

		p.SetState(5148)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserListContext is an interface to support dynamic dispatch.
type IAlterUserListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAlterUserEntry() []IAlterUserEntryContext
	AlterUserEntry(i int) IAlterUserEntryContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsAlterUserListContext differentiates from other interfaces.
	IsAlterUserListContext()
}

type AlterUserListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserListContext() *AlterUserListContext {
	var p = new(AlterUserListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterUserList
	return p
}

func InitEmptyAlterUserListContext(p *AlterUserListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterUserList
}

func (*AlterUserListContext) IsAlterUserListContext() {}

func NewAlterUserListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserListContext {
	var p = new(AlterUserListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_alterUserList

	return p
}

func (s *AlterUserListContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserListContext) AllAlterUserEntry() []IAlterUserEntryContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAlterUserEntryContext); ok {
			len++
		}
	}

	tst := make([]IAlterUserEntryContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAlterUserEntryContext); ok {
			tst[i] = t.(IAlterUserEntryContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserListContext) AlterUserEntry(i int) IAlterUserEntryContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAlterUserEntryContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAlterUserEntryContext)
}

func (s *AlterUserListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *AlterUserListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *AlterUserListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterAlterUserList(s)
	}
}

func (s *AlterUserListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitAlterUserList(s)
	}
}

func (s *AlterUserListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitAlterUserList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) AlterUserList() (localctx IAlterUserListContext) {
	localctx = NewAlterUserListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 628, TiDBParserRULE_alterUserList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5149)
		p.AlterUserEntry()
	}
	p.SetState(5154)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5150)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5151)
			p.AlterUserEntry()
		}

		p.SetState(5156)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ICreateUserEntryContext is an interface to support dynamic dispatch.
type ICreateUserEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext
	WITH_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	RANDOM_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	AS_SYMBOL() antlr.TerminalNode
	TextStringHash() ITextStringHashContext

	// IsCreateUserEntryContext differentiates from other interfaces.
	IsCreateUserEntryContext()
}

type CreateUserEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCreateUserEntryContext() *CreateUserEntryContext {
	var p = new(CreateUserEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createUserEntry
	return p
}

func InitEmptyCreateUserEntryContext(p *CreateUserEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_createUserEntry
}

func (*CreateUserEntryContext) IsCreateUserEntryContext() {}

func NewCreateUserEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CreateUserEntryContext {
	var p = new(CreateUserEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_createUserEntry

	return p
}

func (s *CreateUserEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *CreateUserEntryContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *CreateUserEntryContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIDENTIFIED_SYMBOL, 0)
}

func (s *CreateUserEntryContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *CreateUserEntryContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *CreateUserEntryContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *CreateUserEntryContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *CreateUserEntryContext) RANDOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRANDOM_SYMBOL, 0)
}

func (s *CreateUserEntryContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *CreateUserEntryContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *CreateUserEntryContext) TextStringHash() ITextStringHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringHashContext)
}

func (s *CreateUserEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CreateUserEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CreateUserEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterCreateUserEntry(s)
	}
}

func (s *CreateUserEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitCreateUserEntry(s)
	}
}

func (s *CreateUserEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitCreateUserEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) CreateUserEntry() (localctx ICreateUserEntryContext) {
	localctx = NewCreateUserEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 630, TiDBParserRULE_createUserEntry)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5157)
		p.User()
	}
	p.SetState(5181)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if _la == TiDBParserIDENTIFIED_SYMBOL {
		{
			p.SetState(5158)
			p.Match(TiDBParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5179)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 694, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5159)
				p.Match(TiDBParserBY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			p.SetState(5161)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserPASSWORD_SYMBOL {
				{
					p.SetState(5160)
					p.Match(TiDBParserPASSWORD_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}

			}
			{
				p.SetState(5163)
				p.TextString()
			}

		case 2:
			{
				p.SetState(5164)
				p.Match(TiDBParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5165)
				p.TextOrIdentifier()
			}
			p.SetState(5170)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 692, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(5166)
					p.Match(TiDBParserAS_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5167)
					p.TextStringHash()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 692, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(5168)
					p.Match(TiDBParserBY_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5169)
					p.TextString()
				}

			} else if p.HasError() { // JIM
				goto errorExit
			}

		case 3:
			p.SetState(5174)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserWITH_SYMBOL {
				{
					p.SetState(5172)
					p.Match(TiDBParserWITH_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5173)
					p.TextOrIdentifier()
				}

			}
			{
				p.SetState(5176)
				p.Match(TiDBParserBY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5177)
				p.Match(TiDBParserRANDOM_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5178)
				p.Match(TiDBParserPASSWORD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IAlterUserEntryContext is an interface to support dynamic dispatch.
type IAlterUserEntryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	User() IUserContext
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	BY_SYMBOL() antlr.TerminalNode
	AllTextString() []ITextStringContext
	TextString(i int) ITextStringContext
	WITH_SYMBOL() antlr.TerminalNode
	TextOrIdentifier() ITextOrIdentifierContext
	DiscardOldPassword() IDiscardOldPasswordContext
	REPLACE_SYMBOL() antlr.TerminalNode
	RetainCurrentPassword() IRetainCurrentPasswordContext
	AS_SYMBOL() antlr.TerminalNode
	TextStringHash() ITextStringHashContext

	// IsAlterUserEntryContext differentiates from other interfaces.
	IsAlterUserEntryContext()
}

type AlterUserEntryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlterUserEntryContext() *AlterUserEntryContext {
	var p = new(AlterUserEntryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterUserEntry
	return p
}

func InitEmptyAlterUserEntryContext(p *AlterUserEntryContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_alterUserEntry
}

func (*AlterUserEntryContext) IsAlterUserEntryContext() {}

func NewAlterUserEntryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlterUserEntryContext {
	var p = new(AlterUserEntryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_alterUserEntry

	return p
}

func (s *AlterUserEntryContext) GetParser() antlr.Parser { return s.parser }

func (s *AlterUserEntryContext) User() IUserContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserContext)
}

func (s *AlterUserEntryContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIDENTIFIED_SYMBOL, 0)
}

func (s *AlterUserEntryContext) BY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBY_SYMBOL, 0)
}

func (s *AlterUserEntryContext) AllTextString() []ITextStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringContext); ok {
			len++
		}
	}

	tst := make([]ITextStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringContext); ok {
			tst[i] = t.(ITextStringContext)
			i++
		}
	}

	return tst
}

func (s *AlterUserEntryContext) TextString(i int) ITextStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *AlterUserEntryContext) WITH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITH_SYMBOL, 0)
}

func (s *AlterUserEntryContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *AlterUserEntryContext) DiscardOldPassword() IDiscardOldPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDiscardOldPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDiscardOldPasswordContext)
}

func (s *AlterUserEntryContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLACE_SYMBOL, 0)
}

func (s *AlterUserEntryContext) RetainCurrentPassword() IRetainCurrentPasswordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetainCurrentPasswordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetainCurrentPasswordContext)
}

func (s *AlterUserEntryContext) AS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAS_SYMBOL, 0)
}

func (s *AlterUserEntryContext) TextStringHash() ITextStringHashContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringHashContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringHashContext)
}

func (s *AlterUserEntryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlterUserEntryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlterUserEntryContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterAlterUserEntry(s)
	}
}

func (s *AlterUserEntryContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitAlterUserEntry(s)
	}
}

func (s *AlterUserEntryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitAlterUserEntry(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) AlterUserEntry() (localctx IAlterUserEntryContext) {
	localctx = NewAlterUserEntryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 632, TiDBParserRULE_alterUserEntry)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5183)
		p.User()
	}
	p.SetState(5212)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserIDENTIFIED_SYMBOL:
		{
			p.SetState(5184)
			p.Match(TiDBParserIDENTIFIED_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5207)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext()) == 1 {
			p.SetState(5187)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserWITH_SYMBOL {
				{
					p.SetState(5185)
					p.Match(TiDBParserWITH_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5186)
					p.TextOrIdentifier()
				}

			}
			{
				p.SetState(5189)
				p.Match(TiDBParserBY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5190)
				p.TextString()
			}
			p.SetState(5193)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserREPLACE_SYMBOL {
				{
					p.SetState(5191)
					p.Match(TiDBParserREPLACE_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5192)
					p.TextString()
				}

			}
			p.SetState(5196)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserRETAIN_SYMBOL {
				{
					p.SetState(5195)
					p.RetainCurrentPassword()
				}

			}

		} else if p.HasError() { // JIM
			goto errorExit
		} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 701, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(5198)
				p.Match(TiDBParserWITH_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5199)
				p.TextOrIdentifier()
			}
			p.SetState(5205)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserAS_SYMBOL {
				{
					p.SetState(5200)
					p.Match(TiDBParserAS_SYMBOL)
					if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
					}
				}
				{
					p.SetState(5201)
					p.TextStringHash()
				}
				p.SetState(5203)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)

				if _la == TiDBParserRETAIN_SYMBOL {
					{
						p.SetState(5202)
						p.RetainCurrentPassword()
					}

				}

			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	case TiDBParserEOF, TiDBParserACCOUNT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserREQUIRE_SYMBOL, TiDBParserWITH_SYMBOL, TiDBParserCOMMA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL:
		p.SetState(5210)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDISCARD_SYMBOL {
			{
				p.SetState(5209)
				p.DiscardOldPassword()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRetainCurrentPasswordContext is an interface to support dynamic dispatch.
type IRetainCurrentPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RETAIN_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode

	// IsRetainCurrentPasswordContext differentiates from other interfaces.
	IsRetainCurrentPasswordContext()
}

type RetainCurrentPasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetainCurrentPasswordContext() *RetainCurrentPasswordContext {
	var p = new(RetainCurrentPasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_retainCurrentPassword
	return p
}

func InitEmptyRetainCurrentPasswordContext(p *RetainCurrentPasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_retainCurrentPassword
}

func (*RetainCurrentPasswordContext) IsRetainCurrentPasswordContext() {}

func NewRetainCurrentPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetainCurrentPasswordContext {
	var p = new(RetainCurrentPasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_retainCurrentPassword

	return p
}

func (s *RetainCurrentPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *RetainCurrentPasswordContext) RETAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRETAIN_SYMBOL, 0)
}

func (s *RetainCurrentPasswordContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURRENT_SYMBOL, 0)
}

func (s *RetainCurrentPasswordContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *RetainCurrentPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetainCurrentPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RetainCurrentPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRetainCurrentPassword(s)
	}
}

func (s *RetainCurrentPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRetainCurrentPassword(s)
	}
}

func (s *RetainCurrentPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRetainCurrentPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RetainCurrentPassword() (localctx IRetainCurrentPasswordContext) {
	localctx = NewRetainCurrentPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 634, TiDBParserRULE_retainCurrentPassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5214)
		p.Match(TiDBParserRETAIN_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5215)
		p.Match(TiDBParserCURRENT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5216)
		p.Match(TiDBParserPASSWORD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDiscardOldPasswordContext is an interface to support dynamic dispatch.
type IDiscardOldPasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DISCARD_SYMBOL() antlr.TerminalNode
	OLD_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode

	// IsDiscardOldPasswordContext differentiates from other interfaces.
	IsDiscardOldPasswordContext()
}

type DiscardOldPasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDiscardOldPasswordContext() *DiscardOldPasswordContext {
	var p = new(DiscardOldPasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_discardOldPassword
	return p
}

func InitEmptyDiscardOldPasswordContext(p *DiscardOldPasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_discardOldPassword
}

func (*DiscardOldPasswordContext) IsDiscardOldPasswordContext() {}

func NewDiscardOldPasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DiscardOldPasswordContext {
	var p = new(DiscardOldPasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_discardOldPassword

	return p
}

func (s *DiscardOldPasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *DiscardOldPasswordContext) DISCARD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISCARD_SYMBOL, 0)
}

func (s *DiscardOldPasswordContext) OLD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOLD_SYMBOL, 0)
}

func (s *DiscardOldPasswordContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *DiscardOldPasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DiscardOldPasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DiscardOldPasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDiscardOldPassword(s)
	}
}

func (s *DiscardOldPasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDiscardOldPassword(s)
	}
}

func (s *DiscardOldPasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDiscardOldPassword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DiscardOldPassword() (localctx IDiscardOldPasswordContext) {
	localctx = NewDiscardOldPasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 636, TiDBParserRULE_discardOldPassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5218)
		p.Match(TiDBParserDISCARD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5219)
		p.Match(TiDBParserOLD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5220)
		p.Match(TiDBParserPASSWORD_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReplacePasswordContext is an interface to support dynamic dispatch.
type IReplacePasswordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	REPLACE_SYMBOL() antlr.TerminalNode
	TextString() ITextStringContext

	// IsReplacePasswordContext differentiates from other interfaces.
	IsReplacePasswordContext()
}

type ReplacePasswordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReplacePasswordContext() *ReplacePasswordContext {
	var p = new(ReplacePasswordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_replacePassword
	return p
}

func InitEmptyReplacePasswordContext(p *ReplacePasswordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_replacePassword
}

func (*ReplacePasswordContext) IsReplacePasswordContext() {}

func NewReplacePasswordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReplacePasswordContext {
	var p = new(ReplacePasswordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_replacePassword

	return p
}

func (s *ReplacePasswordContext) GetParser() antlr.Parser { return s.parser }

func (s *ReplacePasswordContext) REPLACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLACE_SYMBOL, 0)
}

func (s *ReplacePasswordContext) TextString() ITextStringContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *ReplacePasswordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReplacePasswordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ReplacePasswordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterReplacePassword(s)
	}
}

func (s *ReplacePasswordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitReplacePassword(s)
	}
}

func (s *ReplacePasswordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitReplacePassword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ReplacePassword() (localctx IReplacePasswordContext) {
	localctx = NewReplacePasswordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 638, TiDBParserRULE_replacePassword)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5222)
		p.Match(TiDBParserREPLACE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5223)
		p.TextString()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserIdentifierOrTextContext is an interface to support dynamic dispatch.
type IUserIdentifierOrTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTextOrIdentifier() []ITextOrIdentifierContext
	TextOrIdentifier(i int) ITextOrIdentifierContext
	AT_SIGN_SYMBOL() antlr.TerminalNode
	AT_TEXT_SUFFIX() antlr.TerminalNode

	// IsUserIdentifierOrTextContext differentiates from other interfaces.
	IsUserIdentifierOrTextContext()
}

type UserIdentifierOrTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserIdentifierOrTextContext() *UserIdentifierOrTextContext {
	var p = new(UserIdentifierOrTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_userIdentifierOrText
	return p
}

func InitEmptyUserIdentifierOrTextContext(p *UserIdentifierOrTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_userIdentifierOrText
}

func (*UserIdentifierOrTextContext) IsUserIdentifierOrTextContext() {}

func NewUserIdentifierOrTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserIdentifierOrTextContext {
	var p = new(UserIdentifierOrTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_userIdentifierOrText

	return p
}

func (s *UserIdentifierOrTextContext) GetParser() antlr.Parser { return s.parser }

func (s *UserIdentifierOrTextContext) AllTextOrIdentifier() []ITextOrIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ITextOrIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextOrIdentifierContext); ok {
			tst[i] = t.(ITextOrIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *UserIdentifierOrTextContext) TextOrIdentifier(i int) ITextOrIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *UserIdentifierOrTextContext) AT_SIGN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_SIGN_SYMBOL, 0)
}

func (s *UserIdentifierOrTextContext) AT_TEXT_SUFFIX() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_TEXT_SUFFIX, 0)
}

func (s *UserIdentifierOrTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserIdentifierOrTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserIdentifierOrTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUserIdentifierOrText(s)
	}
}

func (s *UserIdentifierOrTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUserIdentifierOrText(s)
	}
}

func (s *UserIdentifierOrTextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUserIdentifierOrText(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UserIdentifierOrText() (localctx IUserIdentifierOrTextContext) {
	localctx = NewUserIdentifierOrTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 640, TiDBParserRULE_userIdentifierOrText)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5225)
		p.TextOrIdentifier()
	}
	p.SetState(5229)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	switch p.GetTokenStream().LA(1) {
	case TiDBParserAT_SIGN_SYMBOL:
		{
			p.SetState(5226)
			p.Match(TiDBParserAT_SIGN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5227)
			p.TextOrIdentifier()
		}

	case TiDBParserAT_TEXT_SUFFIX:
		{
			p.SetState(5228)
			p.Match(TiDBParserAT_TEXT_SUFFIX)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserEOF, TiDBParserACCOUNT_SYMBOL, TiDBParserAS_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserDEFAULT_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserFOR_SYMBOL, TiDBParserFROM_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserREQUIRE_SYMBOL, TiDBParserTO_SYMBOL, TiDBParserUSING_SYMBOL, TiDBParserWITH_SYMBOL, TiDBParserEQUAL_OPERATOR, TiDBParserASSIGN_OPERATOR, TiDBParserCOMMA_SYMBOL, TiDBParserCOLON_SYMBOL, TiDBParserATTRIBUTE_SYMBOL:

	default:
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUserContext is an interface to support dynamic dispatch.
type IUserContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UserIdentifierOrText() IUserIdentifierOrTextContext
	CURRENT_USER_SYMBOL() antlr.TerminalNode
	Parentheses() IParenthesesContext

	// IsUserContext differentiates from other interfaces.
	IsUserContext()
}

type UserContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUserContext() *UserContext {
	var p = new(UserContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_user
	return p
}

func InitEmptyUserContext(p *UserContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_user
}

func (*UserContext) IsUserContext() {}

func NewUserContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UserContext {
	var p = new(UserContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_user

	return p
}

func (s *UserContext) GetParser() antlr.Parser { return s.parser }

func (s *UserContext) UserIdentifierOrText() IUserIdentifierOrTextContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUserIdentifierOrTextContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUserIdentifierOrTextContext)
}

func (s *UserContext) CURRENT_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURRENT_USER_SYMBOL, 0)
}

func (s *UserContext) Parentheses() IParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParenthesesContext)
}

func (s *UserContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UserContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UserContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUser(s)
	}
}

func (s *UserContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUser(s)
	}
}

func (s *UserContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUser(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) User() (localctx IUserContext) {
	localctx = NewUserContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 642, TiDBParserRULE_user)
	var _la int

	p.SetState(5236)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5231)
			p.UserIdentifierOrText()
		}

	case TiDBParserCURRENT_USER_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5232)
			p.Match(TiDBParserCURRENT_USER_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		p.SetState(5234)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserOPEN_PAR_SYMBOL {
			{
				p.SetState(5233)
				p.Parentheses()
			}

		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeClauseContext is an interface to support dynamic dispatch.
type ILikeClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LIKE_SYMBOL() antlr.TerminalNode
	TextStringLiteral() ITextStringLiteralContext

	// IsLikeClauseContext differentiates from other interfaces.
	IsLikeClauseContext()
}

type LikeClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLikeClauseContext() *LikeClauseContext {
	var p = new(LikeClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_likeClause
	return p
}

func InitEmptyLikeClauseContext(p *LikeClauseContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_likeClause
}

func (*LikeClauseContext) IsLikeClauseContext() {}

func NewLikeClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeClauseContext {
	var p = new(LikeClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_likeClause

	return p
}

func (s *LikeClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeClauseContext) LIKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLIKE_SYMBOL, 0)
}

func (s *LikeClauseContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *LikeClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeClauseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLikeClause(s)
	}
}

func (s *LikeClauseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLikeClause(s)
	}
}

func (s *LikeClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLikeClause(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LikeClause() (localctx ILikeClauseContext) {
	localctx = NewLikeClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 644, TiDBParserRULE_likeClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5238)
		p.Match(TiDBParserLIKE_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5239)
		p.TextStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILikeOrWhereContext is an interface to support dynamic dispatch.
type ILikeOrWhereContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LikeClause() ILikeClauseContext
	WhereClause() IWhereClauseContext

	// IsLikeOrWhereContext differentiates from other interfaces.
	IsLikeOrWhereContext()
}

type LikeOrWhereContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLikeOrWhereContext() *LikeOrWhereContext {
	var p = new(LikeOrWhereContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_likeOrWhere
	return p
}

func InitEmptyLikeOrWhereContext(p *LikeOrWhereContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_likeOrWhere
}

func (*LikeOrWhereContext) IsLikeOrWhereContext() {}

func NewLikeOrWhereContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LikeOrWhereContext {
	var p = new(LikeOrWhereContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_likeOrWhere

	return p
}

func (s *LikeOrWhereContext) GetParser() antlr.Parser { return s.parser }

func (s *LikeOrWhereContext) LikeClause() ILikeClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILikeClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILikeClauseContext)
}

func (s *LikeOrWhereContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *LikeOrWhereContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LikeOrWhereContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LikeOrWhereContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLikeOrWhere(s)
	}
}

func (s *LikeOrWhereContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLikeOrWhere(s)
	}
}

func (s *LikeOrWhereContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLikeOrWhere(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LikeOrWhere() (localctx ILikeOrWhereContext) {
	localctx = NewLikeOrWhereContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 646, TiDBParserRULE_likeOrWhere)
	p.SetState(5243)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserLIKE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5241)
			p.LikeClause()
		}

	case TiDBParserWHERE_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5242)
			p.WhereClause()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOnlineOptionContext is an interface to support dynamic dispatch.
type IOnlineOptionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ONLINE_SYMBOL() antlr.TerminalNode
	OFFLINE_SYMBOL() antlr.TerminalNode

	// IsOnlineOptionContext differentiates from other interfaces.
	IsOnlineOptionContext()
}

type OnlineOptionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOnlineOptionContext() *OnlineOptionContext {
	var p = new(OnlineOptionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onlineOption
	return p
}

func InitEmptyOnlineOptionContext(p *OnlineOptionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_onlineOption
}

func (*OnlineOptionContext) IsOnlineOptionContext() {}

func NewOnlineOptionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OnlineOptionContext {
	var p = new(OnlineOptionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_onlineOption

	return p
}

func (s *OnlineOptionContext) GetParser() antlr.Parser { return s.parser }

func (s *OnlineOptionContext) ONLINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserONLINE_SYMBOL, 0)
}

func (s *OnlineOptionContext) OFFLINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOFFLINE_SYMBOL, 0)
}

func (s *OnlineOptionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OnlineOptionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OnlineOptionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOnlineOption(s)
	}
}

func (s *OnlineOptionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOnlineOption(s)
	}
}

func (s *OnlineOptionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOnlineOption(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OnlineOption() (localctx IOnlineOptionContext) {
	localctx = NewOnlineOptionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 648, TiDBParserRULE_onlineOption)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5245)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserOFFLINE_SYMBOL || _la == TiDBParserONLINE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INoWriteToBinLogContext is an interface to support dynamic dispatch.
type INoWriteToBinLogContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LOCAL_SYMBOL() antlr.TerminalNode
	NO_WRITE_TO_BINLOG_SYMBOL() antlr.TerminalNode

	// IsNoWriteToBinLogContext differentiates from other interfaces.
	IsNoWriteToBinLogContext()
}

type NoWriteToBinLogContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNoWriteToBinLogContext() *NoWriteToBinLogContext {
	var p = new(NoWriteToBinLogContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_noWriteToBinLog
	return p
}

func InitEmptyNoWriteToBinLogContext(p *NoWriteToBinLogContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_noWriteToBinLog
}

func (*NoWriteToBinLogContext) IsNoWriteToBinLogContext() {}

func NewNoWriteToBinLogContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NoWriteToBinLogContext {
	var p = new(NoWriteToBinLogContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_noWriteToBinLog

	return p
}

func (s *NoWriteToBinLogContext) GetParser() antlr.Parser { return s.parser }

func (s *NoWriteToBinLogContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCAL_SYMBOL, 0)
}

func (s *NoWriteToBinLogContext) NO_WRITE_TO_BINLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_WRITE_TO_BINLOG_SYMBOL, 0)
}

func (s *NoWriteToBinLogContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NoWriteToBinLogContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NoWriteToBinLogContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterNoWriteToBinLog(s)
	}
}

func (s *NoWriteToBinLogContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitNoWriteToBinLog(s)
	}
}

func (s *NoWriteToBinLogContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitNoWriteToBinLog(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) NoWriteToBinLog() (localctx INoWriteToBinLogContext) {
	localctx = NewNoWriteToBinLogContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 650, TiDBParserRULE_noWriteToBinLog)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5247)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserLOCAL_SYMBOL || _la == TiDBParserNO_WRITE_TO_BINLOG_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUsePartitionContext is an interface to support dynamic dispatch.
type IUsePartitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PARTITION_SYMBOL() antlr.TerminalNode
	IdentifierListWithParentheses() IIdentifierListWithParenthesesContext

	// IsUsePartitionContext differentiates from other interfaces.
	IsUsePartitionContext()
}

type UsePartitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsePartitionContext() *UsePartitionContext {
	var p = new(UsePartitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_usePartition
	return p
}

func InitEmptyUsePartitionContext(p *UsePartitionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_usePartition
}

func (*UsePartitionContext) IsUsePartitionContext() {}

func NewUsePartitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsePartitionContext {
	var p = new(UsePartitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_usePartition

	return p
}

func (s *UsePartitionContext) GetParser() antlr.Parser { return s.parser }

func (s *UsePartitionContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITION_SYMBOL, 0)
}

func (s *UsePartitionContext) IdentifierListWithParentheses() IIdentifierListWithParenthesesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListWithParenthesesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListWithParenthesesContext)
}

func (s *UsePartitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsePartitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UsePartitionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUsePartition(s)
	}
}

func (s *UsePartitionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUsePartition(s)
	}
}

func (s *UsePartitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUsePartition(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UsePartition() (localctx IUsePartitionContext) {
	localctx = NewUsePartitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 652, TiDBParserRULE_usePartition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5249)
		p.Match(TiDBParserPARTITION_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5250)
		p.IdentifierListWithParentheses()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFieldIdentifierContext is an interface to support dynamic dispatch.
type IFieldIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DotIdentifier() IDotIdentifierContext
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsFieldIdentifierContext differentiates from other interfaces.
	IsFieldIdentifierContext()
}

type FieldIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFieldIdentifierContext() *FieldIdentifierContext {
	var p = new(FieldIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldIdentifier
	return p
}

func InitEmptyFieldIdentifierContext(p *FieldIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_fieldIdentifier
}

func (*FieldIdentifierContext) IsFieldIdentifierContext() {}

func NewFieldIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FieldIdentifierContext {
	var p = new(FieldIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_fieldIdentifier

	return p
}

func (s *FieldIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *FieldIdentifierContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *FieldIdentifierContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *FieldIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FieldIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FieldIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFieldIdentifier(s)
	}
}

func (s *FieldIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFieldIdentifier(s)
	}
}

func (s *FieldIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFieldIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FieldIdentifier() (localctx IFieldIdentifierContext) {
	localctx = NewFieldIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 654, TiDBParserRULE_fieldIdentifier)
	p.SetState(5257)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserDOT_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5252)
			p.DotIdentifier()
		}

	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5253)
			p.QualifiedIdentifier()
		}
		p.SetState(5255)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 708, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(5254)
				p.DotIdentifier()
			}

		} else if p.HasError() { // JIM
			goto errorExit
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnNameContext is an interface to support dynamic dispatch.
type IColumnNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FieldIdentifier() IFieldIdentifierContext

	// IsColumnNameContext differentiates from other interfaces.
	IsColumnNameContext()
}

type ColumnNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnNameContext() *ColumnNameContext {
	var p = new(ColumnNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnName
	return p
}

func InitEmptyColumnNameContext(p *ColumnNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnName
}

func (*ColumnNameContext) IsColumnNameContext() {}

func NewColumnNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnNameContext {
	var p = new(ColumnNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_columnName

	return p
}

func (s *ColumnNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnNameContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *ColumnNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterColumnName(s)
	}
}

func (s *ColumnNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitColumnName(s)
	}
}

func (s *ColumnNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitColumnName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ColumnName() (localctx IColumnNameContext) {
	localctx = NewColumnNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 656, TiDBParserRULE_columnName)
	p.SetState(5261)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 710, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5259)
			p.Identifier()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5260)
			p.FieldIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnInternalRefContext is an interface to support dynamic dispatch.
type IColumnInternalRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsColumnInternalRefContext differentiates from other interfaces.
	IsColumnInternalRefContext()
}

type ColumnInternalRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnInternalRefContext() *ColumnInternalRefContext {
	var p = new(ColumnInternalRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnInternalRef
	return p
}

func InitEmptyColumnInternalRefContext(p *ColumnInternalRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnInternalRef
}

func (*ColumnInternalRefContext) IsColumnInternalRefContext() {}

func NewColumnInternalRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnInternalRefContext {
	var p = new(ColumnInternalRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_columnInternalRef

	return p
}

func (s *ColumnInternalRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnInternalRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ColumnInternalRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnInternalRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnInternalRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterColumnInternalRef(s)
	}
}

func (s *ColumnInternalRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitColumnInternalRef(s)
	}
}

func (s *ColumnInternalRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitColumnInternalRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ColumnInternalRef() (localctx IColumnInternalRefContext) {
	localctx = NewColumnInternalRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 658, TiDBParserRULE_columnInternalRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5263)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnInternalRefListContext is an interface to support dynamic dispatch.
type IColumnInternalRefListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllColumnInternalRef() []IColumnInternalRefContext
	ColumnInternalRef(i int) IColumnInternalRefContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsColumnInternalRefListContext differentiates from other interfaces.
	IsColumnInternalRefListContext()
}

type ColumnInternalRefListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnInternalRefListContext() *ColumnInternalRefListContext {
	var p = new(ColumnInternalRefListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnInternalRefList
	return p
}

func InitEmptyColumnInternalRefListContext(p *ColumnInternalRefListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnInternalRefList
}

func (*ColumnInternalRefListContext) IsColumnInternalRefListContext() {}

func NewColumnInternalRefListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnInternalRefListContext {
	var p = new(ColumnInternalRefListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_columnInternalRefList

	return p
}

func (s *ColumnInternalRefListContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnInternalRefListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *ColumnInternalRefListContext) AllColumnInternalRef() []IColumnInternalRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IColumnInternalRefContext); ok {
			len++
		}
	}

	tst := make([]IColumnInternalRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IColumnInternalRefContext); ok {
			tst[i] = t.(IColumnInternalRefContext)
			i++
		}
	}

	return tst
}

func (s *ColumnInternalRefListContext) ColumnInternalRef(i int) IColumnInternalRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnInternalRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnInternalRefContext)
}

func (s *ColumnInternalRefListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ColumnInternalRefListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *ColumnInternalRefListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *ColumnInternalRefListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnInternalRefListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnInternalRefListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterColumnInternalRefList(s)
	}
}

func (s *ColumnInternalRefListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitColumnInternalRefList(s)
	}
}

func (s *ColumnInternalRefListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitColumnInternalRefList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ColumnInternalRefList() (localctx IColumnInternalRefListContext) {
	localctx = NewColumnInternalRefListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 660, TiDBParserRULE_columnInternalRefList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5265)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5266)
		p.ColumnInternalRef()
	}
	p.SetState(5271)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5267)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5268)
			p.ColumnInternalRef()
		}

		p.SetState(5273)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5274)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IColumnRefContext is an interface to support dynamic dispatch.
type IColumnRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext

	// IsColumnRefContext differentiates from other interfaces.
	IsColumnRefContext()
}

type ColumnRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyColumnRefContext() *ColumnRefContext {
	var p = new(ColumnRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnRef
	return p
}

func InitEmptyColumnRefContext(p *ColumnRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_columnRef
}

func (*ColumnRefContext) IsColumnRefContext() {}

func NewColumnRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ColumnRefContext {
	var p = new(ColumnRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_columnRef

	return p
}

func (s *ColumnRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ColumnRefContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *ColumnRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ColumnRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ColumnRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterColumnRef(s)
	}
}

func (s *ColumnRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitColumnRef(s)
	}
}

func (s *ColumnRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitColumnRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ColumnRef() (localctx IColumnRefContext) {
	localctx = NewColumnRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 662, TiDBParserRULE_columnRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5276)
		p.FieldIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IInsertIdentifierContext is an interface to support dynamic dispatch.
type IInsertIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ColumnRef() IColumnRefContext
	TableWild() ITableWildContext

	// IsInsertIdentifierContext differentiates from other interfaces.
	IsInsertIdentifierContext()
}

type InsertIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInsertIdentifierContext() *InsertIdentifierContext {
	var p = new(InsertIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_insertIdentifier
	return p
}

func InitEmptyInsertIdentifierContext(p *InsertIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_insertIdentifier
}

func (*InsertIdentifierContext) IsInsertIdentifierContext() {}

func NewInsertIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InsertIdentifierContext {
	var p = new(InsertIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_insertIdentifier

	return p
}

func (s *InsertIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *InsertIdentifierContext) ColumnRef() IColumnRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IColumnRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IColumnRefContext)
}

func (s *InsertIdentifierContext) TableWild() ITableWildContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableWildContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableWildContext)
}

func (s *InsertIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InsertIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *InsertIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterInsertIdentifier(s)
	}
}

func (s *InsertIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitInsertIdentifier(s)
	}
}

func (s *InsertIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitInsertIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) InsertIdentifier() (localctx IInsertIdentifierContext) {
	localctx = NewInsertIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 664, TiDBParserRULE_insertIdentifier)
	p.SetState(5280)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 712, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5278)
			p.ColumnRef()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5279)
			p.TableWild()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexNameContext is an interface to support dynamic dispatch.
type IIndexNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsIndexNameContext differentiates from other interfaces.
	IsIndexNameContext()
}

type IndexNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexNameContext() *IndexNameContext {
	var p = new(IndexNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexName
	return p
}

func InitEmptyIndexNameContext(p *IndexNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexName
}

func (*IndexNameContext) IsIndexNameContext() {}

func NewIndexNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexNameContext {
	var p = new(IndexNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexName

	return p
}

func (s *IndexNameContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IndexNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexName(s)
	}
}

func (s *IndexNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexName(s)
	}
}

func (s *IndexNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexName() (localctx IIndexNameContext) {
	localctx = NewIndexNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 666, TiDBParserRULE_indexName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5282)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIndexRefContext is an interface to support dynamic dispatch.
type IIndexRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldIdentifier() IFieldIdentifierContext

	// IsIndexRefContext differentiates from other interfaces.
	IsIndexRefContext()
}

type IndexRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIndexRefContext() *IndexRefContext {
	var p = new(IndexRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexRef
	return p
}

func InitEmptyIndexRefContext(p *IndexRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_indexRef
}

func (*IndexRefContext) IsIndexRefContext() {}

func NewIndexRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IndexRefContext {
	var p = new(IndexRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_indexRef

	return p
}

func (s *IndexRefContext) GetParser() antlr.Parser { return s.parser }

func (s *IndexRefContext) FieldIdentifier() IFieldIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldIdentifierContext)
}

func (s *IndexRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IndexRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIndexRef(s)
	}
}

func (s *IndexRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIndexRef(s)
	}
}

func (s *IndexRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIndexRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IndexRef() (localctx IIndexRefContext) {
	localctx = NewIndexRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 668, TiDBParserRULE_indexRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5284)
		p.FieldIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableWildContext is an interface to support dynamic dispatch.
type ITableWildContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllDOT_SYMBOL() []antlr.TerminalNode
	DOT_SYMBOL(i int) antlr.TerminalNode
	MULT_OPERATOR() antlr.TerminalNode

	// IsTableWildContext differentiates from other interfaces.
	IsTableWildContext()
}

type TableWildContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableWildContext() *TableWildContext {
	var p = new(TableWildContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableWild
	return p
}

func InitEmptyTableWildContext(p *TableWildContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableWild
}

func (*TableWildContext) IsTableWildContext() {}

func NewTableWildContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableWildContext {
	var p = new(TableWildContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableWild

	return p
}

func (s *TableWildContext) GetParser() antlr.Parser { return s.parser }

func (s *TableWildContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *TableWildContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableWildContext) AllDOT_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserDOT_SYMBOL)
}

func (s *TableWildContext) DOT_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserDOT_SYMBOL, i)
}

func (s *TableWildContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULT_OPERATOR, 0)
}

func (s *TableWildContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableWildContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableWildContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableWild(s)
	}
}

func (s *TableWildContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableWild(s)
	}
}

func (s *TableWildContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableWild(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableWild() (localctx ITableWildContext) {
	localctx = NewTableWildContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 670, TiDBParserRULE_tableWild)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5286)
		p.Identifier()
	}
	{
		p.SetState(5287)
		p.Match(TiDBParserDOT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	p.SetState(5291)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	if ((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-6384741829871848468) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&870188863488261855) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-460035944622047605) != 0) || ((int64((_la-196)) & ^0x3f) == 0 && ((int64(1)<<(_la-196))&-2863298813801015965) != 0) || ((int64((_la-262)) & ^0x3f) == 0 && ((int64(1)<<(_la-262))&-297237626723362459) != 0) || ((int64((_la-327)) & ^0x3f) == 0 && ((int64(1)<<(_la-327))&-7289982179169589309) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-1770021221380194305) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2215001111029112159) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283318072503) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&4450630148141932515) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-18077457131314819) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&1152921504640401343) != 0) || ((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&1407) != 0) {
		{
			p.SetState(5288)
			p.Identifier()
		}
		{
			p.SetState(5289)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	}
	{
		p.SetState(5293)
		p.Match(TiDBParserMULT_OPERATOR)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaNameContext is an interface to support dynamic dispatch.
type ISchemaNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsSchemaNameContext differentiates from other interfaces.
	IsSchemaNameContext()
}

type SchemaNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaNameContext() *SchemaNameContext {
	var p = new(SchemaNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_schemaName
	return p
}

func InitEmptySchemaNameContext(p *SchemaNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_schemaName
}

func (*SchemaNameContext) IsSchemaNameContext() {}

func NewSchemaNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaNameContext {
	var p = new(SchemaNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_schemaName

	return p
}

func (s *SchemaNameContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SchemaNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSchemaName(s)
	}
}

func (s *SchemaNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSchemaName(s)
	}
}

func (s *SchemaNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSchemaName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SchemaName() (localctx ISchemaNameContext) {
	localctx = NewSchemaNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 672, TiDBParserRULE_schemaName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5295)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISchemaRefContext is an interface to support dynamic dispatch.
type ISchemaRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsSchemaRefContext differentiates from other interfaces.
	IsSchemaRefContext()
}

type SchemaRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySchemaRefContext() *SchemaRefContext {
	var p = new(SchemaRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_schemaRef
	return p
}

func InitEmptySchemaRefContext(p *SchemaRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_schemaRef
}

func (*SchemaRefContext) IsSchemaRefContext() {}

func NewSchemaRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SchemaRefContext {
	var p = new(SchemaRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_schemaRef

	return p
}

func (s *SchemaRefContext) GetParser() antlr.Parser { return s.parser }

func (s *SchemaRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SchemaRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SchemaRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SchemaRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSchemaRef(s)
	}
}

func (s *SchemaRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSchemaRef(s)
	}
}

func (s *SchemaRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSchemaRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SchemaRef() (localctx ISchemaRefContext) {
	localctx = NewSchemaRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 674, TiDBParserRULE_schemaRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5297)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureNameContext is an interface to support dynamic dispatch.
type IProcedureNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsProcedureNameContext differentiates from other interfaces.
	IsProcedureNameContext()
}

type ProcedureNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureNameContext() *ProcedureNameContext {
	var p = new(ProcedureNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_procedureName
	return p
}

func InitEmptyProcedureNameContext(p *ProcedureNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_procedureName
}

func (*ProcedureNameContext) IsProcedureNameContext() {}

func NewProcedureNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureNameContext {
	var p = new(ProcedureNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_procedureName

	return p
}

func (s *ProcedureNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *ProcedureNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterProcedureName(s)
	}
}

func (s *ProcedureNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitProcedureName(s)
	}
}

func (s *ProcedureNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitProcedureName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ProcedureName() (localctx IProcedureNameContext) {
	localctx = NewProcedureNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 676, TiDBParserRULE_procedureName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5299)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IProcedureRefContext is an interface to support dynamic dispatch.
type IProcedureRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsProcedureRefContext differentiates from other interfaces.
	IsProcedureRefContext()
}

type ProcedureRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyProcedureRefContext() *ProcedureRefContext {
	var p = new(ProcedureRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_procedureRef
	return p
}

func InitEmptyProcedureRefContext(p *ProcedureRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_procedureRef
}

func (*ProcedureRefContext) IsProcedureRefContext() {}

func NewProcedureRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ProcedureRefContext {
	var p = new(ProcedureRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_procedureRef

	return p
}

func (s *ProcedureRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ProcedureRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *ProcedureRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ProcedureRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ProcedureRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterProcedureRef(s)
	}
}

func (s *ProcedureRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitProcedureRef(s)
	}
}

func (s *ProcedureRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitProcedureRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ProcedureRef() (localctx IProcedureRefContext) {
	localctx = NewProcedureRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 678, TiDBParserRULE_procedureRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5301)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionNameContext is an interface to support dynamic dispatch.
type IFunctionNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsFunctionNameContext differentiates from other interfaces.
	IsFunctionNameContext()
}

type FunctionNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionNameContext() *FunctionNameContext {
	var p = new(FunctionNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_functionName
	return p
}

func InitEmptyFunctionNameContext(p *FunctionNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_functionName
}

func (*FunctionNameContext) IsFunctionNameContext() {}

func NewFunctionNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionNameContext {
	var p = new(FunctionNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_functionName

	return p
}

func (s *FunctionNameContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *FunctionNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFunctionName(s)
	}
}

func (s *FunctionNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFunctionName(s)
	}
}

func (s *FunctionNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFunctionName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FunctionName() (localctx IFunctionNameContext) {
	localctx = NewFunctionNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 680, TiDBParserRULE_functionName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5303)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFunctionRefContext is an interface to support dynamic dispatch.
type IFunctionRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsFunctionRefContext differentiates from other interfaces.
	IsFunctionRefContext()
}

type FunctionRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionRefContext() *FunctionRefContext {
	var p = new(FunctionRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_functionRef
	return p
}

func InitEmptyFunctionRefContext(p *FunctionRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_functionRef
}

func (*FunctionRefContext) IsFunctionRefContext() {}

func NewFunctionRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionRefContext {
	var p = new(FunctionRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_functionRef

	return p
}

func (s *FunctionRefContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *FunctionRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FunctionRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFunctionRef(s)
	}
}

func (s *FunctionRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFunctionRef(s)
	}
}

func (s *FunctionRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFunctionRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FunctionRef() (localctx IFunctionRefContext) {
	localctx = NewFunctionRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 682, TiDBParserRULE_functionRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5305)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerNameContext is an interface to support dynamic dispatch.
type ITriggerNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsTriggerNameContext differentiates from other interfaces.
	IsTriggerNameContext()
}

type TriggerNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerNameContext() *TriggerNameContext {
	var p = new(TriggerNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_triggerName
	return p
}

func InitEmptyTriggerNameContext(p *TriggerNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_triggerName
}

func (*TriggerNameContext) IsTriggerNameContext() {}

func NewTriggerNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerNameContext {
	var p = new(TriggerNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_triggerName

	return p
}

func (s *TriggerNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *TriggerNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTriggerName(s)
	}
}

func (s *TriggerNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTriggerName(s)
	}
}

func (s *TriggerNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTriggerName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TriggerName() (localctx ITriggerNameContext) {
	localctx = NewTriggerNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 684, TiDBParserRULE_triggerName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5307)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITriggerRefContext is an interface to support dynamic dispatch.
type ITriggerRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsTriggerRefContext differentiates from other interfaces.
	IsTriggerRefContext()
}

type TriggerRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTriggerRefContext() *TriggerRefContext {
	var p = new(TriggerRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_triggerRef
	return p
}

func InitEmptyTriggerRefContext(p *TriggerRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_triggerRef
}

func (*TriggerRefContext) IsTriggerRefContext() {}

func NewTriggerRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TriggerRefContext {
	var p = new(TriggerRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_triggerRef

	return p
}

func (s *TriggerRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TriggerRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *TriggerRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TriggerRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TriggerRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTriggerRef(s)
	}
}

func (s *TriggerRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTriggerRef(s)
	}
}

func (s *TriggerRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTriggerRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TriggerRef() (localctx ITriggerRefContext) {
	localctx = NewTriggerRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 686, TiDBParserRULE_triggerRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5309)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewNameContext is an interface to support dynamic dispatch.
type IViewNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsViewNameContext differentiates from other interfaces.
	IsViewNameContext()
}

type ViewNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewNameContext() *ViewNameContext {
	var p = new(ViewNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_viewName
	return p
}

func InitEmptyViewNameContext(p *ViewNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_viewName
}

func (*ViewNameContext) IsViewNameContext() {}

func NewViewNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewNameContext {
	var p = new(ViewNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_viewName

	return p
}

func (s *ViewNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *ViewNameContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *ViewNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterViewName(s)
	}
}

func (s *ViewNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitViewName(s)
	}
}

func (s *ViewNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitViewName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ViewName() (localctx IViewNameContext) {
	localctx = NewViewNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 688, TiDBParserRULE_viewName)
	p.SetState(5313)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5311)
			p.QualifiedIdentifier()
		}

	case TiDBParserDOT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5312)
			p.DotIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IViewRefContext is an interface to support dynamic dispatch.
type IViewRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsViewRefContext differentiates from other interfaces.
	IsViewRefContext()
}

type ViewRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyViewRefContext() *ViewRefContext {
	var p = new(ViewRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_viewRef
	return p
}

func InitEmptyViewRefContext(p *ViewRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_viewRef
}

func (*ViewRefContext) IsViewRefContext() {}

func NewViewRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ViewRefContext {
	var p = new(ViewRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_viewRef

	return p
}

func (s *ViewRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ViewRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *ViewRefContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *ViewRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ViewRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ViewRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterViewRef(s)
	}
}

func (s *ViewRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitViewRef(s)
	}
}

func (s *ViewRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitViewRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ViewRef() (localctx IViewRefContext) {
	localctx = NewViewRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 690, TiDBParserRULE_viewRef)
	p.SetState(5317)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5315)
			p.QualifiedIdentifier()
		}

	case TiDBParserDOT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5316)
			p.DotIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceNameContext is an interface to support dynamic dispatch.
type ITablespaceNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsTablespaceNameContext differentiates from other interfaces.
	IsTablespaceNameContext()
}

type TablespaceNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceNameContext() *TablespaceNameContext {
	var p = new(TablespaceNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tablespaceName
	return p
}

func InitEmptyTablespaceNameContext(p *TablespaceNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tablespaceName
}

func (*TablespaceNameContext) IsTablespaceNameContext() {}

func NewTablespaceNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceNameContext {
	var p = new(TablespaceNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tablespaceName

	return p
}

func (s *TablespaceNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablespaceNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTablespaceName(s)
	}
}

func (s *TablespaceNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTablespaceName(s)
	}
}

func (s *TablespaceNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTablespaceName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TablespaceName() (localctx ITablespaceNameContext) {
	localctx = NewTablespaceNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 692, TiDBParserRULE_tablespaceName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5319)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITablespaceRefContext is an interface to support dynamic dispatch.
type ITablespaceRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsTablespaceRefContext differentiates from other interfaces.
	IsTablespaceRefContext()
}

type TablespaceRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTablespaceRefContext() *TablespaceRefContext {
	var p = new(TablespaceRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tablespaceRef
	return p
}

func InitEmptyTablespaceRefContext(p *TablespaceRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tablespaceRef
}

func (*TablespaceRefContext) IsTablespaceRefContext() {}

func NewTablespaceRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TablespaceRefContext {
	var p = new(TablespaceRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tablespaceRef

	return p
}

func (s *TablespaceRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TablespaceRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TablespaceRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TablespaceRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TablespaceRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTablespaceRef(s)
	}
}

func (s *TablespaceRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTablespaceRef(s)
	}
}

func (s *TablespaceRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTablespaceRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TablespaceRef() (localctx ITablespaceRefContext) {
	localctx = NewTablespaceRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 694, TiDBParserRULE_tablespaceRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5321)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogfileGroupNameContext is an interface to support dynamic dispatch.
type ILogfileGroupNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLogfileGroupNameContext differentiates from other interfaces.
	IsLogfileGroupNameContext()
}

type LogfileGroupNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogfileGroupNameContext() *LogfileGroupNameContext {
	var p = new(LogfileGroupNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_logfileGroupName
	return p
}

func InitEmptyLogfileGroupNameContext(p *LogfileGroupNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_logfileGroupName
}

func (*LogfileGroupNameContext) IsLogfileGroupNameContext() {}

func NewLogfileGroupNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogfileGroupNameContext {
	var p = new(LogfileGroupNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_logfileGroupName

	return p
}

func (s *LogfileGroupNameContext) GetParser() antlr.Parser { return s.parser }

func (s *LogfileGroupNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LogfileGroupNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogfileGroupNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogfileGroupNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLogfileGroupName(s)
	}
}

func (s *LogfileGroupNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLogfileGroupName(s)
	}
}

func (s *LogfileGroupNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLogfileGroupName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LogfileGroupName() (localctx ILogfileGroupNameContext) {
	localctx = NewLogfileGroupNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 696, TiDBParserRULE_logfileGroupName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5323)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILogfileGroupRefContext is an interface to support dynamic dispatch.
type ILogfileGroupRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLogfileGroupRefContext differentiates from other interfaces.
	IsLogfileGroupRefContext()
}

type LogfileGroupRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLogfileGroupRefContext() *LogfileGroupRefContext {
	var p = new(LogfileGroupRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_logfileGroupRef
	return p
}

func InitEmptyLogfileGroupRefContext(p *LogfileGroupRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_logfileGroupRef
}

func (*LogfileGroupRefContext) IsLogfileGroupRefContext() {}

func NewLogfileGroupRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LogfileGroupRefContext {
	var p = new(LogfileGroupRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_logfileGroupRef

	return p
}

func (s *LogfileGroupRefContext) GetParser() antlr.Parser { return s.parser }

func (s *LogfileGroupRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LogfileGroupRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LogfileGroupRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LogfileGroupRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLogfileGroupRef(s)
	}
}

func (s *LogfileGroupRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLogfileGroupRef(s)
	}
}

func (s *LogfileGroupRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLogfileGroupRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LogfileGroupRef() (localctx ILogfileGroupRefContext) {
	localctx = NewLogfileGroupRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 698, TiDBParserRULE_logfileGroupRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5325)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventNameContext is an interface to support dynamic dispatch.
type IEventNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsEventNameContext differentiates from other interfaces.
	IsEventNameContext()
}

type EventNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventNameContext() *EventNameContext {
	var p = new(EventNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_eventName
	return p
}

func InitEmptyEventNameContext(p *EventNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_eventName
}

func (*EventNameContext) IsEventNameContext() {}

func NewEventNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventNameContext {
	var p = new(EventNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_eventName

	return p
}

func (s *EventNameContext) GetParser() antlr.Parser { return s.parser }

func (s *EventNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *EventNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterEventName(s)
	}
}

func (s *EventNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitEventName(s)
	}
}

func (s *EventNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitEventName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) EventName() (localctx IEventNameContext) {
	localctx = NewEventNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 700, TiDBParserRULE_eventName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5327)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEventRefContext is an interface to support dynamic dispatch.
type IEventRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext

	// IsEventRefContext differentiates from other interfaces.
	IsEventRefContext()
}

type EventRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEventRefContext() *EventRefContext {
	var p = new(EventRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_eventRef
	return p
}

func InitEmptyEventRefContext(p *EventRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_eventRef
}

func (*EventRefContext) IsEventRefContext() {}

func NewEventRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EventRefContext {
	var p = new(EventRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_eventRef

	return p
}

func (s *EventRefContext) GetParser() antlr.Parser { return s.parser }

func (s *EventRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *EventRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EventRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EventRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterEventRef(s)
	}
}

func (s *EventRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitEventRef(s)
	}
}

func (s *EventRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitEventRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) EventRef() (localctx IEventRefContext) {
	localctx = NewEventRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 702, TiDBParserRULE_eventRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5329)
		p.QualifiedIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUdfNameContext is an interface to support dynamic dispatch.
type IUdfNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsUdfNameContext differentiates from other interfaces.
	IsUdfNameContext()
}

type UdfNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUdfNameContext() *UdfNameContext {
	var p = new(UdfNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_udfName
	return p
}

func InitEmptyUdfNameContext(p *UdfNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_udfName
}

func (*UdfNameContext) IsUdfNameContext() {}

func NewUdfNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UdfNameContext {
	var p = new(UdfNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_udfName

	return p
}

func (s *UdfNameContext) GetParser() antlr.Parser { return s.parser }

func (s *UdfNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *UdfNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UdfNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *UdfNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUdfName(s)
	}
}

func (s *UdfNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUdfName(s)
	}
}

func (s *UdfNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUdfName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) UdfName() (localctx IUdfNameContext) {
	localctx = NewUdfNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 704, TiDBParserRULE_udfName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5331)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerNameContext is an interface to support dynamic dispatch.
type IServerNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext

	// IsServerNameContext differentiates from other interfaces.
	IsServerNameContext()
}

type ServerNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerNameContext() *ServerNameContext {
	var p = new(ServerNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_serverName
	return p
}

func InitEmptyServerNameContext(p *ServerNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_serverName
}

func (*ServerNameContext) IsServerNameContext() {}

func NewServerNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerNameContext {
	var p = new(ServerNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_serverName

	return p
}

func (s *ServerNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerNameContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *ServerNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterServerName(s)
	}
}

func (s *ServerNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitServerName(s)
	}
}

func (s *ServerNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitServerName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ServerName() (localctx IServerNameContext) {
	localctx = NewServerNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 706, TiDBParserRULE_serverName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5333)
		p.TextOrIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IServerRefContext is an interface to support dynamic dispatch.
type IServerRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext

	// IsServerRefContext differentiates from other interfaces.
	IsServerRefContext()
}

type ServerRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyServerRefContext() *ServerRefContext {
	var p = new(ServerRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_serverRef
	return p
}

func InitEmptyServerRefContext(p *ServerRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_serverRef
}

func (*ServerRefContext) IsServerRefContext() {}

func NewServerRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ServerRefContext {
	var p = new(ServerRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_serverRef

	return p
}

func (s *ServerRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ServerRefContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *ServerRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ServerRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ServerRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterServerRef(s)
	}
}

func (s *ServerRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitServerRef(s)
	}
}

func (s *ServerRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitServerRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ServerRef() (localctx IServerRefContext) {
	localctx = NewServerRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 708, TiDBParserRULE_serverRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5335)
		p.TextOrIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEngineRefContext is an interface to support dynamic dispatch.
type IEngineRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextOrIdentifier() ITextOrIdentifierContext

	// IsEngineRefContext differentiates from other interfaces.
	IsEngineRefContext()
}

type EngineRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEngineRefContext() *EngineRefContext {
	var p = new(EngineRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_engineRef
	return p
}

func InitEmptyEngineRefContext(p *EngineRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_engineRef
}

func (*EngineRefContext) IsEngineRefContext() {}

func NewEngineRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EngineRefContext {
	var p = new(EngineRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_engineRef

	return p
}

func (s *EngineRefContext) GetParser() antlr.Parser { return s.parser }

func (s *EngineRefContext) TextOrIdentifier() ITextOrIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextOrIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextOrIdentifierContext)
}

func (s *EngineRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EngineRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EngineRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterEngineRef(s)
	}
}

func (s *EngineRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitEngineRef(s)
	}
}

func (s *EngineRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitEngineRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) EngineRef() (localctx IEngineRefContext) {
	localctx = NewEngineRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 710, TiDBParserRULE_engineRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5337)
		p.TextOrIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableNameContext is an interface to support dynamic dispatch.
type ITableNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsTableNameContext differentiates from other interfaces.
	IsTableNameContext()
}

type TableNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableNameContext() *TableNameContext {
	var p = new(TableNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableName
	return p
}

func InitEmptyTableNameContext(p *TableNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableName
}

func (*TableNameContext) IsTableNameContext() {}

func NewTableNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableNameContext {
	var p = new(TableNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableName

	return p
}

func (s *TableNameContext) GetParser() antlr.Parser { return s.parser }

func (s *TableNameContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *TableNameContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *TableNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableName(s)
	}
}

func (s *TableNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableName(s)
	}
}

func (s *TableNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableName() (localctx ITableNameContext) {
	localctx = NewTableNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 712, TiDBParserRULE_tableName)
	p.SetState(5341)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5339)
			p.QualifiedIdentifier()
		}

	case TiDBParserDOT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5340)
			p.DotIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFilterTableRefContext is an interface to support dynamic dispatch.
type IFilterTableRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SchemaRef() ISchemaRefContext
	DotIdentifier() IDotIdentifierContext

	// IsFilterTableRefContext differentiates from other interfaces.
	IsFilterTableRefContext()
}

type FilterTableRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFilterTableRefContext() *FilterTableRefContext {
	var p = new(FilterTableRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterTableRef
	return p
}

func InitEmptyFilterTableRefContext(p *FilterTableRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_filterTableRef
}

func (*FilterTableRefContext) IsFilterTableRefContext() {}

func NewFilterTableRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FilterTableRefContext {
	var p = new(FilterTableRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_filterTableRef

	return p
}

func (s *FilterTableRefContext) GetParser() antlr.Parser { return s.parser }

func (s *FilterTableRefContext) SchemaRef() ISchemaRefContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISchemaRefContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISchemaRefContext)
}

func (s *FilterTableRefContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *FilterTableRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FilterTableRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FilterTableRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFilterTableRef(s)
	}
}

func (s *FilterTableRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFilterTableRef(s)
	}
}

func (s *FilterTableRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFilterTableRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FilterTableRef() (localctx IFilterTableRefContext) {
	localctx = NewFilterTableRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 714, TiDBParserRULE_filterTableRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5343)
		p.SchemaRef()
	}
	{
		p.SetState(5344)
		p.DotIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRefWithWildcardContext is an interface to support dynamic dispatch.
type ITableRefWithWildcardContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DOT_SYMBOL() antlr.TerminalNode
	MULT_OPERATOR() antlr.TerminalNode
	DotIdentifier() IDotIdentifierContext

	// IsTableRefWithWildcardContext differentiates from other interfaces.
	IsTableRefWithWildcardContext()
}

type TableRefWithWildcardContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRefWithWildcardContext() *TableRefWithWildcardContext {
	var p = new(TableRefWithWildcardContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableRefWithWildcard
	return p
}

func InitEmptyTableRefWithWildcardContext(p *TableRefWithWildcardContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableRefWithWildcard
}

func (*TableRefWithWildcardContext) IsTableRefWithWildcardContext() {}

func NewTableRefWithWildcardContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRefWithWildcardContext {
	var p = new(TableRefWithWildcardContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableRefWithWildcard

	return p
}

func (s *TableRefWithWildcardContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRefWithWildcardContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TableRefWithWildcardContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDOT_SYMBOL, 0)
}

func (s *TableRefWithWildcardContext) MULT_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULT_OPERATOR, 0)
}

func (s *TableRefWithWildcardContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *TableRefWithWildcardContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRefWithWildcardContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRefWithWildcardContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableRefWithWildcard(s)
	}
}

func (s *TableRefWithWildcardContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableRefWithWildcard(s)
	}
}

func (s *TableRefWithWildcardContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableRefWithWildcard(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableRefWithWildcard() (localctx ITableRefWithWildcardContext) {
	localctx = NewTableRefWithWildcardContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 716, TiDBParserRULE_tableRefWithWildcard)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5346)
		p.Identifier()
	}
	p.SetState(5354)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 718, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5347)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5348)
			p.Match(TiDBParserMULT_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	} else if p.HasError() { // JIM
		goto errorExit
	} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 718, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(5349)
			p.DotIdentifier()
		}
		p.SetState(5352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDOT_SYMBOL {
			{
				p.SetState(5350)
				p.Match(TiDBParserDOT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}
			{
				p.SetState(5351)
				p.Match(TiDBParserMULT_OPERATOR)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRefContext is an interface to support dynamic dispatch.
type ITableRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsTableRefContext differentiates from other interfaces.
	IsTableRefContext()
}

type TableRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRefContext() *TableRefContext {
	var p = new(TableRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableRef
	return p
}

func InitEmptyTableRefContext(p *TableRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableRef
}

func (*TableRefContext) IsTableRefContext() {}

func NewTableRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRefContext {
	var p = new(TableRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableRef

	return p
}

func (s *TableRefContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRefContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *TableRefContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *TableRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableRef(s)
	}
}

func (s *TableRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableRef(s)
	}
}

func (s *TableRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableRef() (localctx ITableRefContext) {
	localctx = NewTableRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 718, TiDBParserRULE_tableRef)
	p.SetState(5358)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5356)
			p.QualifiedIdentifier()
		}

	case TiDBParserDOT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5357)
			p.DotIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableRefListContext is an interface to support dynamic dispatch.
type ITableRefListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableRef() []ITableRefContext
	TableRef(i int) ITableRefContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTableRefListContext differentiates from other interfaces.
	IsTableRefListContext()
}

type TableRefListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableRefListContext() *TableRefListContext {
	var p = new(TableRefListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableRefList
	return p
}

func InitEmptyTableRefListContext(p *TableRefListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableRefList
}

func (*TableRefListContext) IsTableRefListContext() {}

func NewTableRefListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableRefListContext {
	var p = new(TableRefListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableRefList

	return p
}

func (s *TableRefListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableRefListContext) AllTableRef() []ITableRefContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableRefContext); ok {
			len++
		}
	}

	tst := make([]ITableRefContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableRefContext); ok {
			tst[i] = t.(ITableRefContext)
			i++
		}
	}

	return tst
}

func (s *TableRefListContext) TableRef(i int) ITableRefContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefContext)
}

func (s *TableRefListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *TableRefListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *TableRefListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableRefListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableRefListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableRefList(s)
	}
}

func (s *TableRefListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableRefList(s)
	}
}

func (s *TableRefListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableRefList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableRefList() (localctx ITableRefListContext) {
	localctx = NewTableRefListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 720, TiDBParserRULE_tableRefList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5360)
		p.TableRef()
	}
	p.SetState(5365)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5361)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5362)
			p.TableRef()
		}

		p.SetState(5367)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITableAliasRefListContext is an interface to support dynamic dispatch.
type ITableAliasRefListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTableRefWithWildcard() []ITableRefWithWildcardContext
	TableRefWithWildcard(i int) ITableRefWithWildcardContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTableAliasRefListContext differentiates from other interfaces.
	IsTableAliasRefListContext()
}

type TableAliasRefListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTableAliasRefListContext() *TableAliasRefListContext {
	var p = new(TableAliasRefListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableAliasRefList
	return p
}

func InitEmptyTableAliasRefListContext(p *TableAliasRefListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_tableAliasRefList
}

func (*TableAliasRefListContext) IsTableAliasRefListContext() {}

func NewTableAliasRefListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TableAliasRefListContext {
	var p = new(TableAliasRefListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_tableAliasRefList

	return p
}

func (s *TableAliasRefListContext) GetParser() antlr.Parser { return s.parser }

func (s *TableAliasRefListContext) AllTableRefWithWildcard() []ITableRefWithWildcardContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITableRefWithWildcardContext); ok {
			len++
		}
	}

	tst := make([]ITableRefWithWildcardContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITableRefWithWildcardContext); ok {
			tst[i] = t.(ITableRefWithWildcardContext)
			i++
		}
	}

	return tst
}

func (s *TableAliasRefListContext) TableRefWithWildcard(i int) ITableRefWithWildcardContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITableRefWithWildcardContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITableRefWithWildcardContext)
}

func (s *TableAliasRefListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *TableAliasRefListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *TableAliasRefListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TableAliasRefListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TableAliasRefListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTableAliasRefList(s)
	}
}

func (s *TableAliasRefListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTableAliasRefList(s)
	}
}

func (s *TableAliasRefListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTableAliasRefList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TableAliasRefList() (localctx ITableAliasRefListContext) {
	localctx = NewTableAliasRefListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 722, TiDBParserRULE_tableAliasRefList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5368)
		p.TableRefWithWildcard()
	}
	p.SetState(5373)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5369)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5370)
			p.TableRefWithWildcard()
		}

		p.SetState(5375)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParameterNameContext is an interface to support dynamic dispatch.
type IParameterNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsParameterNameContext differentiates from other interfaces.
	IsParameterNameContext()
}

type ParameterNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterNameContext() *ParameterNameContext {
	var p = new(ParameterNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_parameterName
	return p
}

func InitEmptyParameterNameContext(p *ParameterNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_parameterName
}

func (*ParameterNameContext) IsParameterNameContext() {}

func NewParameterNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterNameContext {
	var p = new(ParameterNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_parameterName

	return p
}

func (s *ParameterNameContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParameterNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParameterNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterParameterName(s)
	}
}

func (s *ParameterNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitParameterName(s)
	}
}

func (s *ParameterNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitParameterName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ParameterName() (localctx IParameterNameContext) {
	localctx = NewParameterNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 724, TiDBParserRULE_parameterName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5376)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelIdentifierContext is an interface to support dynamic dispatch.
type ILabelIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	LabelKeyword() ILabelKeywordContext

	// IsLabelIdentifierContext differentiates from other interfaces.
	IsLabelIdentifierContext()
}

type LabelIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelIdentifierContext() *LabelIdentifierContext {
	var p = new(LabelIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_labelIdentifier
	return p
}

func InitEmptyLabelIdentifierContext(p *LabelIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_labelIdentifier
}

func (*LabelIdentifierContext) IsLabelIdentifierContext() {}

func NewLabelIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelIdentifierContext {
	var p = new(LabelIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_labelIdentifier

	return p
}

func (s *LabelIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelIdentifierContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *LabelIdentifierContext) LabelKeyword() ILabelKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelKeywordContext)
}

func (s *LabelIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLabelIdentifier(s)
	}
}

func (s *LabelIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLabelIdentifier(s)
	}
}

func (s *LabelIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLabelIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LabelIdentifier() (localctx ILabelIdentifierContext) {
	localctx = NewLabelIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 726, TiDBParserRULE_labelIdentifier)
	p.SetState(5380)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserUNDERLINE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5378)
			p.PureIdentifier()
		}

	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5379)
			p.LabelKeyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelRefContext is an interface to support dynamic dispatch.
type ILabelRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelIdentifier() ILabelIdentifierContext

	// IsLabelRefContext differentiates from other interfaces.
	IsLabelRefContext()
}

type LabelRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelRefContext() *LabelRefContext {
	var p = new(LabelRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_labelRef
	return p
}

func InitEmptyLabelRefContext(p *LabelRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_labelRef
}

func (*LabelRefContext) IsLabelRefContext() {}

func NewLabelRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelRefContext {
	var p = new(LabelRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_labelRef

	return p
}

func (s *LabelRefContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelRefContext) LabelIdentifier() ILabelIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelIdentifierContext)
}

func (s *LabelRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLabelRef(s)
	}
}

func (s *LabelRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLabelRef(s)
	}
}

func (s *LabelRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLabelRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LabelRef() (localctx ILabelRefContext) {
	localctx = NewLabelRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 728, TiDBParserRULE_labelRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5382)
		p.LabelIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleIdentifierContext is an interface to support dynamic dispatch.
type IRoleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	RoleKeyword() IRoleKeywordContext

	// IsRoleIdentifierContext differentiates from other interfaces.
	IsRoleIdentifierContext()
}

type RoleIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleIdentifierContext() *RoleIdentifierContext {
	var p = new(RoleIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleIdentifier
	return p
}

func InitEmptyRoleIdentifierContext(p *RoleIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleIdentifier
}

func (*RoleIdentifierContext) IsRoleIdentifierContext() {}

func NewRoleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleIdentifierContext {
	var p = new(RoleIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_roleIdentifier

	return p
}

func (s *RoleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleIdentifierContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *RoleIdentifierContext) RoleKeyword() IRoleKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleKeywordContext)
}

func (s *RoleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRoleIdentifier(s)
	}
}

func (s *RoleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRoleIdentifier(s)
	}
}

func (s *RoleIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRoleIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RoleIdentifier() (localctx IRoleIdentifierContext) {
	localctx = NewRoleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 730, TiDBParserRULE_roleIdentifier)
	p.SetState(5386)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserUNDERLINE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5384)
			p.PureIdentifier()
		}

	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5385)
			p.RoleKeyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleRefContext is an interface to support dynamic dispatch.
type IRoleRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleIdentifier() IRoleIdentifierContext

	// IsRoleRefContext differentiates from other interfaces.
	IsRoleRefContext()
}

type RoleRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleRefContext() *RoleRefContext {
	var p = new(RoleRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleRef
	return p
}

func InitEmptyRoleRefContext(p *RoleRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleRef
}

func (*RoleRefContext) IsRoleRefContext() {}

func NewRoleRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleRefContext {
	var p = new(RoleRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_roleRef

	return p
}

func (s *RoleRefContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleRefContext) RoleIdentifier() IRoleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleIdentifierContext)
}

func (s *RoleRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRoleRef(s)
	}
}

func (s *RoleRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRoleRef(s)
	}
}

func (s *RoleRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRoleRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RoleRef() (localctx IRoleRefContext) {
	localctx = NewRoleRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 732, TiDBParserRULE_roleRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5388)
		p.RoleIdentifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPluginRefContext is an interface to support dynamic dispatch.
type IPluginRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsPluginRefContext differentiates from other interfaces.
	IsPluginRefContext()
}

type PluginRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPluginRefContext() *PluginRefContext {
	var p = new(PluginRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_pluginRef
	return p
}

func InitEmptyPluginRefContext(p *PluginRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_pluginRef
}

func (*PluginRefContext) IsPluginRefContext() {}

func NewPluginRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PluginRefContext {
	var p = new(PluginRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_pluginRef

	return p
}

func (s *PluginRefContext) GetParser() antlr.Parser { return s.parser }

func (s *PluginRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *PluginRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PluginRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PluginRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPluginRef(s)
	}
}

func (s *PluginRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPluginRef(s)
	}
}

func (s *PluginRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPluginRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PluginRef() (localctx IPluginRefContext) {
	localctx = NewPluginRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 734, TiDBParserRULE_pluginRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5390)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IComponentRefContext is an interface to support dynamic dispatch.
type IComponentRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringLiteral() ITextStringLiteralContext

	// IsComponentRefContext differentiates from other interfaces.
	IsComponentRefContext()
}

type ComponentRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyComponentRefContext() *ComponentRefContext {
	var p = new(ComponentRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_componentRef
	return p
}

func InitEmptyComponentRefContext(p *ComponentRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_componentRef
}

func (*ComponentRefContext) IsComponentRefContext() {}

func NewComponentRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ComponentRefContext {
	var p = new(ComponentRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_componentRef

	return p
}

func (s *ComponentRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ComponentRefContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *ComponentRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ComponentRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ComponentRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterComponentRef(s)
	}
}

func (s *ComponentRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitComponentRef(s)
	}
}

func (s *ComponentRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitComponentRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ComponentRef() (localctx IComponentRefContext) {
	localctx = NewComponentRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 736, TiDBParserRULE_componentRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5392)
		p.TextStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IResourceGroupRefContext is an interface to support dynamic dispatch.
type IResourceGroupRefContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsResourceGroupRefContext differentiates from other interfaces.
	IsResourceGroupRefContext()
}

type ResourceGroupRefContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyResourceGroupRefContext() *ResourceGroupRefContext {
	var p = new(ResourceGroupRefContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupRef
	return p
}

func InitEmptyResourceGroupRefContext(p *ResourceGroupRefContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_resourceGroupRef
}

func (*ResourceGroupRefContext) IsResourceGroupRefContext() {}

func NewResourceGroupRefContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ResourceGroupRefContext {
	var p = new(ResourceGroupRefContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_resourceGroupRef

	return p
}

func (s *ResourceGroupRefContext) GetParser() antlr.Parser { return s.parser }

func (s *ResourceGroupRefContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ResourceGroupRefContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ResourceGroupRefContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ResourceGroupRefContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterResourceGroupRef(s)
	}
}

func (s *ResourceGroupRefContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitResourceGroupRef(s)
	}
}

func (s *ResourceGroupRefContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitResourceGroupRef(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) ResourceGroupRef() (localctx IResourceGroupRefContext) {
	localctx = NewResourceGroupRefContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 738, TiDBParserRULE_resourceGroupRef)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5394)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IWindowNameContext is an interface to support dynamic dispatch.
type IWindowNameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsWindowNameContext differentiates from other interfaces.
	IsWindowNameContext()
}

type WindowNameContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWindowNameContext() *WindowNameContext {
	var p = new(WindowNameContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowName
	return p
}

func InitEmptyWindowNameContext(p *WindowNameContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_windowName
}

func (*WindowNameContext) IsWindowNameContext() {}

func NewWindowNameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WindowNameContext {
	var p = new(WindowNameContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_windowName

	return p
}

func (s *WindowNameContext) GetParser() antlr.Parser { return s.parser }

func (s *WindowNameContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *WindowNameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WindowNameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WindowNameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterWindowName(s)
	}
}

func (s *WindowNameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitWindowName(s)
	}
}

func (s *WindowNameContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitWindowName(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) WindowName() (localctx IWindowNameContext) {
	localctx = NewWindowNameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 740, TiDBParserRULE_windowName)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5396)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPureIdentifierContext is an interface to support dynamic dispatch.
type IPureIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	BACK_TICK_QUOTED_ID() antlr.TerminalNode
	UNDERLINE_SYMBOL() antlr.TerminalNode

	// IsPureIdentifierContext differentiates from other interfaces.
	IsPureIdentifierContext()
}

type PureIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPureIdentifierContext() *PureIdentifierContext {
	var p = new(PureIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_pureIdentifier
	return p
}

func InitEmptyPureIdentifierContext(p *PureIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_pureIdentifier
}

func (*PureIdentifierContext) IsPureIdentifierContext() {}

func NewPureIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PureIdentifierContext {
	var p = new(PureIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_pureIdentifier

	return p
}

func (s *PureIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *PureIdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(TiDBParserIDENTIFIER, 0)
}

func (s *PureIdentifierContext) BACK_TICK_QUOTED_ID() antlr.TerminalNode {
	return s.GetToken(TiDBParserBACK_TICK_QUOTED_ID, 0)
}

func (s *PureIdentifierContext) UNDERLINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNDERLINE_SYMBOL, 0)
}

func (s *PureIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PureIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PureIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPureIdentifier(s)
	}
}

func (s *PureIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPureIdentifier(s)
	}
}

func (s *PureIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPureIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) PureIdentifier() (localctx IPureIdentifierContext) {
	localctx = NewPureIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 742, TiDBParserRULE_pureIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5398)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-780)) & ^0x3f) == 0 && ((int64(1)<<(_la-780))&41943041) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	IdentifierKeyword() IIdentifierKeywordContext

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *IdentifierContext) IdentifierKeyword() IIdentifierKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordContext)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentifier(s)
	}
}

func (s *IdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentifier(s)
	}
}

func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 744, TiDBParserRULE_identifier)
	p.SetState(5402)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserUNDERLINE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5400)
			p.PureIdentifier()
		}

	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5401)
			p.IdentifierKeyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListContext is an interface to support dynamic dispatch.
type IIdentifierListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllIdentifier() []IIdentifierContext
	Identifier(i int) IIdentifierContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsIdentifierListContext differentiates from other interfaces.
	IsIdentifierListContext()
}

type IdentifierListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListContext() *IdentifierListContext {
	var p = new(IdentifierListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierList
	return p
}

func InitEmptyIdentifierListContext(p *IdentifierListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierList
}

func (*IdentifierListContext) IsIdentifierListContext() {}

func NewIdentifierListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListContext {
	var p = new(IdentifierListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identifierList

	return p
}

func (s *IdentifierListContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListContext) AllIdentifier() []IIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IIdentifierContext); ok {
			tst[i] = t.(IIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *IdentifierListContext) Identifier(i int) IIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *IdentifierListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *IdentifierListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentifierList(s)
	}
}

func (s *IdentifierListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentifierList(s)
	}
}

func (s *IdentifierListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentifierList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentifierList() (localctx IIdentifierListContext) {
	localctx = NewIdentifierListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 746, TiDBParserRULE_identifierList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5404)
		p.Identifier()
	}
	p.SetState(5409)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5405)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5406)
			p.Identifier()
		}

		p.SetState(5411)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierListWithParenthesesContext is an interface to support dynamic dispatch.
type IIdentifierListWithParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	IdentifierList() IIdentifierListContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsIdentifierListWithParenthesesContext differentiates from other interfaces.
	IsIdentifierListWithParenthesesContext()
}

type IdentifierListWithParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierListWithParenthesesContext() *IdentifierListWithParenthesesContext {
	var p = new(IdentifierListWithParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierListWithParentheses
	return p
}

func InitEmptyIdentifierListWithParenthesesContext(p *IdentifierListWithParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierListWithParentheses
}

func (*IdentifierListWithParenthesesContext) IsIdentifierListWithParenthesesContext() {}

func NewIdentifierListWithParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierListWithParenthesesContext {
	var p = new(IdentifierListWithParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identifierListWithParentheses

	return p
}

func (s *IdentifierListWithParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierListWithParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *IdentifierListWithParenthesesContext) IdentifierList() IIdentifierListContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierListContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierListContext)
}

func (s *IdentifierListWithParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *IdentifierListWithParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierListWithParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierListWithParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentifierListWithParentheses(s)
	}
}

func (s *IdentifierListWithParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentifierListWithParentheses(s)
	}
}

func (s *IdentifierListWithParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentifierListWithParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentifierListWithParentheses() (localctx IIdentifierListWithParenthesesContext) {
	localctx = NewIdentifierListWithParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 748, TiDBParserRULE_identifierListWithParentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5412)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5413)
		p.IdentifierList()
	}
	{
		p.SetState(5414)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IQualifiedIdentifierContext is an interface to support dynamic dispatch.
type IQualifiedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	DotIdentifier() IDotIdentifierContext

	// IsQualifiedIdentifierContext differentiates from other interfaces.
	IsQualifiedIdentifierContext()
}

type QualifiedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdentifierContext() *QualifiedIdentifierContext {
	var p = new(QualifiedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_qualifiedIdentifier
	return p
}

func InitEmptyQualifiedIdentifierContext(p *QualifiedIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_qualifiedIdentifier
}

func (*QualifiedIdentifierContext) IsQualifiedIdentifierContext() {}

func NewQualifiedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdentifierContext {
	var p = new(QualifiedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_qualifiedIdentifier

	return p
}

func (s *QualifiedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedIdentifierContext) DotIdentifier() IDotIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *QualifiedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QualifiedIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterQualifiedIdentifier(s)
	}
}

func (s *QualifiedIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitQualifiedIdentifier(s)
	}
}

func (s *QualifiedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitQualifiedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) QualifiedIdentifier() (localctx IQualifiedIdentifierContext) {
	localctx = NewQualifiedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 750, TiDBParserRULE_qualifiedIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5416)
		p.Identifier()
	}
	p.SetState(5418)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 726, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(5417)
			p.DotIdentifier()
		}

	} else if p.HasError() { // JIM
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISimpleIdentifierContext is an interface to support dynamic dispatch.
type ISimpleIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllDotIdentifier() []IDotIdentifierContext
	DotIdentifier(i int) IDotIdentifierContext

	// IsSimpleIdentifierContext differentiates from other interfaces.
	IsSimpleIdentifierContext()
}

type SimpleIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleIdentifierContext() *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_simpleIdentifier
	return p
}

func InitEmptySimpleIdentifierContext(p *SimpleIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_simpleIdentifier
}

func (*SimpleIdentifierContext) IsSimpleIdentifierContext() {}

func NewSimpleIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleIdentifierContext {
	var p = new(SimpleIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_simpleIdentifier

	return p
}

func (s *SimpleIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *SimpleIdentifierContext) AllDotIdentifier() []IDotIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			len++
		}
	}

	tst := make([]IDotIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDotIdentifierContext); ok {
			tst[i] = t.(IDotIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *SimpleIdentifierContext) DotIdentifier(i int) IDotIdentifierContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDotIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDotIdentifierContext)
}

func (s *SimpleIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SimpleIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSimpleIdentifier(s)
	}
}

func (s *SimpleIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSimpleIdentifier(s)
	}
}

func (s *SimpleIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSimpleIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SimpleIdentifier() (localctx ISimpleIdentifierContext) {
	localctx = NewSimpleIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 752, TiDBParserRULE_simpleIdentifier)
	var _la int

	p.SetState(5430)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5420)
			p.Identifier()
		}
		p.SetState(5425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserDOT_SYMBOL {
			{
				p.SetState(5421)
				p.DotIdentifier()
			}
			p.SetState(5423)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}
			_la = p.GetTokenStream().LA(1)

			if _la == TiDBParserDOT_SYMBOL {
				{
					p.SetState(5422)
					p.DotIdentifier()
				}

			}

		}

	case TiDBParserDOT_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5427)
			p.DotIdentifier()
		}
		{
			p.SetState(5428)
			p.DotIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IDotIdentifierContext is an interface to support dynamic dispatch.
type IDotIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DOT_SYMBOL() antlr.TerminalNode
	Identifier() IIdentifierContext

	// IsDotIdentifierContext differentiates from other interfaces.
	IsDotIdentifierContext()
}

type DotIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDotIdentifierContext() *DotIdentifierContext {
	var p = new(DotIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dotIdentifier
	return p
}

func InitEmptyDotIdentifierContext(p *DotIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_dotIdentifier
}

func (*DotIdentifierContext) IsDotIdentifierContext() {}

func NewDotIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DotIdentifierContext {
	var p = new(DotIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_dotIdentifier

	return p
}

func (s *DotIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DotIdentifierContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDOT_SYMBOL, 0)
}

func (s *DotIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *DotIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DotIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DotIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterDotIdentifier(s)
	}
}

func (s *DotIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitDotIdentifier(s)
	}
}

func (s *DotIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitDotIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) DotIdentifier() (localctx IDotIdentifierContext) {
	localctx = NewDotIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 754, TiDBParserRULE_dotIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5432)
		p.Match(TiDBParserDOT_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5433)
		p.Identifier()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUlong_numberContext is an interface to support dynamic dispatch.
type IUlong_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	HEX_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	DECIMAL_NUMBER() antlr.TerminalNode
	FLOAT_NUMBER() antlr.TerminalNode

	// IsUlong_numberContext differentiates from other interfaces.
	IsUlong_numberContext()
}

type Ulong_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUlong_numberContext() *Ulong_numberContext {
	var p = new(Ulong_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ulong_number
	return p
}

func InitEmptyUlong_numberContext(p *Ulong_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ulong_number
}

func (*Ulong_numberContext) IsUlong_numberContext() {}

func NewUlong_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ulong_numberContext {
	var p = new(Ulong_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_ulong_number

	return p
}

func (s *Ulong_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Ulong_numberContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *Ulong_numberContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserHEX_NUMBER, 0)
}

func (s *Ulong_numberContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserLONG_NUMBER, 0)
}

func (s *Ulong_numberContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserULONGLONG_NUMBER, 0)
}

func (s *Ulong_numberContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserDECIMAL_NUMBER, 0)
}

func (s *Ulong_numberContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserFLOAT_NUMBER, 0)
}

func (s *Ulong_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ulong_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ulong_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUlong_number(s)
	}
}

func (s *Ulong_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUlong_number(s)
	}
}

func (s *Ulong_numberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUlong_number(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Ulong_number() (localctx IUlong_numberContext) {
	localctx = NewUlong_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 756, TiDBParserRULE_ulong_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5435)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&28587302322183) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReal_ulong_numberContext is an interface to support dynamic dispatch.
type IReal_ulong_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	HEX_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode

	// IsReal_ulong_numberContext differentiates from other interfaces.
	IsReal_ulong_numberContext()
}

type Real_ulong_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_ulong_numberContext() *Real_ulong_numberContext {
	var p = new(Real_ulong_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_real_ulong_number
	return p
}

func InitEmptyReal_ulong_numberContext(p *Real_ulong_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_real_ulong_number
}

func (*Real_ulong_numberContext) IsReal_ulong_numberContext() {}

func NewReal_ulong_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_ulong_numberContext {
	var p = new(Real_ulong_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_real_ulong_number

	return p
}

func (s *Real_ulong_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_ulong_numberContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *Real_ulong_numberContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserHEX_NUMBER, 0)
}

func (s *Real_ulong_numberContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserLONG_NUMBER, 0)
}

func (s *Real_ulong_numberContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserULONGLONG_NUMBER, 0)
}

func (s *Real_ulong_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_ulong_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_ulong_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterReal_ulong_number(s)
	}
}

func (s *Real_ulong_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitReal_ulong_number(s)
	}
}

func (s *Real_ulong_numberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitReal_ulong_number(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Real_ulong_number() (localctx IReal_ulong_numberContext) {
	localctx = NewReal_ulong_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 758, TiDBParserRULE_real_ulong_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5437)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&2199023255559) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IUlonglong_numberContext is an interface to support dynamic dispatch.
type IUlonglong_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	DECIMAL_NUMBER() antlr.TerminalNode
	FLOAT_NUMBER() antlr.TerminalNode

	// IsUlonglong_numberContext differentiates from other interfaces.
	IsUlonglong_numberContext()
}

type Ulonglong_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUlonglong_numberContext() *Ulonglong_numberContext {
	var p = new(Ulonglong_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ulonglong_number
	return p
}

func InitEmptyUlonglong_numberContext(p *Ulonglong_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_ulonglong_number
}

func (*Ulonglong_numberContext) IsUlonglong_numberContext() {}

func NewUlonglong_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Ulonglong_numberContext {
	var p = new(Ulonglong_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_ulonglong_number

	return p
}

func (s *Ulonglong_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Ulonglong_numberContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *Ulonglong_numberContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserLONG_NUMBER, 0)
}

func (s *Ulonglong_numberContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserULONGLONG_NUMBER, 0)
}

func (s *Ulonglong_numberContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserDECIMAL_NUMBER, 0)
}

func (s *Ulonglong_numberContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserFLOAT_NUMBER, 0)
}

func (s *Ulonglong_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Ulonglong_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Ulonglong_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterUlonglong_number(s)
	}
}

func (s *Ulonglong_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitUlonglong_number(s)
	}
}

func (s *Ulonglong_numberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitUlonglong_number(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Ulonglong_number() (localctx IUlonglong_numberContext) {
	localctx = NewUlonglong_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 760, TiDBParserRULE_ulonglong_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5439)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&26388279066631) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IReal_ulonglong_numberContext is an interface to support dynamic dispatch.
type IReal_ulonglong_numberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	HEX_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode

	// IsReal_ulonglong_numberContext differentiates from other interfaces.
	IsReal_ulonglong_numberContext()
}

type Real_ulonglong_numberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReal_ulonglong_numberContext() *Real_ulonglong_numberContext {
	var p = new(Real_ulonglong_numberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_real_ulonglong_number
	return p
}

func InitEmptyReal_ulonglong_numberContext(p *Real_ulonglong_numberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_real_ulonglong_number
}

func (*Real_ulonglong_numberContext) IsReal_ulonglong_numberContext() {}

func NewReal_ulonglong_numberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Real_ulonglong_numberContext {
	var p = new(Real_ulonglong_numberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_real_ulonglong_number

	return p
}

func (s *Real_ulonglong_numberContext) GetParser() antlr.Parser { return s.parser }

func (s *Real_ulonglong_numberContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *Real_ulonglong_numberContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserHEX_NUMBER, 0)
}

func (s *Real_ulonglong_numberContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserULONGLONG_NUMBER, 0)
}

func (s *Real_ulonglong_numberContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserLONG_NUMBER, 0)
}

func (s *Real_ulonglong_numberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Real_ulonglong_numberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Real_ulonglong_numberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterReal_ulonglong_number(s)
	}
}

func (s *Real_ulonglong_numberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitReal_ulonglong_number(s)
	}
}

func (s *Real_ulonglong_numberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitReal_ulonglong_number(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Real_ulonglong_number() (localctx IReal_ulonglong_numberContext) {
	localctx = NewReal_ulonglong_numberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 762, TiDBParserRULE_real_ulonglong_number)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5441)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&2199023255559) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextLiteral() ITextLiteralContext
	NumLiteral() INumLiteralContext
	TemporalLiteral() ITemporalLiteralContext
	NullLiteral() INullLiteralContext
	BoolLiteral() IBoolLiteralContext
	HEX_NUMBER() antlr.TerminalNode
	BIN_NUMBER() antlr.TerminalNode
	UNDERSCORE_CHARSET() antlr.TerminalNode

	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) TextLiteral() ITextLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextLiteralContext)
}

func (s *LiteralContext) NumLiteral() INumLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INumLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INumLiteralContext)
}

func (s *LiteralContext) TemporalLiteral() ITemporalLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalLiteralContext)
}

func (s *LiteralContext) NullLiteral() INullLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INullLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INullLiteralContext)
}

func (s *LiteralContext) BoolLiteral() IBoolLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IBoolLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IBoolLiteralContext)
}

func (s *LiteralContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserHEX_NUMBER, 0)
}

func (s *LiteralContext) BIN_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserBIN_NUMBER, 0)
}

func (s *LiteralContext) UNDERSCORE_CHARSET() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNDERSCORE_CHARSET, 0)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLiteral(s)
	}
}

func (s *LiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLiteral(s)
	}
}

func (s *LiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 764, TiDBParserRULE_literal)
	var _la int

	p.SetState(5452)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 731, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5443)
			p.TextLiteral()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5444)
			p.NumLiteral()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5445)
			p.TemporalLiteral()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5446)
			p.NullLiteral()
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5447)
			p.BoolLiteral()
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		p.SetState(5449)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserUNDERSCORE_CHARSET {
			{
				p.SetState(5448)
				p.Match(TiDBParserUNDERSCORE_CHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5451)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserHEX_NUMBER || _la == TiDBParserBIN_NUMBER) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISignedLiteralContext is an interface to support dynamic dispatch.
type ISignedLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Literal() ILiteralContext
	PLUS_OPERATOR() antlr.TerminalNode
	Ulong_number() IUlong_numberContext
	MINUS_OPERATOR() antlr.TerminalNode

	// IsSignedLiteralContext differentiates from other interfaces.
	IsSignedLiteralContext()
}

type SignedLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySignedLiteralContext() *SignedLiteralContext {
	var p = new(SignedLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_signedLiteral
	return p
}

func InitEmptySignedLiteralContext(p *SignedLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_signedLiteral
}

func (*SignedLiteralContext) IsSignedLiteralContext() {}

func NewSignedLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SignedLiteralContext {
	var p = new(SignedLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_signedLiteral

	return p
}

func (s *SignedLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SignedLiteralContext) Literal() ILiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}

func (s *SignedLiteralContext) PLUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUS_OPERATOR, 0)
}

func (s *SignedLiteralContext) Ulong_number() IUlong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUlong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUlong_numberContext)
}

func (s *SignedLiteralContext) MINUS_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUS_OPERATOR, 0)
}

func (s *SignedLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SignedLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SignedLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSignedLiteral(s)
	}
}

func (s *SignedLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSignedLiteral(s)
	}
}

func (s *SignedLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSignedLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SignedLiteral() (localctx ISignedLiteralContext) {
	localctx = NewSignedLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 766, TiDBParserRULE_signedLiteral)
	p.SetState(5459)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserDATE_SYMBOL, TiDBParserFALSE_SYMBOL, TiDBParserNULL_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRUE_SYMBOL, TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserNULL2_SYMBOL, TiDBParserHEX_NUMBER, TiDBParserBIN_NUMBER, TiDBParserDECIMAL_NUMBER, TiDBParserFLOAT_NUMBER, TiDBParserUNDERSCORE_CHARSET, TiDBParserNCHAR_TEXT, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5454)
			p.Literal()
		}

	case TiDBParserPLUS_OPERATOR:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5455)
			p.Match(TiDBParserPLUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5456)
			p.Ulong_number()
		}

	case TiDBParserMINUS_OPERATOR:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5457)
			p.Match(TiDBParserMINUS_OPERATOR)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5458)
			p.Ulong_number()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStringListContext is an interface to support dynamic dispatch.
type IStringListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllTextString() []ITextStringContext
	TextString(i int) ITextStringContext
	CLOSE_PAR_SYMBOL() antlr.TerminalNode
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsStringListContext differentiates from other interfaces.
	IsStringListContext()
}

type StringListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStringListContext() *StringListContext {
	var p = new(StringListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_stringList
	return p
}

func InitEmptyStringListContext(p *StringListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_stringList
}

func (*StringListContext) IsStringListContext() {}

func NewStringListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StringListContext {
	var p = new(StringListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_stringList

	return p
}

func (s *StringListContext) GetParser() antlr.Parser { return s.parser }

func (s *StringListContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *StringListContext) AllTextString() []ITextStringContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringContext); ok {
			len++
		}
	}

	tst := make([]ITextStringContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringContext); ok {
			tst[i] = t.(ITextStringContext)
			i++
		}
	}

	return tst
}

func (s *StringListContext) TextString(i int) ITextStringContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringContext)
}

func (s *StringListContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *StringListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *StringListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *StringListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StringListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterStringList(s)
	}
}

func (s *StringListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitStringList(s)
	}
}

func (s *StringListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitStringList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) StringList() (localctx IStringListContext) {
	localctx = NewStringListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 768, TiDBParserRULE_stringList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5461)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5462)
		p.TextString()
	}
	p.SetState(5467)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5463)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5464)
			p.TextString()
		}

		p.SetState(5469)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(5470)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringLiteralContext is an interface to support dynamic dispatch.
type ITextStringLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetValue returns the value token.
	GetValue() antlr.Token

	// SetValue sets the value token.
	SetValue(antlr.Token)

	// Getter signatures
	SINGLE_QUOTED_TEXT() antlr.TerminalNode
	DOUBLE_QUOTED_TEXT() antlr.TerminalNode

	// IsTextStringLiteralContext differentiates from other interfaces.
	IsTextStringLiteralContext()
}

type TextStringLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
	value  antlr.Token
}

func NewEmptyTextStringLiteralContext() *TextStringLiteralContext {
	var p = new(TextStringLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textStringLiteral
	return p
}

func InitEmptyTextStringLiteralContext(p *TextStringLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textStringLiteral
}

func (*TextStringLiteralContext) IsTextStringLiteralContext() {}

func NewTextStringLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringLiteralContext {
	var p = new(TextStringLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_textStringLiteral

	return p
}

func (s *TextStringLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringLiteralContext) GetValue() antlr.Token { return s.value }

func (s *TextStringLiteralContext) SetValue(v antlr.Token) { s.value = v }

func (s *TextStringLiteralContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(TiDBParserSINGLE_QUOTED_TEXT, 0)
}

func (s *TextStringLiteralContext) DOUBLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(TiDBParserDOUBLE_QUOTED_TEXT, 0)
}

func (s *TextStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTextStringLiteral(s)
	}
}

func (s *TextStringLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTextStringLiteral(s)
	}
}

func (s *TextStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTextStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TextStringLiteral() (localctx ITextStringLiteralContext) {
	localctx = NewTextStringLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 770, TiDBParserRULE_textStringLiteral)
	p.SetState(5474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5472)

			var _m = p.Match(TiDBParserSINGLE_QUOTED_TEXT)

			localctx.(*TextStringLiteralContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserDOUBLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5473)

			var _m = p.Match(TiDBParserDOUBLE_QUOTED_TEXT)

			localctx.(*TextStringLiteralContext).value = _m
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringContext is an interface to support dynamic dispatch.
type ITextStringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringLiteral() ITextStringLiteralContext
	HEX_NUMBER() antlr.TerminalNode
	BIN_NUMBER() antlr.TerminalNode

	// IsTextStringContext differentiates from other interfaces.
	IsTextStringContext()
}

type TextStringContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextStringContext() *TextStringContext {
	var p = new(TextStringContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textString
	return p
}

func InitEmptyTextStringContext(p *TextStringContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textString
}

func (*TextStringContext) IsTextStringContext() {}

func NewTextStringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringContext {
	var p = new(TextStringContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_textString

	return p
}

func (s *TextStringContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextStringContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserHEX_NUMBER, 0)
}

func (s *TextStringContext) BIN_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserBIN_NUMBER, 0)
}

func (s *TextStringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTextString(s)
	}
}

func (s *TextStringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTextString(s)
	}
}

func (s *TextStringContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTextString(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TextString() (localctx ITextStringContext) {
	localctx = NewTextStringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 772, TiDBParserRULE_textString)
	p.SetState(5479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5476)
			p.TextStringLiteral()
		}

	case TiDBParserHEX_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5477)
			p.Match(TiDBParserHEX_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserBIN_NUMBER:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5478)
			p.Match(TiDBParserBIN_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringHashContext is an interface to support dynamic dispatch.
type ITextStringHashContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringLiteral() ITextStringLiteralContext
	HEX_NUMBER() antlr.TerminalNode

	// IsTextStringHashContext differentiates from other interfaces.
	IsTextStringHashContext()
}

type TextStringHashContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextStringHashContext() *TextStringHashContext {
	var p = new(TextStringHashContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textStringHash
	return p
}

func InitEmptyTextStringHashContext(p *TextStringHashContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textStringHash
}

func (*TextStringHashContext) IsTextStringHashContext() {}

func NewTextStringHashContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringHashContext {
	var p = new(TextStringHashContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_textStringHash

	return p
}

func (s *TextStringHashContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringHashContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextStringHashContext) HEX_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserHEX_NUMBER, 0)
}

func (s *TextStringHashContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringHashContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringHashContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTextStringHash(s)
	}
}

func (s *TextStringHashContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTextStringHash(s)
	}
}

func (s *TextStringHashContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTextStringHash(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TextStringHash() (localctx ITextStringHashContext) {
	localctx = NewTextStringHashContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 774, TiDBParserRULE_textStringHash)
	p.SetState(5483)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5481)
			p.TextStringLiteral()
		}

	case TiDBParserHEX_NUMBER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5482)
			p.Match(TiDBParserHEX_NUMBER)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextLiteralContext is an interface to support dynamic dispatch.
type ITextLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTextStringLiteral() []ITextStringLiteralContext
	TextStringLiteral(i int) ITextStringLiteralContext
	NCHAR_TEXT() antlr.TerminalNode
	UNDERSCORE_CHARSET() antlr.TerminalNode

	// IsTextLiteralContext differentiates from other interfaces.
	IsTextLiteralContext()
}

type TextLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextLiteralContext() *TextLiteralContext {
	var p = new(TextLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textLiteral
	return p
}

func InitEmptyTextLiteralContext(p *TextLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textLiteral
}

func (*TextLiteralContext) IsTextLiteralContext() {}

func NewTextLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextLiteralContext {
	var p = new(TextLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_textLiteral

	return p
}

func (s *TextLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TextLiteralContext) AllTextStringLiteral() []ITextStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]ITextStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringLiteralContext); ok {
			tst[i] = t.(ITextStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TextLiteralContext) TextStringLiteral(i int) ITextStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextLiteralContext) NCHAR_TEXT() antlr.TerminalNode {
	return s.GetToken(TiDBParserNCHAR_TEXT, 0)
}

func (s *TextLiteralContext) UNDERSCORE_CHARSET() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNDERSCORE_CHARSET, 0)
}

func (s *TextLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTextLiteral(s)
	}
}

func (s *TextLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTextLiteral(s)
	}
}

func (s *TextLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTextLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TextLiteral() (localctx ITextLiteralContext) {
	localctx = NewTextLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 776, TiDBParserRULE_textLiteral)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(5490)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserUNDERSCORE_CHARSET, TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.SetState(5486)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)

		if _la == TiDBParserUNDERSCORE_CHARSET {
			{
				p.SetState(5485)
				p.Match(TiDBParserUNDERSCORE_CHARSET)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		}
		{
			p.SetState(5488)
			p.TextStringLiteral()
		}

	case TiDBParserNCHAR_TEXT:
		{
			p.SetState(5489)
			p.Match(TiDBParserNCHAR_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	p.SetState(5495)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 739, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(5492)
				p.TextStringLiteral()
			}

		}
		p.SetState(5497)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 739, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringNoLinebreakContext is an interface to support dynamic dispatch.
type ITextStringNoLinebreakContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TextStringLiteral() ITextStringLiteralContext

	// IsTextStringNoLinebreakContext differentiates from other interfaces.
	IsTextStringNoLinebreakContext()
}

type TextStringNoLinebreakContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextStringNoLinebreakContext() *TextStringNoLinebreakContext {
	var p = new(TextStringNoLinebreakContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textStringNoLinebreak
	return p
}

func InitEmptyTextStringNoLinebreakContext(p *TextStringNoLinebreakContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textStringNoLinebreak
}

func (*TextStringNoLinebreakContext) IsTextStringNoLinebreakContext() {}

func NewTextStringNoLinebreakContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringNoLinebreakContext {
	var p = new(TextStringNoLinebreakContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_textStringNoLinebreak

	return p
}

func (s *TextStringNoLinebreakContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringNoLinebreakContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextStringNoLinebreakContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringNoLinebreakContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringNoLinebreakContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTextStringNoLinebreak(s)
	}
}

func (s *TextStringNoLinebreakContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTextStringNoLinebreak(s)
	}
}

func (s *TextStringNoLinebreakContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTextStringNoLinebreak(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TextStringNoLinebreak() (localctx ITextStringNoLinebreakContext) {
	localctx = NewTextStringNoLinebreakContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 778, TiDBParserRULE_textStringNoLinebreak)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5498)
		p.TextStringLiteral()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextStringLiteralListContext is an interface to support dynamic dispatch.
type ITextStringLiteralListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTextStringLiteral() []ITextStringLiteralContext
	TextStringLiteral(i int) ITextStringLiteralContext
	AllCOMMA_SYMBOL() []antlr.TerminalNode
	COMMA_SYMBOL(i int) antlr.TerminalNode

	// IsTextStringLiteralListContext differentiates from other interfaces.
	IsTextStringLiteralListContext()
}

type TextStringLiteralListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextStringLiteralListContext() *TextStringLiteralListContext {
	var p = new(TextStringLiteralListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textStringLiteralList
	return p
}

func InitEmptyTextStringLiteralListContext(p *TextStringLiteralListContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textStringLiteralList
}

func (*TextStringLiteralListContext) IsTextStringLiteralListContext() {}

func NewTextStringLiteralListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextStringLiteralListContext {
	var p = new(TextStringLiteralListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_textStringLiteralList

	return p
}

func (s *TextStringLiteralListContext) GetParser() antlr.Parser { return s.parser }

func (s *TextStringLiteralListContext) AllTextStringLiteral() []ITextStringLiteralContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			len++
		}
	}

	tst := make([]ITextStringLiteralContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITextStringLiteralContext); ok {
			tst[i] = t.(ITextStringLiteralContext)
			i++
		}
	}

	return tst
}

func (s *TextStringLiteralListContext) TextStringLiteral(i int) ITextStringLiteralContext {
	var t antlr.RuleContext
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext)
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextStringLiteralListContext) AllCOMMA_SYMBOL() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserCOMMA_SYMBOL)
}

func (s *TextStringLiteralListContext) COMMA_SYMBOL(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, i)
}

func (s *TextStringLiteralListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextStringLiteralListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextStringLiteralListContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTextStringLiteralList(s)
	}
}

func (s *TextStringLiteralListContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTextStringLiteralList(s)
	}
}

func (s *TextStringLiteralListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTextStringLiteralList(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TextStringLiteralList() (localctx ITextStringLiteralListContext) {
	localctx = NewTextStringLiteralListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 780, TiDBParserRULE_textStringLiteralList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5500)
		p.TextStringLiteral()
	}
	p.SetState(5505)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)

	for _la == TiDBParserCOMMA_SYMBOL {
		{
			p.SetState(5501)
			p.Match(TiDBParserCOMMA_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5502)
			p.TextStringLiteral()
		}

		p.SetState(5507)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INumLiteralContext is an interface to support dynamic dispatch.
type INumLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	INT_NUMBER() antlr.TerminalNode
	LONG_NUMBER() antlr.TerminalNode
	ULONGLONG_NUMBER() antlr.TerminalNode
	DECIMAL_NUMBER() antlr.TerminalNode
	FLOAT_NUMBER() antlr.TerminalNode

	// IsNumLiteralContext differentiates from other interfaces.
	IsNumLiteralContext()
}

type NumLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNumLiteralContext() *NumLiteralContext {
	var p = new(NumLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_numLiteral
	return p
}

func InitEmptyNumLiteralContext(p *NumLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_numLiteral
}

func (*NumLiteralContext) IsNumLiteralContext() {}

func NewNumLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NumLiteralContext {
	var p = new(NumLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_numLiteral

	return p
}

func (s *NumLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NumLiteralContext) INT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, 0)
}

func (s *NumLiteralContext) LONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserLONG_NUMBER, 0)
}

func (s *NumLiteralContext) ULONGLONG_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserULONGLONG_NUMBER, 0)
}

func (s *NumLiteralContext) DECIMAL_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserDECIMAL_NUMBER, 0)
}

func (s *NumLiteralContext) FLOAT_NUMBER() antlr.TerminalNode {
	return s.GetToken(TiDBParserFLOAT_NUMBER, 0)
}

func (s *NumLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NumLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterNumLiteral(s)
	}
}

func (s *NumLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitNumLiteral(s)
	}
}

func (s *NumLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitNumLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) NumLiteral() (localctx INumLiteralContext) {
	localctx = NewNumLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 782, TiDBParserRULE_numLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5508)
		_la = p.GetTokenStream().LA(1)

		if !((int64((_la-747)) & ^0x3f) == 0 && ((int64(1)<<(_la-747))&26388279066631) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IBoolLiteralContext is an interface to support dynamic dispatch.
type IBoolLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TRUE_SYMBOL() antlr.TerminalNode
	FALSE_SYMBOL() antlr.TerminalNode

	// IsBoolLiteralContext differentiates from other interfaces.
	IsBoolLiteralContext()
}

type BoolLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBoolLiteralContext() *BoolLiteralContext {
	var p = new(BoolLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_boolLiteral
	return p
}

func InitEmptyBoolLiteralContext(p *BoolLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_boolLiteral
}

func (*BoolLiteralContext) IsBoolLiteralContext() {}

func NewBoolLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BoolLiteralContext {
	var p = new(BoolLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_boolLiteral

	return p
}

func (s *BoolLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *BoolLiteralContext) TRUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRUE_SYMBOL, 0)
}

func (s *BoolLiteralContext) FALSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFALSE_SYMBOL, 0)
}

func (s *BoolLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BoolLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BoolLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterBoolLiteral(s)
	}
}

func (s *BoolLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitBoolLiteral(s)
	}
}

func (s *BoolLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitBoolLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) BoolLiteral() (localctx IBoolLiteralContext) {
	localctx = NewBoolLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 784, TiDBParserRULE_boolLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5510)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserFALSE_SYMBOL || _la == TiDBParserTRUE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// INullLiteralContext is an interface to support dynamic dispatch.
type INullLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NULL_SYMBOL() antlr.TerminalNode
	NULL2_SYMBOL() antlr.TerminalNode

	// IsNullLiteralContext differentiates from other interfaces.
	IsNullLiteralContext()
}

type NullLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNullLiteralContext() *NullLiteralContext {
	var p = new(NullLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_nullLiteral
	return p
}

func InitEmptyNullLiteralContext(p *NullLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_nullLiteral
}

func (*NullLiteralContext) IsNullLiteralContext() {}

func NewNullLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NullLiteralContext {
	var p = new(NullLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_nullLiteral

	return p
}

func (s *NullLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *NullLiteralContext) NULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL_SYMBOL, 0)
}

func (s *NullLiteralContext) NULL2_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULL2_SYMBOL, 0)
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *NullLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterNullLiteral(s)
	}
}

func (s *NullLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitNullLiteral(s)
	}
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) NullLiteral() (localctx INullLiteralContext) {
	localctx = NewNullLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 786, TiDBParserRULE_nullLiteral)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5512)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserNULL_SYMBOL || _la == TiDBParserNULL2_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITemporalLiteralContext is an interface to support dynamic dispatch.
type ITemporalLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DATE_SYMBOL() antlr.TerminalNode
	SINGLE_QUOTED_TEXT() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode

	// IsTemporalLiteralContext differentiates from other interfaces.
	IsTemporalLiteralContext()
}

type TemporalLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalLiteralContext() *TemporalLiteralContext {
	var p = new(TemporalLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_temporalLiteral
	return p
}

func InitEmptyTemporalLiteralContext(p *TemporalLiteralContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_temporalLiteral
}

func (*TemporalLiteralContext) IsTemporalLiteralContext() {}

func NewTemporalLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalLiteralContext {
	var p = new(TemporalLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_temporalLiteral

	return p
}

func (s *TemporalLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *TemporalLiteralContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATE_SYMBOL, 0)
}

func (s *TemporalLiteralContext) SINGLE_QUOTED_TEXT() antlr.TerminalNode {
	return s.GetToken(TiDBParserSINGLE_QUOTED_TEXT, 0)
}

func (s *TemporalLiteralContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIME_SYMBOL, 0)
}

func (s *TemporalLiteralContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_SYMBOL, 0)
}

func (s *TemporalLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TemporalLiteralContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTemporalLiteral(s)
	}
}

func (s *TemporalLiteralContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTemporalLiteral(s)
	}
}

func (s *TemporalLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTemporalLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TemporalLiteral() (localctx ITemporalLiteralContext) {
	localctx = NewTemporalLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 788, TiDBParserRULE_temporalLiteral)
	p.SetState(5520)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserDATE_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5514)
			p.Match(TiDBParserDATE_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5515)
			p.Match(TiDBParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserTIME_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5516)
			p.Match(TiDBParserTIME_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5517)
			p.Match(TiDBParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserTIMESTAMP_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5518)
			p.Match(TiDBParserTIMESTAMP_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5519)
			p.Match(TiDBParserSINGLE_QUOTED_TEXT)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IFloatOptionsContext is an interface to support dynamic dispatch.
type IFloatOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	FieldLength() IFieldLengthContext
	Precision() IPrecisionContext

	// IsFloatOptionsContext differentiates from other interfaces.
	IsFloatOptionsContext()
}

type FloatOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFloatOptionsContext() *FloatOptionsContext {
	var p = new(FloatOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_floatOptions
	return p
}

func InitEmptyFloatOptionsContext(p *FloatOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_floatOptions
}

func (*FloatOptionsContext) IsFloatOptionsContext() {}

func NewFloatOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FloatOptionsContext {
	var p = new(FloatOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_floatOptions

	return p
}

func (s *FloatOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *FloatOptionsContext) FieldLength() IFieldLengthContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFieldLengthContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFieldLengthContext)
}

func (s *FloatOptionsContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *FloatOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FloatOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FloatOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterFloatOptions(s)
	}
}

func (s *FloatOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitFloatOptions(s)
	}
}

func (s *FloatOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitFloatOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) FloatOptions() (localctx IFloatOptionsContext) {
	localctx = NewFloatOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 790, TiDBParserRULE_floatOptions)
	p.SetState(5524)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 742, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5522)
			p.FieldLength()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5523)
			p.Precision()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IStandardFloatOptionsContext is an interface to support dynamic dispatch.
type IStandardFloatOptionsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Precision() IPrecisionContext

	// IsStandardFloatOptionsContext differentiates from other interfaces.
	IsStandardFloatOptionsContext()
}

type StandardFloatOptionsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStandardFloatOptionsContext() *StandardFloatOptionsContext {
	var p = new(StandardFloatOptionsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_standardFloatOptions
	return p
}

func InitEmptyStandardFloatOptionsContext(p *StandardFloatOptionsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_standardFloatOptions
}

func (*StandardFloatOptionsContext) IsStandardFloatOptionsContext() {}

func NewStandardFloatOptionsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StandardFloatOptionsContext {
	var p = new(StandardFloatOptionsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_standardFloatOptions

	return p
}

func (s *StandardFloatOptionsContext) GetParser() antlr.Parser { return s.parser }

func (s *StandardFloatOptionsContext) Precision() IPrecisionContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPrecisionContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPrecisionContext)
}

func (s *StandardFloatOptionsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StandardFloatOptionsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *StandardFloatOptionsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterStandardFloatOptions(s)
	}
}

func (s *StandardFloatOptionsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitStandardFloatOptions(s)
	}
}

func (s *StandardFloatOptionsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitStandardFloatOptions(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) StandardFloatOptions() (localctx IStandardFloatOptionsContext) {
	localctx = NewStandardFloatOptionsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 792, TiDBParserRULE_standardFloatOptions)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5526)
		p.Precision()
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IPrecisionContext is an interface to support dynamic dispatch.
type IPrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	AllINT_NUMBER() []antlr.TerminalNode
	INT_NUMBER(i int) antlr.TerminalNode
	COMMA_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsPrecisionContext differentiates from other interfaces.
	IsPrecisionContext()
}

type PrecisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPrecisionContext() *PrecisionContext {
	var p = new(PrecisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_precision
	return p
}

func InitEmptyPrecisionContext(p *PrecisionContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_precision
}

func (*PrecisionContext) IsPrecisionContext() {}

func NewPrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PrecisionContext {
	var p = new(PrecisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_precision

	return p
}

func (s *PrecisionContext) GetParser() antlr.Parser { return s.parser }

func (s *PrecisionContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *PrecisionContext) AllINT_NUMBER() []antlr.TerminalNode {
	return s.GetTokens(TiDBParserINT_NUMBER)
}

func (s *PrecisionContext) INT_NUMBER(i int) antlr.TerminalNode {
	return s.GetToken(TiDBParserINT_NUMBER, i)
}

func (s *PrecisionContext) COMMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMA_SYMBOL, 0)
}

func (s *PrecisionContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *PrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PrecisionContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterPrecision(s)
	}
}

func (s *PrecisionContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitPrecision(s)
	}
}

func (s *PrecisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitPrecision(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Precision() (localctx IPrecisionContext) {
	localctx = NewPrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 794, TiDBParserRULE_precision)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5528)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5529)
		p.Match(TiDBParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5530)
		p.Match(TiDBParserCOMMA_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5531)
		p.Match(TiDBParserINT_NUMBER)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5532)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ITextOrIdentifierContext is an interface to support dynamic dispatch.
type ITextOrIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	TextStringLiteral() ITextStringLiteralContext

	// IsTextOrIdentifierContext differentiates from other interfaces.
	IsTextOrIdentifierContext()
}

type TextOrIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTextOrIdentifierContext() *TextOrIdentifierContext {
	var p = new(TextOrIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textOrIdentifier
	return p
}

func InitEmptyTextOrIdentifierContext(p *TextOrIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_textOrIdentifier
}

func (*TextOrIdentifierContext) IsTextOrIdentifierContext() {}

func NewTextOrIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TextOrIdentifierContext {
	var p = new(TextOrIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_textOrIdentifier

	return p
}

func (s *TextOrIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TextOrIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *TextOrIdentifierContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *TextOrIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TextOrIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TextOrIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterTextOrIdentifier(s)
	}
}

func (s *TextOrIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitTextOrIdentifier(s)
	}
}

func (s *TextOrIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitTextOrIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) TextOrIdentifier() (localctx ITextOrIdentifierContext) {
	localctx = NewTextOrIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 796, TiDBParserRULE_textOrIdentifier)
	p.SetState(5536)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserS3_SYMBOL, TiDBParserINVOKE_SYMBOL, TiDBParserLAMBDA_SYMBOL, TiDBParserATTRIBUTE_SYMBOL, TiDBParserJSON_VALUE_SYMBOL, TiDBParserRETURNING_SYMBOL, TiDBParserINTERSECT_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5534)
			p.Identifier()
		}

	case TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5535)
			p.TextStringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILValueIdentifierContext is an interface to support dynamic dispatch.
type ILValueIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PureIdentifier() IPureIdentifierContext
	LValueKeyword() ILValueKeywordContext

	// IsLValueIdentifierContext differentiates from other interfaces.
	IsLValueIdentifierContext()
}

type LValueIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLValueIdentifierContext() *LValueIdentifierContext {
	var p = new(LValueIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lValueIdentifier
	return p
}

func InitEmptyLValueIdentifierContext(p *LValueIdentifierContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lValueIdentifier
}

func (*LValueIdentifierContext) IsLValueIdentifierContext() {}

func NewLValueIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LValueIdentifierContext {
	var p = new(LValueIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lValueIdentifier

	return p
}

func (s *LValueIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *LValueIdentifierContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *LValueIdentifierContext) LValueKeyword() ILValueKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILValueKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILValueKeywordContext)
}

func (s *LValueIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LValueIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LValueIdentifierContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLValueIdentifier(s)
	}
}

func (s *LValueIdentifierContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLValueIdentifier(s)
	}
}

func (s *LValueIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLValueIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LValueIdentifier() (localctx ILValueIdentifierContext) {
	localctx = NewLValueIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 798, TiDBParserRULE_lValueIdentifier)
	p.SetState(5540)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserUNDERLINE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5538)
			p.PureIdentifier()
		}

	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVENT_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXECUTE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserRESOURCE_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserRESTART_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5539)
			p.LValueKeyword()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleIdentifierOrTextContext is an interface to support dynamic dispatch.
type IRoleIdentifierOrTextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleIdentifier() IRoleIdentifierContext
	TextStringLiteral() ITextStringLiteralContext

	// IsRoleIdentifierOrTextContext differentiates from other interfaces.
	IsRoleIdentifierOrTextContext()
}

type RoleIdentifierOrTextContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleIdentifierOrTextContext() *RoleIdentifierOrTextContext {
	var p = new(RoleIdentifierOrTextContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleIdentifierOrText
	return p
}

func InitEmptyRoleIdentifierOrTextContext(p *RoleIdentifierOrTextContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleIdentifierOrText
}

func (*RoleIdentifierOrTextContext) IsRoleIdentifierOrTextContext() {}

func NewRoleIdentifierOrTextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleIdentifierOrTextContext {
	var p = new(RoleIdentifierOrTextContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_roleIdentifierOrText

	return p
}

func (s *RoleIdentifierOrTextContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleIdentifierOrTextContext) RoleIdentifier() IRoleIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleIdentifierContext)
}

func (s *RoleIdentifierOrTextContext) TextStringLiteral() ITextStringLiteralContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITextStringLiteralContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITextStringLiteralContext)
}

func (s *RoleIdentifierOrTextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleIdentifierOrTextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleIdentifierOrTextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRoleIdentifierOrText(s)
	}
}

func (s *RoleIdentifierOrTextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRoleIdentifierOrText(s)
	}
}

func (s *RoleIdentifierOrTextContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRoleIdentifierOrText(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RoleIdentifierOrText() (localctx IRoleIdentifierOrTextContext) {
	localctx = NewRoleIdentifierOrTextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 800, TiDBParserRULE_roleIdentifierOrText)
	p.SetState(5544)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANALYSE_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTHORS_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCONTRIBUTORS_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCUBE_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDES_KEY_FILE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserFUNCTION_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGLOBAL_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_STATEMENT_TIME_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserOLD_PASSWORD_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDOFILE_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROWS_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserROW_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_CACHE_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUDF_RETURNS_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserREMOTE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL, TiDBParserUNDERLINE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5542)
			p.RoleIdentifier()
		}

	case TiDBParserDOUBLE_QUOTED_TEXT, TiDBParserSINGLE_QUOTED_TEXT:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5543)
			p.TextStringLiteral()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISizeNumberContext is an interface to support dynamic dispatch.
type ISizeNumberContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Real_ulonglong_number() IReal_ulonglong_numberContext
	PureIdentifier() IPureIdentifierContext

	// IsSizeNumberContext differentiates from other interfaces.
	IsSizeNumberContext()
}

type SizeNumberContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySizeNumberContext() *SizeNumberContext {
	var p = new(SizeNumberContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_sizeNumber
	return p
}

func InitEmptySizeNumberContext(p *SizeNumberContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_sizeNumber
}

func (*SizeNumberContext) IsSizeNumberContext() {}

func NewSizeNumberContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SizeNumberContext {
	var p = new(SizeNumberContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_sizeNumber

	return p
}

func (s *SizeNumberContext) GetParser() antlr.Parser { return s.parser }

func (s *SizeNumberContext) Real_ulonglong_number() IReal_ulonglong_numberContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReal_ulonglong_numberContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReal_ulonglong_numberContext)
}

func (s *SizeNumberContext) PureIdentifier() IPureIdentifierContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPureIdentifierContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPureIdentifierContext)
}

func (s *SizeNumberContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SizeNumberContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SizeNumberContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSizeNumber(s)
	}
}

func (s *SizeNumberContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSizeNumber(s)
	}
}

func (s *SizeNumberContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSizeNumber(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SizeNumber() (localctx ISizeNumberContext) {
	localctx = NewSizeNumberContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 802, TiDBParserRULE_sizeNumber)
	p.SetState(5548)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserINT_NUMBER, TiDBParserLONG_NUMBER, TiDBParserULONGLONG_NUMBER, TiDBParserHEX_NUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5546)
			p.Real_ulonglong_number()
		}

	case TiDBParserUNDERLINE_SYMBOL, TiDBParserIDENTIFIER, TiDBParserBACK_TICK_QUOTED_ID:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5547)
			p.PureIdentifier()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IParenthesesContext is an interface to support dynamic dispatch.
type IParenthesesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	OPEN_PAR_SYMBOL() antlr.TerminalNode
	CLOSE_PAR_SYMBOL() antlr.TerminalNode

	// IsParenthesesContext differentiates from other interfaces.
	IsParenthesesContext()
}

type ParenthesesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParenthesesContext() *ParenthesesContext {
	var p = new(ParenthesesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_parentheses
	return p
}

func InitEmptyParenthesesContext(p *ParenthesesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_parentheses
}

func (*ParenthesesContext) IsParenthesesContext() {}

func NewParenthesesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParenthesesContext {
	var p = new(ParenthesesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_parentheses

	return p
}

func (s *ParenthesesContext) GetParser() antlr.Parser { return s.parser }

func (s *ParenthesesContext) OPEN_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_PAR_SYMBOL, 0)
}

func (s *ParenthesesContext) CLOSE_PAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_PAR_SYMBOL, 0)
}

func (s *ParenthesesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ParenthesesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterParentheses(s)
	}
}

func (s *ParenthesesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitParentheses(s)
	}
}

func (s *ParenthesesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitParentheses(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Parentheses() (localctx IParenthesesContext) {
	localctx = NewParenthesesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 804, TiDBParserRULE_parentheses)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5550)
		p.Match(TiDBParserOPEN_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}
	{
		p.SetState(5551)
		p.Match(TiDBParserCLOSE_PAR_SYMBOL)
		if p.HasError() {
			// Recognition error - abort rule
			goto errorExit
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IEqualContext is an interface to support dynamic dispatch.
type IEqualContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EQUAL_OPERATOR() antlr.TerminalNode
	ASSIGN_OPERATOR() antlr.TerminalNode

	// IsEqualContext differentiates from other interfaces.
	IsEqualContext()
}

type EqualContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEqualContext() *EqualContext {
	var p = new(EqualContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_equal
	return p
}

func InitEmptyEqualContext(p *EqualContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_equal
}

func (*EqualContext) IsEqualContext() {}

func NewEqualContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EqualContext {
	var p = new(EqualContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_equal

	return p
}

func (s *EqualContext) GetParser() antlr.Parser { return s.parser }

func (s *EqualContext) EQUAL_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserEQUAL_OPERATOR, 0)
}

func (s *EqualContext) ASSIGN_OPERATOR() antlr.TerminalNode {
	return s.GetToken(TiDBParserASSIGN_OPERATOR, 0)
}

func (s *EqualContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EqualContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterEqual(s)
	}
}

func (s *EqualContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitEqual(s)
	}
}

func (s *EqualContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitEqual(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) Equal() (localctx IEqualContext) {
	localctx = NewEqualContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 806, TiDBParserRULE_equal)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5553)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserEQUAL_OPERATOR || _la == TiDBParserASSIGN_OPERATOR) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IOptionTypeContext is an interface to support dynamic dispatch.
type IOptionTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERSIST_SYMBOL() antlr.TerminalNode
	PERSIST_ONLY_SYMBOL() antlr.TerminalNode
	GLOBAL_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode

	// IsOptionTypeContext differentiates from other interfaces.
	IsOptionTypeContext()
}

type OptionTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOptionTypeContext() *OptionTypeContext {
	var p = new(OptionTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionType
	return p
}

func InitEmptyOptionTypeContext(p *OptionTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_optionType
}

func (*OptionTypeContext) IsOptionTypeContext() {}

func NewOptionTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OptionTypeContext {
	var p = new(OptionTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_optionType

	return p
}

func (s *OptionTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *OptionTypeContext) PERSIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPERSIST_SYMBOL, 0)
}

func (s *OptionTypeContext) PERSIST_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPERSIST_ONLY_SYMBOL, 0)
}

func (s *OptionTypeContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGLOBAL_SYMBOL, 0)
}

func (s *OptionTypeContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCAL_SYMBOL, 0)
}

func (s *OptionTypeContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSESSION_SYMBOL, 0)
}

func (s *OptionTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OptionTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *OptionTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterOptionType(s)
	}
}

func (s *OptionTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitOptionType(s)
	}
}

func (s *OptionTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitOptionType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) OptionType() (localctx IOptionTypeContext) {
	localctx = NewOptionTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 808, TiDBParserRULE_optionType)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5555)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserGLOBAL_SYMBOL || _la == TiDBParserLOCAL_SYMBOL || _la == TiDBParserSESSION_SYMBOL || _la == TiDBParserPERSIST_SYMBOL || _la == TiDBParserPERSIST_ONLY_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IVarIdentTypeContext is an interface to support dynamic dispatch.
type IVarIdentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL_SYMBOL() antlr.TerminalNode
	DOT_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode

	// IsVarIdentTypeContext differentiates from other interfaces.
	IsVarIdentTypeContext()
}

type VarIdentTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVarIdentTypeContext() *VarIdentTypeContext {
	var p = new(VarIdentTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_varIdentType
	return p
}

func InitEmptyVarIdentTypeContext(p *VarIdentTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_varIdentType
}

func (*VarIdentTypeContext) IsVarIdentTypeContext() {}

func NewVarIdentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VarIdentTypeContext {
	var p = new(VarIdentTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_varIdentType

	return p
}

func (s *VarIdentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *VarIdentTypeContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGLOBAL_SYMBOL, 0)
}

func (s *VarIdentTypeContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDOT_SYMBOL, 0)
}

func (s *VarIdentTypeContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCAL_SYMBOL, 0)
}

func (s *VarIdentTypeContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSESSION_SYMBOL, 0)
}

func (s *VarIdentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VarIdentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VarIdentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterVarIdentType(s)
	}
}

func (s *VarIdentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitVarIdentType(s)
	}
}

func (s *VarIdentTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitVarIdentType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) VarIdentType() (localctx IVarIdentTypeContext) {
	localctx = NewVarIdentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 810, TiDBParserRULE_varIdentType)
	p.SetState(5563)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserGLOBAL_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5557)
			p.Match(TiDBParserGLOBAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5558)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserLOCAL_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5559)
			p.Match(TiDBParserLOCAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5560)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserSESSION_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5561)
			p.Match(TiDBParserSESSION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5562)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ISetVarIdentTypeContext is an interface to support dynamic dispatch.
type ISetVarIdentTypeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	PERSIST_SYMBOL() antlr.TerminalNode
	DOT_SYMBOL() antlr.TerminalNode
	PERSIST_ONLY_SYMBOL() antlr.TerminalNode
	GLOBAL_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode

	// IsSetVarIdentTypeContext differentiates from other interfaces.
	IsSetVarIdentTypeContext()
}

type SetVarIdentTypeContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySetVarIdentTypeContext() *SetVarIdentTypeContext {
	var p = new(SetVarIdentTypeContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setVarIdentType
	return p
}

func InitEmptySetVarIdentTypeContext(p *SetVarIdentTypeContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_setVarIdentType
}

func (*SetVarIdentTypeContext) IsSetVarIdentTypeContext() {}

func NewSetVarIdentTypeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SetVarIdentTypeContext {
	var p = new(SetVarIdentTypeContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_setVarIdentType

	return p
}

func (s *SetVarIdentTypeContext) GetParser() antlr.Parser { return s.parser }

func (s *SetVarIdentTypeContext) PERSIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPERSIST_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) DOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDOT_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) PERSIST_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPERSIST_ONLY_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGLOBAL_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCAL_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSESSION_SYMBOL, 0)
}

func (s *SetVarIdentTypeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetVarIdentTypeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SetVarIdentTypeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterSetVarIdentType(s)
	}
}

func (s *SetVarIdentTypeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitSetVarIdentType(s)
	}
}

func (s *SetVarIdentTypeContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitSetVarIdentType(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) SetVarIdentType() (localctx ISetVarIdentTypeContext) {
	localctx = NewSetVarIdentTypeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 812, TiDBParserRULE_setVarIdentType)
	p.SetState(5575)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserPERSIST_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5565)
			p.Match(TiDBParserPERSIST_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5566)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserPERSIST_ONLY_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5567)
			p.Match(TiDBParserPERSIST_ONLY_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5568)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserGLOBAL_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5569)
			p.Match(TiDBParserGLOBAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5570)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserLOCAL_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5571)
			p.Match(TiDBParserLOCAL_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5572)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserSESSION_SYMBOL:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5573)
			p.Match(TiDBParserSESSION_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}
		{
			p.SetState(5574)
			p.Match(TiDBParserDOT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordContext is an interface to support dynamic dispatch.
type IIdentifierKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	LabelKeyword() ILabelKeywordContext
	RoleOrIdentifierKeyword() IRoleOrIdentifierKeywordContext
	EXECUTE_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode
	RESTART_SYMBOL() antlr.TerminalNode
	IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext
	IdentifierKeywordsAmbiguous1RolesAndLabels() IIdentifierKeywordsAmbiguous1RolesAndLabelsContext
	IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext
	IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext
	IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext
	S3_SYMBOL() antlr.TerminalNode
	INVOKE_SYMBOL() antlr.TerminalNode
	LAMBDA_SYMBOL() antlr.TerminalNode
	ATTRIBUTE_SYMBOL() antlr.TerminalNode
	JSON_VALUE_SYMBOL() antlr.TerminalNode
	RETURNING_SYMBOL() antlr.TerminalNode
	INTERSECT_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordContext differentiates from other interfaces.
	IsIdentifierKeywordContext()
}

type IdentifierKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordContext() *IdentifierKeywordContext {
	var p = new(IdentifierKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeyword
	return p
}

func InitEmptyIdentifierKeywordContext(p *IdentifierKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeyword
}

func (*IdentifierKeywordContext) IsIdentifierKeywordContext() {}

func NewIdentifierKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordContext {
	var p = new(IdentifierKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identifierKeyword

	return p
}

func (s *IdentifierKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordContext) LabelKeyword() ILabelKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILabelKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILabelKeywordContext)
}

func (s *IdentifierKeywordContext) RoleOrIdentifierKeyword() IRoleOrIdentifierKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrIdentifierKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrIdentifierKeywordContext)
}

func (s *IdentifierKeywordContext) EXECUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXECUTE_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHUTDOWN_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) RESTART_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESTART_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsUnambiguousContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsUnambiguousContext)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsAmbiguous1RolesAndLabels() IIdentifierKeywordsAmbiguous1RolesAndLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous1RolesAndLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous1RolesAndLabelsContext)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous2LabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous2LabelsContext)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous3RolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous3RolesContext)
}

func (s *IdentifierKeywordContext) IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous4SystemVariablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous4SystemVariablesContext)
}

func (s *IdentifierKeywordContext) S3_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserS3_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) INVOKE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINVOKE_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) LAMBDA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLAMBDA_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) ATTRIBUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserATTRIBUTE_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) JSON_VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_VALUE_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) RETURNING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRETURNING_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) INTERSECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINTERSECT_SYMBOL, 0)
}

func (s *IdentifierKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentifierKeyword(s)
	}
}

func (s *IdentifierKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentifierKeyword(s)
	}
}

func (s *IdentifierKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentifierKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentifierKeyword() (localctx IIdentifierKeywordContext) {
	localctx = NewIdentifierKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 814, TiDBParserRULE_identifierKeyword)
	var _la int

	p.SetState(5592)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 751, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 749, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5577)
				p.LabelKeyword()
			}

		case 2:
			{
				p.SetState(5578)
				p.RoleOrIdentifierKeyword()
			}

		case 3:
			{
				p.SetState(5579)
				p.Match(TiDBParserEXECUTE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(5580)
				p.Match(TiDBParserSHUTDOWN_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(5581)
				p.Match(TiDBParserRESTART_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5589)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL:
			{
				p.SetState(5584)
				p.IdentifierKeywordsUnambiguous()
			}

		case TiDBParserEXECUTE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserRESTART_SYMBOL:
			{
				p.SetState(5585)
				p.IdentifierKeywordsAmbiguous1RolesAndLabels()
			}

		case TiDBParserASCII_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserCLONE_SYMBOL:
			{
				p.SetState(5586)
				p.IdentifierKeywordsAmbiguous2Labels()
			}

		case TiDBParserEVENT_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserRESOURCE_SYMBOL:
			{
				p.SetState(5587)
				p.IdentifierKeywordsAmbiguous3Roles()
			}

		case TiDBParserGLOBAL_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL:
			{
				p.SetState(5588)
				p.IdentifierKeywordsAmbiguous4SystemVariables()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5591)
			_la = p.GetTokenStream().LA(1)

			if !((int64((_la-795)) & ^0x3f) == 0 && ((int64(1)<<(_la-795))&127) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsAmbiguous1RolesAndLabelsContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsAmbiguous1RolesAndLabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EXECUTE_SYMBOL() antlr.TerminalNode
	RESTART_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsAmbiguous1RolesAndLabelsContext differentiates from other interfaces.
	IsIdentifierKeywordsAmbiguous1RolesAndLabelsContext()
}

type IdentifierKeywordsAmbiguous1RolesAndLabelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsAmbiguous1RolesAndLabelsContext() *IdentifierKeywordsAmbiguous1RolesAndLabelsContext {
	var p = new(IdentifierKeywordsAmbiguous1RolesAndLabelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous1RolesAndLabels
	return p
}

func InitEmptyIdentifierKeywordsAmbiguous1RolesAndLabelsContext(p *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous1RolesAndLabels
}

func (*IdentifierKeywordsAmbiguous1RolesAndLabelsContext) IsIdentifierKeywordsAmbiguous1RolesAndLabelsContext() {
}

func NewIdentifierKeywordsAmbiguous1RolesAndLabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsAmbiguous1RolesAndLabelsContext {
	var p = new(IdentifierKeywordsAmbiguous1RolesAndLabelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous1RolesAndLabels

	return p
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) EXECUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXECUTE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) RESTART_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESTART_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHUTDOWN_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentifierKeywordsAmbiguous1RolesAndLabels(s)
	}
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentifierKeywordsAmbiguous1RolesAndLabels(s)
	}
}

func (s *IdentifierKeywordsAmbiguous1RolesAndLabelsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentifierKeywordsAmbiguous1RolesAndLabels(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentifierKeywordsAmbiguous1RolesAndLabels() (localctx IIdentifierKeywordsAmbiguous1RolesAndLabelsContext) {
	localctx = NewIdentifierKeywordsAmbiguous1RolesAndLabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 816, TiDBParserRULE_identifierKeywordsAmbiguous1RolesAndLabels)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5594)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserEXECUTE_SYMBOL || _la == TiDBParserSHUTDOWN_SYMBOL || _la == TiDBParserRESTART_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsAmbiguous2LabelsContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsAmbiguous2LabelsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ASCII_SYMBOL() antlr.TerminalNode
	BEGIN_SYMBOL() antlr.TerminalNode
	BYTE_SYMBOL() antlr.TerminalNode
	CACHE_SYMBOL() antlr.TerminalNode
	CHARSET_SYMBOL() antlr.TerminalNode
	CHECKSUM_SYMBOL() antlr.TerminalNode
	CLONE_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	COMMIT_SYMBOL() antlr.TerminalNode
	CONTAINS_SYMBOL() antlr.TerminalNode
	DEALLOCATE_SYMBOL() antlr.TerminalNode
	DO_SYMBOL() antlr.TerminalNode
	END_SYMBOL() antlr.TerminalNode
	FLUSH_SYMBOL() antlr.TerminalNode
	FOLLOWS_SYMBOL() antlr.TerminalNode
	HANDLER_SYMBOL() antlr.TerminalNode
	HELP_SYMBOL() antlr.TerminalNode
	IMPORT_SYMBOL() antlr.TerminalNode
	INSTALL_SYMBOL() antlr.TerminalNode
	LANGUAGE_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	PRECEDES_SYMBOL() antlr.TerminalNode
	PREPARE_SYMBOL() antlr.TerminalNode
	REPAIR_SYMBOL() antlr.TerminalNode
	RESET_SYMBOL() antlr.TerminalNode
	ROLLBACK_SYMBOL() antlr.TerminalNode
	SAVEPOINT_SYMBOL() antlr.TerminalNode
	SIGNED_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	START_SYMBOL() antlr.TerminalNode
	STOP_SYMBOL() antlr.TerminalNode
	TRUNCATE_SYMBOL() antlr.TerminalNode
	UNICODE_SYMBOL() antlr.TerminalNode
	UNINSTALL_SYMBOL() antlr.TerminalNode
	XA_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsAmbiguous2LabelsContext differentiates from other interfaces.
	IsIdentifierKeywordsAmbiguous2LabelsContext()
}

type IdentifierKeywordsAmbiguous2LabelsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsAmbiguous2LabelsContext() *IdentifierKeywordsAmbiguous2LabelsContext {
	var p = new(IdentifierKeywordsAmbiguous2LabelsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous2Labels
	return p
}

func InitEmptyIdentifierKeywordsAmbiguous2LabelsContext(p *IdentifierKeywordsAmbiguous2LabelsContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous2Labels
}

func (*IdentifierKeywordsAmbiguous2LabelsContext) IsIdentifierKeywordsAmbiguous2LabelsContext() {}

func NewIdentifierKeywordsAmbiguous2LabelsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsAmbiguous2LabelsContext {
	var p = new(IdentifierKeywordsAmbiguous2LabelsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous2Labels

	return p
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordsAmbiguous2LabelsContext) ASCII_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserASCII_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBEGIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) BYTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBYTE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCACHE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CHARSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHARSET_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHECKSUM_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CLONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLONE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) COMMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) CONTAINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONTAINS_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) DEALLOCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEALLOCATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) DO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDO_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEND_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) FLUSH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFLUSH_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) FOLLOWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOLLOWS_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) HANDLER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHANDLER_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) HELP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHELP_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIMPORT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) INSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSTALL_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) LANGUAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLANGUAGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) PRECEDES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRECEDES_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) PREPARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPREPARE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) REPAIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPAIR_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) RESET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESET_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) ROLLBACK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLLBACK_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) SAVEPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSAVEPOINT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) SIGNED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSIGNED_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSLAVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTART_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) STOP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTOP_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) TRUNCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRUNCATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) UNICODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNICODE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) UNINSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNINSTALL_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) XA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserXA_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentifierKeywordsAmbiguous2Labels(s)
	}
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentifierKeywordsAmbiguous2Labels(s)
	}
}

func (s *IdentifierKeywordsAmbiguous2LabelsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentifierKeywordsAmbiguous2Labels(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentifierKeywordsAmbiguous2Labels() (localctx IIdentifierKeywordsAmbiguous2LabelsContext) {
	localctx = NewIdentifierKeywordsAmbiguous2LabelsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 818, TiDBParserRULE_identifierKeywordsAmbiguous2Labels)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5596)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2594284492135333888) != 0) || ((int64((_la-75)) & ^0x3f) == 0 && ((int64(1)<<(_la-75))&281474976743429) != 0) || ((int64((_la-147)) & ^0x3f) == 0 && ((int64(1)<<(_la-147))&1688849860268033) != 0) || ((int64((_la-219)) & ^0x3f) == 0 && ((int64(1)<<(_la-219))&281475043852297) != 0) || ((int64((_la-373)) & ^0x3f) == 0 && ((int64(1)<<(_la-373))&21990232555521) != 0) || ((int64((_la-455)) & ^0x3f) == 0 && ((int64(1)<<(_la-455))&720575957592711169) != 0) || ((int64((_la-543)) & ^0x3f) == 0 && ((int64(1)<<(_la-543))&-9205357638345293311) != 0) || _la == TiDBParserUNINSTALL_SYMBOL || _la == TiDBParserXA_SYMBOL || _la == TiDBParserCLONE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILabelKeywordContext is an interface to support dynamic dispatch.
type ILabelKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleOrLabelKeyword() IRoleOrLabelKeywordContext
	EVENT_SYMBOL() antlr.TerminalNode
	FILE_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode
	PROCESS_SYMBOL() antlr.TerminalNode
	PROXY_SYMBOL() antlr.TerminalNode
	RELOAD_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	SUPER_SYMBOL() antlr.TerminalNode
	IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext
	IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext
	IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext

	// IsLabelKeywordContext differentiates from other interfaces.
	IsLabelKeywordContext()
}

type LabelKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLabelKeywordContext() *LabelKeywordContext {
	var p = new(LabelKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_labelKeyword
	return p
}

func InitEmptyLabelKeywordContext(p *LabelKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_labelKeyword
}

func (*LabelKeywordContext) IsLabelKeywordContext() {}

func NewLabelKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LabelKeywordContext {
	var p = new(LabelKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_labelKeyword

	return p
}

func (s *LabelKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *LabelKeywordContext) RoleOrLabelKeyword() IRoleOrLabelKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrLabelKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrLabelKeywordContext)
}

func (s *LabelKeywordContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEVENT_SYMBOL, 0)
}

func (s *LabelKeywordContext) FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFILE_SYMBOL, 0)
}

func (s *LabelKeywordContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNONE_SYMBOL, 0)
}

func (s *LabelKeywordContext) PROCESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROCESS_SYMBOL, 0)
}

func (s *LabelKeywordContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROXY_SYMBOL, 0)
}

func (s *LabelKeywordContext) RELOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELOAD_SYMBOL, 0)
}

func (s *LabelKeywordContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATION_SYMBOL, 0)
}

func (s *LabelKeywordContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESOURCE_SYMBOL, 0)
}

func (s *LabelKeywordContext) SUPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUPER_SYMBOL, 0)
}

func (s *LabelKeywordContext) IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsUnambiguousContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsUnambiguousContext)
}

func (s *LabelKeywordContext) IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous3RolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous3RolesContext)
}

func (s *LabelKeywordContext) IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous4SystemVariablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous4SystemVariablesContext)
}

func (s *LabelKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LabelKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LabelKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLabelKeyword(s)
	}
}

func (s *LabelKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLabelKeyword(s)
	}
}

func (s *LabelKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLabelKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LabelKeyword() (localctx ILabelKeywordContext) {
	localctx = NewLabelKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 820, TiDBParserRULE_labelKeyword)
	p.SetState(5615)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 754, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5608)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 752, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5598)
				p.RoleOrLabelKeyword()
			}

		case 2:
			{
				p.SetState(5599)
				p.Match(TiDBParserEVENT_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 3:
			{
				p.SetState(5600)
				p.Match(TiDBParserFILE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 4:
			{
				p.SetState(5601)
				p.Match(TiDBParserNONE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 5:
			{
				p.SetState(5602)
				p.Match(TiDBParserPROCESS_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 6:
			{
				p.SetState(5603)
				p.Match(TiDBParserPROXY_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 7:
			{
				p.SetState(5604)
				p.Match(TiDBParserRELOAD_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 8:
			{
				p.SetState(5605)
				p.Match(TiDBParserREPLICATION_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 9:
			{
				p.SetState(5606)
				p.Match(TiDBParserRESOURCE_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case 10:
			{
				p.SetState(5607)
				p.Match(TiDBParserSUPER_SYMBOL)
				if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
				}
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5613)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL:
			{
				p.SetState(5610)
				p.IdentifierKeywordsUnambiguous()
			}

		case TiDBParserEVENT_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserRESOURCE_SYMBOL:
			{
				p.SetState(5611)
				p.IdentifierKeywordsAmbiguous3Roles()
			}

		case TiDBParserGLOBAL_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL:
			{
				p.SetState(5612)
				p.IdentifierKeywordsAmbiguous4SystemVariables()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsAmbiguous3RolesContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsAmbiguous3RolesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EVENT_SYMBOL() antlr.TerminalNode
	FILE_SYMBOL() antlr.TerminalNode
	NONE_SYMBOL() antlr.TerminalNode
	PROCESS_SYMBOL() antlr.TerminalNode
	PROXY_SYMBOL() antlr.TerminalNode
	RELOAD_SYMBOL() antlr.TerminalNode
	REPLICATION_SYMBOL() antlr.TerminalNode
	RESOURCE_SYMBOL() antlr.TerminalNode
	SUPER_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsAmbiguous3RolesContext differentiates from other interfaces.
	IsIdentifierKeywordsAmbiguous3RolesContext()
}

type IdentifierKeywordsAmbiguous3RolesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsAmbiguous3RolesContext() *IdentifierKeywordsAmbiguous3RolesContext {
	var p = new(IdentifierKeywordsAmbiguous3RolesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous3Roles
	return p
}

func InitEmptyIdentifierKeywordsAmbiguous3RolesContext(p *IdentifierKeywordsAmbiguous3RolesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous3Roles
}

func (*IdentifierKeywordsAmbiguous3RolesContext) IsIdentifierKeywordsAmbiguous3RolesContext() {}

func NewIdentifierKeywordsAmbiguous3RolesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsAmbiguous3RolesContext {
	var p = new(IdentifierKeywordsAmbiguous3RolesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous3Roles

	return p
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordsAmbiguous3RolesContext) EVENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEVENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) NONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNONE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) PROCESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROCESS_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) PROXY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROXY_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) RELOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELOAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) RESOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESOURCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) SUPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUPER_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentifierKeywordsAmbiguous3Roles(s)
	}
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentifierKeywordsAmbiguous3Roles(s)
	}
}

func (s *IdentifierKeywordsAmbiguous3RolesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentifierKeywordsAmbiguous3Roles(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentifierKeywordsAmbiguous3Roles() (localctx IIdentifierKeywordsAmbiguous3RolesContext) {
	localctx = NewIdentifierKeywordsAmbiguous3RolesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 822, TiDBParserRULE_identifierKeywordsAmbiguous3Roles)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5617)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserEVENT_SYMBOL || _la == TiDBParserFILE_SYMBOL || ((int64((_la-369)) & ^0x3f) == 0 && ((int64(1)<<(_la-369))&306244774661193729) != 0) || _la == TiDBParserRELOAD_SYMBOL || _la == TiDBParserREPLICATION_SYMBOL || _la == TiDBParserSUPER_SYMBOL || _la == TiDBParserRESOURCE_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsUnambiguousContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsUnambiguousContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTION_SYMBOL() antlr.TerminalNode
	ACCOUNT_SYMBOL() antlr.TerminalNode
	ACTIVE_SYMBOL() antlr.TerminalNode
	ADDDATE_SYMBOL() antlr.TerminalNode
	ADMIN_SYMBOL() antlr.TerminalNode
	AFTER_SYMBOL() antlr.TerminalNode
	AGAINST_SYMBOL() antlr.TerminalNode
	AGGREGATE_SYMBOL() antlr.TerminalNode
	ALGORITHM_SYMBOL() antlr.TerminalNode
	ALWAYS_SYMBOL() antlr.TerminalNode
	ANY_SYMBOL() antlr.TerminalNode
	AT_SYMBOL() antlr.TerminalNode
	AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode
	AUTO_INCREMENT_SYMBOL() antlr.TerminalNode
	AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode
	AVG_SYMBOL() antlr.TerminalNode
	BACKUP_SYMBOL() antlr.TerminalNode
	BINLOG_SYMBOL() antlr.TerminalNode
	BIT_SYMBOL() antlr.TerminalNode
	BLOCK_SYMBOL() antlr.TerminalNode
	BOOLEAN_SYMBOL() antlr.TerminalNode
	BOOL_SYMBOL() antlr.TerminalNode
	BTREE_SYMBOL() antlr.TerminalNode
	BUCKETS_SYMBOL() antlr.TerminalNode
	CASCADED_SYMBOL() antlr.TerminalNode
	CATALOG_NAME_SYMBOL() antlr.TerminalNode
	CHAIN_SYMBOL() antlr.TerminalNode
	CHANGED_SYMBOL() antlr.TerminalNode
	CHANNEL_SYMBOL() antlr.TerminalNode
	CIPHER_SYMBOL() antlr.TerminalNode
	CLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	CLIENT_SYMBOL() antlr.TerminalNode
	CLOSE_SYMBOL() antlr.TerminalNode
	COALESCE_SYMBOL() antlr.TerminalNode
	CODE_SYMBOL() antlr.TerminalNode
	COLLATION_SYMBOL() antlr.TerminalNode
	COLUMNS_SYMBOL() antlr.TerminalNode
	COLUMN_FORMAT_SYMBOL() antlr.TerminalNode
	COLUMN_NAME_SYMBOL() antlr.TerminalNode
	COMMITTED_SYMBOL() antlr.TerminalNode
	COMPACT_SYMBOL() antlr.TerminalNode
	COMPLETION_SYMBOL() antlr.TerminalNode
	COMPONENT_SYMBOL() antlr.TerminalNode
	COMPRESSED_SYMBOL() antlr.TerminalNode
	COMPRESSION_SYMBOL() antlr.TerminalNode
	CONCURRENT_SYMBOL() antlr.TerminalNode
	CONNECTION_SYMBOL() antlr.TerminalNode
	CONSISTENT_SYMBOL() antlr.TerminalNode
	CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode
	CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode
	CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode
	CONTEXT_SYMBOL() antlr.TerminalNode
	CPU_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	CURSOR_NAME_SYMBOL() antlr.TerminalNode
	DATAFILE_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	DATE_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	DEFAULT_AUTH_SYMBOL() antlr.TerminalNode
	DEFINER_SYMBOL() antlr.TerminalNode
	DEFINITION_SYMBOL() antlr.TerminalNode
	DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode
	DESCRIPTION_SYMBOL() antlr.TerminalNode
	DIAGNOSTICS_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	DISABLE_SYMBOL() antlr.TerminalNode
	DISCARD_SYMBOL() antlr.TerminalNode
	DISK_SYMBOL() antlr.TerminalNode
	DUMPFILE_SYMBOL() antlr.TerminalNode
	DUPLICATE_SYMBOL() antlr.TerminalNode
	DYNAMIC_SYMBOL() antlr.TerminalNode
	ENABLE_SYMBOL() antlr.TerminalNode
	ENCRYPTION_SYMBOL() antlr.TerminalNode
	ENDS_SYMBOL() antlr.TerminalNode
	ENFORCED_SYMBOL() antlr.TerminalNode
	ENGINES_SYMBOL() antlr.TerminalNode
	ENGINE_SYMBOL() antlr.TerminalNode
	ENUM_SYMBOL() antlr.TerminalNode
	ERRORS_SYMBOL() antlr.TerminalNode
	ERROR_SYMBOL() antlr.TerminalNode
	ESCAPE_SYMBOL() antlr.TerminalNode
	EVENTS_SYMBOL() antlr.TerminalNode
	EVERY_SYMBOL() antlr.TerminalNode
	EXCHANGE_SYMBOL() antlr.TerminalNode
	EXCLUDE_SYMBOL() antlr.TerminalNode
	EXPANSION_SYMBOL() antlr.TerminalNode
	EXPIRE_SYMBOL() antlr.TerminalNode
	EXPORT_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	EXTENT_SIZE_SYMBOL() antlr.TerminalNode
	FAST_SYMBOL() antlr.TerminalNode
	FAULTS_SYMBOL() antlr.TerminalNode
	FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	FILTER_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	FIXED_SYMBOL() antlr.TerminalNode
	FOLLOWING_SYMBOL() antlr.TerminalNode
	FORMAT_SYMBOL() antlr.TerminalNode
	FOUND_SYMBOL() antlr.TerminalNode
	FULL_SYMBOL() antlr.TerminalNode
	GENERAL_SYMBOL() antlr.TerminalNode
	GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode
	GEOMETRY_SYMBOL() antlr.TerminalNode
	GET_FORMAT_SYMBOL() antlr.TerminalNode
	GET_MASTER_PUBLIC_KEY_SYMBOL() antlr.TerminalNode
	GRANTS_SYMBOL() antlr.TerminalNode
	GROUP_REPLICATION_SYMBOL() antlr.TerminalNode
	HASH_SYMBOL() antlr.TerminalNode
	HISTOGRAM_SYMBOL() antlr.TerminalNode
	HISTORY_SYMBOL() antlr.TerminalNode
	HOSTS_SYMBOL() antlr.TerminalNode
	HOST_SYMBOL() antlr.TerminalNode
	HOUR_SYMBOL() antlr.TerminalNode
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode
	INACTIVE_SYMBOL() antlr.TerminalNode
	INDEXES_SYMBOL() antlr.TerminalNode
	INITIAL_SIZE_SYMBOL() antlr.TerminalNode
	INSERT_METHOD_SYMBOL() antlr.TerminalNode
	INSTANCE_SYMBOL() antlr.TerminalNode
	INVISIBLE_SYMBOL() antlr.TerminalNode
	INVOKER_SYMBOL() antlr.TerminalNode
	IO_SYMBOL() antlr.TerminalNode
	IPC_SYMBOL() antlr.TerminalNode
	ISOLATION_SYMBOL() antlr.TerminalNode
	ISSUER_SYMBOL() antlr.TerminalNode
	JSON_SYMBOL() antlr.TerminalNode
	KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode
	LEAVES_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	LEVEL_SYMBOL() antlr.TerminalNode
	LINESTRING_SYMBOL() antlr.TerminalNode
	LIST_SYMBOL() antlr.TerminalNode
	LOCKED_SYMBOL() antlr.TerminalNode
	LOCKS_SYMBOL() antlr.TerminalNode
	LOGFILE_SYMBOL() antlr.TerminalNode
	LOGS_SYMBOL() antlr.TerminalNode
	MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode
	MASTER_COMPRESSION_ALGORITHM_SYMBOL() antlr.TerminalNode
	MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode
	MASTER_DELAY_SYMBOL() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode
	MASTER_HOST_SYMBOL() antlr.TerminalNode
	NETWORK_NAMESPACE_SYMBOL() antlr.TerminalNode
	MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode
	MASTER_LOG_POS_SYMBOL() antlr.TerminalNode
	MASTER_PASSWORD_SYMBOL() antlr.TerminalNode
	MASTER_PORT_SYMBOL() antlr.TerminalNode
	MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode
	MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode
	MASTER_SERVER_ID_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CA_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode
	MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode
	MASTER_SSL_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	MASTER_TLS_CIPHERSUITES_SYMBOL() antlr.TerminalNode
	MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode
	MASTER_USER_SYMBOL() antlr.TerminalNode
	MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_ROWS_SYMBOL() antlr.TerminalNode
	MAX_SIZE_SYMBOL() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode
	MEDIUM_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	MERGE_SYMBOL() antlr.TerminalNode
	MESSAGE_TEXT_SYMBOL() antlr.TerminalNode
	MICROSECOND_SYMBOL() antlr.TerminalNode
	MIGRATE_SYMBOL() antlr.TerminalNode
	MINUTE_SYMBOL() antlr.TerminalNode
	MIN_ROWS_SYMBOL() antlr.TerminalNode
	MODE_SYMBOL() antlr.TerminalNode
	MODIFY_SYMBOL() antlr.TerminalNode
	MONTH_SYMBOL() antlr.TerminalNode
	MULTILINESTRING_SYMBOL() antlr.TerminalNode
	MULTIPOINT_SYMBOL() antlr.TerminalNode
	MULTIPOLYGON_SYMBOL() antlr.TerminalNode
	MUTEX_SYMBOL() antlr.TerminalNode
	MYSQL_ERRNO_SYMBOL() antlr.TerminalNode
	NAMES_SYMBOL() antlr.TerminalNode
	NAME_SYMBOL() antlr.TerminalNode
	NATIONAL_SYMBOL() antlr.TerminalNode
	NCHAR_SYMBOL() antlr.TerminalNode
	NDBCLUSTER_SYMBOL() antlr.TerminalNode
	NESTED_SYMBOL() antlr.TerminalNode
	NEVER_SYMBOL() antlr.TerminalNode
	NEW_SYMBOL() antlr.TerminalNode
	NEXT_SYMBOL() antlr.TerminalNode
	NODEGROUP_SYMBOL() antlr.TerminalNode
	NOWAIT_SYMBOL() antlr.TerminalNode
	NO_WAIT_SYMBOL() antlr.TerminalNode
	NULLS_SYMBOL() antlr.TerminalNode
	NUMBER_SYMBOL() antlr.TerminalNode
	NVARCHAR_SYMBOL() antlr.TerminalNode
	OFFSET_SYMBOL() antlr.TerminalNode
	OJ_SYMBOL() antlr.TerminalNode
	OLD_SYMBOL() antlr.TerminalNode
	ONE_SYMBOL() antlr.TerminalNode
	ONLY_SYMBOL() antlr.TerminalNode
	OPEN_SYMBOL() antlr.TerminalNode
	OPTIONAL_SYMBOL() antlr.TerminalNode
	OPTIONS_SYMBOL() antlr.TerminalNode
	ORDINALITY_SYMBOL() antlr.TerminalNode
	ORGANIZATION_SYMBOL() antlr.TerminalNode
	OTHERS_SYMBOL() antlr.TerminalNode
	OWNER_SYMBOL() antlr.TerminalNode
	PACK_KEYS_SYMBOL() antlr.TerminalNode
	PAGE_SYMBOL() antlr.TerminalNode
	PARSER_SYMBOL() antlr.TerminalNode
	PARTIAL_SYMBOL() antlr.TerminalNode
	PARTITIONING_SYMBOL() antlr.TerminalNode
	PARTITIONS_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	PATH_SYMBOL() antlr.TerminalNode
	PHASE_SYMBOL() antlr.TerminalNode
	PLUGINS_SYMBOL() antlr.TerminalNode
	PLUGIN_DIR_SYMBOL() antlr.TerminalNode
	PLUGIN_SYMBOL() antlr.TerminalNode
	POINT_SYMBOL() antlr.TerminalNode
	POLYGON_SYMBOL() antlr.TerminalNode
	PORT_SYMBOL() antlr.TerminalNode
	PRECEDING_SYMBOL() antlr.TerminalNode
	PRESERVE_SYMBOL() antlr.TerminalNode
	PREV_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	PRIVILEGE_CHECKS_USER_SYMBOL() antlr.TerminalNode
	PROCESSLIST_SYMBOL() antlr.TerminalNode
	PROFILES_SYMBOL() antlr.TerminalNode
	PROFILE_SYMBOL() antlr.TerminalNode
	QUARTER_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	QUICK_SYMBOL() antlr.TerminalNode
	READ_ONLY_SYMBOL() antlr.TerminalNode
	REBUILD_SYMBOL() antlr.TerminalNode
	RECOVER_SYMBOL() antlr.TerminalNode
	REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	REDUNDANT_SYMBOL() antlr.TerminalNode
	REFERENCE_SYMBOL() antlr.TerminalNode
	RELAY_SYMBOL() antlr.TerminalNode
	RELAYLOG_SYMBOL() antlr.TerminalNode
	RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode
	RELAY_LOG_POS_SYMBOL() antlr.TerminalNode
	RELAY_THREAD_SYMBOL() antlr.TerminalNode
	REMOVE_SYMBOL() antlr.TerminalNode
	REORGANIZE_SYMBOL() antlr.TerminalNode
	REPEATABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	USER_RESOURCES_SYMBOL() antlr.TerminalNode
	RESPECT_SYMBOL() antlr.TerminalNode
	RESTORE_SYMBOL() antlr.TerminalNode
	RESUME_SYMBOL() antlr.TerminalNode
	RETAIN_SYMBOL() antlr.TerminalNode
	RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode
	RETURNS_SYMBOL() antlr.TerminalNode
	REUSE_SYMBOL() antlr.TerminalNode
	REVERSE_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	ROLLUP_SYMBOL() antlr.TerminalNode
	ROTATE_SYMBOL() antlr.TerminalNode
	ROUTINE_SYMBOL() antlr.TerminalNode
	ROW_COUNT_SYMBOL() antlr.TerminalNode
	ROW_FORMAT_SYMBOL() antlr.TerminalNode
	RTREE_SYMBOL() antlr.TerminalNode
	SCHEDULE_SYMBOL() antlr.TerminalNode
	SCHEMA_NAME_SYMBOL() antlr.TerminalNode
	SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode
	SECONDARY_LOAD_SYMBOL() antlr.TerminalNode
	SECONDARY_SYMBOL() antlr.TerminalNode
	SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode
	SECOND_SYMBOL() antlr.TerminalNode
	SECURITY_SYMBOL() antlr.TerminalNode
	SERIALIZABLE_SYMBOL() antlr.TerminalNode
	SERIAL_SYMBOL() antlr.TerminalNode
	SERVER_SYMBOL() antlr.TerminalNode
	SHARE_SYMBOL() antlr.TerminalNode
	SIMPLE_SYMBOL() antlr.TerminalNode
	SKIP_SYMBOL() antlr.TerminalNode
	SLOW_SYMBOL() antlr.TerminalNode
	SNAPSHOT_SYMBOL() antlr.TerminalNode
	SOCKET_SYMBOL() antlr.TerminalNode
	SONAME_SYMBOL() antlr.TerminalNode
	SOUNDS_SYMBOL() antlr.TerminalNode
	SOURCE_SYMBOL() antlr.TerminalNode
	SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode
	SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode
	SQL_NO_CACHE_SYMBOL() antlr.TerminalNode
	SQL_THREAD_SYMBOL() antlr.TerminalNode
	SRID_SYMBOL() antlr.TerminalNode
	STACKED_SYMBOL() antlr.TerminalNode
	STARTS_SYMBOL() antlr.TerminalNode
	STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode
	STATS_PERSISTENT_SYMBOL() antlr.TerminalNode
	STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode
	STATUS_SYMBOL() antlr.TerminalNode
	STORAGE_SYMBOL() antlr.TerminalNode
	STRING_SYMBOL() antlr.TerminalNode
	SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	SUBDATE_SYMBOL() antlr.TerminalNode
	SUBJECT_SYMBOL() antlr.TerminalNode
	SUBPARTITIONS_SYMBOL() antlr.TerminalNode
	SUBPARTITION_SYMBOL() antlr.TerminalNode
	SUSPEND_SYMBOL() antlr.TerminalNode
	SWAPS_SYMBOL() antlr.TerminalNode
	SWITCHES_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode
	TABLE_NAME_SYMBOL() antlr.TerminalNode
	TEMPORARY_SYMBOL() antlr.TerminalNode
	TEMPTABLE_SYMBOL() antlr.TerminalNode
	TEXT_SYMBOL() antlr.TerminalNode
	THAN_SYMBOL() antlr.TerminalNode
	THREAD_PRIORITY_SYMBOL() antlr.TerminalNode
	TIES_SYMBOL() antlr.TerminalNode
	TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode
	TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TRANSACTION_SYMBOL() antlr.TerminalNode
	TRIGGERS_SYMBOL() antlr.TerminalNode
	TYPES_SYMBOL() antlr.TerminalNode
	TYPE_SYMBOL() antlr.TerminalNode
	UNBOUNDED_SYMBOL() antlr.TerminalNode
	UNCOMMITTED_SYMBOL() antlr.TerminalNode
	UNDEFINED_SYMBOL() antlr.TerminalNode
	UNDOFILE_SYMBOL() antlr.TerminalNode
	UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	UNKNOWN_SYMBOL() antlr.TerminalNode
	UNTIL_SYMBOL() antlr.TerminalNode
	UPGRADE_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	USE_FRM_SYMBOL() antlr.TerminalNode
	VALIDATION_SYMBOL() antlr.TerminalNode
	VALUE_SYMBOL() antlr.TerminalNode
	VARIABLES_SYMBOL() antlr.TerminalNode
	VCPU_SYMBOL() antlr.TerminalNode
	VIEW_SYMBOL() antlr.TerminalNode
	VISIBLE_SYMBOL() antlr.TerminalNode
	WAIT_SYMBOL() antlr.TerminalNode
	WARNINGS_SYMBOL() antlr.TerminalNode
	WEEK_SYMBOL() antlr.TerminalNode
	WEIGHT_STRING_SYMBOL() antlr.TerminalNode
	WITHOUT_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode
	WRAPPER_SYMBOL() antlr.TerminalNode
	X509_SYMBOL() antlr.TerminalNode
	XID_SYMBOL() antlr.TerminalNode
	XML_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode
	ARRAY_SYMBOL() antlr.TerminalNode
	FAILED_LOGIN_ATTEMPTS_SYMBOL() antlr.TerminalNode
	MEMBER_SYMBOL() antlr.TerminalNode
	OFF_SYMBOL() antlr.TerminalNode
	PASSWORD_LOCK_TIME_SYMBOL() antlr.TerminalNode
	RANDOM_SYMBOL() antlr.TerminalNode
	REQUIRE_ROW_FORMAT_SYMBOL() antlr.TerminalNode
	REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() antlr.TerminalNode
	STREAM_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsUnambiguousContext differentiates from other interfaces.
	IsIdentifierKeywordsUnambiguousContext()
}

type IdentifierKeywordsUnambiguousContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsUnambiguousContext() *IdentifierKeywordsUnambiguousContext {
	var p = new(IdentifierKeywordsUnambiguousContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsUnambiguous
	return p
}

func InitEmptyIdentifierKeywordsUnambiguousContext(p *IdentifierKeywordsUnambiguousContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsUnambiguous
}

func (*IdentifierKeywordsUnambiguousContext) IsIdentifierKeywordsUnambiguousContext() {}

func NewIdentifierKeywordsUnambiguousContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsUnambiguousContext {
	var p = new(IdentifierKeywordsUnambiguousContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identifierKeywordsUnambiguous

	return p
}

func (s *IdentifierKeywordsUnambiguousContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierKeywordsUnambiguousContext) ACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserACTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ACCOUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserACCOUNT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserACTIVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ADDDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserADDDATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ADMIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserADMIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AFTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAFTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AGAINST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAGAINST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AGGREGATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAGGREGATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALGORITHM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ALWAYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALWAYS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ANY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserANY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAUTOEXTEND_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AUTO_INCREMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAUTO_INCREMENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAVG_ROW_LENGTH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) AVG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAVG_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BACKUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBACKUP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BINLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINLOG_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBLOCK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BOOLEAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBOOLEAN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BOOL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBOOL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBTREE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) BUCKETS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBUCKETS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CASCADED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCASCADED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CATALOG_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCATALOG_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CHAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHAIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CHANGED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHANGED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CHANNEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHANNEL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCIPHER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLASS_ORIGIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLIENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CLOSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COALESCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOALESCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCODE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COLLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLLATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMNS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COLUMN_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMN_FORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COLUMN_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMN_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMITTED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPACT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPACT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPLETION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPLETION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPONENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPONENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPRESSED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPRESSED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) COMPRESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPRESSION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONCURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONCURRENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONNECTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSISTENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSTRAINT_CATALOG_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSTRAINT_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSTRAINT_SCHEMA_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CONTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONTEXT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCPU_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURRENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) CURSOR_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURSOR_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DATAFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATAFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATA_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATETIME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDAY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DEFAULT_AUTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_AUTH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DEFINER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFINER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DEFINITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFINITION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDELAY_KEY_WRITE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DESCRIPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDESCRIPTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DIAGNOSTICS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIAGNOSTICS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIRECTORY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DISABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DISCARD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISCARD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DUMPFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDUMPFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DUPLICATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDUPLICATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) DYNAMIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDYNAMIC_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENCRYPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENCRYPTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENFORCED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENFORCED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENGINES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENGINES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENGINE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ENUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENUM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ERRORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserERRORS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserERROR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ESCAPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserESCAPE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EVENTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEVENTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EVERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEVERY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXCHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXCHANGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXCLUDE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXPANSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXPANSION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXPIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXPIRE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXPORT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTENDED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) EXTENT_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTENT_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFAST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FAULTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFAULTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFILE_BLOCK_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FILTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFILTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIRST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIXED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FOLLOWING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOLLOWING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FOUND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOUND_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFULL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GENERAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGENERAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGEOMETRYCOLLECTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GEOMETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGEOMETRY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GET_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGET_FORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GET_MASTER_PUBLIC_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GRANTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGRANTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GROUP_REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_REPLICATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHASH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HISTOGRAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHISTOGRAM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HISTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHISTORY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HOSTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOSTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOUR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIDENTIFIED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIGNORE_SERVER_IDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINACTIVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INDEXES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINDEXES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INITIAL_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINITIAL_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INSERT_METHOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSERT_METHOD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INSTANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSTANCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INVISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINVISIBLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) INVOKER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINVOKER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) IO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIO_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) IPC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIPC_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ISOLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserISOLATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ISSUER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserISSUER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_BLOCK_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLAST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LEAVES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEAVES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLESS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEVEL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLINESTRING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLIST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LOCKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCKED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LOCKS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCKS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LOGFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOGFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) LOGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOGS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_AUTO_POSITION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_COMPRESSION_ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_CONNECT_RETRY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_DELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_DELAY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_HOST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NETWORK_NAMESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNETWORK_NAMESPACE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_LOG_FILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_LOG_POS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_PASSWORD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_PORT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_RETRY_COUNT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SERVER_ID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SERVER_ID_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CAPATH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CA_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CERT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CIPHER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CRLPATH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CRL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_KEY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_TLS_CIPHERSUITES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_TLS_VERSION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_USER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_ROWS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_USER_CONNECTIONS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MEDIUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEDIUM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEMORY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MERGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMERGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MESSAGE_TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMESSAGE_TEXT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMICROSECOND_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MIGRATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMIGRATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUTE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MIN_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMIN_ROWS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMODE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MODIFY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMODIFY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMONTH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MULTILINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTILINESTRING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MULTIPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTIPOINT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MULTIPOLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTIPOLYGON_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MUTEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMUTEX_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MYSQL_ERRNO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMYSQL_ERRNO_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NAMES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNAMES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NATIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNATIONAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNCHAR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NDBCLUSTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNDBCLUSTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NESTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNESTED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NEVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNEVER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNEW_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNEXT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NODEGROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNODEGROUP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NOWAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOWAIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NO_WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_WAIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULLS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NUMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNUMBER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) NVARCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNVARCHAR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOFFSET_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OJ_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOJ_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OLD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOLD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserONE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserONLY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OPEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OPTIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTIONAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OPTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTIONS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ORDINALITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserORDINALITY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ORGANIZATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserORGANIZATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OTHERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOTHERS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OWNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOWNER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PACK_KEYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPACK_KEYS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPAGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PARSER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARSER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PARTIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTIAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PARTITIONING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITIONING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITIONS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPATH_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PHASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPHASE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PLUGINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUGINS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PLUGIN_DIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUGIN_DIR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PLUGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUGIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) POINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPOINT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) POLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPOLYGON_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPORT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PRECEDING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRECEDING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PRESERVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRESERVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PREV_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPREV_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIVILEGES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PRIVILEGE_CHECKS_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PROCESSLIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROCESSLIST_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PROFILES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROFILES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PROFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) QUARTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUARTER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUERY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUICK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) READ_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREAD_ONLY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REBUILD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREBUILD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RECOVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRECOVER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REDUNDANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREDUNDANT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REFERENCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREFERENCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAYLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAYLOG_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_LOG_FILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAY_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_LOG_POS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RELAY_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_THREAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REMOVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREMOVE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REORGANIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREORGANIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPEATABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPEATABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_DO_DB_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_DO_TABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_IGNORE_DB_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_REWRITE_DB_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) USER_RESOURCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_RESOURCES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RESPECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESPECT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RESTORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESTORE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RESUME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESUME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RETAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRETAIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRETURNED_SQLSTATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RETURNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRETURNS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REUSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREUSE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REVERSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREVERSE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROLLUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLLUP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROTATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROUTINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROUTINE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROW_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_COUNT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_FORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRTREE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SCHEDULE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSCHEDULE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SCHEMA_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSCHEMA_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECONDARY_ENGINE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECONDARY_LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECONDARY_LOAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECONDARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECONDARY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECONDARY_UNLOAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECOND_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SECURITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECURITY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SERIALIZABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSERIALIZABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SERIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSERIAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSERVER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SHARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHARE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SIMPLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSIMPLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SKIP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSKIP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SLOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSLOW_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SNAPSHOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSNAPSHOT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SOCKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSOCKET_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SONAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSONAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SOUNDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSOUNDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSOURCE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_AFTER_GTIDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_BEFORE_GTIDS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_BUFFER_RESULT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_NO_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_NO_CACHE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SQL_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_THREAD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SRID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSRID_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STACKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTACKED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STARTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTARTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATS_AUTO_RECALC_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STATS_PERSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATS_PERSISTENT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STATUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATUS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTORAGE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTRING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBCLASS_ORIGIN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBDATE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBJECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBJECT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBPARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBPARTITIONS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUBPARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBPARTITION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SUSPEND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUSPEND_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SWAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSWAPS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) SWITCHES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSWITCHES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLESPACE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_CHECKSUM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TABLE_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_NAME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TEMPORARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTEMPORARY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TEMPTABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTEMPTABLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTEXT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) THAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTHAN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) THREAD_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTHREAD_PRIORITY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_ADD_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_DIFF_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRANSACTION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TRIGGERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRIGGERS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TYPES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTYPES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTYPE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNBOUNDED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNCOMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNCOMMITTED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNDEFINED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNDEFINED_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNDOFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNDOFILE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNKNOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNKNOWN_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UNTIL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNTIL_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) UPGRADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUPGRADE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) USE_FRM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSE_FRM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VALIDATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVALIDATION_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVALUE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VARIABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVARIABLES_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VCPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVCPU_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVIEW_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) VISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVISIBLE_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWAIT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WARNINGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWARNINGS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WEEK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWEEK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WEIGHT_STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWEIGHT_STRING_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WITHOUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITHOUT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWORK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) WRAPPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWRAPPER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) X509_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserX509_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) XID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserXID_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) XML_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserXML_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserYEAR_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) ARRAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserARRAY_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) FAILED_LOGIN_ATTEMPTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) MEMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEMBER_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) OFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOFF_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) PASSWORD_LOCK_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_LOCK_TIME_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) RANDOM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRANDOM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REQUIRE_ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) REQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) STREAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTREAM_SYMBOL, 0)
}

func (s *IdentifierKeywordsUnambiguousContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsUnambiguousContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsUnambiguousContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentifierKeywordsUnambiguous(s)
	}
}

func (s *IdentifierKeywordsUnambiguousContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentifierKeywordsUnambiguous(s)
	}
}

func (s *IdentifierKeywordsUnambiguousContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentifierKeywordsUnambiguous(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentifierKeywordsUnambiguous() (localctx IIdentifierKeywordsUnambiguousContext) {
	localctx = NewIdentifierKeywordsUnambiguousContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 824, TiDBParserRULE_identifierKeywordsUnambiguous)
	var _la int

	p.SetState(5621)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 755, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5619)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8979026322011384852) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&293728076221109983) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-1036516489208775157) != 0) || ((int64((_la-201)) & ^0x3f) == 0 && ((int64(1)<<(_la-201))&-6430563964047286645) != 0) || ((int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&1868853107068508261) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&173760286417661087) != 0) || ((int64((_la-398)) & ^0x3f) == 0 && ((int64(1)<<(_la-398))&-4228991016542077057) != 0) || ((int64((_la-462)) & ^0x3f) == 0 && ((int64(1)<<(_la-462))&2209089036834331935) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082145862309015) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&3874169395838459587) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-315315032541044359) != 0) || ((int64((_la-720)) & ^0x3f) == 0 && ((int64(1)<<(_la-720))&497599) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5620)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserTIMESTAMP_SYMBOL || _la == TiDBParserTIME_SYMBOL || ((int64((_la-731)) & ^0x3f) == 0 && ((int64(1)<<(_la-731))&16381) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleKeywordContext is an interface to support dynamic dispatch.
type IRoleKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	RoleOrLabelKeyword() IRoleOrLabelKeywordContext
	RoleOrIdentifierKeyword() IRoleOrIdentifierKeywordContext
	IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext
	IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext
	IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext

	// IsRoleKeywordContext differentiates from other interfaces.
	IsRoleKeywordContext()
}

type RoleKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleKeywordContext() *RoleKeywordContext {
	var p = new(RoleKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleKeyword
	return p
}

func InitEmptyRoleKeywordContext(p *RoleKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleKeyword
}

func (*RoleKeywordContext) IsRoleKeywordContext() {}

func NewRoleKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleKeywordContext {
	var p = new(RoleKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_roleKeyword

	return p
}

func (s *RoleKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleKeywordContext) RoleOrLabelKeyword() IRoleOrLabelKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrLabelKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrLabelKeywordContext)
}

func (s *RoleKeywordContext) RoleOrIdentifierKeyword() IRoleOrIdentifierKeywordContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRoleOrIdentifierKeywordContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRoleOrIdentifierKeywordContext)
}

func (s *RoleKeywordContext) IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsUnambiguousContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsUnambiguousContext)
}

func (s *RoleKeywordContext) IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous2LabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous2LabelsContext)
}

func (s *RoleKeywordContext) IdentifierKeywordsAmbiguous4SystemVariables() IIdentifierKeywordsAmbiguous4SystemVariablesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous4SystemVariablesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous4SystemVariablesContext)
}

func (s *RoleKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRoleKeyword(s)
	}
}

func (s *RoleKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRoleKeyword(s)
	}
}

func (s *RoleKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRoleKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RoleKeyword() (localctx IRoleKeywordContext) {
	localctx = NewRoleKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 826, TiDBParserRULE_roleKeyword)
	p.SetState(5632)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 758, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(5625)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 756, p.GetParserRuleContext()) {
		case 1:
			{
				p.SetState(5623)
				p.RoleOrLabelKeyword()
			}

		case 2:
			{
				p.SetState(5624)
				p.RoleOrIdentifierKeyword()
			}

		case antlr.ATNInvalidAltNumber:
			goto errorExit
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		p.SetState(5630)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL:
			{
				p.SetState(5627)
				p.IdentifierKeywordsUnambiguous()
			}

		case TiDBParserASCII_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserCLONE_SYMBOL:
			{
				p.SetState(5628)
				p.IdentifierKeywordsAmbiguous2Labels()
			}

		case TiDBParserGLOBAL_SYMBOL, TiDBParserLOCAL_SYMBOL, TiDBParserSESSION_SYMBOL, TiDBParserPERSIST_SYMBOL, TiDBParserPERSIST_ONLY_SYMBOL:
			{
				p.SetState(5629)
				p.IdentifierKeywordsAmbiguous4SystemVariables()
			}

		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// ILValueKeywordContext is an interface to support dynamic dispatch.
type ILValueKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext
	IdentifierKeywordsAmbiguous1RolesAndLabels() IIdentifierKeywordsAmbiguous1RolesAndLabelsContext
	IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext
	IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext

	// IsLValueKeywordContext differentiates from other interfaces.
	IsLValueKeywordContext()
}

type LValueKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLValueKeywordContext() *LValueKeywordContext {
	var p = new(LValueKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lValueKeyword
	return p
}

func InitEmptyLValueKeywordContext(p *LValueKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_lValueKeyword
}

func (*LValueKeywordContext) IsLValueKeywordContext() {}

func NewLValueKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LValueKeywordContext {
	var p = new(LValueKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_lValueKeyword

	return p
}

func (s *LValueKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *LValueKeywordContext) IdentifierKeywordsUnambiguous() IIdentifierKeywordsUnambiguousContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsUnambiguousContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsUnambiguousContext)
}

func (s *LValueKeywordContext) IdentifierKeywordsAmbiguous1RolesAndLabels() IIdentifierKeywordsAmbiguous1RolesAndLabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous1RolesAndLabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous1RolesAndLabelsContext)
}

func (s *LValueKeywordContext) IdentifierKeywordsAmbiguous2Labels() IIdentifierKeywordsAmbiguous2LabelsContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous2LabelsContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous2LabelsContext)
}

func (s *LValueKeywordContext) IdentifierKeywordsAmbiguous3Roles() IIdentifierKeywordsAmbiguous3RolesContext {
	var t antlr.RuleContext
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierKeywordsAmbiguous3RolesContext); ok {
			t = ctx.(antlr.RuleContext)
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierKeywordsAmbiguous3RolesContext)
}

func (s *LValueKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LValueKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LValueKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterLValueKeyword(s)
	}
}

func (s *LValueKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitLValueKeyword(s)
	}
}

func (s *LValueKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitLValueKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) LValueKeyword() (localctx ILValueKeywordContext) {
	localctx = NewLValueKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 828, TiDBParserRULE_lValueKeyword)
	p.SetState(5638)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserACTION_SYMBOL, TiDBParserADDDATE_SYMBOL, TiDBParserAFTER_SYMBOL, TiDBParserAGAINST_SYMBOL, TiDBParserAGGREGATE_SYMBOL, TiDBParserALGORITHM_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserANY_SYMBOL, TiDBParserAT_SYMBOL, TiDBParserAUTOEXTEND_SIZE_SYMBOL, TiDBParserAUTO_INCREMENT_SYMBOL, TiDBParserAVG_ROW_LENGTH_SYMBOL, TiDBParserAVG_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBINLOG_SYMBOL, TiDBParserBIT_SYMBOL, TiDBParserBLOCK_SYMBOL, TiDBParserBOOLEAN_SYMBOL, TiDBParserBOOL_SYMBOL, TiDBParserBTREE_SYMBOL, TiDBParserCASCADED_SYMBOL, TiDBParserCATALOG_NAME_SYMBOL, TiDBParserCHAIN_SYMBOL, TiDBParserCHANGED_SYMBOL, TiDBParserCHANNEL_SYMBOL, TiDBParserCIPHER_SYMBOL, TiDBParserCLASS_ORIGIN_SYMBOL, TiDBParserCLIENT_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOALESCE_SYMBOL, TiDBParserCODE_SYMBOL, TiDBParserCOLLATION_SYMBOL, TiDBParserCOLUMNS_SYMBOL, TiDBParserCOLUMN_NAME_SYMBOL, TiDBParserCOLUMN_FORMAT_SYMBOL, TiDBParserCOMMITTED_SYMBOL, TiDBParserCOMPACT_SYMBOL, TiDBParserCOMPLETION_SYMBOL, TiDBParserCOMPRESSED_SYMBOL, TiDBParserCOMPRESSION_SYMBOL, TiDBParserCONCURRENT_SYMBOL, TiDBParserCONNECTION_SYMBOL, TiDBParserCONSISTENT_SYMBOL, TiDBParserCONSTRAINT_CATALOG_SYMBOL, TiDBParserCONSTRAINT_NAME_SYMBOL, TiDBParserCONSTRAINT_SCHEMA_SYMBOL, TiDBParserCONTEXT_SYMBOL, TiDBParserCPU_SYMBOL, TiDBParserCURRENT_SYMBOL, TiDBParserCURSOR_NAME_SYMBOL, TiDBParserDATAFILE_SYMBOL, TiDBParserDATA_SYMBOL, TiDBParserDATETIME_SYMBOL, TiDBParserDATE_SYMBOL, TiDBParserDAY_SYMBOL, TiDBParserDEFAULT_AUTH_SYMBOL, TiDBParserDEFINER_SYMBOL, TiDBParserDELAY_KEY_WRITE_SYMBOL, TiDBParserDIAGNOSTICS_SYMBOL, TiDBParserDIRECTORY_SYMBOL, TiDBParserDISABLE_SYMBOL, TiDBParserDISCARD_SYMBOL, TiDBParserDISK_SYMBOL, TiDBParserDUMPFILE_SYMBOL, TiDBParserDUPLICATE_SYMBOL, TiDBParserDYNAMIC_SYMBOL, TiDBParserENABLE_SYMBOL, TiDBParserENCRYPTION_SYMBOL, TiDBParserENDS_SYMBOL, TiDBParserENGINES_SYMBOL, TiDBParserENGINE_SYMBOL, TiDBParserENUM_SYMBOL, TiDBParserERROR_SYMBOL, TiDBParserERRORS_SYMBOL, TiDBParserESCAPE_SYMBOL, TiDBParserEVENTS_SYMBOL, TiDBParserEVERY_SYMBOL, TiDBParserEXCHANGE_SYMBOL, TiDBParserEXPANSION_SYMBOL, TiDBParserEXPIRE_SYMBOL, TiDBParserEXPORT_SYMBOL, TiDBParserEXTENDED_SYMBOL, TiDBParserEXTENT_SIZE_SYMBOL, TiDBParserFAST_SYMBOL, TiDBParserFAULTS_SYMBOL, TiDBParserFILE_BLOCK_SIZE_SYMBOL, TiDBParserFILTER_SYMBOL, TiDBParserFIRST_SYMBOL, TiDBParserFIXED_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserFOUND_SYMBOL, TiDBParserFULL_SYMBOL, TiDBParserGENERAL_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserGEOMETRYCOLLECTION_SYMBOL, TiDBParserGEOMETRY_SYMBOL, TiDBParserGET_FORMAT_SYMBOL, TiDBParserGRANTS_SYMBOL, TiDBParserHASH_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserHOSTS_SYMBOL, TiDBParserHOUR_SYMBOL, TiDBParserIDENTIFIED_SYMBOL, TiDBParserIGNORE_SERVER_IDS_SYMBOL, TiDBParserINDEXES_SYMBOL, TiDBParserINITIAL_SIZE_SYMBOL, TiDBParserINSERT_METHOD_SYMBOL, TiDBParserINSTANCE_SYMBOL, TiDBParserINVOKER_SYMBOL, TiDBParserIO_SYMBOL, TiDBParserIPC_SYMBOL, TiDBParserISOLATION_SYMBOL, TiDBParserISSUER_SYMBOL, TiDBParserJSON_SYMBOL, TiDBParserKEY_BLOCK_SIZE_SYMBOL, TiDBParserLAST_SYMBOL, TiDBParserLEAVES_SYMBOL, TiDBParserLESS_SYMBOL, TiDBParserLEVEL_SYMBOL, TiDBParserLINESTRING_SYMBOL, TiDBParserLIST_SYMBOL, TiDBParserLOCKS_SYMBOL, TiDBParserLOGFILE_SYMBOL, TiDBParserLOGS_SYMBOL, TiDBParserMASTER_AUTO_POSITION_SYMBOL, TiDBParserMASTER_CONNECT_RETRY_SYMBOL, TiDBParserMASTER_DELAY_SYMBOL, TiDBParserMASTER_HOST_SYMBOL, TiDBParserMASTER_LOG_FILE_SYMBOL, TiDBParserMASTER_LOG_POS_SYMBOL, TiDBParserMASTER_PASSWORD_SYMBOL, TiDBParserMASTER_PORT_SYMBOL, TiDBParserMASTER_RETRY_COUNT_SYMBOL, TiDBParserMASTER_SERVER_ID_SYMBOL, TiDBParserMASTER_SSL_CAPATH_SYMBOL, TiDBParserMASTER_SSL_CA_SYMBOL, TiDBParserMASTER_SSL_CERT_SYMBOL, TiDBParserMASTER_SSL_CIPHER_SYMBOL, TiDBParserMASTER_SSL_CRL_SYMBOL, TiDBParserMASTER_SSL_CRLPATH_SYMBOL, TiDBParserMASTER_SSL_KEY_SYMBOL, TiDBParserMASTER_SSL_SYMBOL, TiDBParserMASTER_SYMBOL, TiDBParserMASTER_TLS_VERSION_SYMBOL, TiDBParserMASTER_USER_SYMBOL, TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, TiDBParserMAX_ROWS_SYMBOL, TiDBParserMAX_SIZE_SYMBOL, TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, TiDBParserMAX_USER_CONNECTIONS_SYMBOL, TiDBParserMEDIUM_SYMBOL, TiDBParserMEMORY_SYMBOL, TiDBParserMERGE_SYMBOL, TiDBParserMESSAGE_TEXT_SYMBOL, TiDBParserMICROSECOND_SYMBOL, TiDBParserMIGRATE_SYMBOL, TiDBParserMINUTE_SYMBOL, TiDBParserMIN_ROWS_SYMBOL, TiDBParserMODE_SYMBOL, TiDBParserMODIFY_SYMBOL, TiDBParserMONTH_SYMBOL, TiDBParserMULTILINESTRING_SYMBOL, TiDBParserMULTIPOINT_SYMBOL, TiDBParserMULTIPOLYGON_SYMBOL, TiDBParserMUTEX_SYMBOL, TiDBParserMYSQL_ERRNO_SYMBOL, TiDBParserNAMES_SYMBOL, TiDBParserNAME_SYMBOL, TiDBParserNATIONAL_SYMBOL, TiDBParserNCHAR_SYMBOL, TiDBParserNDBCLUSTER_SYMBOL, TiDBParserNEVER_SYMBOL, TiDBParserNEW_SYMBOL, TiDBParserNEXT_SYMBOL, TiDBParserNODEGROUP_SYMBOL, TiDBParserNO_WAIT_SYMBOL, TiDBParserNUMBER_SYMBOL, TiDBParserNVARCHAR_SYMBOL, TiDBParserOFFSET_SYMBOL, TiDBParserONE_SYMBOL, TiDBParserONLY_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPACK_KEYS_SYMBOL, TiDBParserPAGE_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTIAL_SYMBOL, TiDBParserPARTITIONING_SYMBOL, TiDBParserPARTITIONS_SYMBOL, TiDBParserPASSWORD_SYMBOL, TiDBParserPHASE_SYMBOL, TiDBParserPLUGINS_SYMBOL, TiDBParserPLUGIN_DIR_SYMBOL, TiDBParserPLUGIN_SYMBOL, TiDBParserPOINT_SYMBOL, TiDBParserPOLYGON_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRESERVE_SYMBOL, TiDBParserPREV_SYMBOL, TiDBParserPRIVILEGES_SYMBOL, TiDBParserPROCESSLIST_SYMBOL, TiDBParserPROFILE_SYMBOL, TiDBParserPROFILES_SYMBOL, TiDBParserQUARTER_SYMBOL, TiDBParserQUERY_SYMBOL, TiDBParserQUICK_SYMBOL, TiDBParserREAD_ONLY_SYMBOL, TiDBParserREBUILD_SYMBOL, TiDBParserRECOVER_SYMBOL, TiDBParserREDO_BUFFER_SIZE_SYMBOL, TiDBParserREDUNDANT_SYMBOL, TiDBParserRELAY_SYMBOL, TiDBParserRELAYLOG_SYMBOL, TiDBParserRELAY_LOG_FILE_SYMBOL, TiDBParserRELAY_LOG_POS_SYMBOL, TiDBParserRELAY_THREAD_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREORGANIZE_SYMBOL, TiDBParserREPEATABLE_SYMBOL, TiDBParserREPLICATE_DO_DB_SYMBOL, TiDBParserREPLICATE_IGNORE_DB_SYMBOL, TiDBParserREPLICATE_DO_TABLE_SYMBOL, TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, TiDBParserREPLICATE_REWRITE_DB_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserRESUME_SYMBOL, TiDBParserRETURNED_SQLSTATE_SYMBOL, TiDBParserRETURNS_SYMBOL, TiDBParserREVERSE_SYMBOL, TiDBParserROLLUP_SYMBOL, TiDBParserROTATE_SYMBOL, TiDBParserROUTINE_SYMBOL, TiDBParserROW_COUNT_SYMBOL, TiDBParserROW_FORMAT_SYMBOL, TiDBParserRTREE_SYMBOL, TiDBParserSCHEDULE_SYMBOL, TiDBParserSCHEMA_NAME_SYMBOL, TiDBParserSECOND_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERIALIZABLE_SYMBOL, TiDBParserSERIAL_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSHARE_SYMBOL, TiDBParserSIMPLE_SYMBOL, TiDBParserSLOW_SYMBOL, TiDBParserSNAPSHOT_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSOUNDS_SYMBOL, TiDBParserSOURCE_SYMBOL, TiDBParserSQL_AFTER_GTIDS_SYMBOL, TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, TiDBParserSQL_BEFORE_GTIDS_SYMBOL, TiDBParserSQL_BUFFER_RESULT_SYMBOL, TiDBParserSQL_NO_CACHE_SYMBOL, TiDBParserSQL_THREAD_SYMBOL, TiDBParserSTACKED_SYMBOL, TiDBParserSTARTS_SYMBOL, TiDBParserSTATS_AUTO_RECALC_SYMBOL, TiDBParserSTATS_PERSISTENT_SYMBOL, TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, TiDBParserSTATUS_SYMBOL, TiDBParserSTORAGE_SYMBOL, TiDBParserSTRING_SYMBOL, TiDBParserSUBCLASS_ORIGIN_SYMBOL, TiDBParserSUBDATE_SYMBOL, TiDBParserSUBJECT_SYMBOL, TiDBParserSUBPARTITIONS_SYMBOL, TiDBParserSUBPARTITION_SYMBOL, TiDBParserSUSPEND_SYMBOL, TiDBParserSWAPS_SYMBOL, TiDBParserSWITCHES_SYMBOL, TiDBParserTABLES_SYMBOL, TiDBParserTABLESPACE_SYMBOL, TiDBParserTABLE_CHECKSUM_SYMBOL, TiDBParserTABLE_NAME_SYMBOL, TiDBParserTEMPORARY_SYMBOL, TiDBParserTEMPTABLE_SYMBOL, TiDBParserTEXT_SYMBOL, TiDBParserTHAN_SYMBOL, TiDBParserTIMESTAMP_SYMBOL, TiDBParserTIMESTAMP_ADD_SYMBOL, TiDBParserTIMESTAMP_DIFF_SYMBOL, TiDBParserTIME_SYMBOL, TiDBParserTRANSACTION_SYMBOL, TiDBParserTRIGGERS_SYMBOL, TiDBParserTYPES_SYMBOL, TiDBParserTYPE_SYMBOL, TiDBParserUNCOMMITTED_SYMBOL, TiDBParserUNDEFINED_SYMBOL, TiDBParserUNDOFILE_SYMBOL, TiDBParserUNDO_BUFFER_SIZE_SYMBOL, TiDBParserUNKNOWN_SYMBOL, TiDBParserUNTIL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserUSER_RESOURCES_SYMBOL, TiDBParserUSER_SYMBOL, TiDBParserUSE_FRM_SYMBOL, TiDBParserVALIDATION_SYMBOL, TiDBParserVALUE_SYMBOL, TiDBParserVARIABLES_SYMBOL, TiDBParserVIEW_SYMBOL, TiDBParserWAIT_SYMBOL, TiDBParserWARNINGS_SYMBOL, TiDBParserWEEK_SYMBOL, TiDBParserWEIGHT_STRING_SYMBOL, TiDBParserWITHOUT_SYMBOL, TiDBParserWORK_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserX509_SYMBOL, TiDBParserXID_SYMBOL, TiDBParserXML_SYMBOL, TiDBParserYEAR_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserADMIN_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCOMPONENT_SYMBOL, TiDBParserSKIP_SYMBOL, TiDBParserLOCKED_SYMBOL, TiDBParserNOWAIT_SYMBOL, TiDBParserHISTOGRAM_SYMBOL, TiDBParserBUCKETS_SYMBOL, TiDBParserEXCLUDE_SYMBOL, TiDBParserFOLLOWING_SYMBOL, TiDBParserNULLS_SYMBOL, TiDBParserOTHERS_SYMBOL, TiDBParserPRECEDING_SYMBOL, TiDBParserRESPECT_SYMBOL, TiDBParserTIES_SYMBOL, TiDBParserUNBOUNDED_SYMBOL, TiDBParserNESTED_SYMBOL, TiDBParserORDINALITY_SYMBOL, TiDBParserPATH_SYMBOL, TiDBParserHISTORY_SYMBOL, TiDBParserREUSE_SYMBOL, TiDBParserSRID_SYMBOL, TiDBParserTHREAD_PRIORITY_SYMBOL, TiDBParserVCPU_SYMBOL, TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, TiDBParserGET_MASTER_PUBLIC_KEY_SYMBOL, TiDBParserDEFINITION_SYMBOL, TiDBParserDESCRIPTION_SYMBOL, TiDBParserORGANIZATION_SYMBOL, TiDBParserREFERENCE_SYMBOL, TiDBParserOPTIONAL_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL, TiDBParserACTIVE_SYMBOL, TiDBParserINACTIVE_SYMBOL, TiDBParserRETAIN_SYMBOL, TiDBParserOLD_SYMBOL, TiDBParserNETWORK_NAMESPACE_SYMBOL, TiDBParserENFORCED_SYMBOL, TiDBParserARRAY_SYMBOL, TiDBParserOJ_SYMBOL, TiDBParserMEMBER_SYMBOL, TiDBParserRANDOM_SYMBOL, TiDBParserMASTER_COMPRESSION_ALGORITHM_SYMBOL, TiDBParserMASTER_ZSTD_COMPRESSION_LEVEL_SYMBOL, TiDBParserPRIVILEGE_CHECKS_USER_SYMBOL, TiDBParserMASTER_TLS_CIPHERSUITES_SYMBOL, TiDBParserREQUIRE_ROW_FORMAT_SYMBOL, TiDBParserPASSWORD_LOCK_TIME_SYMBOL, TiDBParserFAILED_LOGIN_ATTEMPTS_SYMBOL, TiDBParserREQUIRE_TABLE_PRIMARY_KEY_CHECK_SYMBOL, TiDBParserSTREAM_SYMBOL, TiDBParserOFF_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5634)
			p.IdentifierKeywordsUnambiguous()
		}

	case TiDBParserEXECUTE_SYMBOL, TiDBParserSHUTDOWN_SYMBOL, TiDBParserRESTART_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5635)
			p.IdentifierKeywordsAmbiguous1RolesAndLabels()
		}

	case TiDBParserASCII_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserIMPORT_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserCLONE_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5636)
			p.IdentifierKeywordsAmbiguous2Labels()
		}

	case TiDBParserEVENT_SYMBOL, TiDBParserFILE_SYMBOL, TiDBParserNONE_SYMBOL, TiDBParserPROCESS_SYMBOL, TiDBParserPROXY_SYMBOL, TiDBParserRELOAD_SYMBOL, TiDBParserREPLICATION_SYMBOL, TiDBParserSUPER_SYMBOL, TiDBParserRESOURCE_SYMBOL:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5637)
			p.IdentifierKeywordsAmbiguous3Roles()
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IIdentifierKeywordsAmbiguous4SystemVariablesContext is an interface to support dynamic dispatch.
type IIdentifierKeywordsAmbiguous4SystemVariablesContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	GLOBAL_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	PERSIST_SYMBOL() antlr.TerminalNode
	PERSIST_ONLY_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode

	// IsIdentifierKeywordsAmbiguous4SystemVariablesContext differentiates from other interfaces.
	IsIdentifierKeywordsAmbiguous4SystemVariablesContext()
}

type IdentifierKeywordsAmbiguous4SystemVariablesContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierKeywordsAmbiguous4SystemVariablesContext() *IdentifierKeywordsAmbiguous4SystemVariablesContext {
	var p = new(IdentifierKeywordsAmbiguous4SystemVariablesContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous4SystemVariables
	return p
}

func InitEmptyIdentifierKeywordsAmbiguous4SystemVariablesContext(p *IdentifierKeywordsAmbiguous4SystemVariablesContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous4SystemVariables
}

func (*IdentifierKeywordsAmbiguous4SystemVariablesContext) IsIdentifierKeywordsAmbiguous4SystemVariablesContext() {
}

func NewIdentifierKeywordsAmbiguous4SystemVariablesContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierKeywordsAmbiguous4SystemVariablesContext {
	var p = new(IdentifierKeywordsAmbiguous4SystemVariablesContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_identifierKeywordsAmbiguous4SystemVariables

	return p
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) GetParser() antlr.Parser {
	return s.parser
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGLOBAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCAL_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) PERSIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPERSIST_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) PERSIST_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPERSIST_ONLY_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSESSION_SYMBOL, 0)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterIdentifierKeywordsAmbiguous4SystemVariables(s)
	}
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitIdentifierKeywordsAmbiguous4SystemVariables(s)
	}
}

func (s *IdentifierKeywordsAmbiguous4SystemVariablesContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitIdentifierKeywordsAmbiguous4SystemVariables(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) IdentifierKeywordsAmbiguous4SystemVariables() (localctx IIdentifierKeywordsAmbiguous4SystemVariablesContext) {
	localctx = NewIdentifierKeywordsAmbiguous4SystemVariablesContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 830, TiDBParserRULE_identifierKeywordsAmbiguous4SystemVariables)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(5640)
		_la = p.GetTokenStream().LA(1)

		if !(_la == TiDBParserGLOBAL_SYMBOL || _la == TiDBParserLOCAL_SYMBOL || _la == TiDBParserSESSION_SYMBOL || _la == TiDBParserPERSIST_SYMBOL || _la == TiDBParserPERSIST_ONLY_SYMBOL) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOrIdentifierKeywordContext is an interface to support dynamic dispatch.
type IRoleOrIdentifierKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACCOUNT_SYMBOL() antlr.TerminalNode
	ASCII_SYMBOL() antlr.TerminalNode
	ALWAYS_SYMBOL() antlr.TerminalNode
	BACKUP_SYMBOL() antlr.TerminalNode
	BEGIN_SYMBOL() antlr.TerminalNode
	BYTE_SYMBOL() antlr.TerminalNode
	CACHE_SYMBOL() antlr.TerminalNode
	CHARSET_SYMBOL() antlr.TerminalNode
	CHECKSUM_SYMBOL() antlr.TerminalNode
	CLONE_SYMBOL() antlr.TerminalNode
	CLOSE_SYMBOL() antlr.TerminalNode
	COMMENT_SYMBOL() antlr.TerminalNode
	COMMIT_SYMBOL() antlr.TerminalNode
	CONTAINS_SYMBOL() antlr.TerminalNode
	DEALLOCATE_SYMBOL() antlr.TerminalNode
	DO_SYMBOL() antlr.TerminalNode
	END_SYMBOL() antlr.TerminalNode
	FLUSH_SYMBOL() antlr.TerminalNode
	FOLLOWS_SYMBOL() antlr.TerminalNode
	FORMAT_SYMBOL() antlr.TerminalNode
	GROUP_REPLICATION_SYMBOL() antlr.TerminalNode
	HANDLER_SYMBOL() antlr.TerminalNode
	HELP_SYMBOL() antlr.TerminalNode
	HOST_SYMBOL() antlr.TerminalNode
	INSTALL_SYMBOL() antlr.TerminalNode
	INVISIBLE_SYMBOL() antlr.TerminalNode
	LANGUAGE_SYMBOL() antlr.TerminalNode
	NO_SYMBOL() antlr.TerminalNode
	OPEN_SYMBOL() antlr.TerminalNode
	OPTIONS_SYMBOL() antlr.TerminalNode
	OWNER_SYMBOL() antlr.TerminalNode
	PARSER_SYMBOL() antlr.TerminalNode
	PARTITION_SYMBOL() antlr.TerminalNode
	PORT_SYMBOL() antlr.TerminalNode
	PRECEDES_SYMBOL() antlr.TerminalNode
	PREPARE_SYMBOL() antlr.TerminalNode
	REMOVE_SYMBOL() antlr.TerminalNode
	REPAIR_SYMBOL() antlr.TerminalNode
	RESET_SYMBOL() antlr.TerminalNode
	RESTORE_SYMBOL() antlr.TerminalNode
	ROLE_SYMBOL() antlr.TerminalNode
	ROLLBACK_SYMBOL() antlr.TerminalNode
	SAVEPOINT_SYMBOL() antlr.TerminalNode
	SECONDARY_SYMBOL() antlr.TerminalNode
	SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode
	SECONDARY_LOAD_SYMBOL() antlr.TerminalNode
	SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode
	SECURITY_SYMBOL() antlr.TerminalNode
	SERVER_SYMBOL() antlr.TerminalNode
	SIGNED_SYMBOL() antlr.TerminalNode
	SOCKET_SYMBOL() antlr.TerminalNode
	SLAVE_SYMBOL() antlr.TerminalNode
	SONAME_SYMBOL() antlr.TerminalNode
	START_SYMBOL() antlr.TerminalNode
	STOP_SYMBOL() antlr.TerminalNode
	TRUNCATE_SYMBOL() antlr.TerminalNode
	UNICODE_SYMBOL() antlr.TerminalNode
	UNINSTALL_SYMBOL() antlr.TerminalNode
	UPGRADE_SYMBOL() antlr.TerminalNode
	VISIBLE_SYMBOL() antlr.TerminalNode
	WRAPPER_SYMBOL() antlr.TerminalNode
	XA_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode
	IMPORT_SYMBOL() antlr.TerminalNode

	// IsRoleOrIdentifierKeywordContext differentiates from other interfaces.
	IsRoleOrIdentifierKeywordContext()
}

type RoleOrIdentifierKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOrIdentifierKeywordContext() *RoleOrIdentifierKeywordContext {
	var p = new(RoleOrIdentifierKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleOrIdentifierKeyword
	return p
}

func InitEmptyRoleOrIdentifierKeywordContext(p *RoleOrIdentifierKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleOrIdentifierKeyword
}

func (*RoleOrIdentifierKeywordContext) IsRoleOrIdentifierKeywordContext() {}

func NewRoleOrIdentifierKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOrIdentifierKeywordContext {
	var p = new(RoleOrIdentifierKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_roleOrIdentifierKeyword

	return p
}

func (s *RoleOrIdentifierKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOrIdentifierKeywordContext) ACCOUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserACCOUNT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) ASCII_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserASCII_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) ALWAYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALWAYS_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) BACKUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBACKUP_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) BEGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBEGIN_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) BYTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBYTE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCACHE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CHARSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHARSET_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHECKSUM_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CLONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLONE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CLOSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLOSE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) COMMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMENT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) COMMIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMIT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) CONTAINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONTAINS_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) DEALLOCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEALLOCATE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) DO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDO_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) END_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEND_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) FLUSH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFLUSH_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) FOLLOWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOLLOWS_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFORMAT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) GROUP_REPLICATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGROUP_REPLICATION_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) HANDLER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHANDLER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) HELP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHELP_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOST_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) INSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSTALL_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) INVISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINVISIBLE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) LANGUAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLANGUAGE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) NO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) OPEN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPEN_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) OPTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTIONS_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) OWNER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOWNER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PARSER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARSER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITION_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPORT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PRECEDES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRECEDES_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) PREPARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPREPARE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) REMOVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREMOVE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) REPAIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPAIR_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) RESET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESET_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) RESTORE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESTORE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) ROLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) ROLLBACK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLLBACK_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SAVEPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSAVEPOINT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECONDARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECONDARY_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECONDARY_ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECONDARY_ENGINE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECONDARY_LOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECONDARY_LOAD_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECONDARY_UNLOAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECONDARY_UNLOAD_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SECURITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECURITY_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SERVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSERVER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SIGNED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSIGNED_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SOCKET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSOCKET_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SLAVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSLAVE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SONAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSONAME_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) START_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTART_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) STOP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTOP_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) TRUNCATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRUNCATE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) UNICODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNICODE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) UNINSTALL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNINSTALL_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) UPGRADE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUPGRADE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) VISIBLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVISIBLE_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) WRAPPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWRAPPER_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) XA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserXA_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHUTDOWN_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIMPORT_SYMBOL, 0)
}

func (s *RoleOrIdentifierKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOrIdentifierKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOrIdentifierKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRoleOrIdentifierKeyword(s)
	}
}

func (s *RoleOrIdentifierKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRoleOrIdentifierKeyword(s)
	}
}

func (s *RoleOrIdentifierKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRoleOrIdentifierKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RoleOrIdentifierKeyword() (localctx IRoleOrIdentifierKeywordContext) {
	localctx = NewRoleOrIdentifierKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 832, TiDBParserRULE_roleOrIdentifierKeyword)
	var _la int

	p.SetState(5645)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case TiDBParserACCOUNT_SYMBOL, TiDBParserALWAYS_SYMBOL, TiDBParserASCII_SYMBOL, TiDBParserBACKUP_SYMBOL, TiDBParserBEGIN_SYMBOL, TiDBParserBYTE_SYMBOL, TiDBParserCACHE_SYMBOL, TiDBParserCHARSET_SYMBOL, TiDBParserCHECKSUM_SYMBOL, TiDBParserCLOSE_SYMBOL, TiDBParserCOMMENT_SYMBOL, TiDBParserCOMMIT_SYMBOL, TiDBParserCONTAINS_SYMBOL, TiDBParserDEALLOCATE_SYMBOL, TiDBParserDO_SYMBOL, TiDBParserEND_SYMBOL, TiDBParserFLUSH_SYMBOL, TiDBParserFOLLOWS_SYMBOL, TiDBParserFORMAT_SYMBOL, TiDBParserGROUP_REPLICATION_SYMBOL, TiDBParserHANDLER_SYMBOL, TiDBParserHELP_SYMBOL, TiDBParserHOST_SYMBOL, TiDBParserINSTALL_SYMBOL, TiDBParserLANGUAGE_SYMBOL, TiDBParserNO_SYMBOL, TiDBParserOPEN_SYMBOL, TiDBParserOPTIONS_SYMBOL, TiDBParserOWNER_SYMBOL, TiDBParserPARSER_SYMBOL, TiDBParserPARTITION_SYMBOL, TiDBParserPORT_SYMBOL, TiDBParserPRECEDES_SYMBOL, TiDBParserPREPARE_SYMBOL, TiDBParserREMOVE_SYMBOL, TiDBParserREPAIR_SYMBOL, TiDBParserRESET_SYMBOL, TiDBParserRESTORE_SYMBOL, TiDBParserROLLBACK_SYMBOL, TiDBParserSAVEPOINT_SYMBOL, TiDBParserSECURITY_SYMBOL, TiDBParserSERVER_SYMBOL, TiDBParserSIGNED_SYMBOL, TiDBParserSLAVE_SYMBOL, TiDBParserSOCKET_SYMBOL, TiDBParserSONAME_SYMBOL, TiDBParserSTART_SYMBOL, TiDBParserSTOP_SYMBOL, TiDBParserTRUNCATE_SYMBOL, TiDBParserUNICODE_SYMBOL, TiDBParserUNINSTALL_SYMBOL, TiDBParserUPGRADE_SYMBOL, TiDBParserWRAPPER_SYMBOL, TiDBParserXA_SYMBOL, TiDBParserROLE_SYMBOL, TiDBParserINVISIBLE_SYMBOL, TiDBParserVISIBLE_SYMBOL, TiDBParserCLONE_SYMBOL, TiDBParserSECONDARY_SYMBOL, TiDBParserSECONDARY_ENGINE_SYMBOL, TiDBParserSECONDARY_LOAD_SYMBOL, TiDBParserSECONDARY_UNLOAD_SYMBOL:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5642)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&2594284492269555716) != 0) || ((int64((_la-66)) & ^0x3f) == 0 && ((int64(1)<<(_la-66))&144115188092635649) != 0) || ((int64((_la-147)) & ^0x3f) == 0 && ((int64(1)<<(_la-147))&-9203668788485025791) != 0) || ((int64((_la-219)) & ^0x3f) == 0 && ((int64(1)<<(_la-219))&281475043819561) != 0) || ((int64((_la-373)) & ^0x3f) == 0 && ((int64(1)<<(_la-373))&23094341287937) != 0) || ((int64((_la-452)) & ^0x3f) == 0 && ((int64(1)<<(_la-452))&5766877052741681161) != 0) || ((int64((_la-519)) & ^0x3f) == 0 && ((int64(1)<<(_la-519))&8606711811) != 0) || ((int64((_la-597)) & ^0x3f) == 0 && ((int64(1)<<(_la-597))&4631952216750818817) != 0) || ((int64((_la-661)) & ^0x3f) == 0 && ((int64(1)<<(_la-661))&8646911284551417859) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case TiDBParserSHUTDOWN_SYMBOL:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5643)
			p.Match(TiDBParserSHUTDOWN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case TiDBParserIMPORT_SYMBOL:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5644)
			p.Match(TiDBParserIMPORT_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

// IRoleOrLabelKeywordContext is an interface to support dynamic dispatch.
type IRoleOrLabelKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ACTION_SYMBOL() antlr.TerminalNode
	ACTIVE_SYMBOL() antlr.TerminalNode
	ADDDATE_SYMBOL() antlr.TerminalNode
	AFTER_SYMBOL() antlr.TerminalNode
	AGAINST_SYMBOL() antlr.TerminalNode
	AGGREGATE_SYMBOL() antlr.TerminalNode
	ALGORITHM_SYMBOL() antlr.TerminalNode
	ANALYSE_SYMBOL() antlr.TerminalNode
	ANY_SYMBOL() antlr.TerminalNode
	AT_SYMBOL() antlr.TerminalNode
	AUTHORS_SYMBOL() antlr.TerminalNode
	AUTO_INCREMENT_SYMBOL() antlr.TerminalNode
	AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode
	AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode
	AVG_SYMBOL() antlr.TerminalNode
	BINLOG_SYMBOL() antlr.TerminalNode
	BIT_SYMBOL() antlr.TerminalNode
	BLOCK_SYMBOL() antlr.TerminalNode
	BOOL_SYMBOL() antlr.TerminalNode
	BOOLEAN_SYMBOL() antlr.TerminalNode
	BTREE_SYMBOL() antlr.TerminalNode
	BUCKETS_SYMBOL() antlr.TerminalNode
	CASCADED_SYMBOL() antlr.TerminalNode
	CATALOG_NAME_SYMBOL() antlr.TerminalNode
	CHAIN_SYMBOL() antlr.TerminalNode
	CHANGED_SYMBOL() antlr.TerminalNode
	CHANNEL_SYMBOL() antlr.TerminalNode
	CIPHER_SYMBOL() antlr.TerminalNode
	CLIENT_SYMBOL() antlr.TerminalNode
	CLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	COALESCE_SYMBOL() antlr.TerminalNode
	CODE_SYMBOL() antlr.TerminalNode
	COLLATION_SYMBOL() antlr.TerminalNode
	COLUMN_NAME_SYMBOL() antlr.TerminalNode
	COLUMN_FORMAT_SYMBOL() antlr.TerminalNode
	COLUMNS_SYMBOL() antlr.TerminalNode
	COMMITTED_SYMBOL() antlr.TerminalNode
	COMPACT_SYMBOL() antlr.TerminalNode
	COMPLETION_SYMBOL() antlr.TerminalNode
	COMPONENT_SYMBOL() antlr.TerminalNode
	COMPRESSED_SYMBOL() antlr.TerminalNode
	COMPRESSION_SYMBOL() antlr.TerminalNode
	CONCURRENT_SYMBOL() antlr.TerminalNode
	CONNECTION_SYMBOL() antlr.TerminalNode
	CONSISTENT_SYMBOL() antlr.TerminalNode
	CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode
	CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode
	CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode
	CONTEXT_SYMBOL() antlr.TerminalNode
	CONTRIBUTORS_SYMBOL() antlr.TerminalNode
	CPU_SYMBOL() antlr.TerminalNode
	CURRENT_SYMBOL() antlr.TerminalNode
	CURSOR_NAME_SYMBOL() antlr.TerminalNode
	DATA_SYMBOL() antlr.TerminalNode
	DATAFILE_SYMBOL() antlr.TerminalNode
	DATETIME_SYMBOL() antlr.TerminalNode
	DATE_SYMBOL() antlr.TerminalNode
	DAY_SYMBOL() antlr.TerminalNode
	DEFAULT_AUTH_SYMBOL() antlr.TerminalNode
	DEFINER_SYMBOL() antlr.TerminalNode
	DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode
	DES_KEY_FILE_SYMBOL() antlr.TerminalNode
	DESCRIPTION_SYMBOL() antlr.TerminalNode
	DIAGNOSTICS_SYMBOL() antlr.TerminalNode
	DIRECTORY_SYMBOL() antlr.TerminalNode
	DISABLE_SYMBOL() antlr.TerminalNode
	DISCARD_SYMBOL() antlr.TerminalNode
	DISK_SYMBOL() antlr.TerminalNode
	DUMPFILE_SYMBOL() antlr.TerminalNode
	DUPLICATE_SYMBOL() antlr.TerminalNode
	DYNAMIC_SYMBOL() antlr.TerminalNode
	ENCRYPTION_SYMBOL() antlr.TerminalNode
	ENDS_SYMBOL() antlr.TerminalNode
	ENUM_SYMBOL() antlr.TerminalNode
	ENGINE_SYMBOL() antlr.TerminalNode
	ENGINES_SYMBOL() antlr.TerminalNode
	ERROR_SYMBOL() antlr.TerminalNode
	ERRORS_SYMBOL() antlr.TerminalNode
	ESCAPE_SYMBOL() antlr.TerminalNode
	EVENTS_SYMBOL() antlr.TerminalNode
	EVERY_SYMBOL() antlr.TerminalNode
	EXCLUDE_SYMBOL() antlr.TerminalNode
	EXPANSION_SYMBOL() antlr.TerminalNode
	EXPORT_SYMBOL() antlr.TerminalNode
	EXTENDED_SYMBOL() antlr.TerminalNode
	EXTENT_SIZE_SYMBOL() antlr.TerminalNode
	FAULTS_SYMBOL() antlr.TerminalNode
	FAST_SYMBOL() antlr.TerminalNode
	FOLLOWING_SYMBOL() antlr.TerminalNode
	FOUND_SYMBOL() antlr.TerminalNode
	ENABLE_SYMBOL() antlr.TerminalNode
	FULL_SYMBOL() antlr.TerminalNode
	FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	FILTER_SYMBOL() antlr.TerminalNode
	FIRST_SYMBOL() antlr.TerminalNode
	FIXED_SYMBOL() antlr.TerminalNode
	GENERAL_SYMBOL() antlr.TerminalNode
	GEOMETRY_SYMBOL() antlr.TerminalNode
	GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode
	GET_FORMAT_SYMBOL() antlr.TerminalNode
	GRANTS_SYMBOL() antlr.TerminalNode
	GLOBAL_SYMBOL() antlr.TerminalNode
	HASH_SYMBOL() antlr.TerminalNode
	HISTOGRAM_SYMBOL() antlr.TerminalNode
	HISTORY_SYMBOL() antlr.TerminalNode
	HOSTS_SYMBOL() antlr.TerminalNode
	HOUR_SYMBOL() antlr.TerminalNode
	IDENTIFIED_SYMBOL() antlr.TerminalNode
	IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode
	INVOKER_SYMBOL() antlr.TerminalNode
	INDEXES_SYMBOL() antlr.TerminalNode
	INITIAL_SIZE_SYMBOL() antlr.TerminalNode
	INSTANCE_SYMBOL() antlr.TerminalNode
	INACTIVE_SYMBOL() antlr.TerminalNode
	IO_SYMBOL() antlr.TerminalNode
	IPC_SYMBOL() antlr.TerminalNode
	ISOLATION_SYMBOL() antlr.TerminalNode
	ISSUER_SYMBOL() antlr.TerminalNode
	INSERT_METHOD_SYMBOL() antlr.TerminalNode
	JSON_SYMBOL() antlr.TerminalNode
	KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode
	LAST_SYMBOL() antlr.TerminalNode
	LEAVES_SYMBOL() antlr.TerminalNode
	LESS_SYMBOL() antlr.TerminalNode
	LEVEL_SYMBOL() antlr.TerminalNode
	LINESTRING_SYMBOL() antlr.TerminalNode
	LIST_SYMBOL() antlr.TerminalNode
	LOCAL_SYMBOL() antlr.TerminalNode
	LOCKED_SYMBOL() antlr.TerminalNode
	LOCKS_SYMBOL() antlr.TerminalNode
	LOGFILE_SYMBOL() antlr.TerminalNode
	LOGS_SYMBOL() antlr.TerminalNode
	MAX_ROWS_SYMBOL() antlr.TerminalNode
	MASTER_SYMBOL() antlr.TerminalNode
	MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode
	MASTER_HOST_SYMBOL() antlr.TerminalNode
	MASTER_PORT_SYMBOL() antlr.TerminalNode
	MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode
	MASTER_LOG_POS_SYMBOL() antlr.TerminalNode
	MASTER_USER_SYMBOL() antlr.TerminalNode
	MASTER_PASSWORD_SYMBOL() antlr.TerminalNode
	MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode
	MASTER_SERVER_ID_SYMBOL() antlr.TerminalNode
	MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode
	MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode
	MASTER_DELAY_SYMBOL() antlr.TerminalNode
	MASTER_SSL_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CA_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode
	MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode
	MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode
	MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode
	MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode
	MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_STATEMENT_TIME_SYMBOL() antlr.TerminalNode
	MAX_SIZE_SYMBOL() antlr.TerminalNode
	MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode
	MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode
	MEDIUM_SYMBOL() antlr.TerminalNode
	MEMORY_SYMBOL() antlr.TerminalNode
	MERGE_SYMBOL() antlr.TerminalNode
	MESSAGE_TEXT_SYMBOL() antlr.TerminalNode
	MICROSECOND_SYMBOL() antlr.TerminalNode
	MIGRATE_SYMBOL() antlr.TerminalNode
	MINUTE_SYMBOL() antlr.TerminalNode
	MIN_ROWS_SYMBOL() antlr.TerminalNode
	MODIFY_SYMBOL() antlr.TerminalNode
	MODE_SYMBOL() antlr.TerminalNode
	MONTH_SYMBOL() antlr.TerminalNode
	MULTILINESTRING_SYMBOL() antlr.TerminalNode
	MULTIPOINT_SYMBOL() antlr.TerminalNode
	MULTIPOLYGON_SYMBOL() antlr.TerminalNode
	MUTEX_SYMBOL() antlr.TerminalNode
	MYSQL_ERRNO_SYMBOL() antlr.TerminalNode
	NAME_SYMBOL() antlr.TerminalNode
	NAMES_SYMBOL() antlr.TerminalNode
	NATIONAL_SYMBOL() antlr.TerminalNode
	NCHAR_SYMBOL() antlr.TerminalNode
	NDBCLUSTER_SYMBOL() antlr.TerminalNode
	NESTED_SYMBOL() antlr.TerminalNode
	NEVER_SYMBOL() antlr.TerminalNode
	NEXT_SYMBOL() antlr.TerminalNode
	NEW_SYMBOL() antlr.TerminalNode
	NO_WAIT_SYMBOL() antlr.TerminalNode
	NODEGROUP_SYMBOL() antlr.TerminalNode
	NULLS_SYMBOL() antlr.TerminalNode
	NOWAIT_SYMBOL() antlr.TerminalNode
	NUMBER_SYMBOL() antlr.TerminalNode
	NVARCHAR_SYMBOL() antlr.TerminalNode
	OFFSET_SYMBOL() antlr.TerminalNode
	OLD_SYMBOL() antlr.TerminalNode
	OLD_PASSWORD_SYMBOL() antlr.TerminalNode
	ONE_SYMBOL() antlr.TerminalNode
	OPTIONAL_SYMBOL() antlr.TerminalNode
	ORDINALITY_SYMBOL() antlr.TerminalNode
	ORGANIZATION_SYMBOL() antlr.TerminalNode
	OTHERS_SYMBOL() antlr.TerminalNode
	PACK_KEYS_SYMBOL() antlr.TerminalNode
	PAGE_SYMBOL() antlr.TerminalNode
	PARTIAL_SYMBOL() antlr.TerminalNode
	PARTITIONING_SYMBOL() antlr.TerminalNode
	PARTITIONS_SYMBOL() antlr.TerminalNode
	PASSWORD_SYMBOL() antlr.TerminalNode
	PATH_SYMBOL() antlr.TerminalNode
	PHASE_SYMBOL() antlr.TerminalNode
	PLUGIN_DIR_SYMBOL() antlr.TerminalNode
	PLUGIN_SYMBOL() antlr.TerminalNode
	PLUGINS_SYMBOL() antlr.TerminalNode
	POINT_SYMBOL() antlr.TerminalNode
	POLYGON_SYMBOL() antlr.TerminalNode
	PRECEDING_SYMBOL() antlr.TerminalNode
	PRESERVE_SYMBOL() antlr.TerminalNode
	PREV_SYMBOL() antlr.TerminalNode
	THREAD_PRIORITY_SYMBOL() antlr.TerminalNode
	PRIVILEGES_SYMBOL() antlr.TerminalNode
	PROCESSLIST_SYMBOL() antlr.TerminalNode
	PROFILE_SYMBOL() antlr.TerminalNode
	PROFILES_SYMBOL() antlr.TerminalNode
	QUARTER_SYMBOL() antlr.TerminalNode
	QUERY_SYMBOL() antlr.TerminalNode
	QUICK_SYMBOL() antlr.TerminalNode
	READ_ONLY_SYMBOL() antlr.TerminalNode
	REBUILD_SYMBOL() antlr.TerminalNode
	RECOVER_SYMBOL() antlr.TerminalNode
	REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	REDOFILE_SYMBOL() antlr.TerminalNode
	REDUNDANT_SYMBOL() antlr.TerminalNode
	RELAY_SYMBOL() antlr.TerminalNode
	RELAYLOG_SYMBOL() antlr.TerminalNode
	RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode
	RELAY_LOG_POS_SYMBOL() antlr.TerminalNode
	RELAY_THREAD_SYMBOL() antlr.TerminalNode
	REMOTE_SYMBOL() antlr.TerminalNode
	REORGANIZE_SYMBOL() antlr.TerminalNode
	REPEATABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode
	REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode
	REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode
	USER_RESOURCES_SYMBOL() antlr.TerminalNode
	RESPECT_SYMBOL() antlr.TerminalNode
	RESUME_SYMBOL() antlr.TerminalNode
	RETAIN_SYMBOL() antlr.TerminalNode
	RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode
	RETURNS_SYMBOL() antlr.TerminalNode
	REUSE_SYMBOL() antlr.TerminalNode
	REVERSE_SYMBOL() antlr.TerminalNode
	ROLLUP_SYMBOL() antlr.TerminalNode
	ROTATE_SYMBOL() antlr.TerminalNode
	ROUTINE_SYMBOL() antlr.TerminalNode
	ROW_COUNT_SYMBOL() antlr.TerminalNode
	ROW_FORMAT_SYMBOL() antlr.TerminalNode
	RTREE_SYMBOL() antlr.TerminalNode
	SCHEDULE_SYMBOL() antlr.TerminalNode
	SCHEMA_NAME_SYMBOL() antlr.TerminalNode
	SECOND_SYMBOL() antlr.TerminalNode
	SERIAL_SYMBOL() antlr.TerminalNode
	SERIALIZABLE_SYMBOL() antlr.TerminalNode
	SESSION_SYMBOL() antlr.TerminalNode
	SHARE_SYMBOL() antlr.TerminalNode
	SIMPLE_SYMBOL() antlr.TerminalNode
	SKIP_SYMBOL() antlr.TerminalNode
	SLOW_SYMBOL() antlr.TerminalNode
	SNAPSHOT_SYMBOL() antlr.TerminalNode
	SOUNDS_SYMBOL() antlr.TerminalNode
	SOURCE_SYMBOL() antlr.TerminalNode
	SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode
	SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode
	SQL_CACHE_SYMBOL() antlr.TerminalNode
	SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode
	SQL_NO_CACHE_SYMBOL() antlr.TerminalNode
	SQL_THREAD_SYMBOL() antlr.TerminalNode
	SRID_SYMBOL() antlr.TerminalNode
	STACKED_SYMBOL() antlr.TerminalNode
	STARTS_SYMBOL() antlr.TerminalNode
	STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode
	STATS_PERSISTENT_SYMBOL() antlr.TerminalNode
	STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode
	STATUS_SYMBOL() antlr.TerminalNode
	STORAGE_SYMBOL() antlr.TerminalNode
	STRING_SYMBOL() antlr.TerminalNode
	SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode
	SUBDATE_SYMBOL() antlr.TerminalNode
	SUBJECT_SYMBOL() antlr.TerminalNode
	SUBPARTITION_SYMBOL() antlr.TerminalNode
	SUBPARTITIONS_SYMBOL() antlr.TerminalNode
	SUPER_SYMBOL() antlr.TerminalNode
	SUSPEND_SYMBOL() antlr.TerminalNode
	SWAPS_SYMBOL() antlr.TerminalNode
	SWITCHES_SYMBOL() antlr.TerminalNode
	TABLE_NAME_SYMBOL() antlr.TerminalNode
	TABLES_SYMBOL() antlr.TerminalNode
	TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode
	TABLESPACE_SYMBOL() antlr.TerminalNode
	TEMPORARY_SYMBOL() antlr.TerminalNode
	TEMPTABLE_SYMBOL() antlr.TerminalNode
	TEXT_SYMBOL() antlr.TerminalNode
	THAN_SYMBOL() antlr.TerminalNode
	TIES_SYMBOL() antlr.TerminalNode
	TRANSACTION_SYMBOL() antlr.TerminalNode
	TRIGGERS_SYMBOL() antlr.TerminalNode
	TIMESTAMP_SYMBOL() antlr.TerminalNode
	TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode
	TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode
	TIME_SYMBOL() antlr.TerminalNode
	TYPES_SYMBOL() antlr.TerminalNode
	TYPE_SYMBOL() antlr.TerminalNode
	UDF_RETURNS_SYMBOL() antlr.TerminalNode
	UNBOUNDED_SYMBOL() antlr.TerminalNode
	UNCOMMITTED_SYMBOL() antlr.TerminalNode
	UNDEFINED_SYMBOL() antlr.TerminalNode
	UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode
	UNDOFILE_SYMBOL() antlr.TerminalNode
	UNKNOWN_SYMBOL() antlr.TerminalNode
	UNTIL_SYMBOL() antlr.TerminalNode
	USER_SYMBOL() antlr.TerminalNode
	USE_FRM_SYMBOL() antlr.TerminalNode
	VARIABLES_SYMBOL() antlr.TerminalNode
	VCPU_SYMBOL() antlr.TerminalNode
	VIEW_SYMBOL() antlr.TerminalNode
	VALUE_SYMBOL() antlr.TerminalNode
	WARNINGS_SYMBOL() antlr.TerminalNode
	WAIT_SYMBOL() antlr.TerminalNode
	WEEK_SYMBOL() antlr.TerminalNode
	WORK_SYMBOL() antlr.TerminalNode
	WEIGHT_STRING_SYMBOL() antlr.TerminalNode
	X509_SYMBOL() antlr.TerminalNode
	XID_SYMBOL() antlr.TerminalNode
	XML_SYMBOL() antlr.TerminalNode
	YEAR_SYMBOL() antlr.TerminalNode
	SHUTDOWN_SYMBOL() antlr.TerminalNode
	CUBE_SYMBOL() antlr.TerminalNode
	IMPORT_SYMBOL() antlr.TerminalNode
	FUNCTION_SYMBOL() antlr.TerminalNode
	ROWS_SYMBOL() antlr.TerminalNode
	ROW_SYMBOL() antlr.TerminalNode
	EXCHANGE_SYMBOL() antlr.TerminalNode
	EXPIRE_SYMBOL() antlr.TerminalNode
	ONLY_SYMBOL() antlr.TerminalNode
	VALIDATION_SYMBOL() antlr.TerminalNode
	WITHOUT_SYMBOL() antlr.TerminalNode
	ADMIN_SYMBOL() antlr.TerminalNode

	// IsRoleOrLabelKeywordContext differentiates from other interfaces.
	IsRoleOrLabelKeywordContext()
}

type RoleOrLabelKeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRoleOrLabelKeywordContext() *RoleOrLabelKeywordContext {
	var p = new(RoleOrLabelKeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleOrLabelKeyword
	return p
}

func InitEmptyRoleOrLabelKeywordContext(p *RoleOrLabelKeywordContext) {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = TiDBParserRULE_roleOrLabelKeyword
}

func (*RoleOrLabelKeywordContext) IsRoleOrLabelKeywordContext() {}

func NewRoleOrLabelKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RoleOrLabelKeywordContext {
	var p = new(RoleOrLabelKeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = TiDBParserRULE_roleOrLabelKeyword

	return p
}

func (s *RoleOrLabelKeywordContext) GetParser() antlr.Parser { return s.parser }

func (s *RoleOrLabelKeywordContext) ACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserACTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserACTIVE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ADDDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserADDDATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AFTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAFTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AGAINST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAGAINST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AGGREGATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAGGREGATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ALGORITHM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserALGORITHM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ANALYSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserANALYSE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ANY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserANY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AUTHORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAUTHORS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AUTO_INCREMENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAUTO_INCREMENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AUTOEXTEND_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAUTOEXTEND_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AVG_ROW_LENGTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAVG_ROW_LENGTH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) AVG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserAVG_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BINLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBINLOG_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBIT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BLOCK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBLOCK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BOOL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBOOL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BOOLEAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBOOLEAN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBTREE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) BUCKETS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserBUCKETS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CASCADED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCASCADED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CATALOG_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCATALOG_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CHAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHAIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CHANGED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHANGED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CHANNEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCHANNEL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCIPHER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CLIENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLIENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCLASS_ORIGIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COALESCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOALESCE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCODE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COLLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLLATION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COLUMN_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMN_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COLUMN_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMN_FORMAT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COLUMNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOLUMNS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMMITTED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPACT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPACT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPLETION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPLETION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPONENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPONENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPRESSED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPRESSED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) COMPRESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCOMPRESSION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONCURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONCURRENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONNECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONNECTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSISTENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONSTRAINT_CATALOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSTRAINT_CATALOG_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONSTRAINT_SCHEMA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSTRAINT_SCHEMA_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONSTRAINT_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONSTRAINT_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONTEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONTEXT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CONTRIBUTORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCONTRIBUTORS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCPU_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CURRENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURRENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CURSOR_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCURSOR_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DATA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATA_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DATAFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATAFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DATETIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATETIME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDAY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DEFAULT_AUTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFAULT_AUTH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DEFINER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDEFINER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DELAY_KEY_WRITE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDELAY_KEY_WRITE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DES_KEY_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDES_KEY_FILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DESCRIPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDESCRIPTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DIAGNOSTICS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIAGNOSTICS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DIRECTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDIRECTORY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DISABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DISCARD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISCARD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DISK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDISK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DUMPFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDUMPFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DUPLICATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDUPLICATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) DYNAMIC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserDYNAMIC_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENCRYPTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENCRYPTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENUM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENGINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENGINE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENGINES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENGINES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ERROR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserERROR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ERRORS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserERRORS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ESCAPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserESCAPE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EVENTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEVENTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EVERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEVERY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXCLUDE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXCLUDE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXPANSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXPANSION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXPORT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXTENDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTENDED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXTENT_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXTENT_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FAULTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFAULTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFAST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FOLLOWING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOLLOWING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FOUND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFOUND_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ENABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserENABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FULL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFULL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FILE_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFILE_BLOCK_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FILTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFILTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FIRST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIRST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FIXED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFIXED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GENERAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGENERAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GEOMETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGEOMETRY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GEOMETRYCOLLECTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGEOMETRYCOLLECTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GET_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGET_FORMAT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GRANTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGRANTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GLOBAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserGLOBAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HASH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHASH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HISTOGRAM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHISTOGRAM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HISTORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHISTORY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HOSTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOSTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserHOUR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IDENTIFIED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIDENTIFIED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IGNORE_SERVER_IDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIGNORE_SERVER_IDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INVOKER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINVOKER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INDEXES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINDEXES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INITIAL_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINITIAL_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INSTANCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSTANCE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INACTIVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINACTIVE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIO_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IPC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIPC_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ISOLATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserISOLATION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ISSUER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserISSUER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) INSERT_METHOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserINSERT_METHOD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) JSON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserJSON_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) KEY_BLOCK_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserKEY_BLOCK_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LAST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLAST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LEAVES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEAVES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LESS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLESS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LEVEL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLEVEL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLINESTRING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLIST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOCAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOCKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCKED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOCKS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOCKS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOGFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOGFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) LOGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserLOGS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_ROWS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_HEARTBEAT_PERIOD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_HEARTBEAT_PERIOD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_HOST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_HOST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_PORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_PORT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_LOG_FILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_LOG_POS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_USER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_PASSWORD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_PUBLIC_KEY_PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_PUBLIC_KEY_PATH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SERVER_ID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SERVER_ID_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_CONNECT_RETRY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_CONNECT_RETRY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_RETRY_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_RETRY_COUNT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_DELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_DELAY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CA_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CA_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CAPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CAPATH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_TLS_VERSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_TLS_VERSION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CERT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CERT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CIPHER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CIPHER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CRL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CRL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_CRLPATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_CRLPATH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_SSL_KEY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_SSL_KEY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MASTER_AUTO_POSITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMASTER_AUTO_POSITION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_CONNECTIONS_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_CONNECTIONS_PER_HOUR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_QUERIES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_QUERIES_PER_HOUR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_STATEMENT_TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_STATEMENT_TIME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_UPDATES_PER_HOUR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_UPDATES_PER_HOUR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MAX_USER_CONNECTIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMAX_USER_CONNECTIONS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MEDIUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEDIUM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MEMORY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMEMORY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MERGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMERGE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MESSAGE_TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMESSAGE_TEXT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MICROSECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMICROSECOND_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MIGRATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMIGRATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MINUTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMINUTE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MIN_ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMIN_ROWS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MODIFY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMODIFY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MODE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMODE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MONTH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMONTH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MULTILINESTRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTILINESTRING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MULTIPOINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTIPOINT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MULTIPOLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMULTIPOLYGON_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MUTEX_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMUTEX_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) MYSQL_ERRNO_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserMYSQL_ERRNO_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NAMES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNAMES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NATIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNATIONAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNCHAR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NDBCLUSTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNDBCLUSTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NESTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNESTED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NEVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNEVER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNEXT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNEW_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NO_WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNO_WAIT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NODEGROUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNODEGROUP_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NULLS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNULLS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NOWAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNOWAIT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NUMBER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNUMBER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) NVARCHAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserNVARCHAR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OFFSET_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOFFSET_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OLD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOLD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OLD_PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOLD_PASSWORD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ONE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserONE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OPTIONAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOPTIONAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ORDINALITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserORDINALITY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ORGANIZATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserORGANIZATION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) OTHERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserOTHERS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PACK_KEYS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPACK_KEYS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPAGE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PARTIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTIAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PARTITIONING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITIONING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPARTITIONS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PASSWORD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPASSWORD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PATH_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPATH_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PHASE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPHASE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PLUGIN_DIR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUGIN_DIR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PLUGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUGIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PLUGINS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPLUGINS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) POINT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPOINT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) POLYGON_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPOLYGON_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PRECEDING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRECEDING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PRESERVE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRESERVE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PREV_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPREV_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) THREAD_PRIORITY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTHREAD_PRIORITY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PRIVILEGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPRIVILEGES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PROCESSLIST_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROCESSLIST_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PROFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) PROFILES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserPROFILES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) QUARTER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUARTER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) QUERY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUERY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) QUICK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserQUICK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) READ_ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREAD_ONLY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REBUILD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREBUILD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RECOVER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRECOVER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REDOFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREDOFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REDUNDANT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREDUNDANT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAYLOG_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAYLOG_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAY_LOG_FILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_LOG_FILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAY_LOG_POS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_LOG_POS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RELAY_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRELAY_THREAD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REMOTE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREMOTE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REORGANIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREORGANIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPEATABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPEATABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_DO_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_DO_DB_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_IGNORE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_IGNORE_DB_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_DO_TABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_IGNORE_TABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_WILD_DO_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_WILD_DO_TABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_WILD_IGNORE_TABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_WILD_IGNORE_TABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REPLICATE_REWRITE_DB_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREPLICATE_REWRITE_DB_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) USER_RESOURCES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_RESOURCES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RESPECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESPECT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RESUME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRESUME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RETAIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRETAIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RETURNED_SQLSTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRETURNED_SQLSTATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RETURNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRETURNS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REUSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREUSE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) REVERSE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserREVERSE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROLLUP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROLLUP_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROTATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROTATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROUTINE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROUTINE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROW_COUNT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_COUNT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROW_FORMAT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_FORMAT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) RTREE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserRTREE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SCHEDULE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSCHEDULE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SCHEMA_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSCHEMA_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SECOND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSECOND_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SERIAL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSERIAL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SERIALIZABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSERIALIZABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SESSION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSESSION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SHARE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHARE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SIMPLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSIMPLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SKIP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSKIP_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SLOW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSLOW_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SNAPSHOT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSNAPSHOT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SOUNDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSOUNDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SOURCE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSOURCE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_AFTER_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_AFTER_GTIDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_AFTER_MTS_GAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_AFTER_MTS_GAPS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_BEFORE_GTIDS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_BEFORE_GTIDS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_CACHE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_BUFFER_RESULT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_BUFFER_RESULT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_NO_CACHE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_NO_CACHE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SQL_THREAD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSQL_THREAD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SRID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSRID_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STACKED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTACKED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STARTS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTARTS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STATS_AUTO_RECALC_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATS_AUTO_RECALC_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STATS_PERSISTENT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATS_PERSISTENT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STATS_SAMPLE_PAGES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATS_SAMPLE_PAGES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STATUS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTATUS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STORAGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTORAGE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSTRING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBCLASS_ORIGIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBCLASS_ORIGIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBDATE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBDATE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBJECT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBJECT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBPARTITION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBPARTITION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUBPARTITIONS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUBPARTITIONS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUPER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUPER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SUSPEND_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSUSPEND_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SWAPS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSWAPS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SWITCHES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSWITCHES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TABLE_NAME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_NAME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TABLE_CHECKSUM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLE_CHECKSUM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TABLESPACE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTABLESPACE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TEMPORARY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTEMPORARY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TEMPTABLE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTEMPTABLE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TEXT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTEXT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) THAN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTHAN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TRANSACTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRANSACTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TRIGGERS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTRIGGERS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIMESTAMP_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIMESTAMP_ADD_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_ADD_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIMESTAMP_DIFF_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIMESTAMP_DIFF_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TIME_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTIME_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TYPES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTYPES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) TYPE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserTYPE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UDF_RETURNS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUDF_RETURNS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNBOUNDED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNBOUNDED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNCOMMITTED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNCOMMITTED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNDEFINED_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNDEFINED_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNDO_BUFFER_SIZE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNDO_BUFFER_SIZE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNDOFILE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNDOFILE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNKNOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNKNOWN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) UNTIL_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUNTIL_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) USER_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSER_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) USE_FRM_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserUSE_FRM_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VARIABLES_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVARIABLES_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VCPU_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVCPU_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VIEW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVIEW_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VALUE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVALUE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WARNINGS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWARNINGS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WAIT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWAIT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WEEK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWEEK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WORK_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWORK_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WEIGHT_STRING_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWEIGHT_STRING_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) X509_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserX509_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) XID_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserXID_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) XML_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserXML_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) YEAR_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserYEAR_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) SHUTDOWN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserSHUTDOWN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) CUBE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserCUBE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) IMPORT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserIMPORT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) FUNCTION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserFUNCTION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROWS_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROWS_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ROW_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserROW_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXCHANGE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXCHANGE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) EXPIRE_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserEXPIRE_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ONLY_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserONLY_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) VALIDATION_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserVALIDATION_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) WITHOUT_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserWITHOUT_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) ADMIN_SYMBOL() antlr.TerminalNode {
	return s.GetToken(TiDBParserADMIN_SYMBOL, 0)
}

func (s *RoleOrLabelKeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RoleOrLabelKeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *RoleOrLabelKeywordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.EnterRoleOrLabelKeyword(s)
	}
}

func (s *RoleOrLabelKeywordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(TiDBParserListener); ok {
		listenerT.ExitRoleOrLabelKeyword(s)
	}
}

func (s *RoleOrLabelKeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case TiDBParserVisitor:
		return t.VisitRoleOrLabelKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}

func (p *TiDBParser) RoleOrLabelKeyword() (localctx IRoleOrLabelKeywordContext) {
	localctx = NewRoleOrLabelKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 834, TiDBParserRULE_roleOrLabelKeyword)
	var _la int

	p.SetState(5652)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 761, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(5647)
			_la = p.GetTokenStream().LA(1)

			if !(((int64(_la) & ^0x3f) == 0 && ((int64(1)<<_la)&-8979026322141404184) != 0) || ((int64((_la-64)) & ^0x3f) == 0 && ((int64(1)<<(_la-64))&293728076757980891) != 0) || ((int64((_la-129)) & ^0x3f) == 0 && ((int64(1)<<(_la-129))&-1036806760278507893) != 0) || ((int64((_la-202)) & ^0x3f) == 0 && ((int64(1)<<(_la-202))&6008090054826942021) != 0) || ((int64((_la-268)) & ^0x3f) == 0 && ((int64(1)<<(_la-268))&2012968295144429669) != 0) || ((int64((_la-333)) & ^0x3f) == 0 && ((int64(1)<<(_la-333))&3186450531003551) != 0) || ((int64((_la-399)) & ^0x3f) == 0 && ((int64(1)<<(_la-399))&-2123500508502540357) != 0) || ((int64((_la-463)) & ^0x3f) == 0 && ((int64(1)<<(_la-463))&888371177957633551) != 0) || ((int64((_la-528)) & ^0x3f) == 0 && ((int64(1)<<(_la-528))&556082283301262519) != 0) || ((int64((_la-592)) & ^0x3f) == 0 && ((int64(1)<<(_la-592))&3784097394692726723) != 0) || ((int64((_la-656)) & ^0x3f) == 0 && ((int64(1)<<(_la-656))&-5647576991346663167) != 0) || ((int64((_la-724)) & ^0x3f) == 0 && ((int64(1)<<(_la-724))&27) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(5648)
			p.Match(TiDBParserSHUTDOWN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(5649)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserCUBE_SYMBOL || _la == TiDBParserFUNCTION_SYMBOL || _la == TiDBParserIMPORT_SYMBOL || _la == TiDBParserROWS_SYMBOL || _la == TiDBParserROW_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(5650)
			_la = p.GetTokenStream().LA(1)

			if !(_la == TiDBParserEXCHANGE_SYMBOL || _la == TiDBParserEXPIRE_SYMBOL || _la == TiDBParserONLY_SYMBOL || _la == TiDBParserSUPER_SYMBOL || _la == TiDBParserVALIDATION_SYMBOL || _la == TiDBParserWITHOUT_SYMBOL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(5651)
			p.Match(TiDBParserADMIN_SYMBOL)
			if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}

errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}

func (p *TiDBParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 190:
		var t *ExprContext = nil
		if localctx != nil {
			t = localctx.(*ExprContext)
		}
		return p.Expr_Sempred(t, predIndex)

	case 191:
		var t *BoolPriContext = nil
		if localctx != nil {
			t = localctx.(*BoolPriContext)
		}
		return p.BoolPri_Sempred(t, predIndex)

	case 195:
		var t *BitExprContext = nil
		if localctx != nil {
			t = localctx.(*BitExprContext)
		}
		return p.BitExpr_Sempred(t, predIndex)

	case 196:
		var t *SimpleExprContext = nil
		if localctx != nil {
			t = localctx.(*SimpleExprContext)
		}
		return p.SimpleExpr_Sempred(t, predIndex)

	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *TiDBParser) Expr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 1:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 2:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TiDBParser) BoolPri_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 3:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 4:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 5:
		return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TiDBParser) BitExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 6:
		return p.Precpred(p.GetParserRuleContext(), 7)

	case 7:
		return p.Precpred(p.GetParserRuleContext(), 6)

	case 8:
		return p.Precpred(p.GetParserRuleContext(), 5)

	case 9:
		return p.Precpred(p.GetParserRuleContext(), 3)

	case 10:
		return p.Precpred(p.GetParserRuleContext(), 2)

	case 11:
		return p.Precpred(p.GetParserRuleContext(), 1)

	case 12:
		return p.Precpred(p.GetParserRuleContext(), 4)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *TiDBParser) SimpleExpr_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
		return p.Precpred(p.GetParserRuleContext(), 16)

	case 14:
		return p.Precpred(p.GetParserRuleContext(), 22)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}
